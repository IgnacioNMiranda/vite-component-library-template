;(function (t) {
  const e = (t['en'] = t['en'] || {})
  e.dictionary = Object.assign(e.dictionary || {}, {
    '%0 of %1': '%0 of %1',
    Accept: 'Accept',
    'Align cell text to the bottom': 'Align cell text to the bottom',
    'Align cell text to the center': 'Align cell text to the center',
    'Align cell text to the left': 'Align cell text to the left',
    'Align cell text to the middle': 'Align cell text to the middle',
    'Align cell text to the right': 'Align cell text to the right',
    'Align cell text to the top': 'Align cell text to the top',
    'Align table to the left': 'Align table to the left',
    'Align table to the right': 'Align table to the right',
    Alignment: 'Alignment',
    Aquamarine: 'Aquamarine',
    Background: 'Background',
    Black: 'Black',
    'Block quote': 'Block quote',
    Blue: 'Blue',
    Bold: 'Bold',
    Border: 'Border',
    'Break text': 'Break text',
    'Bulleted List': 'Bulleted List',
    'Bulleted list styles toolbar': 'Bulleted list styles toolbar',
    Cancel: 'Cancel',
    'Caption for image: %0': 'Caption for image: %0',
    'Caption for the image': 'Caption for the image',
    'Cell properties': 'Cell properties',
    'Center table': 'Center table',
    'Centered image': 'Centered image',
    'Change image text alternative': 'Change image text alternative',
    'Choose heading': 'Choose heading',
    Circle: 'Circle',
    Code: 'Code',
    Color: 'Color',
    'Color picker': 'Color picker',
    Column: 'Column',
    Dashed: 'Dashed',
    Decimal: 'Decimal',
    'Decimal with leading zero': 'Decimal with leading zero',
    'Decrease indent': 'Decrease indent',
    'Delete column': 'Delete column',
    'Delete row': 'Delete row',
    'Dim grey': 'Dim grey',
    Dimensions: 'Dimensions',
    Disc: 'Disc',
    Dotted: 'Dotted',
    Double: 'Double',
    Downloadable: 'Downloadable',
    'Dropdown toolbar': 'Dropdown toolbar',
    'Edit block': 'Edit block',
    'Edit link': 'Edit link',
    'Editor block content toolbar': 'Editor block content toolbar',
    'Editor contextual toolbar': 'Editor contextual toolbar',
    'Editor editing area: %0': 'Editor editing area: %0',
    'Editor toolbar': 'Editor toolbar',
    'Enter image caption': 'Enter image caption',
    'Enter table caption': 'Enter table caption',
    'Full size image': 'Full size image',
    Green: 'Green',
    Grey: 'Grey',
    Groove: 'Groove',
    'Header column': 'Header column',
    'Header row': 'Header row',
    Heading: 'Heading',
    'Heading 1': 'Heading 1',
    'Heading 2': 'Heading 2',
    'Heading 3': 'Heading 3',
    'Heading 4': 'Heading 4',
    'Heading 5': 'Heading 5',
    'Heading 6': 'Heading 6',
    Height: 'Height',
    HEX: 'HEX',
    'Horizontal text alignment toolbar': 'Horizontal text alignment toolbar',
    'Image resize list': 'Image resize list',
    'Image toolbar': 'Image toolbar',
    'image widget': 'image widget',
    'In line': 'In line',
    'Increase indent': 'Increase indent',
    Insert: 'Insert',
    'Insert column left': 'Insert column left',
    'Insert column right': 'Insert column right',
    'Insert image': 'Insert image',
    'Insert image via URL': 'Insert image via URL',
    'Insert media': 'Insert media',
    'Insert paragraph after block': 'Insert paragraph after block',
    'Insert paragraph before block': 'Insert paragraph before block',
    'Insert row above': 'Insert row above',
    'Insert row below': 'Insert row below',
    'Insert table': 'Insert table',
    Inset: 'Inset',
    Italic: 'Italic',
    'Justify cell text': 'Justify cell text',
    'Left aligned image': 'Left aligned image',
    'Light blue': 'Light blue',
    'Light green': 'Light green',
    'Light grey': 'Light grey',
    Link: 'Link',
    'Link image': 'Link image',
    'Link URL': 'Link URL',
    'List properties': 'List properties',
    'Lower-latin': 'Lower-latin',
    'Lower–roman': 'Lower–roman',
    'Media toolbar': 'Media toolbar',
    'Media URL': 'Media URL',
    'media widget': 'media widget',
    'Merge cell down': 'Merge cell down',
    'Merge cell left': 'Merge cell left',
    'Merge cell right': 'Merge cell right',
    'Merge cell up': 'Merge cell up',
    'Merge cells': 'Merge cells',
    Next: 'Next',
    None: 'None',
    'Numbered List': 'Numbered List',
    'Numbered list styles toolbar': 'Numbered list styles toolbar',
    'Open in a new tab': 'Open in a new tab',
    'Open link in new tab': 'Open link in new tab',
    'Open media in new tab': 'Open media in new tab',
    Orange: 'Orange',
    Original: 'Original',
    Outset: 'Outset',
    Padding: 'Padding',
    Paragraph: 'Paragraph',
    'Paste the media URL in the input.': 'Paste the media URL in the input.',
    'Press Enter to type after or press Shift + Enter to type before the widget':
      'Press Enter to type after or press Shift + Enter to type before the widget',
    Previous: 'Previous',
    Purple: 'Purple',
    Red: 'Red',
    Redo: 'Redo',
    'Remove color': 'Remove color',
    'Remove Format': 'Remove Format',
    'Resize image': 'Resize image',
    'Resize image to %0': 'Resize image to %0',
    'Resize image to the original size': 'Resize image to the original size',
    'Restore default': 'Restore default',
    'Reversed order': 'Reversed order',
    'Rich Text Editor': 'Rich Text Editor',
    Ridge: 'Ridge',
    'Right aligned image': 'Right aligned image',
    Row: 'Row',
    Save: 'Save',
    'Select all': 'Select all',
    'Select column': 'Select column',
    'Select row': 'Select row',
    'Show more items': 'Show more items',
    'Side image': 'Side image',
    Solid: 'Solid',
    'Split cell horizontally': 'Split cell horizontally',
    'Split cell vertically': 'Split cell vertically',
    Square: 'Square',
    'Start at': 'Start at',
    'Start index must be greater than 0.': 'Start index must be greater than 0.',
    Strikethrough: 'Strikethrough',
    Style: 'Style',
    Subscript: 'Subscript',
    Superscript: 'Superscript',
    'Table alignment toolbar': 'Table alignment toolbar',
    'Table cell text alignment': 'Table cell text alignment',
    'Table properties': 'Table properties',
    'Table toolbar': 'Table toolbar',
    'Text alternative': 'Text alternative',
    'The color is invalid. Try "#FF0000" or "rgb(255,0,0)" or "red".':
      'The color is invalid. Try "#FF0000" or "rgb(255,0,0)" or "red".',
    'The URL must not be empty.': 'The URL must not be empty.',
    'The value is invalid. Try "10px" or "2em" or simply "2".':
      'The value is invalid. Try "10px" or "2em" or simply "2".',
    'This link has no URL': 'This link has no URL',
    'This media URL is not supported.': 'This media URL is not supported.',
    'Tip: Paste the URL into the content to embed faster.': 'Tip: Paste the URL into the content to embed faster.',
    'To-do List': 'To-do List',
    'Toggle caption off': 'Toggle caption off',
    'Toggle caption on': 'Toggle caption on',
    'Toggle the circle list style': 'Toggle the circle list style',
    'Toggle the decimal list style': 'Toggle the decimal list style',
    'Toggle the decimal with leading zero list style': 'Toggle the decimal with leading zero list style',
    'Toggle the disc list style': 'Toggle the disc list style',
    'Toggle the lower–latin list style': 'Toggle the lower–latin list style',
    'Toggle the lower–roman list style': 'Toggle the lower–roman list style',
    'Toggle the square list style': 'Toggle the square list style',
    'Toggle the upper–latin list style': 'Toggle the upper–latin list style',
    'Toggle the upper–roman list style': 'Toggle the upper–roman list style',
    Turquoise: 'Turquoise',
    'Type or paste your content here.': 'Type or paste your content here.',
    'Type your title': 'Type your title',
    Underline: 'Underline',
    Undo: 'Undo',
    Unlink: 'Unlink',
    Update: 'Update',
    'Update image URL': 'Update image URL',
    'Upload failed': 'Upload failed',
    'Upload in progress': 'Upload in progress',
    'Upper-latin': 'Upper-latin',
    'Upper-roman': 'Upper-roman',
    'Vertical text alignment toolbar': 'Vertical text alignment toolbar',
    White: 'White',
    'Widget toolbar': 'Widget toolbar',
    Width: 'Width',
    'Wrap text': 'Wrap text',
    Yellow: 'Yellow',
  })
})(window.CKEDITOR_TRANSLATIONS || (window.CKEDITOR_TRANSLATIONS = {}))
/*!
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md.
 */ ;(function t(e, n) {
  if (typeof exports === 'object' && typeof module === 'object') module.exports = n()
  else if (typeof define === 'function' && define.amd) define([], n)
  else if (typeof exports === 'object') exports['ClassicEditor'] = n()
  else e['ClassicEditor'] = n()
})(self, () =>
  (() => {
    var t = {
      8168: (t, e, n) => {
        const o = n(8874)
        const i = {}
        for (const t of Object.keys(o)) {
          i[o[t]] = t
        }
        const r = {
          rgb: { channels: 3, labels: 'rgb' },
          hsl: { channels: 3, labels: 'hsl' },
          hsv: { channels: 3, labels: 'hsv' },
          hwb: { channels: 3, labels: 'hwb' },
          cmyk: { channels: 4, labels: 'cmyk' },
          xyz: { channels: 3, labels: 'xyz' },
          lab: { channels: 3, labels: 'lab' },
          lch: { channels: 3, labels: 'lch' },
          hex: { channels: 1, labels: ['hex'] },
          keyword: { channels: 1, labels: ['keyword'] },
          ansi16: { channels: 1, labels: ['ansi16'] },
          ansi256: { channels: 1, labels: ['ansi256'] },
          hcg: { channels: 3, labels: ['h', 'c', 'g'] },
          apple: { channels: 3, labels: ['r16', 'g16', 'b16'] },
          gray: { channels: 1, labels: ['gray'] },
        }
        t.exports = r
        for (const t of Object.keys(r)) {
          if (!('channels' in r[t])) {
            throw new Error('missing channels property: ' + t)
          }
          if (!('labels' in r[t])) {
            throw new Error('missing channel labels property: ' + t)
          }
          if (r[t].labels.length !== r[t].channels) {
            throw new Error('channel and label counts mismatch: ' + t)
          }
          const { channels: e, labels: n } = r[t]
          delete r[t].channels
          delete r[t].labels
          Object.defineProperty(r[t], 'channels', { value: e })
          Object.defineProperty(r[t], 'labels', { value: n })
        }
        r.rgb.hsl = function (t) {
          const e = t[0] / 255
          const n = t[1] / 255
          const o = t[2] / 255
          const i = Math.min(e, n, o)
          const r = Math.max(e, n, o)
          const s = r - i
          let a
          let c
          if (r === i) {
            a = 0
          } else if (e === r) {
            a = (n - o) / s
          } else if (n === r) {
            a = 2 + (o - e) / s
          } else if (o === r) {
            a = 4 + (e - n) / s
          }
          a = Math.min(a * 60, 360)
          if (a < 0) {
            a += 360
          }
          const l = (i + r) / 2
          if (r === i) {
            c = 0
          } else if (l <= 0.5) {
            c = s / (r + i)
          } else {
            c = s / (2 - r - i)
          }
          return [a, c * 100, l * 100]
        }
        r.rgb.hsv = function (t) {
          let e
          let n
          let o
          let i
          let r
          const s = t[0] / 255
          const a = t[1] / 255
          const c = t[2] / 255
          const l = Math.max(s, a, c)
          const d = l - Math.min(s, a, c)
          const u = function (t) {
            return (l - t) / 6 / d + 1 / 2
          }
          if (d === 0) {
            i = 0
            r = 0
          } else {
            r = d / l
            e = u(s)
            n = u(a)
            o = u(c)
            if (s === l) {
              i = o - n
            } else if (a === l) {
              i = 1 / 3 + e - o
            } else if (c === l) {
              i = 2 / 3 + n - e
            }
            if (i < 0) {
              i += 1
            } else if (i > 1) {
              i -= 1
            }
          }
          return [i * 360, r * 100, l * 100]
        }
        r.rgb.hwb = function (t) {
          const e = t[0]
          const n = t[1]
          let o = t[2]
          const i = r.rgb.hsl(t)[0]
          const s = (1 / 255) * Math.min(e, Math.min(n, o))
          o = 1 - (1 / 255) * Math.max(e, Math.max(n, o))
          return [i, s * 100, o * 100]
        }
        r.rgb.cmyk = function (t) {
          const e = t[0] / 255
          const n = t[1] / 255
          const o = t[2] / 255
          const i = Math.min(1 - e, 1 - n, 1 - o)
          const r = (1 - e - i) / (1 - i) || 0
          const s = (1 - n - i) / (1 - i) || 0
          const a = (1 - o - i) / (1 - i) || 0
          return [r * 100, s * 100, a * 100, i * 100]
        }
        function s(t, e) {
          return (t[0] - e[0]) ** 2 + (t[1] - e[1]) ** 2 + (t[2] - e[2]) ** 2
        }
        r.rgb.keyword = function (t) {
          const e = i[t]
          if (e) {
            return e
          }
          let n = Infinity
          let r
          for (const e of Object.keys(o)) {
            const i = o[e]
            const a = s(t, i)
            if (a < n) {
              n = a
              r = e
            }
          }
          return r
        }
        r.keyword.rgb = function (t) {
          return o[t]
        }
        r.rgb.xyz = function (t) {
          let e = t[0] / 255
          let n = t[1] / 255
          let o = t[2] / 255
          e = e > 0.04045 ? ((e + 0.055) / 1.055) ** 2.4 : e / 12.92
          n = n > 0.04045 ? ((n + 0.055) / 1.055) ** 2.4 : n / 12.92
          o = o > 0.04045 ? ((o + 0.055) / 1.055) ** 2.4 : o / 12.92
          const i = e * 0.4124 + n * 0.3576 + o * 0.1805
          const r = e * 0.2126 + n * 0.7152 + o * 0.0722
          const s = e * 0.0193 + n * 0.1192 + o * 0.9505
          return [i * 100, r * 100, s * 100]
        }
        r.rgb.lab = function (t) {
          const e = r.rgb.xyz(t)
          let n = e[0]
          let o = e[1]
          let i = e[2]
          n /= 95.047
          o /= 100
          i /= 108.883
          n = n > 0.008856 ? n ** (1 / 3) : 7.787 * n + 16 / 116
          o = o > 0.008856 ? o ** (1 / 3) : 7.787 * o + 16 / 116
          i = i > 0.008856 ? i ** (1 / 3) : 7.787 * i + 16 / 116
          const s = 116 * o - 16
          const a = 500 * (n - o)
          const c = 200 * (o - i)
          return [s, a, c]
        }
        r.hsl.rgb = function (t) {
          const e = t[0] / 360
          const n = t[1] / 100
          const o = t[2] / 100
          let i
          let r
          let s
          if (n === 0) {
            s = o * 255
            return [s, s, s]
          }
          if (o < 0.5) {
            i = o * (1 + n)
          } else {
            i = o + n - o * n
          }
          const a = 2 * o - i
          const c = [0, 0, 0]
          for (let t = 0; t < 3; t++) {
            r = e + (1 / 3) * -(t - 1)
            if (r < 0) {
              r++
            }
            if (r > 1) {
              r--
            }
            if (6 * r < 1) {
              s = a + (i - a) * 6 * r
            } else if (2 * r < 1) {
              s = i
            } else if (3 * r < 2) {
              s = a + (i - a) * (2 / 3 - r) * 6
            } else {
              s = a
            }
            c[t] = s * 255
          }
          return c
        }
        r.hsl.hsv = function (t) {
          const e = t[0]
          let n = t[1] / 100
          let o = t[2] / 100
          let i = n
          const r = Math.max(o, 0.01)
          o *= 2
          n *= o <= 1 ? o : 2 - o
          i *= r <= 1 ? r : 2 - r
          const s = (o + n) / 2
          const a = o === 0 ? (2 * i) / (r + i) : (2 * n) / (o + n)
          return [e, a * 100, s * 100]
        }
        r.hsv.rgb = function (t) {
          const e = t[0] / 60
          const n = t[1] / 100
          let o = t[2] / 100
          const i = Math.floor(e) % 6
          const r = e - Math.floor(e)
          const s = 255 * o * (1 - n)
          const a = 255 * o * (1 - n * r)
          const c = 255 * o * (1 - n * (1 - r))
          o *= 255
          switch (i) {
            case 0:
              return [o, c, s]
            case 1:
              return [a, o, s]
            case 2:
              return [s, o, c]
            case 3:
              return [s, a, o]
            case 4:
              return [c, s, o]
            case 5:
              return [o, s, a]
          }
        }
        r.hsv.hsl = function (t) {
          const e = t[0]
          const n = t[1] / 100
          const o = t[2] / 100
          const i = Math.max(o, 0.01)
          let r
          let s
          s = (2 - n) * o
          const a = (2 - n) * i
          r = n * i
          r /= a <= 1 ? a : 2 - a
          r = r || 0
          s /= 2
          return [e, r * 100, s * 100]
        }
        r.hwb.rgb = function (t) {
          const e = t[0] / 360
          let n = t[1] / 100
          let o = t[2] / 100
          const i = n + o
          let r
          if (i > 1) {
            n /= i
            o /= i
          }
          const s = Math.floor(6 * e)
          const a = 1 - o
          r = 6 * e - s
          if ((s & 1) !== 0) {
            r = 1 - r
          }
          const c = n + r * (a - n)
          let l
          let d
          let u
          switch (s) {
            default:
            case 6:
            case 0:
              l = a
              d = c
              u = n
              break
            case 1:
              l = c
              d = a
              u = n
              break
            case 2:
              l = n
              d = a
              u = c
              break
            case 3:
              l = n
              d = c
              u = a
              break
            case 4:
              l = c
              d = n
              u = a
              break
            case 5:
              l = a
              d = n
              u = c
              break
          }
          return [l * 255, d * 255, u * 255]
        }
        r.cmyk.rgb = function (t) {
          const e = t[0] / 100
          const n = t[1] / 100
          const o = t[2] / 100
          const i = t[3] / 100
          const r = 1 - Math.min(1, e * (1 - i) + i)
          const s = 1 - Math.min(1, n * (1 - i) + i)
          const a = 1 - Math.min(1, o * (1 - i) + i)
          return [r * 255, s * 255, a * 255]
        }
        r.xyz.rgb = function (t) {
          const e = t[0] / 100
          const n = t[1] / 100
          const o = t[2] / 100
          let i
          let r
          let s
          i = e * 3.2406 + n * -1.5372 + o * -0.4986
          r = e * -0.9689 + n * 1.8758 + o * 0.0415
          s = e * 0.0557 + n * -0.204 + o * 1.057
          i = i > 0.0031308 ? 1.055 * i ** (1 / 2.4) - 0.055 : i * 12.92
          r = r > 0.0031308 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92
          s = s > 0.0031308 ? 1.055 * s ** (1 / 2.4) - 0.055 : s * 12.92
          i = Math.min(Math.max(0, i), 1)
          r = Math.min(Math.max(0, r), 1)
          s = Math.min(Math.max(0, s), 1)
          return [i * 255, r * 255, s * 255]
        }
        r.xyz.lab = function (t) {
          let e = t[0]
          let n = t[1]
          let o = t[2]
          e /= 95.047
          n /= 100
          o /= 108.883
          e = e > 0.008856 ? e ** (1 / 3) : 7.787 * e + 16 / 116
          n = n > 0.008856 ? n ** (1 / 3) : 7.787 * n + 16 / 116
          o = o > 0.008856 ? o ** (1 / 3) : 7.787 * o + 16 / 116
          const i = 116 * n - 16
          const r = 500 * (e - n)
          const s = 200 * (n - o)
          return [i, r, s]
        }
        r.lab.xyz = function (t) {
          const e = t[0]
          const n = t[1]
          const o = t[2]
          let i
          let r
          let s
          r = (e + 16) / 116
          i = n / 500 + r
          s = r - o / 200
          const a = r ** 3
          const c = i ** 3
          const l = s ** 3
          r = a > 0.008856 ? a : (r - 16 / 116) / 7.787
          i = c > 0.008856 ? c : (i - 16 / 116) / 7.787
          s = l > 0.008856 ? l : (s - 16 / 116) / 7.787
          i *= 95.047
          r *= 100
          s *= 108.883
          return [i, r, s]
        }
        r.lab.lch = function (t) {
          const e = t[0]
          const n = t[1]
          const o = t[2]
          let i
          const r = Math.atan2(o, n)
          i = (r * 360) / 2 / Math.PI
          if (i < 0) {
            i += 360
          }
          const s = Math.sqrt(n * n + o * o)
          return [e, s, i]
        }
        r.lch.lab = function (t) {
          const e = t[0]
          const n = t[1]
          const o = t[2]
          const i = (o / 360) * 2 * Math.PI
          const r = n * Math.cos(i)
          const s = n * Math.sin(i)
          return [e, r, s]
        }
        r.rgb.ansi16 = function (t, e = null) {
          const [n, o, i] = t
          let s = e === null ? r.rgb.hsv(t)[2] : e
          s = Math.round(s / 50)
          if (s === 0) {
            return 30
          }
          let a = 30 + ((Math.round(i / 255) << 2) | (Math.round(o / 255) << 1) | Math.round(n / 255))
          if (s === 2) {
            a += 60
          }
          return a
        }
        r.hsv.ansi16 = function (t) {
          return r.rgb.ansi16(r.hsv.rgb(t), t[2])
        }
        r.rgb.ansi256 = function (t) {
          const e = t[0]
          const n = t[1]
          const o = t[2]
          if (e === n && n === o) {
            if (e < 8) {
              return 16
            }
            if (e > 248) {
              return 231
            }
            return Math.round(((e - 8) / 247) * 24) + 232
          }
          const i = 16 + 36 * Math.round((e / 255) * 5) + 6 * Math.round((n / 255) * 5) + Math.round((o / 255) * 5)
          return i
        }
        r.ansi16.rgb = function (t) {
          let e = t % 10
          if (e === 0 || e === 7) {
            if (t > 50) {
              e += 3.5
            }
            e = (e / 10.5) * 255
            return [e, e, e]
          }
          const n = (~~(t > 50) + 1) * 0.5
          const o = (e & 1) * n * 255
          const i = ((e >> 1) & 1) * n * 255
          const r = ((e >> 2) & 1) * n * 255
          return [o, i, r]
        }
        r.ansi256.rgb = function (t) {
          if (t >= 232) {
            const e = (t - 232) * 10 + 8
            return [e, e, e]
          }
          t -= 16
          let e
          const n = (Math.floor(t / 36) / 5) * 255
          const o = (Math.floor((e = t % 36) / 6) / 5) * 255
          const i = ((e % 6) / 5) * 255
          return [n, o, i]
        }
        r.rgb.hex = function (t) {
          const e = ((Math.round(t[0]) & 255) << 16) + ((Math.round(t[1]) & 255) << 8) + (Math.round(t[2]) & 255)
          const n = e.toString(16).toUpperCase()
          return '000000'.substring(n.length) + n
        }
        r.hex.rgb = function (t) {
          const e = t.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i)
          if (!e) {
            return [0, 0, 0]
          }
          let n = e[0]
          if (e[0].length === 3) {
            n = n
              .split('')
              .map((t) => t + t)
              .join('')
          }
          const o = parseInt(n, 16)
          const i = (o >> 16) & 255
          const r = (o >> 8) & 255
          const s = o & 255
          return [i, r, s]
        }
        r.rgb.hcg = function (t) {
          const e = t[0] / 255
          const n = t[1] / 255
          const o = t[2] / 255
          const i = Math.max(Math.max(e, n), o)
          const r = Math.min(Math.min(e, n), o)
          const s = i - r
          let a
          let c
          if (s < 1) {
            a = r / (1 - s)
          } else {
            a = 0
          }
          if (s <= 0) {
            c = 0
          } else if (i === e) {
            c = ((n - o) / s) % 6
          } else if (i === n) {
            c = 2 + (o - e) / s
          } else {
            c = 4 + (e - n) / s
          }
          c /= 6
          c %= 1
          return [c * 360, s * 100, a * 100]
        }
        r.hsl.hcg = function (t) {
          const e = t[1] / 100
          const n = t[2] / 100
          const o = n < 0.5 ? 2 * e * n : 2 * e * (1 - n)
          let i = 0
          if (o < 1) {
            i = (n - 0.5 * o) / (1 - o)
          }
          return [t[0], o * 100, i * 100]
        }
        r.hsv.hcg = function (t) {
          const e = t[1] / 100
          const n = t[2] / 100
          const o = e * n
          let i = 0
          if (o < 1) {
            i = (n - o) / (1 - o)
          }
          return [t[0], o * 100, i * 100]
        }
        r.hcg.rgb = function (t) {
          const e = t[0] / 360
          const n = t[1] / 100
          const o = t[2] / 100
          if (n === 0) {
            return [o * 255, o * 255, o * 255]
          }
          const i = [0, 0, 0]
          const r = (e % 1) * 6
          const s = r % 1
          const a = 1 - s
          let c = 0
          switch (Math.floor(r)) {
            case 0:
              i[0] = 1
              i[1] = s
              i[2] = 0
              break
            case 1:
              i[0] = a
              i[1] = 1
              i[2] = 0
              break
            case 2:
              i[0] = 0
              i[1] = 1
              i[2] = s
              break
            case 3:
              i[0] = 0
              i[1] = a
              i[2] = 1
              break
            case 4:
              i[0] = s
              i[1] = 0
              i[2] = 1
              break
            default:
              i[0] = 1
              i[1] = 0
              i[2] = a
          }
          c = (1 - n) * o
          return [(n * i[0] + c) * 255, (n * i[1] + c) * 255, (n * i[2] + c) * 255]
        }
        r.hcg.hsv = function (t) {
          const e = t[1] / 100
          const n = t[2] / 100
          const o = e + n * (1 - e)
          let i = 0
          if (o > 0) {
            i = e / o
          }
          return [t[0], i * 100, o * 100]
        }
        r.hcg.hsl = function (t) {
          const e = t[1] / 100
          const n = t[2] / 100
          const o = n * (1 - e) + 0.5 * e
          let i = 0
          if (o > 0 && o < 0.5) {
            i = e / (2 * o)
          } else if (o >= 0.5 && o < 1) {
            i = e / (2 * (1 - o))
          }
          return [t[0], i * 100, o * 100]
        }
        r.hcg.hwb = function (t) {
          const e = t[1] / 100
          const n = t[2] / 100
          const o = e + n * (1 - e)
          return [t[0], (o - e) * 100, (1 - o) * 100]
        }
        r.hwb.hcg = function (t) {
          const e = t[1] / 100
          const n = t[2] / 100
          const o = 1 - n
          const i = o - e
          let r = 0
          if (i < 1) {
            r = (o - i) / (1 - i)
          }
          return [t[0], i * 100, r * 100]
        }
        r.apple.rgb = function (t) {
          return [(t[0] / 65535) * 255, (t[1] / 65535) * 255, (t[2] / 65535) * 255]
        }
        r.rgb.apple = function (t) {
          return [(t[0] / 255) * 65535, (t[1] / 255) * 65535, (t[2] / 255) * 65535]
        }
        r.gray.rgb = function (t) {
          return [(t[0] / 100) * 255, (t[0] / 100) * 255, (t[0] / 100) * 255]
        }
        r.gray.hsl = function (t) {
          return [0, 0, t[0]]
        }
        r.gray.hsv = r.gray.hsl
        r.gray.hwb = function (t) {
          return [0, 100, t[0]]
        }
        r.gray.cmyk = function (t) {
          return [0, 0, 0, t[0]]
        }
        r.gray.lab = function (t) {
          return [t[0], 0, 0]
        }
        r.gray.hex = function (t) {
          const e = Math.round((t[0] / 100) * 255) & 255
          const n = (e << 16) + (e << 8) + e
          const o = n.toString(16).toUpperCase()
          return '000000'.substring(o.length) + o
        }
        r.rgb.gray = function (t) {
          const e = (t[0] + t[1] + t[2]) / 3
          return [(e / 255) * 100]
        }
      },
      2085: (t, e, n) => {
        const o = n(8168)
        const i = n(4111)
        const r = {}
        const s = Object.keys(o)
        function a(t) {
          const e = function (...e) {
            const n = e[0]
            if (n === undefined || n === null) {
              return n
            }
            if (n.length > 1) {
              e = n
            }
            return t(e)
          }
          if ('conversion' in t) {
            e.conversion = t.conversion
          }
          return e
        }
        function c(t) {
          const e = function (...e) {
            const n = e[0]
            if (n === undefined || n === null) {
              return n
            }
            if (n.length > 1) {
              e = n
            }
            const o = t(e)
            if (typeof o === 'object') {
              for (let t = o.length, e = 0; e < t; e++) {
                o[e] = Math.round(o[e])
              }
            }
            return o
          }
          if ('conversion' in t) {
            e.conversion = t.conversion
          }
          return e
        }
        s.forEach((t) => {
          r[t] = {}
          Object.defineProperty(r[t], 'channels', { value: o[t].channels })
          Object.defineProperty(r[t], 'labels', { value: o[t].labels })
          const e = i(t)
          const n = Object.keys(e)
          n.forEach((n) => {
            const o = e[n]
            r[t][n] = c(o)
            r[t][n].raw = a(o)
          })
        })
        t.exports = r
      },
      4111: (t, e, n) => {
        const o = n(8168)
        function i() {
          const t = {}
          const e = Object.keys(o)
          for (let n = e.length, o = 0; o < n; o++) {
            t[e[o]] = { distance: -1, parent: null }
          }
          return t
        }
        function r(t) {
          const e = i()
          const n = [t]
          e[t].distance = 0
          while (n.length) {
            const t = n.pop()
            const i = Object.keys(o[t])
            for (let o = i.length, r = 0; r < o; r++) {
              const o = i[r]
              const s = e[o]
              if (s.distance === -1) {
                s.distance = e[t].distance + 1
                s.parent = t
                n.unshift(o)
              }
            }
          }
          return e
        }
        function s(t, e) {
          return function (n) {
            return e(t(n))
          }
        }
        function a(t, e) {
          const n = [e[t].parent, t]
          let i = o[e[t].parent][t]
          let r = e[t].parent
          while (e[r].parent) {
            n.unshift(e[r].parent)
            i = s(o[e[r].parent][r], i)
            r = e[r].parent
          }
          i.conversion = n
          return i
        }
        t.exports = function (t) {
          const e = r(t)
          const n = {}
          const o = Object.keys(e)
          for (let t = o.length, i = 0; i < t; i++) {
            const t = o[i]
            const r = e[t]
            if (r.parent === null) {
              continue
            }
            n[t] = a(t, e)
          }
          return n
        }
      },
      8874: (t) => {
        'use strict'
        t.exports = {
          aliceblue: [240, 248, 255],
          antiquewhite: [250, 235, 215],
          aqua: [0, 255, 255],
          aquamarine: [127, 255, 212],
          azure: [240, 255, 255],
          beige: [245, 245, 220],
          bisque: [255, 228, 196],
          black: [0, 0, 0],
          blanchedalmond: [255, 235, 205],
          blue: [0, 0, 255],
          blueviolet: [138, 43, 226],
          brown: [165, 42, 42],
          burlywood: [222, 184, 135],
          cadetblue: [95, 158, 160],
          chartreuse: [127, 255, 0],
          chocolate: [210, 105, 30],
          coral: [255, 127, 80],
          cornflowerblue: [100, 149, 237],
          cornsilk: [255, 248, 220],
          crimson: [220, 20, 60],
          cyan: [0, 255, 255],
          darkblue: [0, 0, 139],
          darkcyan: [0, 139, 139],
          darkgoldenrod: [184, 134, 11],
          darkgray: [169, 169, 169],
          darkgreen: [0, 100, 0],
          darkgrey: [169, 169, 169],
          darkkhaki: [189, 183, 107],
          darkmagenta: [139, 0, 139],
          darkolivegreen: [85, 107, 47],
          darkorange: [255, 140, 0],
          darkorchid: [153, 50, 204],
          darkred: [139, 0, 0],
          darksalmon: [233, 150, 122],
          darkseagreen: [143, 188, 143],
          darkslateblue: [72, 61, 139],
          darkslategray: [47, 79, 79],
          darkslategrey: [47, 79, 79],
          darkturquoise: [0, 206, 209],
          darkviolet: [148, 0, 211],
          deeppink: [255, 20, 147],
          deepskyblue: [0, 191, 255],
          dimgray: [105, 105, 105],
          dimgrey: [105, 105, 105],
          dodgerblue: [30, 144, 255],
          firebrick: [178, 34, 34],
          floralwhite: [255, 250, 240],
          forestgreen: [34, 139, 34],
          fuchsia: [255, 0, 255],
          gainsboro: [220, 220, 220],
          ghostwhite: [248, 248, 255],
          gold: [255, 215, 0],
          goldenrod: [218, 165, 32],
          gray: [128, 128, 128],
          green: [0, 128, 0],
          greenyellow: [173, 255, 47],
          grey: [128, 128, 128],
          honeydew: [240, 255, 240],
          hotpink: [255, 105, 180],
          indianred: [205, 92, 92],
          indigo: [75, 0, 130],
          ivory: [255, 255, 240],
          khaki: [240, 230, 140],
          lavender: [230, 230, 250],
          lavenderblush: [255, 240, 245],
          lawngreen: [124, 252, 0],
          lemonchiffon: [255, 250, 205],
          lightblue: [173, 216, 230],
          lightcoral: [240, 128, 128],
          lightcyan: [224, 255, 255],
          lightgoldenrodyellow: [250, 250, 210],
          lightgray: [211, 211, 211],
          lightgreen: [144, 238, 144],
          lightgrey: [211, 211, 211],
          lightpink: [255, 182, 193],
          lightsalmon: [255, 160, 122],
          lightseagreen: [32, 178, 170],
          lightskyblue: [135, 206, 250],
          lightslategray: [119, 136, 153],
          lightslategrey: [119, 136, 153],
          lightsteelblue: [176, 196, 222],
          lightyellow: [255, 255, 224],
          lime: [0, 255, 0],
          limegreen: [50, 205, 50],
          linen: [250, 240, 230],
          magenta: [255, 0, 255],
          maroon: [128, 0, 0],
          mediumaquamarine: [102, 205, 170],
          mediumblue: [0, 0, 205],
          mediumorchid: [186, 85, 211],
          mediumpurple: [147, 112, 219],
          mediumseagreen: [60, 179, 113],
          mediumslateblue: [123, 104, 238],
          mediumspringgreen: [0, 250, 154],
          mediumturquoise: [72, 209, 204],
          mediumvioletred: [199, 21, 133],
          midnightblue: [25, 25, 112],
          mintcream: [245, 255, 250],
          mistyrose: [255, 228, 225],
          moccasin: [255, 228, 181],
          navajowhite: [255, 222, 173],
          navy: [0, 0, 128],
          oldlace: [253, 245, 230],
          olive: [128, 128, 0],
          olivedrab: [107, 142, 35],
          orange: [255, 165, 0],
          orangered: [255, 69, 0],
          orchid: [218, 112, 214],
          palegoldenrod: [238, 232, 170],
          palegreen: [152, 251, 152],
          paleturquoise: [175, 238, 238],
          palevioletred: [219, 112, 147],
          papayawhip: [255, 239, 213],
          peachpuff: [255, 218, 185],
          peru: [205, 133, 63],
          pink: [255, 192, 203],
          plum: [221, 160, 221],
          powderblue: [176, 224, 230],
          purple: [128, 0, 128],
          rebeccapurple: [102, 51, 153],
          red: [255, 0, 0],
          rosybrown: [188, 143, 143],
          royalblue: [65, 105, 225],
          saddlebrown: [139, 69, 19],
          salmon: [250, 128, 114],
          sandybrown: [244, 164, 96],
          seagreen: [46, 139, 87],
          seashell: [255, 245, 238],
          sienna: [160, 82, 45],
          silver: [192, 192, 192],
          skyblue: [135, 206, 235],
          slateblue: [106, 90, 205],
          slategray: [112, 128, 144],
          slategrey: [112, 128, 144],
          snow: [255, 250, 250],
          springgreen: [0, 255, 127],
          steelblue: [70, 130, 180],
          tan: [210, 180, 140],
          teal: [0, 128, 128],
          thistle: [216, 191, 216],
          tomato: [255, 99, 71],
          turquoise: [64, 224, 208],
          violet: [238, 130, 238],
          wheat: [245, 222, 179],
          white: [255, 255, 255],
          whitesmoke: [245, 245, 245],
          yellow: [255, 255, 0],
          yellowgreen: [154, 205, 50],
        }
      },
      5363: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          '.ck-content code{background-color:hsla(0,0%,78%,.3);border-radius:2px;padding:.15em}.ck.ck-editor__editable .ck-code_selected{background-color:hsla(0,0%,78%,.5)}',
          '',
          {
            version: 3,
            sources: ['webpack://./node_modules/@ckeditor/ckeditor5-basic-styles/theme/code.css'],
            names: [],
            mappings: 'AAKA,iBACC,kCAAuC,CAEvC,iBAAkB,CADlB,aAED,CAEA,0CACC,kCACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content code {\n\tbackground-color: hsla(0, 0%, 78%, 0.3);\n\tpadding: .15em;\n\tborder-radius: 2px;\n}\n\n.ck.ck-editor__editable .ck-code_selected  {\n\tbackground-color: hsla(0, 0%, 78%, 0.5);\n}\n',
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      3789: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          '.ck-content blockquote{border-left:5px solid #ccc;font-style:italic;margin-left:0;margin-right:0;overflow:hidden;padding-left:1.5em;padding-right:1.5em}.ck-content[dir=rtl] blockquote{border-left:0;border-right:5px solid #ccc}',
          '',
          {
            version: 3,
            sources: ['webpack://./node_modules/@ckeditor/ckeditor5-block-quote/theme/blockquote.css'],
            names: [],
            mappings:
              'AAKA,uBAWC,0BAAsC,CADtC,iBAAkB,CAFlB,aAAc,CACd,cAAe,CAPf,eAAgB,CAIhB,kBAAmB,CADnB,mBAOD,CAEA,gCACC,aAAc,CACd,2BACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content blockquote {\n\t/* See #12 */\n\toverflow: hidden;\n\n\t/* https://github.com/ckeditor/ckeditor5-block-quote/issues/15 */\n\tpadding-right: 1.5em;\n\tpadding-left: 1.5em;\n\n\tmargin-left: 0;\n\tmargin-right: 0;\n\tfont-style: italic;\n\tborder-left: solid 5px hsl(0, 0%, 80%);\n}\n\n.ck-content[dir="rtl"] blockquote {\n\tborder-left: 0;\n\tborder-right: solid 5px hsl(0, 0%, 80%);\n}\n',
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      799: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          '.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position{display:inline;pointer-events:none;position:relative}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span{position:absolute;width:0}.ck.ck-editor__editable .ck-widget:-webkit-drag>.ck-widget__selection-handle,.ck.ck-editor__editable .ck-widget:-webkit-drag>.ck-widget__type-around{display:none}.ck.ck-clipboard-drop-target-line{pointer-events:none;position:absolute}:root{--ck-clipboard-drop-target-dot-width:12px;--ck-clipboard-drop-target-dot-height:8px;--ck-clipboard-drop-target-color:var(--ck-color-focus-border)}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span{background:var(--ck-clipboard-drop-target-color);border:1px solid var(--ck-clipboard-drop-target-color);bottom:calc(var(--ck-clipboard-drop-target-dot-height)*-.5);margin-left:-1px;top:calc(var(--ck-clipboard-drop-target-dot-height)*-.5)}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span:after{border-color:var(--ck-clipboard-drop-target-color) transparent transparent transparent;border-style:solid;border-width:calc(var(--ck-clipboard-drop-target-dot-height)) calc(var(--ck-clipboard-drop-target-dot-width)*.5) 0 calc(var(--ck-clipboard-drop-target-dot-width)*.5);content:"";display:block;height:0;left:50%;position:absolute;top:calc(var(--ck-clipboard-drop-target-dot-height)*-.5);transform:translateX(-50%);width:0}.ck.ck-editor__editable .ck-widget.ck-clipboard-drop-target-range{outline:var(--ck-widget-outline-thickness) solid var(--ck-clipboard-drop-target-color)!important}.ck.ck-editor__editable .ck-widget:-webkit-drag{zoom:.6;outline:none!important}.ck.ck-clipboard-drop-target-line{background:var(--ck-clipboard-drop-target-color);border:1px solid var(--ck-clipboard-drop-target-color);height:0;margin-top:-1px}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-clipboard/theme/clipboard.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-clipboard/clipboard.css',
            ],
            names: [],
            mappings:
              'AASC,8DACC,cAAe,CAEf,mBAAoB,CADpB,iBAOD,CAJC,mEACC,iBAAkB,CAClB,OACD,CAWA,qJACC,YACD,CAIF,kCAEC,mBAAoB,CADpB,iBAED,CChCA,MACC,yCAA0C,CAC1C,yCAA0C,CAC1C,6DACD,CAOE,mEAIC,gDAAiD,CADjD,sDAAuD,CAFvD,2DAA8D,CAI9D,gBAAiB,CAHjB,wDAqBD,CAfC,yEAWC,sFAAuF,CAEvF,kBAAmB,CADnB,qKAA0K,CAX1K,UAAW,CAIX,aAAc,CAFd,QAAS,CAIT,QAAS,CADT,iBAAkB,CAElB,wDAA2D,CAE3D,0BAA2B,CAR3B,OAYD,CAOF,kEACC,gGACD,CAKA,gDACC,OAAS,CACT,sBACD,CAGD,kCAGC,gDAAiD,CADjD,sDAAuD,CADvD,QAAS,CAGT,eACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor__editable {\n\t/*\n\t * Vertical drop target (in text).\n\t */\n\t& .ck.ck-clipboard-drop-target-position {\n\t\tdisplay: inline;\n\t\tposition: relative;\n\t\tpointer-events: none;\n\n\t\t& span {\n\t\t\tposition: absolute;\n\t\t\twidth: 0;\n\t\t}\n\t}\n\n\t/*\n\t * Styles of the widget being dragged (its preview).\n\t */\n\t& .ck-widget:-webkit-drag {\n\t\t& > .ck-widget__selection-handle {\n\t\t\tdisplay: none;\n\t\t}\n\n\t\t& > .ck-widget__type-around {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n}\n\n.ck.ck-clipboard-drop-target-line {\n\tposition: absolute;\n\tpointer-events: none;\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-clipboard-drop-target-dot-width: 12px;\n\t--ck-clipboard-drop-target-dot-height: 8px;\n\t--ck-clipboard-drop-target-color: var(--ck-color-focus-border)\n}\n\n.ck.ck-editor__editable {\n\t/*\n\t * Vertical drop target (in text).\n\t */\n\t& .ck.ck-clipboard-drop-target-position {\n\t\t& span {\n\t\t\tbottom: calc(-.5 * var(--ck-clipboard-drop-target-dot-height));\n\t\t\ttop: calc(-.5 * var(--ck-clipboard-drop-target-dot-height));\n\t\t\tborder: 1px solid var(--ck-clipboard-drop-target-color);\n\t\t\tbackground: var(--ck-clipboard-drop-target-color);\n\t\t\tmargin-left: -1px;\n\n\t\t\t/* The triangle above the marker */\n\t\t\t&::after {\n\t\t\t\tcontent: "";\n\t\t\t\twidth: 0;\n\t\t\t\theight: 0;\n\n\t\t\t\tdisplay: block;\n\t\t\t\tposition: absolute;\n\t\t\t\tleft: 50%;\n\t\t\t\ttop: calc(var(--ck-clipboard-drop-target-dot-height) * -.5);\n\n\t\t\t\ttransform: translateX(-50%);\n\t\t\t\tborder-color: var(--ck-clipboard-drop-target-color) transparent transparent transparent;\n\t\t\t\tborder-width: calc(var(--ck-clipboard-drop-target-dot-height)) calc(.5 * var(--ck-clipboard-drop-target-dot-width)) 0 calc(.5 * var(--ck-clipboard-drop-target-dot-width));\n\t\t\t\tborder-style: solid;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Styles of the widget that it a drop target.\n\t */\n\t& .ck-widget.ck-clipboard-drop-target-range {\n\t\toutline: var(--ck-widget-outline-thickness) solid var(--ck-clipboard-drop-target-color) !important;\n\t}\n\n\t/*\n\t * Styles of the widget being dragged (its preview).\n\t */\n\t& .ck-widget:-webkit-drag {\n\t\tzoom: 0.6;\n\t\toutline: none !important;\n\t}\n}\n\n.ck.ck-clipboard-drop-target-line {\n\theight: 0;\n\tborder: 1px solid var(--ck-clipboard-drop-target-color);\n\tbackground: var(--ck-clipboard-drop-target-color);\n\tmargin-top: -1px;\n}\n',
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      3624: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          '.ck.ck-editor{position:relative}.ck.ck-editor .ck-editor__top .ck-sticky-panel .ck-toolbar{z-index:var(--ck-z-modal)}.ck.ck-editor__top .ck-sticky-panel .ck-toolbar{border-radius:0}.ck-rounded-corners .ck.ck-editor__top .ck-sticky-panel .ck-toolbar,.ck.ck-editor__top .ck-sticky-panel .ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius);border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-editor__top .ck-sticky-panel .ck-toolbar{border-bottom-width:0}.ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar{border-bottom-width:1px;border-radius:0}.ck-rounded-corners .ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar,.ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius);border-radius:0}.ck.ck-editor__main>.ck-editor__editable{background:var(--ck-color-base-background);border-radius:0}.ck-rounded-corners .ck.ck-editor__main>.ck-editor__editable,.ck.ck-editor__main>.ck-editor__editable.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-top-right-radius:0}.ck.ck-editor__main>.ck-editor__editable:not(.ck-focused){border-color:var(--ck-color-base-border)}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-editor-classic/theme/classiceditor.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-editor-classic/classiceditor.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css',
            ],
            names: [],
            mappings:
              'AAKA,cAIC,iBAMD,CAJC,2DAEC,yBACD,CCLC,gDCED,eDKC,CAPA,uICMA,qCAAsC,CDJpC,2BAA4B,CAC5B,4BAIF,CAPA,gDAMC,qBACD,CAEA,iFACC,uBAAwB,CCR1B,eDaC,CANA,yMCHA,qCAAsC,CDOpC,eAEF,CAKF,yCAEC,0CAA2C,CCpB3C,eD8BD,CAZA,yHCdE,qCAAsC,CDmBtC,wBAAyB,CACzB,yBAMF,CAHC,0DACC,wCACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor {\n\t/* All the elements within `.ck-editor` are positioned relatively to it.\n\t If any element needs to be positioned with respect to the <body>, etc.,\n\t it must land outside of the `.ck-editor` in DOM. */\n\tposition: relative;\n\n\t& .ck-editor__top .ck-sticky-panel .ck-toolbar {\n\t\t/* https://github.com/ckeditor/ckeditor5-editor-classic/issues/62 */\n\t\tz-index: var(--ck-z-modal);\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../mixins/_rounded.css";\n\n.ck.ck-editor__top {\n\t& .ck-sticky-panel {\n\t\t& .ck-toolbar {\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-bottom-left-radius: 0;\n\t\t\t\tborder-bottom-right-radius: 0;\n\t\t\t}\n\n\t\t\tborder-bottom-width: 0;\n\t\t}\n\n\t\t& .ck-sticky-panel__content_sticky .ck-toolbar {\n\t\t\tborder-bottom-width: 1px;\n\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-radius: 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/* Note: Use ck-editor__main to make sure these styles don\'t apply to other editor types */\n.ck.ck-editor__main > .ck-editor__editable {\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/113 */\n\tbackground: var(--ck-color-base-background);\n\n\t@mixin ck-rounded-corners {\n\t\tborder-top-left-radius: 0;\n\t\tborder-top-right-radius: 0;\n\t}\n\n\t&:not(.ck-focused) {\n\t\tborder-color: var(--ck-color-base-border);\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      7372: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          '.ck .ck-placeholder,.ck.ck-placeholder{position:relative}.ck .ck-placeholder:before,.ck.ck-placeholder:before{content:attr(data-placeholder);left:0;pointer-events:none;position:absolute;right:0}.ck.ck-read-only .ck-placeholder:before{display:none}.ck.ck-reset_all .ck-placeholder{position:relative}.ck .ck-placeholder:before,.ck.ck-placeholder:before{color:var(--ck-color-engine-placeholder-text);cursor:text}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-engine/theme/placeholder.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-engine/placeholder.css',
            ],
            names: [],
            mappings:
              'AAMA,uCAEC,iBAWD,CATC,qDAIC,8BAA+B,CAF/B,MAAO,CAKP,mBAAoB,CANpB,iBAAkB,CAElB,OAKD,CAKA,wCACC,YACD,CAQD,iCACC,iBACD,CC5BC,qDAEC,6CAA8C,CAD9C,WAED',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* See ckeditor/ckeditor5#936. */\n.ck.ck-placeholder,\n.ck .ck-placeholder {\n\tposition: relative;\n\n\t&::before {\n\t\tposition: absolute;\n\t\tleft: 0;\n\t\tright: 0;\n\t\tcontent: attr(data-placeholder);\n\n\t\t/* See ckeditor/ckeditor5#469. */\n\t\tpointer-events: none;\n\t}\n}\n\n/* See ckeditor/ckeditor5#1987. */\n.ck.ck-read-only .ck-placeholder {\n\t&::before {\n\t\tdisplay: none;\n\t}\n}\n\n/*\n * Rules for the `ck-placeholder` are loaded before the rules for `ck-reset_all` in the base CKEditor 5 DLL build.\n * This fix overwrites the incorrectly set `position: static` from `ck-reset_all`.\n * See https://github.com/ckeditor/ckeditor5/issues/11418.\n */\n.ck.ck-reset_all .ck-placeholder {\n\tposition: relative;\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* See ckeditor/ckeditor5#936. */\n.ck.ck-placeholder, .ck .ck-placeholder {\n\t&::before {\n\t\tcursor: text;\n\t\tcolor: var(--ck-color-engine-placeholder-text);\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      5037: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          '.ck.ck-editor__editable span[data-ck-unsafe-element]{display:none}',
          '',
          {
            version: 3,
            sources: ['webpack://./node_modules/@ckeditor/ckeditor5-engine/theme/renderer.css'],
            names: [],
            mappings: 'AAMA,qDACC,YACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* Elements marked by the Renderer as hidden should be invisible in the editor. */\n.ck.ck-editor__editable span[data-ck-unsafe-element] {\n\tdisplay: none;\n}\n',
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      4249: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          '.ck.ck-heading_heading1{font-size:20px}.ck.ck-heading_heading2{font-size:17px}.ck.ck-heading_heading3{font-size:14px}.ck[class*=ck-heading_heading]{font-weight:700}.ck.ck-dropdown.ck-heading-dropdown .ck-dropdown__button .ck-button__label{width:8em}.ck.ck-dropdown.ck-heading-dropdown .ck-dropdown__panel .ck-list__item{min-width:18em}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-heading/theme/heading.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-heading/heading.css',
            ],
            names: [],
            mappings: 'AAKA,wBACC,cACD,CAEA,wBACC,cACD,CAEA,wBACC,cACD,CAEA,+BACC,eACD,CCZC,2EACC,SACD,CAEA,uEACC,cACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-heading_heading1 {\n\tfont-size: 20px;\n}\n\n.ck.ck-heading_heading2 {\n\tfont-size: 17px;\n}\n\n.ck.ck-heading_heading3 {\n\tfont-size: 14px;\n}\n\n.ck[class*="ck-heading_heading"] {\n\tfont-weight: bold;\n}\n',
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* Resize dropdown's button label. */\n.ck.ck-dropdown.ck-heading-dropdown {\n\t& .ck-dropdown__button .ck-button__label {\n\t\twidth: 8em;\n\t}\n\n\t& .ck-dropdown__panel .ck-list__item {\n\t\tmin-width: 18em;\n\t}\n}\n",
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      2430: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          '.ck-content .image{clear:both;display:table;margin:.9em auto;min-width:50px;text-align:center}.ck-content .image img{display:block;margin:0 auto;max-width:100%;min-width:100%}.ck-content .image-inline{align-items:flex-start;display:inline-flex;max-width:100%}.ck-content .image-inline picture{display:flex}.ck-content .image-inline img,.ck-content .image-inline picture{flex-grow:1;flex-shrink:1;max-width:100%}.ck.ck-editor__editable .image>figcaption.ck-placeholder:before{overflow:hidden;padding-left:inherit;padding-right:inherit;text-overflow:ellipsis;white-space:nowrap}.ck.ck-editor__editable .image-inline.ck-widget_selected,.ck.ck-editor__editable .image.ck-widget_selected{z-index:1}.ck.ck-editor__editable .image-inline.ck-widget_selected ::selection{display:none}.ck.ck-editor__editable td .image-inline img,.ck.ck-editor__editable th .image-inline img{max-width:none}',
          '',
          {
            version: 3,
            sources: ['webpack://./node_modules/@ckeditor/ckeditor5-image/theme/image.css'],
            names: [],
            mappings:
              'AAMC,mBAEC,UAAW,CADX,aAAc,CAOd,gBAAkB,CAGlB,cAAe,CARf,iBAuBD,CAbC,uBAEC,aAAc,CAGd,aAAc,CAGd,cAAe,CAGf,cACD,CAGD,0BAYC,sBAAuB,CANvB,mBAAoB,CAGpB,cAoBD,CAdC,kCACC,YACD,CAGA,gEAGC,WAAY,CACZ,aAAc,CAGd,cACD,CAUD,gEASC,eAAgB,CARhB,oBAAqB,CACrB,qBAAsB,CAQtB,sBAAuB,CAFvB,kBAGD,CAWA,2GACC,SAUD,CAHC,qEACC,YACD,CAOA,0FACC,cACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content {\n\t& .image {\n\t\tdisplay: table;\n\t\tclear: both;\n\t\ttext-align: center;\n\n\t\t/* Make sure there is some space between the content and the image. Center image by default. */\n\t\t/* The first value should be equal to --ck-spacing-large variable if used in the editor context\n\t \tto avoid the content jumping (See https://github.com/ckeditor/ckeditor5/issues/9825). */\n\t\tmargin: 0.9em auto;\n\n\t\t/* Make sure the caption will be displayed properly (See: https://github.com/ckeditor/ckeditor5/issues/1870). */\n\t\tmin-width: 50px;\n\n\t\t& img {\n\t\t\t/* Prevent unnecessary margins caused by line-height (see #44). */\n\t\t\tdisplay: block;\n\n\t\t\t/* Center the image if its width is smaller than the content\'s width. */\n\t\t\tmargin: 0 auto;\n\n\t\t\t/* Make sure the image never exceeds the size of the parent container (ckeditor/ckeditor5-ui#67). */\n\t\t\tmax-width: 100%;\n\n\t\t\t/* Make sure the image is never smaller than the parent container (See: https://github.com/ckeditor/ckeditor5/issues/9300). */\n\t\t\tmin-width: 100%\n\t\t}\n\t}\n\n\t& .image-inline {\n\t\t/*\n\t\t * Normally, the .image-inline would have "display: inline-block" and "img { width: 100% }" (to follow the wrapper while resizing).\n\t\t * Unfortunately, together with "srcset", it gets automatically stretched up to the width of the editing root.\n\t\t * This strange behavior does not happen with inline-flex.\n\t\t */\n\t\tdisplay: inline-flex;\n\n\t\t/* While being resized, don\'t allow the image to exceed the width of the editing root. */\n\t\tmax-width: 100%;\n\n\t\t/* This is required by Safari to resize images in a sensible way. Without this, the browser breaks the ratio. */\n\t\talign-items: flex-start;\n\n\t\t/* When the picture is present it must act as a flex container to let the img resize properly */\n\t\t& picture {\n\t\t\tdisplay: flex;\n\t\t}\n\n\t\t/* When the picture is present, it must act like a resizable img. */\n\t\t& picture,\n\t\t& img {\n\t\t\t/* This is necessary for the img to span the entire .image-inline wrapper and to resize properly. */\n\t\t\tflex-grow: 1;\n\t\t\tflex-shrink: 1;\n\n\t\t\t/* Prevents overflowing the editing root boundaries when an inline image is very wide. */\n\t\t\tmax-width: 100%;\n\t\t}\n\t}\n}\n\n.ck.ck-editor__editable {\n\t/*\n\t * Inhertit the content styles padding of the <figcaption> in case the integration overrides `text-align: center`\n\t * of `.image` (e.g. to the left/right). This ensures the placeholder stays at the padding just like the native\n\t * caret does, and not at the edge of <figcaption>.\n\t */\n\t& .image > figcaption.ck-placeholder::before {\n\t\tpadding-left: inherit;\n\t\tpadding-right: inherit;\n\n\t\t/*\n\t\t * Make sure the image caption placeholder doesn\'t overflow the placeholder area.\n\t\t * See https://github.com/ckeditor/ckeditor5/issues/9162.\n\t\t */\n\t\twhite-space: nowrap;\n\t\toverflow: hidden;\n\t\ttext-overflow: ellipsis;\n\t}\n\n\n\t/*\n\t * Make sure the selected inline image always stays on top of its siblings.\n\t * See https://github.com/ckeditor/ckeditor5/issues/9108.\n\t */\n\t& .image.ck-widget_selected {\n\t\tz-index: 1;\n\t}\n\n\t& .image-inline.ck-widget_selected {\n\t\tz-index: 1;\n\n\t\t/*\n\t\t * Make sure the native browser selection style is not displayed.\n\t\t * Inline image widgets have their own styles for the selected state and\n\t\t * leaving this up to the browser is asking for a visual collision.\n\t\t */\n\t\t& ::selection {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n\n\t/* The inline image nested in the table should have its original size if not resized.\n\tSee https://github.com/ckeditor/ckeditor5/issues/9117. */\n\t& td,\n\t& th {\n\t\t& .image-inline img {\n\t\t\tmax-width: none;\n\t\t}\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      2423: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          ':root{--ck-color-image-caption-background:#f7f7f7;--ck-color-image-caption-text:#333;--ck-color-image-caption-highligted-background:#fd0}.ck-content .image>figcaption{background-color:var(--ck-color-image-caption-background);caption-side:bottom;color:var(--ck-color-image-caption-text);display:table-caption;font-size:.75em;outline-offset:-1px;padding:.6em;word-break:break-word}.ck.ck-editor__editable .image>figcaption.image__caption_highlighted{animation:ck-image-caption-highlight .6s ease-out}@keyframes ck-image-caption-highlight{0%{background-color:var(--ck-color-image-caption-highligted-background)}to{background-color:var(--ck-color-image-caption-background)}}',
          '',
          {
            version: 3,
            sources: ['webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imagecaption.css'],
            names: [],
            mappings:
              'AAKA,MACC,2CAAoD,CACpD,kCAA8C,CAC9C,mDACD,CAGA,8BAKC,yDAA0D,CAH1D,mBAAoB,CAEpB,wCAAyC,CAHzC,qBAAsB,CAMtB,eAAgB,CAChB,mBAAoB,CAFpB,YAAa,CAHb,qBAMD,CAGA,qEACC,iDACD,CAEA,sCACC,GACC,oEACD,CAEA,GACC,yDACD,CACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-image-caption-background: hsl(0, 0%, 97%);\n\t--ck-color-image-caption-text: hsl(0, 0%, 20%);\n\t--ck-color-image-caption-highligted-background: hsl(52deg 100% 50%);\n}\n\n/* Content styles */\n.ck-content .image > figcaption {\n\tdisplay: table-caption;\n\tcaption-side: bottom;\n\tword-break: break-word;\n\tcolor: var(--ck-color-image-caption-text);\n\tbackground-color: var(--ck-color-image-caption-background);\n\tpadding: .6em;\n\tfont-size: .75em;\n\toutline-offset: -1px;\n}\n\n/* Editing styles */\n.ck.ck-editor__editable .image > figcaption.image__caption_highlighted {\n\tanimation: ck-image-caption-highlight .6s ease-out;\n}\n\n@keyframes ck-image-caption-highlight {\n\t0% {\n\t\tbackground-color: var(--ck-color-image-caption-highligted-background);\n\t}\n\n\t100% {\n\t\tbackground-color: var(--ck-color-image-caption-background);\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      8879: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          '.ck.ck-image-insert__panel{padding:var(--ck-spacing-large)}.ck.ck-image-insert__ck-finder-button{border:1px solid #ccc;border-radius:var(--ck-border-radius);display:block;margin:var(--ck-spacing-standard) auto;width:100%}.ck.ck-splitbutton>.ck-file-dialog-button.ck-button{border:none;margin:0;padding:0}',
          '',
          {
            version: 3,
            sources: ['webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imageinsert.css'],
            names: [],
            mappings:
              'AAKA,2BACC,+BACD,CAEA,sCAIC,qBAAiC,CACjC,qCAAsC,CAJtC,aAAc,CAEd,sCAAuC,CADvC,UAID,CAGA,oDAGC,WAAY,CADZ,QAAS,CADT,SAGD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-image-insert__panel {\n\tpadding: var(--ck-spacing-large);\n}\n\n.ck.ck-image-insert__ck-finder-button {\n\tdisplay: block;\n\twidth: 100%;\n\tmargin: var(--ck-spacing-standard) auto;\n\tborder: 1px solid hsl(0, 0%, 80%);\n\tborder-radius: var(--ck-border-radius);\n}\n\n/* https://github.com/ckeditor/ckeditor5/issues/7986 */\n.ck.ck-splitbutton > .ck-file-dialog-button.ck-button {\n\tpadding: 0;\n\tmargin: 0;\n\tborder: none;\n}\n',
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      8340: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          '.ck.ck-image-insert-form:focus{outline:none}.ck.ck-form__row{display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between}.ck.ck-form__row>:not(.ck-label){flex-grow:1}.ck.ck-form__row.ck-image-insert-form__action-row{margin-top:var(--ck-spacing-standard)}.ck.ck-form__row.ck-image-insert-form__action-row .ck-button-cancel,.ck.ck-form__row.ck-image-insert-form__action-row .ck-button-save{justify-content:center}.ck.ck-form__row.ck-image-insert-form__action-row .ck-button .ck-button__label{color:var(--ck-color-text)}',
          '',
          {
            version: 3,
            sources: ['webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imageinsertformrowview.css'],
            names: [],
            mappings:
              'AAMC,+BAEC,YACD,CAGD,iBACC,YAAa,CACb,kBAAmB,CACnB,gBAAiB,CACjB,6BAmBD,CAhBC,iCACC,WACD,CAEA,kDACC,qCAUD,CARC,sIAEC,sBACD,CAEA,+EACC,0BACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-image-insert-form {\n\t&:focus {\n\t\t/* See: https://github.com/ckeditor/ckeditor5/issues/4773 */\n\t\toutline: none;\n\t}\n}\n\n.ck.ck-form__row {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\tjustify-content: space-between;\n\n\t/* Ignore labels that work as fieldset legends */\n\t& > *:not(.ck-label) {\n\t\tflex-grow: 1;\n\t}\n\n\t&.ck-image-insert-form__action-row {\n\t\tmargin-top: var(--ck-spacing-standard);\n\n\t\t& .ck-button-save,\n\t\t& .ck-button-cancel {\n\t\t\tjustify-content: center;\n\t\t}\n\n\t\t& .ck-button .ck-button__label {\n\t\t\tcolor: var(--ck-color-text);\n\t\t}\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      2400: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          '.ck-content .image.image_resized{box-sizing:border-box;display:block;max-width:100%}.ck-content .image.image_resized img{width:100%}.ck-content .image.image_resized>figcaption{display:block}.ck.ck-editor__editable td .image-inline.image_resized img,.ck.ck-editor__editable th .image-inline.image_resized img{max-width:100%}[dir=ltr] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon{margin-right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon{margin-left:var(--ck-spacing-standard)}.ck.ck-dropdown .ck-button.ck-resize-image-button .ck-button__label{width:4em}',
          '',
          {
            version: 3,
            sources: ['webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imageresize.css'],
            names: [],
            mappings:
              'AAKA,iCAQC,qBAAsB,CADtB,aAAc,CANd,cAkBD,CATC,qCAEC,UACD,CAEA,4CAEC,aACD,CAQC,sHACC,cACD,CAIF,oFACC,uCACD,CAEA,oFACC,sCACD,CAEA,oEACC,SACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content .image.image_resized {\n\tmax-width: 100%;\n\t/*\n\tThe `<figure>` element for resized images must not use `display:table` as browsers do not support `max-width` for it well.\n\tSee https://stackoverflow.com/questions/4019604/chrome-safari-ignoring-max-width-in-table/14420691#14420691 for more.\n\tFortunately, since we control the width, there is no risk that the image will look bad.\n\t*/\n\tdisplay: block;\n\tbox-sizing: border-box;\n\n\t& img {\n\t\t/* For resized images it is the `<figure>` element that determines the image width. */\n\t\twidth: 100%;\n\t}\n\n\t& > figcaption {\n\t\t/* The `<figure>` element uses `display:block`, so `<figcaption>` also has to. */\n\t\tdisplay: block;\n\t}\n}\n\n.ck.ck-editor__editable {\n\t/* The resized inline image nested in the table should respect its parent size.\n\tSee https://github.com/ckeditor/ckeditor5/issues/9117. */\n\t& td,\n\t& th {\n\t\t& .image-inline.image_resized img {\n\t\t\tmax-width: 100%;\n\t\t}\n\t}\n}\n\n[dir="ltr"] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon {\n\tmargin-right: var(--ck-spacing-standard);\n}\n\n[dir="rtl"] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon {\n\tmargin-left: var(--ck-spacing-standard);\n}\n\n.ck.ck-dropdown .ck-button.ck-resize-image-button .ck-button__label {\n\twidth: 4em;\n}\n',
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      3534: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          ':root{--ck-image-style-spacing:1.5em;--ck-inline-image-style-spacing:calc(var(--ck-image-style-spacing)/2)}.ck-content .image-style-block-align-left,.ck-content .image-style-block-align-right{max-width:calc(100% - var(--ck-image-style-spacing))}.ck-content .image-style-align-left,.ck-content .image-style-align-right{clear:none}.ck-content .image-style-side{float:right;margin-left:var(--ck-image-style-spacing);max-width:50%}.ck-content .image-style-align-left{float:left;margin-right:var(--ck-image-style-spacing)}.ck-content .image-style-align-center{margin-left:auto;margin-right:auto}.ck-content .image-style-align-right{float:right;margin-left:var(--ck-image-style-spacing)}.ck-content .image-style-block-align-right{margin-left:auto;margin-right:0}.ck-content .image-style-block-align-left{margin-left:0;margin-right:auto}.ck-content p+.image-style-align-left,.ck-content p+.image-style-align-right,.ck-content p+.image-style-side{margin-top:0}.ck-content .image-inline.image-style-align-left,.ck-content .image-inline.image-style-align-right{margin-bottom:var(--ck-inline-image-style-spacing);margin-top:var(--ck-inline-image-style-spacing)}.ck-content .image-inline.image-style-align-left{margin-right:var(--ck-inline-image-style-spacing)}.ck-content .image-inline.image-style-align-right{margin-left:var(--ck-inline-image-style-spacing)}.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__action:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover),.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__action:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover){background-color:var(--ck-color-button-on-background)}.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__action:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover):after,.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__action:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover):after{display:none}.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open:hover>.ck-splitbutton__action:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open:hover>.ck-splitbutton__arrow:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open:hover>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover){background-color:var(--ck-color-button-on-hover-background)}',
          '',
          {
            version: 3,
            sources: ['webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imagestyle.css'],
            names: [],
            mappings:
              'AAKA,MACC,8BAA+B,CAC/B,qEACD,CAMC,qFAEC,oDACD,CAIA,yEAEC,UACD,CAEA,8BACC,WAAY,CACZ,yCAA0C,CAC1C,aACD,CAEA,oCACC,UAAW,CACX,0CACD,CAEA,sCACC,gBAAiB,CACjB,iBACD,CAEA,qCACC,WAAY,CACZ,yCACD,CAEA,2CAEC,gBAAiB,CADjB,cAED,CAEA,0CACC,aAAc,CACd,iBACD,CAGA,6GAGC,YACD,CAGC,mGAGC,kDAAmD,CADnD,+CAED,CAEA,iDACC,iDACD,CAEA,kDACC,gDACD,CAUC,0lBAGC,qDAKD,CAHC,8nBACC,YACD,CAKD,oVAGC,2DACD',
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-image-style-spacing: 1.5em;\n\t--ck-inline-image-style-spacing: calc(var(--ck-image-style-spacing) / 2);\n}\n\n.ck-content {\n\t/* Provides a minimal side margin for the left and right aligned images, so that the user has a visual feedback\n\tconfirming successful application of the style if image width exceeds the editor's size.\n\tSee https://github.com/ckeditor/ckeditor5/issues/9342 */\n\t& .image-style-block-align-left,\n\t& .image-style-block-align-right {\n\t\tmax-width: calc(100% - var(--ck-image-style-spacing));\n\t}\n\n\t/* Allows displaying multiple floating images in the same line.\n\tSee https://github.com/ckeditor/ckeditor5/issues/9183#issuecomment-804988132 */\n\t& .image-style-align-left,\n\t& .image-style-align-right {\n\t\tclear: none;\n\t}\n\n\t& .image-style-side {\n\t\tfloat: right;\n\t\tmargin-left: var(--ck-image-style-spacing);\n\t\tmax-width: 50%;\n\t}\n\n\t& .image-style-align-left {\n\t\tfloat: left;\n\t\tmargin-right: var(--ck-image-style-spacing);\n\t}\n\n\t& .image-style-align-center {\n\t\tmargin-left: auto;\n\t\tmargin-right: auto;\n\t}\n\n\t& .image-style-align-right {\n\t\tfloat: right;\n\t\tmargin-left: var(--ck-image-style-spacing);\n\t}\n\n\t& .image-style-block-align-right {\n\t\tmargin-right: 0;\n\t\tmargin-left: auto;\n\t}\n\n\t& .image-style-block-align-left {\n\t\tmargin-left: 0;\n\t\tmargin-right: auto;\n\t}\n\n\t/* Simulates margin collapsing with the preceding paragraph, which does not work for the floating elements. */\n\t& p + .image-style-align-left,\n\t& p + .image-style-align-right,\n\t& p + .image-style-side {\n\t\tmargin-top: 0;\n\t}\n\n\t& .image-inline {\n\t\t&.image-style-align-left,\n\t\t&.image-style-align-right {\n\t\t\tmargin-top: var(--ck-inline-image-style-spacing);\n\t\t\tmargin-bottom: var(--ck-inline-image-style-spacing);\n\t\t}\n\n\t\t&.image-style-align-left {\n\t\t\tmargin-right: var(--ck-inline-image-style-spacing);\n\t\t}\n\n\t\t&.image-style-align-right {\n\t\t\tmargin-left: var(--ck-inline-image-style-spacing);\n\t\t}\n\t}\n}\n\n.ck.ck-splitbutton {\n\t/* The button should display as a regular drop-down if the action button\n\tis forced to fire the same action as the arrow button. */\n\t&.ck-splitbutton_flatten {\n\t\t&:hover,\n\t\t&.ck-splitbutton_open {\n\t\t\t& > .ck-splitbutton__action:not(.ck-disabled),\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled),\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled):not(:hover) {\n\t\t\t\tbackground-color: var(--ck-color-button-on-background);\n\n\t\t\t\t&::after {\n\t\t\t\t\tdisplay: none;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t&.ck-splitbutton_open:hover {\n\t\t\t& > .ck-splitbutton__action:not(.ck-disabled),\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled),\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled):not(:hover) {\n\t\t\t\tbackground-color: var(--ck-color-button-on-hover-background);\n\t\t\t}\n\t\t}\n\t}\n}\n",
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      1547: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          '.ck-image-upload-complete-icon{border-radius:50%;display:block;position:absolute;right:min(var(--ck-spacing-medium),6%);top:min(var(--ck-spacing-medium),6%);z-index:1}.ck-image-upload-complete-icon:after{content:"";position:absolute}:root{--ck-color-image-upload-icon:#fff;--ck-color-image-upload-icon-background:#008a00;--ck-image-upload-icon-size:20;--ck-image-upload-icon-width:2px;--ck-image-upload-icon-is-visible:clamp(0px,100% - 50px,1px)}.ck-image-upload-complete-icon{animation-delay:0ms,3s;animation-duration:.5s,.5s;animation-fill-mode:forwards,forwards;animation-name:ck-upload-complete-icon-show,ck-upload-complete-icon-hide;background:var(--ck-color-image-upload-icon-background);font-size:calc(1px*var(--ck-image-upload-icon-size));height:calc(var(--ck-image-upload-icon-is-visible)*var(--ck-image-upload-icon-size));opacity:0;overflow:hidden;width:calc(var(--ck-image-upload-icon-is-visible)*var(--ck-image-upload-icon-size))}.ck-image-upload-complete-icon:after{animation-delay:.5s;animation-duration:.5s;animation-fill-mode:forwards;animation-name:ck-upload-complete-icon-check;border-right:var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);border-top:var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);box-sizing:border-box;height:0;left:25%;opacity:0;top:50%;transform:scaleX(-1) rotate(135deg);transform-origin:left top;width:0}@keyframes ck-upload-complete-icon-show{0%{opacity:0}to{opacity:1}}@keyframes ck-upload-complete-icon-hide{0%{opacity:1}to{opacity:0}}@keyframes ck-upload-complete-icon-check{0%{height:0;opacity:1;width:0}33%{height:0;width:.3em}to{height:.45em;opacity:1;width:.3em}}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imageuploadicon.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadicon.css',
            ],
            names: [],
            mappings:
              'AAKA,+BAUC,iBAAkB,CATlB,aAAc,CACd,iBAAkB,CAOlB,sCAAwC,CADxC,oCAAsC,CAGtC,SAMD,CAJC,qCACC,UAAW,CACX,iBACD,CChBD,MACC,iCAA8C,CAC9C,+CAA4D,CAG5D,8BAA+B,CAC/B,gCAAiC,CACjC,4DACD,CAEA,+BAWC,sBAA4B,CAN5B,0BAAgC,CADhC,qCAAuC,CADvC,wEAA0E,CAD1E,uDAAwD,CAMxD,oDAAuD,CAWvD,oFAAuF,CAlBvF,SAAU,CAgBV,eAAgB,CAChB,mFA0BD,CAtBC,qCAgBC,mBAAsB,CADtB,sBAAyB,CAEzB,4BAA6B,CAH7B,4CAA6C,CAF7C,sFAAuF,CADvF,oFAAqF,CASrF,qBAAsB,CAdtB,QAAS,CAJT,QAAS,CAGT,SAAU,CADV,OAAQ,CAKR,mCAAoC,CACpC,yBAA0B,CAH1B,OAcD,CAGD,wCACC,GACC,SACD,CAEA,GACC,SACD,CACD,CAEA,wCACC,GACC,SACD,CAEA,GACC,SACD,CACD,CAEA,yCACC,GAGC,QAAS,CAFT,SAAU,CACV,OAED,CACA,IAEC,QAAS,CADT,UAED,CACA,GAGC,YAAc,CAFd,SAAU,CACV,UAED,CACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-image-upload-complete-icon {\n\tdisplay: block;\n\tposition: absolute;\n\n\t/*\n\t * Smaller images should have the icon closer to the border.\n\t * Match the icon position with the linked image indicator brought by the link image feature.\n\t */\n\ttop: min(var(--ck-spacing-medium), 6%);\n\tright: min(var(--ck-spacing-medium), 6%);\n\tborder-radius: 50%;\n\tz-index: 1;\n\n\t&::after {\n\t\tcontent: "";\n\t\tposition: absolute;\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-image-upload-icon: hsl(0, 0%, 100%);\n\t--ck-color-image-upload-icon-background: hsl(120, 100%, 27%);\n\n\t/* Match the icon size with the linked image indicator brought by the link image feature. */\n\t--ck-image-upload-icon-size: 20;\n\t--ck-image-upload-icon-width: 2px;\n\t--ck-image-upload-icon-is-visible: clamp(0px, 100% - 50px, 1px);\n}\n\n.ck-image-upload-complete-icon {\n\topacity: 0;\n\tbackground: var(--ck-color-image-upload-icon-background);\n\tanimation-name: ck-upload-complete-icon-show, ck-upload-complete-icon-hide;\n\tanimation-fill-mode: forwards, forwards;\n\tanimation-duration: 500ms, 500ms;\n\n\t/* To make animation scalable. */\n\tfont-size: calc(1px * var(--ck-image-upload-icon-size));\n\n\t/* Hide completed upload icon after 3 seconds. */\n\tanimation-delay: 0ms, 3000ms;\n\n\t/*\n\t * Use CSS math to simulate container queries.\n\t * https://css-tricks.com/the-raven-technique-one-step-closer-to-container-queries/#what-about-showing-and-hiding-things\n\t */\n\toverflow: hidden;\n\twidth: calc(var(--ck-image-upload-icon-is-visible) * var(--ck-image-upload-icon-size));\n\theight: calc(var(--ck-image-upload-icon-is-visible) * var(--ck-image-upload-icon-size));\n\n\t/* This is check icon element made from border-width mixed with animations. */\n\t&::after {\n\t\t/* Because of border transformation we need to "hard code" left position. */\n\t\tleft: 25%;\n\n\t\ttop: 50%;\n\t\topacity: 0;\n\t\theight: 0;\n\t\twidth: 0;\n\n\t\ttransform: scaleX(-1) rotate(135deg);\n\t\ttransform-origin: left top;\n\t\tborder-top: var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);\n\t\tborder-right: var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);\n\n\t\tanimation-name: ck-upload-complete-icon-check;\n\t\tanimation-duration: 500ms;\n\t\tanimation-delay: 500ms;\n\t\tanimation-fill-mode: forwards;\n\n\t\t/* #1095. While reset is not providing proper box-sizing for pseudoelements, we need to handle it. */\n\t\tbox-sizing: border-box;\n\t}\n}\n\n@keyframes ck-upload-complete-icon-show {\n\tfrom {\n\t\topacity: 0;\n\t}\n\n\tto {\n\t\topacity: 1;\n\t}\n}\n\n@keyframes ck-upload-complete-icon-hide {\n\tfrom {\n\t\topacity: 1;\n\t}\n\n\tto {\n\t\topacity: 0;\n\t}\n}\n\n@keyframes ck-upload-complete-icon-check {\n\t0% {\n\t\topacity: 1;\n\t\twidth: 0;\n\t\theight: 0;\n\t}\n\t33% {\n\t\twidth: 0.3em;\n\t\theight: 0;\n\t}\n\t100% {\n\t\topacity: 1;\n\t\twidth: 0.3em;\n\t\theight: 0.45em;\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      6618: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          '.ck .ck-upload-placeholder-loader{align-items:center;display:flex;justify-content:center;left:0;position:absolute;top:0}.ck .ck-upload-placeholder-loader:before{content:"";position:relative}:root{--ck-color-upload-placeholder-loader:#b3b3b3;--ck-upload-placeholder-loader-size:32px;--ck-upload-placeholder-image-aspect-ratio:2.8}.ck .ck-image-upload-placeholder{margin:0;width:100%}.ck .ck-image-upload-placeholder.image-inline{width:calc(var(--ck-upload-placeholder-loader-size)*2*var(--ck-upload-placeholder-image-aspect-ratio))}.ck .ck-image-upload-placeholder img{aspect-ratio:var(--ck-upload-placeholder-image-aspect-ratio)}.ck .ck-upload-placeholder-loader{height:100%;width:100%}.ck .ck-upload-placeholder-loader:before{animation:ck-upload-placeholder-loader 1s linear infinite;border-radius:50%;border-right:2px solid transparent;border-top:3px solid var(--ck-color-upload-placeholder-loader);height:var(--ck-upload-placeholder-loader-size);width:var(--ck-upload-placeholder-loader-size)}@keyframes ck-upload-placeholder-loader{to{transform:rotate(1turn)}}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imageuploadloader.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadloader.css',
            ],
            names: [],
            mappings:
              'AAKA,kCAGC,kBAAmB,CADnB,YAAa,CAEb,sBAAuB,CAEvB,MAAO,CALP,iBAAkB,CAIlB,KAOD,CAJC,yCACC,UAAW,CACX,iBACD,CCXD,MACC,4CAAqD,CACrD,wCAAyC,CACzC,8CACD,CAEA,iCAGC,QAAS,CADT,UAgBD,CAbC,8CACC,sGACD,CAEA,qCAOC,4DACD,CAGD,kCAEC,WAAY,CADZ,UAWD,CARC,yCAMC,yDAA0D,CAH1D,iBAAkB,CAElB,kCAAmC,CADnC,8DAA+D,CAF/D,+CAAgD,CADhD,8CAMD,CAGD,wCACC,GACC,uBACD,CACD',
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-upload-placeholder-loader {\n\tposition: absolute;\n\tdisplay: flex;\n\talign-items: center;\n\tjustify-content: center;\n\ttop: 0;\n\tleft: 0;\n\n\t&::before {\n\t\tcontent: '';\n\t\tposition: relative;\n\t}\n}\n",
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-upload-placeholder-loader: hsl(0, 0%, 70%);\n\t--ck-upload-placeholder-loader-size: 32px;\n\t--ck-upload-placeholder-image-aspect-ratio: 2.8;\n}\n\n.ck .ck-image-upload-placeholder {\n\t/* We need to control the full width of the SVG gray background. */\n\twidth: 100%;\n\tmargin: 0;\n\n\t&.image-inline {\n\t\twidth: calc( 2 * var(--ck-upload-placeholder-loader-size) * var(--ck-upload-placeholder-image-aspect-ratio) );\n\t}\n\n\t& img {\n\t\t/*\n\t\t * This is an arbitrary aspect for a 1x1 px GIF to display to the user. Not too tall, not too short.\n\t\t * There's nothing special about this number except that it should make the image placeholder look like\n\t\t * a real image during this short period after the upload started and before the image was read from the\n\t\t * file system (and a rich preview was loaded).\n\t\t */\n\t\taspect-ratio: var(--ck-upload-placeholder-image-aspect-ratio);\n\t}\n}\n\n.ck .ck-upload-placeholder-loader {\n\twidth: 100%;\n\theight: 100%;\n\n\t&::before {\n\t\twidth: var(--ck-upload-placeholder-loader-size);\n\t\theight: var(--ck-upload-placeholder-loader-size);\n\t\tborder-radius: 50%;\n\t\tborder-top: 3px solid var(--ck-color-upload-placeholder-loader);\n\t\tborder-right: 2px solid transparent;\n\t\tanimation: ck-upload-placeholder-loader 1s linear infinite;\n\t}\n}\n\n@keyframes ck-upload-placeholder-loader {\n\tto {\n\t\ttransform: rotate( 360deg );\n\t}\n}\n",
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      2926: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          '.ck.ck-editor__editable .image,.ck.ck-editor__editable .image-inline{position:relative}.ck.ck-editor__editable .image .ck-progress-bar,.ck.ck-editor__editable .image-inline .ck-progress-bar{left:0;position:absolute;top:0}.ck.ck-editor__editable .image-inline.ck-appear,.ck.ck-editor__editable .image.ck-appear{animation:fadeIn .7s}.ck.ck-editor__editable .image .ck-progress-bar,.ck.ck-editor__editable .image-inline .ck-progress-bar{background:var(--ck-color-upload-bar-background);height:2px;transition:width .1s;width:0}@keyframes fadeIn{0%{opacity:0}to{opacity:1}}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imageuploadprogress.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadprogress.css',
            ],
            names: [],
            mappings:
              'AAMC,qEAEC,iBACD,CAGA,uGAIC,MAAO,CAFP,iBAAkB,CAClB,KAED,CCRC,yFACC,oBACD,CAID,uGAIC,gDAAiD,CAFjD,UAAW,CAGX,oBAAuB,CAFvB,OAGD,CAGD,kBACC,GAAO,SAAY,CACnB,GAAO,SAAY,CACpB',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor__editable {\n\t& .image,\n\t& .image-inline {\n\t\tposition: relative;\n\t}\n\n\t/* Upload progress bar. */\n\t& .image .ck-progress-bar,\n\t& .image-inline .ck-progress-bar {\n\t\tposition: absolute;\n\t\ttop: 0;\n\t\tleft: 0;\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor__editable {\n\t& .image,\n\t& .image-inline {\n\t\t/* Showing animation. */\n\t\t&.ck-appear {\n\t\t\tanimation: fadeIn 700ms;\n\t\t}\n\t}\n\n\t/* Upload progress bar. */\n\t& .image .ck-progress-bar,\n\t& .image-inline .ck-progress-bar {\n\t\theight: 2px;\n\t\twidth: 0;\n\t\tbackground: var(--ck-color-upload-bar-background);\n\t\ttransition: width 100ms;\n\t}\n}\n\n@keyframes fadeIn {\n\tfrom { opacity: 0; }\n\tto   { opacity: 1; }\n}\n',
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      5269: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          '.ck.ck-text-alternative-form{display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-text-alternative-form .ck-labeled-field-view{display:inline-block}.ck.ck-text-alternative-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-text-alternative-form{flex-wrap:wrap}.ck.ck-text-alternative-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-text-alternative-form .ck-button{flex-basis:50%}}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-image/theme/textalternativeform.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css',
            ],
            names: [],
            mappings:
              'AAOA,6BACC,YAAa,CACb,kBAAmB,CACnB,gBAqBD,CAnBC,oDACC,oBACD,CAEA,uCACC,YACD,CCZA,oCDCD,6BAcE,cAUF,CARE,oDACC,eACD,CAEA,wCACC,cACD,CCrBD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-text-alternative-form {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\n\t& .ck-labeled-field-view {\n\t\tdisplay: inline-block;\n\t}\n\n\t& .ck-label {\n\t\tdisplay: none;\n\t}\n\n\t@mixin ck-media-phone {\n\t\tflex-wrap: wrap;\n\n\t\t& .ck-labeled-field-view {\n\t\t\tflex-basis: 100%;\n\t\t}\n\n\t\t& .ck-button {\n\t\t\tflex-basis: 50%;\n\t\t}\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      3925: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          '.ck .ck-link_selected{background:var(--ck-color-link-selected-background)}.ck .ck-link_selected span.image-inline{outline:var(--ck-widget-outline-thickness) solid var(--ck-color-link-selected-background)}.ck .ck-fake-link-selection{background:var(--ck-color-link-fake-selection)}.ck .ck-fake-link-selection_collapsed{border-right:1px solid var(--ck-color-base-text);height:100%;margin-right:-1px;outline:1px solid hsla(0,0%,100%,.5)}',
          '',
          {
            version: 3,
            sources: ['webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-link/link.css'],
            names: [],
            mappings:
              'AAMA,sBACC,mDAMD,CAHC,wCACC,yFACD,CAOD,4BACC,8CACD,CAGA,sCAEC,gDAAiD,CADjD,WAAY,CAEZ,iBAAkB,CAClB,oCACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* Class added to span element surrounding currently selected link. */\n.ck .ck-link_selected {\n\tbackground: var(--ck-color-link-selected-background);\n\n\t/* Give linked inline images some outline to let the user know they are also part of the link. */\n\t& span.image-inline {\n\t\toutline: var(--ck-widget-outline-thickness) solid var(--ck-color-link-selected-background);\n\t}\n}\n\n/*\n * Classes used by the "fake visual selection" displayed in the content when an input\n * in the link UI has focus (the browser does not render the native selection in this state).\n */\n.ck .ck-fake-link-selection {\n\tbackground: var(--ck-color-link-fake-selection);\n}\n\n/* A collapsed fake visual selection. */\n.ck .ck-fake-link-selection_collapsed {\n\theight: 100%;\n\tborder-right: 1px solid var(--ck-color-base-text);\n\tmargin-right: -1px;\n\toutline: solid 1px hsla(0, 0%, 100%, .5);\n}\n',
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      7536: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          '.ck.ck-link-actions{display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-link-actions .ck-link-actions__preview{display:inline-block}.ck.ck-link-actions .ck-link-actions__preview .ck-button__label{overflow:hidden}@media screen and (max-width:600px){.ck.ck-link-actions{flex-wrap:wrap}.ck.ck-link-actions .ck-link-actions__preview{flex-basis:100%}.ck.ck-link-actions .ck-button:not(.ck-link-actions__preview){flex-basis:50%}}.ck.ck-link-actions .ck-button.ck-link-actions__preview{padding-left:0;padding-right:0}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label{color:var(--ck-color-link-default);cursor:pointer;max-width:var(--ck-input-width);min-width:3em;padding:0 var(--ck-spacing-medium);text-align:center;text-overflow:ellipsis}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label:hover{text-decoration:underline}.ck.ck-link-actions .ck-button.ck-link-actions__preview,.ck.ck-link-actions .ck-button.ck-link-actions__preview:active,.ck.ck-link-actions .ck-button.ck-link-actions__preview:focus,.ck.ck-link-actions .ck-button.ck-link-actions__preview:hover{background:none}.ck.ck-link-actions .ck-button.ck-link-actions__preview:active{box-shadow:none}.ck.ck-link-actions .ck-button.ck-link-actions__preview:focus .ck-button__label{text-decoration:underline}[dir=ltr] .ck.ck-link-actions .ck-button:not(:first-child),[dir=rtl] .ck.ck-link-actions .ck-button:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-link-actions .ck-button.ck-link-actions__preview{margin:var(--ck-spacing-standard) var(--ck-spacing-standard) 0}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label{max-width:100%;min-width:0}[dir=ltr] .ck.ck-link-actions .ck-button:not(.ck-link-actions__preview),[dir=rtl] .ck.ck-link-actions .ck-button:not(.ck-link-actions__preview){margin-left:0}}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-link/theme/linkactions.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-link/linkactions.css',
            ],
            names: [],
            mappings:
              'AAOA,oBACC,YAAa,CACb,kBAAmB,CACnB,gBAqBD,CAnBC,8CACC,oBAKD,CAHC,gEACC,eACD,CCXD,oCDCD,oBAcE,cAUF,CARE,8CACC,eACD,CAEA,8DACC,cACD,CCrBD,CCIA,wDACC,cAAe,CACf,eAmCD,CAjCC,0EAEC,kCAAmC,CAEnC,cAAe,CAIf,+BAAgC,CAChC,aAAc,CARd,kCAAmC,CASnC,iBAAkB,CAPlB,sBAYD,CAHC,gFACC,yBACD,CAGD,mPAIC,eACD,CAEA,+DACC,eACD,CAGC,gFACC,yBACD,CAWD,qHACC,sCACD,CDtDD,oCC0DC,wDACC,8DAMD,CAJC,0EAEC,cAAe,CADf,WAED,CAGD,gJAME,aAEF,CDzED',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-link-actions {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\n\t& .ck-link-actions__preview {\n\t\tdisplay: inline-block;\n\n\t\t& .ck-button__label {\n\t\t\toverflow: hidden;\n\t\t}\n\t}\n\n\t@mixin ck-media-phone {\n\t\tflex-wrap: wrap;\n\n\t\t& .ck-link-actions__preview {\n\t\t\tflex-basis: 100%;\n\t\t}\n\n\t\t& .ck-button:not(.ck-link-actions__preview) {\n\t\t\tflex-basis: 50%;\n\t\t}\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n@import "../mixins/_focus.css";\n@import "../mixins/_shadow.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-link-actions {\n\t& .ck-button.ck-link-actions__preview {\n\t\tpadding-left: 0;\n\t\tpadding-right: 0;\n\n\t\t& .ck-button__label {\n\t\t\tpadding: 0 var(--ck-spacing-medium);\n\t\t\tcolor: var(--ck-color-link-default);\n\t\t\ttext-overflow: ellipsis;\n\t\t\tcursor: pointer;\n\n\t\t\t/* Match the box model of the link editor form\'s input so the balloon\n\t\t\tdoes not change width when moving between actions and the form. */\n\t\t\tmax-width: var(--ck-input-width);\n\t\t\tmin-width: 3em;\n\t\t\ttext-align: center;\n\n\t\t\t&:hover {\n\t\t\t\ttext-decoration: underline;\n\t\t\t}\n\t\t}\n\n\t\t&,\n\t\t&:hover,\n\t\t&:focus,\n\t\t&:active {\n\t\t\tbackground: none;\n\t\t}\n\n\t\t&:active {\n\t\t\tbox-shadow: none;\n\t\t}\n\n\t\t&:focus {\n\t\t\t& .ck-button__label {\n\t\t\t\ttext-decoration: underline;\n\t\t\t}\n\t\t}\n\t}\n\n\t@mixin ck-dir ltr {\n\t\t& .ck-button:not(:first-child) {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-dir rtl {\n\t\t& .ck-button:not(:last-child) {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-media-phone {\n\t\t& .ck-button.ck-link-actions__preview {\n\t\t\tmargin: var(--ck-spacing-standard) var(--ck-spacing-standard) 0;\n\n\t\t\t& .ck-button__label {\n\t\t\t\tmin-width: 0;\n\t\t\t\tmax-width: 100%;\n\t\t\t}\n\t\t}\n\n\t\t& .ck-button:not(.ck-link-actions__preview) {\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tmargin-left: 0;\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tmargin-left: 0;\n\t\t\t}\n\t\t}\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      4874: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          '.ck.ck-link-form{display:flex}.ck.ck-link-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-link-form{flex-wrap:wrap}.ck.ck-link-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-link-form .ck-button{flex-basis:50%}}.ck.ck-link-form_layout-vertical{display:block}.ck.ck-link-form_layout-vertical .ck-button.ck-button-cancel,.ck.ck-link-form_layout-vertical .ck-button.ck-button-save{margin-top:var(--ck-spacing-medium)}.ck.ck-link-form_layout-vertical{min-width:var(--ck-input-width);padding:0}.ck.ck-link-form_layout-vertical .ck-labeled-field-view{margin:var(--ck-spacing-large) var(--ck-spacing-large) var(--ck-spacing-small)}.ck.ck-link-form_layout-vertical .ck-labeled-field-view .ck-input-text{min-width:0;width:100%}.ck.ck-link-form_layout-vertical>.ck-button{border-radius:0;margin:0;padding:var(--ck-spacing-standard);width:50%}.ck.ck-link-form_layout-vertical>.ck-button:not(:focus){border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck.ck-link-form_layout-vertical>.ck-button,[dir=rtl] .ck.ck-link-form_layout-vertical>.ck-button{margin-left:0}[dir=rtl] .ck.ck-link-form_layout-vertical>.ck-button:last-of-type{border-right:1px solid var(--ck-color-base-border)}.ck.ck-link-form_layout-vertical .ck.ck-list{margin:var(--ck-spacing-standard) var(--ck-spacing-large)}.ck.ck-link-form_layout-vertical .ck.ck-list .ck-button.ck-switchbutton{padding:0;width:100%}.ck.ck-link-form_layout-vertical .ck.ck-list .ck-button.ck-switchbutton:hover{background:none}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-link/theme/linkform.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-link/linkform.css',
            ],
            names: [],
            mappings:
              'AAOA,iBACC,YAiBD,CAfC,2BACC,YACD,CCNA,oCDCD,iBAQE,cAUF,CARE,wCACC,eACD,CAEA,4BACC,cACD,CCfD,CDuBD,iCACC,aAYD,CALE,wHAEC,mCACD,CE/BF,iCAEC,+BAAgC,CADhC,SAgDD,CA7CC,wDACC,8EAMD,CAJC,uEACC,WAAY,CACZ,UACD,CAGD,4CAIC,eAAgB,CAFhB,QAAS,CADT,kCAAmC,CAEnC,SAkBD,CAfC,wDACC,gDACD,CARD,4GAeE,aAMF,CAJE,mEACC,kDACD,CAKF,6CACC,yDAUD,CARC,wEACC,SAAU,CACV,UAKD,CAHC,8EACC,eACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-link-form {\n\tdisplay: flex;\n\n\t& .ck-label {\n\t\tdisplay: none;\n\t}\n\n\t@mixin ck-media-phone {\n\t\tflex-wrap: wrap;\n\n\t\t& .ck-labeled-field-view {\n\t\t\tflex-basis: 100%;\n\t\t}\n\n\t\t& .ck-button {\n\t\t\tflex-basis: 50%;\n\t\t}\n\t}\n}\n\n/*\n * Style link form differently when manual decorators are available.\n * See: https://github.com/ckeditor/ckeditor5-link/issues/186.\n */\n.ck.ck-link-form_layout-vertical {\n\tdisplay: block;\n\n\t/*\n\t * Whether the form is in the responsive mode or not, if there are decorator buttons\n\t * keep the top margin of action buttons medium.\n\t */\n\t& .ck-button {\n\t\t&.ck-button-save,\n\t\t&.ck-button-cancel {\n\t\t\tmargin-top: var(--ck-spacing-medium);\n\t\t}\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n/*\n * Style link form differently when manual decorators are available.\n * See: https://github.com/ckeditor/ckeditor5-link/issues/186.\n */\n.ck.ck-link-form_layout-vertical {\n\tpadding: 0;\n\tmin-width: var(--ck-input-width);\n\n\t& .ck-labeled-field-view {\n\t\tmargin: var(--ck-spacing-large) var(--ck-spacing-large) var(--ck-spacing-small);\n\n\t\t& .ck-input-text {\n\t\t\tmin-width: 0;\n\t\t\twidth: 100%;\n\t\t}\n\t}\n\n\t& > .ck-button {\n\t\tpadding: var(--ck-spacing-standard);\n\t\tmargin: 0;\n\t\twidth: 50%;\n\t\tborder-radius: 0;\n\n\t\t&:not(:focus) {\n\t\t\tborder-top: 1px solid var(--ck-color-base-border);\n\t\t}\n\n\t\t@mixin ck-dir ltr {\n\t\t\tmargin-left: 0;\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\tmargin-left: 0;\n\n\t\t\t&:last-of-type {\n\t\t\t\tborder-right: 1px solid var(--ck-color-base-border);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Using additional `.ck` class for stronger CSS specificity than `.ck.ck-link-form > :not(:first-child)`. */\n\t& .ck.ck-list {\n\t\tmargin: var(--ck-spacing-standard) var(--ck-spacing-large);\n\n\t\t& .ck-button.ck-switchbutton {\n\t\t\tpadding: 0;\n\t\t\twidth: 100%;\n\n\t\t\t&:hover {\n\t\t\t\tbackground: none;\n\t\t\t}\n\t\t}\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      4330: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          '.ck.ck-editor__editable a span.image-inline:after,.ck.ck-editor__editable figure.image>a:after{display:block;position:absolute}:root{--ck-link-image-indicator-icon-size:20;--ck-link-image-indicator-icon-is-visible:clamp(0px,100% - 50px,1px)}.ck.ck-editor__editable a span.image-inline:after,.ck.ck-editor__editable figure.image>a:after{background-color:rgba(0,0,0,.4);background-image:url("data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjAgMjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbD0iI2ZmZiIgZD0ibTExLjA3NyAxNSAuOTkxLTEuNDE2YS43NS43NSAwIDEgMSAxLjIyOS44NmwtMS4xNDggMS42NGEuNzQ4Ljc0OCAwIDAgMS0uMjE3LjIwNiA1LjI1MSA1LjI1MSAwIDAgMS04LjUwMy01Ljk1NS43NDEuNzQxIDAgMCAxIC4xMi0uMjc0bDEuMTQ3LTEuNjM5YS43NS43NSAwIDEgMSAxLjIyOC44Nkw0LjkzMyAxMC43bC4wMDYuMDAzYTMuNzUgMy43NSAwIDAgMCA2LjEzMiA0LjI5NGwuMDA2LjAwNHptNS40OTQtNS4zMzVhLjc0OC43NDggMCAwIDEtLjEyLjI3NGwtMS4xNDcgMS42MzlhLjc1Ljc1IDAgMSAxLTEuMjI4LS44NmwuODYtMS4yM2EzLjc1IDMuNzUgMCAwIDAtNi4xNDQtNC4zMDFsLS44NiAxLjIyOWEuNzUuNzUgMCAwIDEtMS4yMjktLjg2bDEuMTQ4LTEuNjRhLjc0OC43NDggMCAwIDEgLjIxNy0uMjA2IDUuMjUxIDUuMjUxIDAgMCAxIDguNTAzIDUuOTU1em0tNC41NjMtMi41MzJhLjc1Ljc1IDAgMCAxIC4xODQgMS4wNDVsLTMuMTU1IDQuNTA1YS43NS43NSAwIDEgMS0xLjIyOS0uODZsMy4xNTUtNC41MDZhLjc1Ljc1IDAgMCAxIDEuMDQ1LS4xODR6Ii8+PC9zdmc+");background-position:50%;background-repeat:no-repeat;background-size:14px;border-radius:100%;content:"";height:calc(var(--ck-link-image-indicator-icon-is-visible)*var(--ck-link-image-indicator-icon-size));overflow:hidden;right:min(var(--ck-spacing-medium),6%);top:min(var(--ck-spacing-medium),6%);width:calc(var(--ck-link-image-indicator-icon-is-visible)*var(--ck-link-image-indicator-icon-size))}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-link/theme/linkimage.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-link/linkimage.css',
            ],
            names: [],
            mappings:
              'AASE,+FACC,aAAc,CACd,iBACD,CCPF,MAEC,sCAAuC,CACvC,oEACD,CAME,+FAUC,+BAAqC,CACrC,83BAA+3B,CAG/3B,uBAA2B,CAD3B,2BAA4B,CAD5B,oBAAqB,CAGrB,kBAAmB,CAdnB,UAAW,CAsBX,oGAAuG,CAFvG,eAAgB,CAbhB,sCAAwC,CADxC,oCAAsC,CAetC,mGAED',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor__editable {\n\t/* Linked image indicator */\n\t& figure.image > a,\n\t& a span.image-inline {\n\t\t&::after {\n\t\t\tdisplay: block;\n\t\t\tposition: absolute;\n\t\t}\n\t}\n}\n\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/* Match the icon size with the upload indicator brought by the image upload feature. */\n\t--ck-link-image-indicator-icon-size: 20;\n\t--ck-link-image-indicator-icon-is-visible: clamp(0px, 100% - 50px, 1px);\n}\n\n.ck.ck-editor__editable {\n\t/* Linked image indicator */\n\t& figure.image > a,\n\t& a span.image-inline {\n\t\t&::after {\n\t\t\tcontent: "";\n\n\t\t\t/*\n\t\t\t * Smaller images should have the icon closer to the border.\n\t\t\t * Match the icon position with the upload indicator brought by the image upload feature.\n\t\t\t */\n\t\t\ttop: min(var(--ck-spacing-medium), 6%);\n\t\t\tright: min(var(--ck-spacing-medium), 6%);\n\n\t\t\tbackground-color: hsla(0, 0%, 0%, .4);\n\t\t\tbackground-image: url("data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjAgMjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbD0iI2ZmZiIgZD0ibTExLjA3NyAxNSAuOTkxLTEuNDE2YS43NS43NSAwIDEgMSAxLjIyOS44NmwtMS4xNDggMS42NGEuNzQ4Ljc0OCAwIDAgMS0uMjE3LjIwNiA1LjI1MSA1LjI1MSAwIDAgMS04LjUwMy01Ljk1NS43NDEuNzQxIDAgMCAxIC4xMi0uMjc0bDEuMTQ3LTEuNjM5YS43NS43NSAwIDEgMSAxLjIyOC44Nkw0LjkzMyAxMC43bC4wMDYuMDAzYTMuNzUgMy43NSAwIDAgMCA2LjEzMiA0LjI5NGwuMDA2LjAwNHptNS40OTQtNS4zMzVhLjc0OC43NDggMCAwIDEtLjEyLjI3NGwtMS4xNDcgMS42MzlhLjc1Ljc1IDAgMSAxLTEuMjI4LS44NmwuODYtMS4yM2EzLjc1IDMuNzUgMCAwIDAtNi4xNDQtNC4zMDFsLS44NiAxLjIyOWEuNzUuNzUgMCAwIDEtMS4yMjktLjg2bDEuMTQ4LTEuNjRhLjc0OC43NDggMCAwIDEgLjIxNy0uMjA2IDUuMjUxIDUuMjUxIDAgMCAxIDguNTAzIDUuOTU1em0tNC41NjMtMi41MzJhLjc1Ljc1IDAgMCAxIC4xODQgMS4wNDVsLTMuMTU1IDQuNTA1YS43NS43NSAwIDEgMS0xLjIyOS0uODZsMy4xNTUtNC41MDZhLjc1Ljc1IDAgMCAxIDEuMDQ1LS4xODR6Ii8+PC9zdmc+");\n\t\t\tbackground-size: 14px;\n\t\t\tbackground-repeat: no-repeat;\n\t\t\tbackground-position: center;\n\t\t\tborder-radius: 100%;\n\n\t\t\t/*\n\t\t\t* Use CSS math to simulate container queries.\n\t\t\t* https://css-tricks.com/the-raven-technique-one-step-closer-to-container-queries/#what-about-showing-and-hiding-things\n\t\t\t*/\n\t\t\toverflow: hidden;\n\t\t\twidth: calc(var(--ck-link-image-indicator-icon-is-visible) * var(--ck-link-image-indicator-icon-size));\n\t\t\theight: calc(var(--ck-link-image-indicator-icon-is-visible) * var(--ck-link-image-indicator-icon-size));\n\t\t}\n\t}\n}\n\n',
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      5782: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          '.ck.ck-collapsible.ck-collapsible_collapsed>.ck-collapsible__children{display:none}:root{--ck-collapsible-arrow-size:calc(var(--ck-icon-size)*0.5)}.ck.ck-collapsible>.ck.ck-button{border-radius:0;color:inherit;font-weight:700;padding:var(--ck-spacing-medium) var(--ck-spacing-large);width:100%}.ck.ck-collapsible>.ck.ck-button:focus{background:transparent}.ck.ck-collapsible>.ck.ck-button:active,.ck.ck-collapsible>.ck.ck-button:hover:not(:focus),.ck.ck-collapsible>.ck.ck-button:not(:focus){background:transparent;border-color:transparent;box-shadow:none}.ck.ck-collapsible>.ck.ck-button>.ck-icon{margin-right:var(--ck-spacing-medium);width:var(--ck-collapsible-arrow-size)}.ck.ck-collapsible>.ck-collapsible__children{padding:0 var(--ck-spacing-large) var(--ck-spacing-large)}.ck.ck-collapsible.ck-collapsible_collapsed>.ck.ck-button .ck-icon{transform:rotate(-90deg)}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-list/theme/collapsible.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-list/collapsible.css',
            ],
            names: [],
            mappings:
              'AAMC,sEACC,YACD,CCHD,MACC,yDACD,CAGC,iCAIC,eAAgB,CAChB,aAAc,CAHd,eAAiB,CACjB,wDAAyD,CAFzD,UAoBD,CAdC,uCACC,sBACD,CAEA,wIACC,sBAAuB,CACvB,wBAAyB,CACzB,eACD,CAEA,0CACC,qCAAsC,CACtC,sCACD,CAGD,6CACC,yDACD,CAGC,mEACC,wBACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-collapsible.ck-collapsible_collapsed {\n\t& > .ck-collapsible__children {\n\t\tdisplay: none;\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-collapsible-arrow-size: calc(0.5 * var(--ck-icon-size));\n}\n\n.ck.ck-collapsible {\n\t& > .ck.ck-button {\n\t\twidth: 100%;\n\t\tfont-weight: bold;\n\t\tpadding: var(--ck-spacing-medium) var(--ck-spacing-large);\n\t\tborder-radius: 0;\n\t\tcolor: inherit;\n\n\t\t&:focus {\n\t\t\tbackground: transparent;\n\t\t}\n\n\t\t&:active, &:not(:focus), &:hover:not(:focus) {\n\t\t\tbackground: transparent;\n\t\t\tborder-color: transparent;\n\t\t\tbox-shadow: none;\n\t\t}\n\n\t\t& > .ck-icon {\n\t\t\tmargin-right: var(--ck-spacing-medium);\n\t\t\twidth: var(--ck-collapsible-arrow-size);\n\t\t}\n\t}\n\n\t& > .ck-collapsible__children {\n\t\tpadding: 0 var(--ck-spacing-large) var(--ck-spacing-large);\n\t}\n\n\t&.ck-collapsible_collapsed {\n\t\t& > .ck.ck-button .ck-icon {\n\t\t\ttransform: rotate(-90deg);\n\t\t}\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      3190: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          '.ck-editor__editable .ck-list-bogus-paragraph{display:block}',
          '',
          {
            version: 3,
            sources: ['webpack://./node_modules/@ckeditor/ckeditor5-list/theme/documentlist.css'],
            names: [],
            mappings: 'AAKA,8CACC,aACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-editor__editable .ck-list-bogus-paragraph {\n\tdisplay: block;\n}\n',
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      4784: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          '.ck-content ol{list-style-type:decimal}.ck-content ol ol{list-style-type:lower-latin}.ck-content ol ol ol{list-style-type:lower-roman}.ck-content ol ol ol ol{list-style-type:upper-latin}.ck-content ol ol ol ol ol{list-style-type:upper-roman}.ck-content ul{list-style-type:disc}.ck-content ul ul{list-style-type:circle}.ck-content ul ul ul,.ck-content ul ul ul ul{list-style-type:square}',
          '',
          {
            version: 3,
            sources: ['webpack://./node_modules/@ckeditor/ckeditor5-list/theme/list.css'],
            names: [],
            mappings:
              'AAKA,eACC,uBAiBD,CAfC,kBACC,2BAaD,CAXC,qBACC,2BASD,CAPC,wBACC,2BAKD,CAHC,2BACC,2BACD,CAMJ,eACC,oBAaD,CAXC,kBACC,sBASD,CAJE,6CACC,sBACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content ol {\n\tlist-style-type: decimal;\n\n\t& ol {\n\t\tlist-style-type: lower-latin;\n\n\t\t& ol {\n\t\t\tlist-style-type: lower-roman;\n\n\t\t\t& ol {\n\t\t\t\tlist-style-type: upper-latin;\n\n\t\t\t\t& ol {\n\t\t\t\t\tlist-style-type: upper-roman;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n.ck-content ul {\n\tlist-style-type: disc;\n\n\t& ul {\n\t\tlist-style-type: circle;\n\n\t\t& ul {\n\t\t\tlist-style-type: square;\n\n\t\t\t& ul {\n\t\t\t\tlist-style-type: square;\n\t\t\t}\n\t\t}\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      9938: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          '.ck.ck-list-properties.ck-list-properties_without-styles{padding:var(--ck-spacing-large)}.ck.ck-list-properties.ck-list-properties_without-styles>*{min-width:14em}.ck.ck-list-properties.ck-list-properties_without-styles>*+*{margin-top:var(--ck-spacing-standard)}.ck.ck-list-properties.ck-list-properties_with-numbered-properties>.ck-list-styles-list{grid-template-columns:repeat(4,auto)}.ck.ck-list-properties.ck-list-properties_with-numbered-properties>.ck-collapsible{border-top:1px solid var(--ck-color-base-border)}.ck.ck-list-properties.ck-list-properties_with-numbered-properties>.ck-collapsible>.ck-collapsible__children>*{width:100%}.ck.ck-list-properties.ck-list-properties_with-numbered-properties>.ck-collapsible>.ck-collapsible__children>*+*{margin-top:var(--ck-spacing-standard)}.ck.ck-list-properties .ck.ck-numbered-list-properties__start-index .ck-input{min-width:auto;width:100%}.ck.ck-list-properties .ck.ck-numbered-list-properties__reversed-order{background:transparent;margin-bottom:calc(var(--ck-spacing-tiny)*-1);padding-left:0;padding-right:0}.ck.ck-list-properties .ck.ck-numbered-list-properties__reversed-order:active,.ck.ck-list-properties .ck.ck-numbered-list-properties__reversed-order:hover{background:none;border-color:transparent;box-shadow:none}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-list/listproperties.css',
            ],
            names: [],
            mappings:
              'AAOC,yDACC,+BASD,CAPC,2DACC,cAKD,CAHC,6DACC,qCACD,CASD,wFACC,oCACD,CAGA,mFACC,gDAWD,CARE,+GACC,UAKD,CAHC,iHACC,qCACD,CAMJ,8EACC,cAAe,CACf,UACD,CAEA,uEACC,sBAAuB,CAGvB,6CAAgD,CAFhD,cAAe,CACf,eAQD,CALC,2JAGC,eAAgB,CADhB,wBAAyB,CADzB,eAGD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-list-properties {\n\t/* When there are no list styles and there is no collapsible. */\n\t&.ck-list-properties_without-styles {\n\t\tpadding: var(--ck-spacing-large);\n\n\t\t& > * {\n\t\t\tmin-width: 14em;\n\n\t\t\t& + * {\n\t\t\t\tmargin-top: var(--ck-spacing-standard);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * When the numbered list property fields (start at, reversed) should be displayed,\n\t * more horizontal space is needed. Reconfigure the style grid to create that space.\n\t */\n\t&.ck-list-properties_with-numbered-properties {\n\t\t& > .ck-list-styles-list {\n\t\t\tgrid-template-columns: repeat( 4, auto );\n\t\t}\n\n\t\t/* When list styles are rendered and property fields are in a collapsible. */\n\t\t& > .ck-collapsible {\n\t\t\tborder-top: 1px solid var(--ck-color-base-border);\n\n\t\t\t& > .ck-collapsible__children {\n\t\t\t\t& > * {\n\t\t\t\t\twidth: 100%;\n\n\t\t\t\t\t& + * {\n\t\t\t\t\t\tmargin-top: var(--ck-spacing-standard);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t& .ck.ck-numbered-list-properties__start-index .ck-input {\n\t\tmin-width: auto;\n\t\twidth: 100%;\n\t}\n\n\t& .ck.ck-numbered-list-properties__reversed-order {\n\t\tbackground: transparent;\n\t\tpadding-left: 0;\n\t\tpadding-right: 0;\n\t\tmargin-bottom: calc(-1 * var(--ck-spacing-tiny));\n\n\t\t&:active, &:hover {\n\t\t\tbox-shadow: none;\n\t\t\tborder-color: transparent;\n\t\t\tbackground: none;\n\t\t}\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      2591: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          '.ck.ck-list-styles-list{display:grid}:root{--ck-list-style-button-size:44px}.ck.ck-list-styles-list{column-gap:var(--ck-spacing-medium);grid-template-columns:repeat(3,auto);padding:var(--ck-spacing-large);row-gap:var(--ck-spacing-medium)}.ck.ck-list-styles-list .ck-button{box-sizing:content-box;margin:0;padding:0}.ck.ck-list-styles-list .ck-button,.ck.ck-list-styles-list .ck-button .ck-icon{height:var(--ck-list-style-button-size);width:var(--ck-list-style-button-size)}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-list/theme/liststyles.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-list/liststyles.css',
            ],
            names: [],
            mappings:
              'AAKA,wBACC,YACD,CCFA,MACC,gCACD,CAEA,wBAGC,mCAAoC,CAFpC,oCAAwC,CAGxC,+BAAgC,CAFhC,gCA4BD,CAxBC,mCAiBC,sBAAuB,CAPvB,QAAS,CANT,SAmBD,CAJC,+EAhBA,uCAAwC,CADxC,sCAoBA',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-list-styles-list {\n\tdisplay: grid;\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-list-style-button-size: 44px;\n}\n\n.ck.ck-list-styles-list {\n\tgrid-template-columns: repeat( 3, auto );\n\trow-gap: var(--ck-spacing-medium);\n\tcolumn-gap: var(--ck-spacing-medium);\n\tpadding: var(--ck-spacing-large);\n\n\t& .ck-button {\n\t\t/* Make the button look like a thumbnail (the icon "takes it all"). */\n\t\twidth: var(--ck-list-style-button-size);\n\t\theight: var(--ck-list-style-button-size);\n\t\tpadding: 0;\n\n\t\t/*\n\t\t * Buttons are aligned by the grid so disable default button margins to not collide with the\n\t\t * gaps in the grid.\n\t\t */\n\t\tmargin: 0;\n\n\t\t/*\n\t\t * Make sure the button border (which is displayed on focus, BTW) does not steal pixels\n\t\t * from the button dimensions and, as a result, decrease the size of the icon\n\t\t * (which becomes blurry as it scales down).\n\t\t */\n\t\tbox-sizing: content-box;\n\n\t\t& .ck-icon {\n\t\t\twidth: var(--ck-list-style-button-size);\n\t\t\theight: var(--ck-list-style-button-size);\n\t\t}\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      9292: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          ':root{--ck-todo-list-checkmark-size:16px}.ck-content .todo-list{list-style:none}.ck-content .todo-list li{margin-bottom:5px}.ck-content .todo-list li .todo-list{margin-top:5px}.ck-content .todo-list .todo-list__label>input{-webkit-appearance:none;border:0;display:inline-block;height:var(--ck-todo-list-checkmark-size);left:-25px;margin-left:0;margin-right:-15px;position:relative;right:0;vertical-align:middle;width:var(--ck-todo-list-checkmark-size)}.ck-content .todo-list .todo-list__label>input:before{border:1px solid #333;border-radius:2px;box-sizing:border-box;content:"";display:block;height:100%;position:absolute;transition:box-shadow .25s ease-in-out,background .25s ease-in-out,border .25s ease-in-out;width:100%}.ck-content .todo-list .todo-list__label>input:after{border-color:transparent;border-style:solid;border-width:0 calc(var(--ck-todo-list-checkmark-size)/8) calc(var(--ck-todo-list-checkmark-size)/8) 0;box-sizing:content-box;content:"";display:block;height:calc(var(--ck-todo-list-checkmark-size)/2.6);left:calc(var(--ck-todo-list-checkmark-size)/3);pointer-events:none;position:absolute;top:calc(var(--ck-todo-list-checkmark-size)/5.3);transform:rotate(45deg);width:calc(var(--ck-todo-list-checkmark-size)/5.3)}.ck-content .todo-list .todo-list__label>input[checked]:before{background:#26ab33;border-color:#26ab33}.ck-content .todo-list .todo-list__label>input[checked]:after{border-color:#fff}.ck-content .todo-list .todo-list__label .todo-list__label__description{vertical-align:middle}[dir=rtl] .todo-list .todo-list__label>input{left:0;margin-left:-15px;margin-right:0;right:-25px}.ck-editor__editable .todo-list .todo-list__label>input{cursor:pointer}.ck-editor__editable .todo-list .todo-list__label>input:hover:before{box-shadow:0 0 0 5px rgba(0,0,0,.1)}',
          '',
          {
            version: 3,
            sources: ['webpack://./node_modules/@ckeditor/ckeditor5-list/theme/todolist.css'],
            names: [],
            mappings:
              'AAKA,MACC,kCACD,CAEA,uBACC,eA0ED,CAxEC,0BACC,iBAKD,CAHC,qCACC,cACD,CAIA,+CACC,uBAAwB,CAQxB,QAAS,CAPT,oBAAqB,CAGrB,yCAA0C,CAO1C,UAAW,CAGX,aAAc,CAFd,kBAAmB,CAVnB,iBAAkB,CAWlB,OAAQ,CARR,qBAAsB,CAFtB,wCAqDD,CAxCC,sDAOC,qBAAiC,CACjC,iBAAkB,CALlB,qBAAsB,CACtB,UAAW,CAHX,aAAc,CAKd,WAAY,CAJZ,iBAAkB,CAOlB,0FAAgG,CAJhG,UAKD,CAEA,qDAaC,wBAAyB,CADzB,kBAAmB,CAEnB,sGAA+G,CAX/G,sBAAuB,CAEvB,UAAW,CAJX,aAAc,CAUd,mDAAwD,CAHxD,+CAAoD,CAJpD,mBAAoB,CAFpB,iBAAkB,CAOlB,gDAAqD,CAMrD,uBAAwB,CALxB,kDAMD,CAGC,+DACC,kBAA8B,CAC9B,oBACD,CAEA,8DACC,iBACD,CAIF,wEACC,qBACD,CAKF,6CACC,MAAO,CAGP,iBAAkB,CAFlB,cAAe,CACf,WAED,CAMA,wDACC,cAKD,CAHC,qEACC,mCACD',
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-todo-list-checkmark-size: 16px;\n}\n\n.ck-content .todo-list {\n\tlist-style: none;\n\n\t& li {\n\t\tmargin-bottom: 5px;\n\n\t\t& .todo-list {\n\t\t\tmargin-top: 5px;\n\t\t}\n\t}\n\n\t& .todo-list__label {\n\t\t& > input {\n\t\t\t-webkit-appearance: none;\n\t\t\tdisplay: inline-block;\n\t\t\tposition: relative;\n\t\t\twidth: var(--ck-todo-list-checkmark-size);\n\t\t\theight: var(--ck-todo-list-checkmark-size);\n\t\t\tvertical-align: middle;\n\n\t\t\t/* Needed on iOS */\n\t\t\tborder: 0;\n\n\t\t\t/* LTR styles */\n\t\t\tleft: -25px;\n\t\t\tmargin-right: -15px;\n\t\t\tright: 0;\n\t\t\tmargin-left: 0;\n\n\t\t\t&::before {\n\t\t\t\tdisplay: block;\n\t\t\t\tposition: absolute;\n\t\t\t\tbox-sizing: border-box;\n\t\t\t\tcontent: '';\n\t\t\t\twidth: 100%;\n\t\t\t\theight: 100%;\n\t\t\t\tborder: 1px solid hsl(0, 0%, 20%);\n\t\t\t\tborder-radius: 2px;\n\t\t\t\ttransition: 250ms ease-in-out box-shadow, 250ms ease-in-out background, 250ms ease-in-out border;\n\t\t\t}\n\n\t\t\t&::after {\n\t\t\t\tdisplay: block;\n\t\t\t\tposition: absolute;\n\t\t\t\tbox-sizing: content-box;\n\t\t\t\tpointer-events: none;\n\t\t\t\tcontent: '';\n\n\t\t\t\t/* Calculate tick position, size and border-width proportional to the checkmark size. */\n\t\t\t\tleft: calc( var(--ck-todo-list-checkmark-size) / 3 );\n\t\t\t\ttop: calc( var(--ck-todo-list-checkmark-size) / 5.3 );\n\t\t\t\twidth: calc( var(--ck-todo-list-checkmark-size) / 5.3 );\n\t\t\t\theight: calc( var(--ck-todo-list-checkmark-size) / 2.6 );\n\t\t\t\tborder-style: solid;\n\t\t\t\tborder-color: transparent;\n\t\t\t\tborder-width: 0 calc( var(--ck-todo-list-checkmark-size) / 8 ) calc( var(--ck-todo-list-checkmark-size) / 8 ) 0;\n\t\t\t\ttransform: rotate(45deg);\n\t\t\t}\n\n\t\t\t&[checked] {\n\t\t\t\t&::before {\n\t\t\t\t\tbackground: hsl(126, 64%, 41%);\n\t\t\t\t\tborder-color: hsl(126, 64%, 41%);\n\t\t\t\t}\n\n\t\t\t\t&::after {\n\t\t\t\t\tborder-color: hsl(0, 0%, 100%);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t& .todo-list__label__description {\n\t\t\tvertical-align: middle;\n\t\t}\n\t}\n}\n\n/* RTL styles */\n[dir=\"rtl\"] .todo-list .todo-list__label > input {\n\tleft: 0;\n\tmargin-right: 0;\n\tright: -25px;\n\tmargin-left: -15px;\n}\n\n/*\n * To-do list should be interactive only during the editing\n * (https://github.com/ckeditor/ckeditor5/issues/2090).\n */\n.ck-editor__editable .todo-list .todo-list__label > input {\n\tcursor: pointer;\n\n\t&:hover::before {\n\t\tbox-shadow: 0 0 0 5px hsla(0, 0%, 0%, 0.1);\n\t}\n}\n",
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      8705: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          '.ck-content .media{clear:both;display:block;margin:.9em 0;min-width:15em}',
          '',
          {
            version: 3,
            sources: ['webpack://./node_modules/@ckeditor/ckeditor5-media-embed/theme/mediaembed.css'],
            names: [],
            mappings: 'AAKA,mBAGC,UAAW,CASX,aAAc,CAJd,aAAe,CAQf,cACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content .media {\n\t/* Don\'t allow floated content overlap the media.\n\thttps://github.com/ckeditor/ckeditor5-media-embed/issues/53 */\n\tclear: both;\n\n\t/* Make sure there is some space between the content and the media. */\n\t/* The first value should be equal to --ck-spacing-large variable if used in the editor context\n\tto avoid the content jumping (See https://github.com/ckeditor/ckeditor5/issues/9825). */\n\tmargin: 0.9em 0;\n\n\t/* Make sure media is not overriden with Bootstrap default `flex` value.\n\tSee: https://github.com/ckeditor/ckeditor5/issues/1373. */\n\tdisplay: block;\n\n\t/* Give the media some minimal width in the content to prevent them\n\tfrom being "squashed" in tight spaces, e.g. in table cells (#44) */\n\tmin-width: 15em;\n}\n',
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      1922: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          '.ck-media__wrapper .ck-media__placeholder{align-items:center;display:flex;flex-direction:column}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url{max-width:100%;position:relative}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url .ck-media__placeholder__url__text{display:block;overflow:hidden}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="goo.gl/maps"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="google.com/maps"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="maps.app.goo.gl"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="maps.google.com"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck-media__placeholder__icon *{display:none}.ck-editor__editable:not(.ck-read-only) .ck-media__wrapper>:not(.ck-media__placeholder),.ck-editor__editable:not(.ck-read-only) .ck-widget:not(.ck-widget_selected) .ck-media__placeholder{pointer-events:none}:root{--ck-media-embed-placeholder-icon-size:3em;--ck-color-media-embed-placeholder-url-text:#757575;--ck-color-media-embed-placeholder-url-text-hover:var(--ck-color-base-text)}.ck-media__wrapper{margin:0 auto}.ck-media__wrapper .ck-media__placeholder{background:var(--ck-color-base-foreground);padding:calc(var(--ck-spacing-standard)*3)}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__icon{background-position:50%;background-size:cover;height:var(--ck-media-embed-placeholder-icon-size);margin-bottom:var(--ck-spacing-large);min-width:var(--ck-media-embed-placeholder-icon-size)}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__icon .ck-icon{height:100%;width:100%}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url__text{color:var(--ck-color-media-embed-placeholder-url-text);font-style:italic;text-align:center;text-overflow:ellipsis;white-space:nowrap}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url__text:hover{color:var(--ck-color-media-embed-placeholder-url-text-hover);cursor:pointer;text-decoration:underline}.ck-media__wrapper[data-oembed-url*="open.spotify.com"]{max-height:380px;max-width:300px}.ck-media__wrapper[data-oembed-url*="goo.gl/maps"] .ck-media__placeholder__icon,.ck-media__wrapper[data-oembed-url*="google.com/maps"] .ck-media__placeholder__icon,.ck-media__wrapper[data-oembed-url*="maps.app.goo.gl"] .ck-media__placeholder__icon,.ck-media__wrapper[data-oembed-url*="maps.google.com"] .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNTAuMzc4IiBoZWlnaHQ9IjI1NC4xNjciIHZpZXdCb3g9IjAgMCA2Ni4yNDYgNjcuMjQ4Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTcyLjUzMSAtMjE4LjQ1NSkgc2NhbGUoLjk4MDEyKSI+PHJlY3Qgcnk9IjUuMjM4IiByeD0iNS4yMzgiIHk9IjIzMS4zOTkiIHg9IjE3Ni4wMzEiIGhlaWdodD0iNjAuMDk5IiB3aWR0aD0iNjAuMDk5IiBmaWxsPSIjMzRhNjY4IiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjxwYXRoIGQ9Im0yMDYuNDc3IDI2MC45LTI4Ljk4NyAyOC45ODdhNS4yMTggNS4yMTggMCAwIDAgMy43OCAxLjYxaDQ5LjYyMWMxLjY5NCAwIDMuMTktLjc5OCA0LjE0Ni0yLjAzN3oiIGZpbGw9IiM1Yzg4YzUiLz48cGF0aCBkPSJNMjI2Ljc0MiAyMjIuOTg4Yy05LjI2NiAwLTE2Ljc3NyA3LjE3LTE2Ljc3NyAxNi4wMTQuMDA3IDIuNzYyLjY2MyA1LjQ3NCAyLjA5MyA3Ljg3NS40My43MDMuODMgMS40MDggMS4xOSAyLjEwNy4zMzMuNTAyLjY1IDEuMDA1Ljk1IDEuNTA4LjM0My40NzcuNjczLjk1Ny45ODggMS40NCAxLjMxIDEuNzY5IDIuNSAzLjUwMiAzLjYzNyA1LjE2OC43OTMgMS4yNzUgMS42ODMgMi42NCAyLjQ2NiAzLjk5IDIuMzYzIDQuMDk0IDQuMDA3IDguMDkyIDQuNiAxMy45MTR2LjAxMmMuMTgyLjQxMi41MTYuNjY2Ljg3OS42NjcuNDAzLS4wMDEuNzY4LS4zMTQuOTMtLjc5OS42MDMtNS43NTYgMi4yMzgtOS43MjkgNC41ODUtMTMuNzk0Ljc4Mi0xLjM1IDEuNjczLTIuNzE1IDIuNDY1LTMuOTkgMS4xMzctMS42NjYgMi4zMjgtMy40IDMuNjM4LTUuMTY5LjMxNS0uNDgyLjY0NS0uOTYyLjk4OC0xLjQzOS4zLS41MDMuNjE3LTEuMDA2Ljk1LTEuNTA4LjM1OS0uNy43Ni0xLjQwNCAxLjE5LTIuMTA3IDEuNDI2LTIuNDAyIDItNS4xMTQgMi4wMDQtNy44NzUgMC04Ljg0NC03LjUxMS0xNi4wMTQtMTYuNzc2LTE2LjAxNHoiIGZpbGw9IiNkZDRiM2UiIHBhaW50LW9yZGVyPSJtYXJrZXJzIHN0cm9rZSBmaWxsIi8+PGVsbGlwc2Ugcnk9IjUuNTY0IiByeD0iNS44MjgiIGN5PSIyMzkuMDAyIiBjeD0iMjI2Ljc0MiIgZmlsbD0iIzgwMmQyNyIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48cGF0aCBkPSJNMTkwLjMwMSAyMzcuMjgzYy00LjY3IDAtOC40NTcgMy44NTMtOC40NTcgOC42MDZzMy43ODYgOC42MDcgOC40NTcgOC42MDdjMy4wNDMgMCA0LjgwNi0uOTU4IDYuMzM3LTIuNTE2IDEuNTMtMS41NTcgMi4wODctMy45MTMgMi4wODctNi4yOSAwLS4zNjItLjAyMy0uNzIyLS4wNjQtMS4wNzloLTguMjU3djMuMDQzaDQuODVjLS4xOTcuNzU5LS41MzEgMS40NS0xLjA1OCAxLjk4Ni0uOTQyLjk1OC0yLjAyOCAxLjU0OC0zLjkwMSAxLjU0OC0yLjg3NiAwLTUuMjA4LTIuMzcyLTUuMjA4LTUuMjk5IDAtMi45MjYgMi4zMzItNS4yOTkgNS4yMDgtNS4yOTkgMS4zOTkgMCAyLjYxOC40MDcgMy41ODQgMS4yOTNsMi4zODEtMi4zOGMwLS4wMDItLjAwMy0uMDA0LS4wMDQtLjAwNS0xLjU4OC0xLjUyNC0zLjYyLTIuMjE1LTUuOTU1LTIuMjE1em00LjQzIDUuNjYuMDAzLjAwNnYtLjAwM3oiIGZpbGw9IiNmZmYiIHBhaW50LW9yZGVyPSJtYXJrZXJzIHN0cm9rZSBmaWxsIi8+PHBhdGggZD0ibTIxNS4xODQgMjUxLjkyOS03Ljk4IDcuOTc5IDI4LjQ3NyAyOC40NzVhNS4yMzMgNS4yMzMgMCAwIDAgLjQ0OS0yLjEyM3YtMzEuMTY1Yy0uNDY5LjY3NS0uOTM0IDEuMzQ5LTEuMzgyIDIuMDA1LS43OTIgMS4yNzUtMS42ODIgMi42NC0yLjQ2NSAzLjk5LTIuMzQ3IDQuMDY1LTMuOTgyIDguMDM4LTQuNTg1IDEzLjc5NC0uMTYyLjQ4NS0uNTI3Ljc5OC0uOTMuNzk5LS4zNjMtLjAwMS0uNjk3LS4yNTUtLjg3OS0uNjY3di0uMDEyYy0uNTkzLTUuODIyLTIuMjM3LTkuODItNC42LTEzLjkxNC0uNzgzLTEuMzUtMS42NzMtMi43MTUtMi40NjYtMy45OS0xLjEzNy0xLjY2Ni0yLjMyNy0zLjQtMy42MzctNS4xNjlsLS4wMDItLjAwM3oiIGZpbGw9IiNjM2MzYzMiLz48cGF0aCBkPSJtMjEyLjk4MyAyNDguNDk1LTM2Ljk1MiAzNi45NTN2LjgxMmE1LjIyNyA1LjIyNyAwIDAgMCA1LjIzOCA1LjIzOGgxLjAxNWwzNS42NjYtMzUuNjY2YTEzNi4yNzUgMTM2LjI3NSAwIDAgMC0yLjc2NC0zLjkgMzcuNTc1IDM3LjU3NSAwIDAgMC0uOTg5LTEuNDQgMzUuMTI3IDM1LjEyNyAwIDAgMC0uOTUtMS41MDhjLS4wODMtLjE2Mi0uMTc2LS4zMjYtLjI2NC0uNDg5eiIgZmlsbD0iI2ZkZGM0ZiIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48cGF0aCBkPSJtMjExLjk5OCAyNjEuMDgzLTYuMTUyIDYuMTUxIDI0LjI2NCAyNC4yNjRoLjc4MWE1LjIyNyA1LjIyNyAwIDAgMCA1LjIzOS01LjIzOHYtMS4wNDV6IiBmaWxsPSIjZmZmIiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjwvZz48L3N2Zz4=)}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder{background:#4268b3}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAyNCIgaGVpZ2h0PSIxMDI0IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxwYXRoIGQ9Ik05NjcuNDg0IDBINTYuNTE3QzI1LjMwNCAwIDAgMjUuMzA0IDAgNTYuNTE3djkxMC45NjZDMCA5OTguNjk0IDI1LjI5NyAxMDI0IDU2LjUyMiAxMDI0SDU0N1Y2MjhINDE0VjQ3M2gxMzNWMzU5LjAyOWMwLTEzMi4yNjIgODAuNzczLTIwNC4yODIgMTk4Ljc1Ni0yMDQuMjgyIDU2LjUxMyAwIDEwNS4wODYgNC4yMDggMTE5LjI0NCA2LjA4OVYyOTlsLTgxLjYxNi4wMzdjLTYzLjk5MyAwLTc2LjM4NCAzMC40OTItNzYuMzg0IDc1LjIzNlY0NzNoMTUzLjQ4N2wtMTkuOTg2IDE1NUg3MDd2Mzk2aDI2MC40ODRjMzEuMjEzIDAgNTYuNTE2LTI1LjMwMyA1Ni41MTYtNTYuNTE2VjU2LjUxNUMxMDI0IDI1LjMwMyA5OTguNjk3IDAgOTY3LjQ4NCAwIiBmaWxsPSIjRkZGRkZFIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder .ck-media__placeholder__url__text{color:#cdf}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder .ck-media__placeholder__url__text:hover{color:#fff}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder{background:linear-gradient(-135deg,#1400c7,#b800b1,#f50000)}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTA0IiBoZWlnaHQ9IjUwNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+PGRlZnM+PHBhdGggaWQ9ImEiIGQ9Ik0wIC4xNTloNTAzLjg0MVY1MDMuOTRIMHoiLz48L2RlZnM+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj48bWFzayBpZD0iYiIgZmlsbD0iI2ZmZiI+PHVzZSB4bGluazpocmVmPSIjYSIvPjwvbWFzaz48cGF0aCBkPSJNMjUxLjkyMS4xNTljLTY4LjQxOCAwLTc2Ljk5Ny4yOS0xMDMuODY3IDEuNTE2LTI2LjgxNCAxLjIyMy00NS4xMjcgNS40ODItNjEuMTUxIDExLjcxLTE2LjU2NiA2LjQzNy0zMC42MTUgMTUuMDUxLTQ0LjYyMSAyOS4wNTYtMTQuMDA1IDE0LjAwNi0yMi42MTkgMjguMDU1LTI5LjA1NiA0NC42MjEtNi4yMjggMTYuMDI0LTEwLjQ4NyAzNC4zMzctMTEuNzEgNjEuMTUxQy4yOSAxNzUuMDgzIDAgMTgzLjY2MiAwIDI1Mi4wOGMwIDY4LjQxNy4yOSA3Ni45OTYgMS41MTYgMTAzLjg2NiAxLjIyMyAyNi44MTQgNS40ODIgNDUuMTI3IDExLjcxIDYxLjE1MSA2LjQzNyAxNi41NjYgMTUuMDUxIDMwLjYxNSAyOS4wNTYgNDQuNjIxIDE0LjAwNiAxNC4wMDUgMjguMDU1IDIyLjYxOSA0NC42MjEgMjkuMDU3IDE2LjAyNCA2LjIyNyAzNC4zMzcgMTAuNDg2IDYxLjE1MSAxMS43MDkgMjYuODcgMS4yMjYgMzUuNDQ5IDEuNTE2IDEwMy44NjcgMS41MTYgNjguNDE3IDAgNzYuOTk2LS4yOSAxMDMuODY2LTEuNTE2IDI2LjgxNC0xLjIyMyA0NS4xMjctNS40ODIgNjEuMTUxLTExLjcwOSAxNi41NjYtNi40MzggMzAuNjE1LTE1LjA1MiA0NC42MjEtMjkuMDU3IDE0LjAwNS0xNC4wMDYgMjIuNjE5LTI4LjA1NSAyOS4wNTctNDQuNjIxIDYuMjI3LTE2LjAyNCAxMC40ODYtMzQuMzM3IDExLjcwOS02MS4xNTEgMS4yMjYtMjYuODcgMS41MTYtMzUuNDQ5IDEuNTE2LTEwMy44NjYgMC02OC40MTgtLjI5LTc2Ljk5Ny0xLjUxNi0xMDMuODY3LTEuMjIzLTI2LjgxNC01LjQ4Mi00NS4xMjctMTEuNzA5LTYxLjE1MS02LjQzOC0xNi41NjYtMTUuMDUyLTMwLjYxNS0yOS4wNTctNDQuNjIxLTE0LjAwNi0xNC4wMDUtMjguMDU1LTIyLjYxOS00NC42MjEtMjkuMDU2LTE2LjAyNC02LjIyOC0zNC4zMzctMTAuNDg3LTYxLjE1MS0xMS43MUMzMjguOTE3LjQ0OSAzMjAuMzM4LjE1OSAyNTEuOTIxLjE1OVptMCA0NS4zOTFjNjcuMjY1IDAgNzUuMjMzLjI1NyAxMDEuNzk3IDEuNDY5IDI0LjU2MiAxLjEyIDM3LjkwMSA1LjIyNCA0Ni43NzggOC42NzQgMTEuNzU5IDQuNTcgMjAuMTUxIDEwLjAyOSAyOC45NjYgMTguODQ1IDguODE2IDguODE1IDE0LjI3NSAxNy4yMDcgMTguODQ1IDI4Ljk2NiAzLjQ1IDguODc3IDcuNTU0IDIyLjIxNiA4LjY3NCA0Ni43NzggMS4yMTIgMjYuNTY0IDEuNDY5IDM0LjUzMiAxLjQ2OSAxMDEuNzk4IDAgNjcuMjY1LS4yNTcgNzUuMjMzLTEuNDY5IDEwMS43OTctMS4xMiAyNC41NjItNS4yMjQgMzcuOTAxLTguNjc0IDQ2Ljc3OC00LjU3IDExLjc1OS0xMC4wMjkgMjAuMTUxLTE4Ljg0NSAyOC45NjYtOC44MTUgOC44MTYtMTcuMjA3IDE0LjI3NS0yOC45NjYgMTguODQ1LTguODc3IDMuNDUtMjIuMjE2IDcuNTU0LTQ2Ljc3OCA4LjY3NC0yNi41NiAxLjIxMi0zNC41MjcgMS40NjktMTAxLjc5NyAxLjQ2OS02Ny4yNzEgMC03NS4yMzctLjI1Ny0xMDEuNzk4LTEuNDY5LTI0LjU2Mi0xLjEyLTM3LjkwMS01LjIyNC00Ni43NzgtOC42NzQtMTEuNzU5LTQuNTctMjAuMTUxLTEwLjAyOS0yOC45NjYtMTguODQ1LTguODE1LTguODE1LTE0LjI3NS0xNy4yMDctMTguODQ1LTI4Ljk2Ni0zLjQ1LTguODc3LTcuNTU0LTIyLjIxNi04LjY3NC00Ni43NzgtMS4yMTItMjYuNTY0LTEuNDY5LTM0LjUzMi0xLjQ2OS0xMDEuNzk3IDAtNjcuMjY2LjI1Ny03NS4yMzQgMS40NjktMTAxLjc5OCAxLjEyLTI0LjU2MiA1LjIyNC0zNy45MDEgOC42NzQtNDYuNzc4IDQuNTctMTEuNzU5IDEwLjAyOS0yMC4xNTEgMTguODQ1LTI4Ljk2NiA4LjgxNS04LjgxNiAxNy4yMDctMTQuMjc1IDI4Ljk2Ni0xOC44NDUgOC44NzctMy40NSAyMi4yMTYtNy41NTQgNDYuNzc4LTguNjc0IDI2LjU2NC0xLjIxMiAzNC41MzItMS40NjkgMTAxLjc5OC0xLjQ2OVoiIGZpbGw9IiNGRkYiIG1hc2s9InVybCgjYikiLz48cGF0aCBkPSJNMjUxLjkyMSAzMzYuMDUzYy00Ni4zNzggMC04My45NzQtMzcuNTk2LTgzLjk3NC04My45NzMgMC00Ni4zNzggMzcuNTk2LTgzLjk3NCA4My45NzQtODMuOTc0IDQ2LjM3NyAwIDgzLjk3MyAzNy41OTYgODMuOTczIDgzLjk3NCAwIDQ2LjM3Ny0zNy41OTYgODMuOTczLTgzLjk3MyA4My45NzNabTAtMjEzLjMzOGMtNzEuNDQ3IDAtMTI5LjM2NSA1Ny45MTgtMTI5LjM2NSAxMjkuMzY1IDAgNzEuNDQ2IDU3LjkxOCAxMjkuMzY0IDEyOS4zNjUgMTI5LjM2NCA3MS40NDYgMCAxMjkuMzY0LTU3LjkxOCAxMjkuMzY0LTEyOS4zNjQgMC03MS40NDctNTcuOTE4LTEyOS4zNjUtMTI5LjM2NC0xMjkuMzY1Wk00MTYuNjI3IDExNy42MDRjMCAxNi42OTYtMTMuNTM1IDMwLjIzLTMwLjIzMSAzMC4yMy0xNi42OTUgMC0zMC4yMy0xMy41MzQtMzAuMjMtMzAuMjMgMC0xNi42OTYgMTMuNTM1LTMwLjIzMSAzMC4yMy0zMC4yMzEgMTYuNjk2IDAgMzAuMjMxIDEzLjUzNSAzMC4yMzEgMzAuMjMxIiBmaWxsPSIjRkZGIi8+PC9nPjwvc3ZnPg==)}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder .ck-media__placeholder__url__text{color:#ffe0fe}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder .ck-media__placeholder__url__text:hover{color:#fff}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder{background:linear-gradient(90deg,#71c6f4,#0d70a5)}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA0MDAgNDAwIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA0MDAgNDAwIiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBkPSJNNDAwIDIwMGMwIDExMC41LTg5LjUgMjAwLTIwMCAyMDBTMCAzMTAuNSAwIDIwMCA4OS41IDAgMjAwIDBzMjAwIDg5LjUgMjAwIDIwMHpNMTYzLjQgMzA1LjVjODguNyAwIDEzNy4yLTczLjUgMTM3LjItMTM3LjIgMC0yLjEgMC00LjItLjEtNi4yIDkuNC02LjggMTcuNi0xNS4zIDI0LjEtMjUtOC42IDMuOC0xNy45IDYuNC0yNy43IDcuNiAxMC02IDE3LjYtMTUuNCAyMS4yLTI2LjctOS4zIDUuNS0xOS42IDkuNS0zMC42IDExLjctOC44LTkuNC0yMS4zLTE1LjItMzUuMi0xNS4yLTI2LjYgMC00OC4yIDIxLjYtNDguMiA0OC4yIDAgMy44LjQgNy41IDEuMyAxMS00MC4xLTItNzUuNi0yMS4yLTk5LjQtNTAuNC00LjEgNy4xLTYuNSAxNS40LTYuNSAyNC4yIDAgMTYuNyA4LjUgMzEuNSAyMS41IDQwLjEtNy45LS4yLTE1LjMtMi40LTIxLjgtNnYuNmMwIDIzLjQgMTYuNiA0Mi44IDM4LjcgNDcuMy00IDEuMS04LjMgMS43LTEyLjcgMS43LTMuMSAwLTYuMS0uMy05LjEtLjkgNi4xIDE5LjIgMjMuOSAzMy4xIDQ1IDMzLjUtMTYuNSAxMi45LTM3LjMgMjAuNi01OS45IDIwLjYtMy45IDAtNy43LS4yLTExLjUtLjcgMjEuMSAxMy44IDQ2LjUgMjEuOCA3My43IDIxLjgiIHN0eWxlPSJmaWxsOiNmZmYiLz48L3N2Zz4=)}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder .ck-media__placeholder__url__text{color:#b8e6ff}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder .ck-media__placeholder__url__text:hover{color:#fff}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-media-embed/theme/mediaembedediting.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-media-embed/mediaembedediting.css',
            ],
            names: [],
            mappings:
              'AAMC,0CAGC,kBAAmB,CAFnB,YAAa,CACb,qBAcD,CAXC,sEAEC,cAAe,CAEf,iBAMD,CAJC,wGAEC,aAAc,CADd,eAED,CAWD,6kBACC,YACD,CAYF,2LACC,mBACD,CC1CA,MACC,0CAA2C,CAE3C,mDAA4D,CAC5D,2EACD,CAEA,mBACC,aA+FD,CA7FC,0CAEC,0CAA2C,CAD3C,0CA6BD,CA1BC,uEAIC,uBAA2B,CAC3B,qBAAsB,CAHtB,kDAAmD,CACnD,qCAAsC,CAFtC,qDAUD,CAJC,gFAEC,WAAY,CADZ,UAED,CAGD,4EACC,sDAAuD,CAGvD,iBAAkB,CADlB,iBAAkB,CAElB,sBAAuB,CAHvB,kBAUD,CALC,kFACC,4DAA6D,CAC7D,cAAe,CACf,yBACD,CAIF,wDAEC,gBAAiB,CADjB,eAED,CAEA,4UAIC,wvGACD,CAEA,2EACC,kBAaD,CAXC,wGACC,orBACD,CAEA,6GACC,UAKD,CAHC,mHACC,UACD,CAIF,4EACC,2DAcD,CAZC,yGACC,4jHACD,CAGA,8GACC,aAKD,CAHC,oHACC,UACD,CAIF,6EAEC,iDAaD,CAXC,0GACC,wiCACD,CAEA,+GACC,aAKD,CAHC,qHACC,UACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-media__wrapper {\n\t& .ck-media__placeholder {\n\t\tdisplay: flex;\n\t\tflex-direction: column;\n\t\talign-items: center;\n\n\t\t& .ck-media__placeholder__url {\n\t\t\t/* Otherwise the URL will overflow when the content is very narrow. */\n\t\t\tmax-width: 100%;\n\n\t\t\tposition: relative;\n\n\t\t\t& .ck-media__placeholder__url__text {\n\t\t\t\toverflow: hidden;\n\t\t\t\tdisplay: block;\n\t\t\t}\n\t\t}\n\t}\n\n\t&[data-oembed-url*="twitter.com"],\n\t&[data-oembed-url*="google.com/maps"],\n\t&[data-oembed-url*="goo.gl/maps"],\n\t&[data-oembed-url*="maps.google.com"],\n\t&[data-oembed-url*="maps.app.goo.gl"],\n\t&[data-oembed-url*="facebook.com"],\n\t&[data-oembed-url*="instagram.com"] {\n\t\t& .ck-media__placeholder__icon * {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n}\n\n/* Disable all mouse interaction as long as the editor is not read–only.\n   https://github.com/ckeditor/ckeditor5-media-embed/issues/58 */\n.ck-editor__editable:not(.ck-read-only) .ck-media__wrapper > *:not(.ck-media__placeholder) {\n\tpointer-events: none;\n}\n\n/* Disable all mouse interaction when the widget is not selected (e.g. to avoid opening links by accident).\n   https://github.com/ckeditor/ckeditor5-media-embed/issues/18 */\n.ck-editor__editable:not(.ck-read-only) .ck-widget:not(.ck-widget_selected) .ck-media__placeholder {\n\tpointer-events: none;\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-media-embed-placeholder-icon-size: 3em;\n\n\t--ck-color-media-embed-placeholder-url-text: hsl(0, 0%, 46%);\n\t--ck-color-media-embed-placeholder-url-text-hover: var(--ck-color-base-text);\n}\n\n.ck-media__wrapper {\n\tmargin: 0 auto;\n\n\t& .ck-media__placeholder {\n\t\tpadding: calc( 3 * var(--ck-spacing-standard) );\n\t\tbackground: var(--ck-color-base-foreground);\n\n\t\t& .ck-media__placeholder__icon {\n\t\t\tmin-width: var(--ck-media-embed-placeholder-icon-size);\n\t\t\theight: var(--ck-media-embed-placeholder-icon-size);\n\t\t\tmargin-bottom: var(--ck-spacing-large);\n\t\t\tbackground-position: center;\n\t\t\tbackground-size: cover;\n\n\t\t\t& .ck-icon {\n\t\t\t\twidth: 100%;\n\t\t\t\theight: 100%;\n\t\t\t}\n\t\t}\n\n\t\t& .ck-media__placeholder__url__text {\n\t\t\tcolor: var(--ck-color-media-embed-placeholder-url-text);\n\t\t\twhite-space: nowrap;\n\t\t\ttext-align: center;\n\t\t\tfont-style: italic;\n\t\t\ttext-overflow: ellipsis;\n\n\t\t\t&:hover {\n\t\t\t\tcolor: var(--ck-color-media-embed-placeholder-url-text-hover);\n\t\t\t\tcursor: pointer;\n\t\t\t\ttext-decoration: underline;\n\t\t\t}\n\t\t}\n\t}\n\n\t&[data-oembed-url*="open.spotify.com"] {\n\t\tmax-width: 300px;\n\t\tmax-height: 380px;\n\t}\n\n\t&[data-oembed-url*="google.com/maps"] .ck-media__placeholder__icon,\n\t&[data-oembed-url*="goo.gl/maps"] .ck-media__placeholder__icon,\n\t&[data-oembed-url*="maps.google.com"] .ck-media__placeholder__icon,\n\t&[data-oembed-url*="maps.app.goo.gl"] .ck-media__placeholder__icon {\n\t\tbackground-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNTAuMzc4IiBoZWlnaHQ9IjI1NC4xNjciIHZpZXdCb3g9IjAgMCA2Ni4yNDYgNjcuMjQ4Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTcyLjUzMSAtMjE4LjQ1NSkgc2NhbGUoLjk4MDEyKSI+PHJlY3Qgcnk9IjUuMjM4IiByeD0iNS4yMzgiIHk9IjIzMS4zOTkiIHg9IjE3Ni4wMzEiIGhlaWdodD0iNjAuMDk5IiB3aWR0aD0iNjAuMDk5IiBmaWxsPSIjMzRhNjY4IiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjxwYXRoIGQ9Ik0yMDYuNDc3IDI2MC45bC0yOC45ODcgMjguOTg3YTUuMjE4IDUuMjE4IDAgMCAwIDMuNzggMS42MWg0OS42MjFjMS42OTQgMCAzLjE5LS43OTggNC4xNDYtMi4wMzd6IiBmaWxsPSIjNWM4OGM1Ii8+PHBhdGggZD0iTTIyNi43NDIgMjIyLjk4OGMtOS4yNjYgMC0xNi43NzcgNy4xNy0xNi43NzcgMTYuMDE0LjAwNyAyLjc2Mi42NjMgNS40NzQgMi4wOTMgNy44NzUuNDMuNzAzLjgzIDEuNDA4IDEuMTkgMi4xMDcuMzMzLjUwMi42NSAxLjAwNS45NSAxLjUwOC4zNDMuNDc3LjY3My45NTcuOTg4IDEuNDQgMS4zMSAxLjc2OSAyLjUgMy41MDIgMy42MzcgNS4xNjguNzkzIDEuMjc1IDEuNjgzIDIuNjQgMi40NjYgMy45OSAyLjM2MyA0LjA5NCA0LjAwNyA4LjA5MiA0LjYgMTMuOTE0di4wMTJjLjE4Mi40MTIuNTE2LjY2Ni44NzkuNjY3LjQwMy0uMDAxLjc2OC0uMzE0LjkzLS43OTkuNjAzLTUuNzU2IDIuMjM4LTkuNzI5IDQuNTg1LTEzLjc5NC43ODItMS4zNSAxLjY3My0yLjcxNSAyLjQ2NS0zLjk5IDEuMTM3LTEuNjY2IDIuMzI4LTMuNCAzLjYzOC01LjE2OS4zMTUtLjQ4Mi42NDUtLjk2Mi45ODgtMS40MzkuMy0uNTAzLjYxNy0xLjAwNi45NS0xLjUwOC4zNTktLjcuNzYtMS40MDQgMS4xOS0yLjEwNyAxLjQyNi0yLjQwMiAyLTUuMTE0IDIuMDA0LTcuODc1IDAtOC44NDQtNy41MTEtMTYuMDE0LTE2Ljc3Ni0xNi4wMTR6IiBmaWxsPSIjZGQ0YjNlIiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjxlbGxpcHNlIHJ5PSI1LjU2NCIgcng9IjUuODI4IiBjeT0iMjM5LjAwMiIgY3g9IjIyNi43NDIiIGZpbGw9IiM4MDJkMjciIHBhaW50LW9yZGVyPSJtYXJrZXJzIHN0cm9rZSBmaWxsIi8+PHBhdGggZD0iTTE5MC4zMDEgMjM3LjI4M2MtNC42NyAwLTguNDU3IDMuODUzLTguNDU3IDguNjA2czMuNzg2IDguNjA3IDguNDU3IDguNjA3YzMuMDQzIDAgNC44MDYtLjk1OCA2LjMzNy0yLjUxNiAxLjUzLTEuNTU3IDIuMDg3LTMuOTEzIDIuMDg3LTYuMjkgMC0uMzYyLS4wMjMtLjcyMi0uMDY0LTEuMDc5aC04LjI1N3YzLjA0M2g0Ljg1Yy0uMTk3Ljc1OS0uNTMxIDEuNDUtMS4wNTggMS45ODYtLjk0Mi45NTgtMi4wMjggMS41NDgtMy45MDEgMS41NDgtMi44NzYgMC01LjIwOC0yLjM3Mi01LjIwOC01LjI5OSAwLTIuOTI2IDIuMzMyLTUuMjk5IDUuMjA4LTUuMjk5IDEuMzk5IDAgMi42MTguNDA3IDMuNTg0IDEuMjkzbDIuMzgxLTIuMzhjMC0uMDAyLS4wMDMtLjAwNC0uMDA0LS4wMDUtMS41ODgtMS41MjQtMy42Mi0yLjIxNS01Ljk1NS0yLjIxNXptNC40MyA1LjY2bC4wMDMuMDA2di0uMDAzeiIgZmlsbD0iI2ZmZiIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48cGF0aCBkPSJNMjE1LjE4NCAyNTEuOTI5bC03Ljk4IDcuOTc5IDI4LjQ3NyAyOC40NzVjLjI4Ny0uNjQ5LjQ0OS0xLjM2Ni40NDktMi4xMjN2LTMxLjE2NWMtLjQ2OS42NzUtLjkzNCAxLjM0OS0xLjM4MiAyLjAwNS0uNzkyIDEuMjc1LTEuNjgyIDIuNjQtMi40NjUgMy45OS0yLjM0NyA0LjA2NS0zLjk4MiA4LjAzOC00LjU4NSAxMy43OTQtLjE2Mi40ODUtLjUyNy43OTgtLjkzLjc5OS0uMzYzLS4wMDEtLjY5Ny0uMjU1LS44NzktLjY2N3YtLjAxMmMtLjU5My01LjgyMi0yLjIzNy05LjgyLTQuNi0xMy45MTQtLjc4My0xLjM1LTEuNjczLTIuNzE1LTIuNDY2LTMuOTktMS4xMzctMS42NjYtMi4zMjctMy40LTMuNjM3LTUuMTY5bC0uMDAyLS4wMDN6IiBmaWxsPSIjYzNjM2MzIi8+PHBhdGggZD0iTTIxMi45ODMgMjQ4LjQ5NWwtMzYuOTUyIDM2Ljk1M3YuODEyYTUuMjI3IDUuMjI3IDAgMCAwIDUuMjM4IDUuMjM4aDEuMDE1bDM1LjY2Ni0zNS42NjZhMTM2LjI3NSAxMzYuMjc1IDAgMCAwLTIuNzY0LTMuOSAzNy41NzUgMzcuNTc1IDAgMCAwLS45ODktMS40NGMtLjI5OS0uNTAzLS42MTYtMS4wMDYtLjk1LTEuNTA4LS4wODMtLjE2Mi0uMTc2LS4zMjYtLjI2NC0uNDg5eiIgZmlsbD0iI2ZkZGM0ZiIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48cGF0aCBkPSJNMjExLjk5OCAyNjEuMDgzbC02LjE1MiA2LjE1MSAyNC4yNjQgMjQuMjY0aC43ODFhNS4yMjcgNS4yMjcgMCAwIDAgNS4yMzktNS4yMzh2LTEuMDQ1eiIgZmlsbD0iI2ZmZiIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48L2c+PC9zdmc+);\n\t}\n\n\t&[data-oembed-url*="facebook.com"] .ck-media__placeholder {\n\t\tbackground: hsl(220, 46%, 48%);\n\n\t\t& .ck-media__placeholder__icon {\n\t\t\tbackground-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIHdpZHRoPSIxMDI0cHgiIGhlaWdodD0iMTAyNHB4IiB2aWV3Qm94PSIwIDAgMTAyNCAxMDI0IiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPiAgICAgICAgPHRpdGxlPkZpbGwgMTwvdGl0bGU+ICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPiAgICA8ZGVmcz48L2RlZnM+ICAgIDxnIGlkPSJQYWdlLTEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPiAgICAgICAgPGcgaWQ9ImZMb2dvX1doaXRlIiBmaWxsPSIjRkZGRkZFIj4gICAgICAgICAgICA8cGF0aCBkPSJNOTY3LjQ4NCwwIEw1Ni41MTcsMCBDMjUuMzA0LDAgMCwyNS4zMDQgMCw1Ni41MTcgTDAsOTY3LjQ4MyBDMCw5OTguNjk0IDI1LjI5NywxMDI0IDU2LjUyMiwxMDI0IEw1NDcsMTAyNCBMNTQ3LDYyOCBMNDE0LDYyOCBMNDE0LDQ3MyBMNTQ3LDQ3MyBMNTQ3LDM1OS4wMjkgQzU0NywyMjYuNzY3IDYyNy43NzMsMTU0Ljc0NyA3NDUuNzU2LDE1NC43NDcgQzgwMi4yNjksMTU0Ljc0NyA4NTAuODQyLDE1OC45NTUgODY1LDE2MC44MzYgTDg2NSwyOTkgTDc4My4zODQsMjk5LjAzNyBDNzE5LjM5MSwyOTkuMDM3IDcwNywzMjkuNTI5IDcwNywzNzQuMjczIEw3MDcsNDczIEw4NjAuNDg3LDQ3MyBMODQwLjUwMSw2MjggTDcwNyw2MjggTDcwNywxMDI0IEw5NjcuNDg0LDEwMjQgQzk5OC42OTcsMTAyNCAxMDI0LDk5OC42OTcgMTAyNCw5NjcuNDg0IEwxMDI0LDU2LjUxNSBDMTAyNCwyNS4zMDMgOTk4LjY5NywwIDk2Ny40ODQsMCIgaWQ9IkZpbGwtMSI+PC9wYXRoPiAgICAgICAgPC9nPiAgICA8L2c+PC9zdmc+);\n\t\t}\n\n\t\t& .ck-media__placeholder__url__text {\n\t\t\tcolor: hsl(220, 100%, 90%);\n\n\t\t\t&:hover {\n\t\t\t\tcolor: hsl(0, 0%, 100%);\n\t\t\t}\n\t\t}\n\t}\n\n\t&[data-oembed-url*="instagram.com"] .ck-media__placeholder {\n\t\tbackground: linear-gradient(-135deg,hsl(246, 100%, 39%),hsl(302, 100%, 36%),hsl(0, 100%, 48%));\n\n\t\t& .ck-media__placeholder__icon {\n\t\t\tbackground-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIHdpZHRoPSI1MDRweCIgaGVpZ2h0PSI1MDRweCIgdmlld0JveD0iMCAwIDUwNCA1MDQiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+ICAgICAgICA8dGl0bGU+Z2x5cGgtbG9nb19NYXkyMDE2PC90aXRsZT4gICAgPGRlc2M+Q3JlYXRlZCB3aXRoIFNrZXRjaC48L2Rlc2M+ICAgIDxkZWZzPiAgICAgICAgPHBvbHlnb24gaWQ9InBhdGgtMSIgcG9pbnRzPSIwIDAuMTU5IDUwMy44NDEgMC4xNTkgNTAzLjg0MSA1MDMuOTQgMCA1MDMuOTQiPjwvcG9seWdvbj4gICAgPC9kZWZzPiAgICA8ZyBpZD0iZ2x5cGgtbG9nb19NYXkyMDE2IiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4gICAgICAgIDxnIGlkPSJHcm91cC0zIj4gICAgICAgICAgICA8bWFzayBpZD0ibWFzay0yIiBmaWxsPSJ3aGl0ZSI+ICAgICAgICAgICAgICAgIDx1c2UgeGxpbms6aHJlZj0iI3BhdGgtMSI+PC91c2U+ICAgICAgICAgICAgPC9tYXNrPiAgICAgICAgICAgIDxnIGlkPSJDbGlwLTIiPjwvZz4gICAgICAgICAgICA8cGF0aCBkPSJNMjUxLjkyMSwwLjE1OSBDMTgzLjUwMywwLjE1OSAxNzQuOTI0LDAuNDQ5IDE0OC4wNTQsMS42NzUgQzEyMS4yNCwyLjg5OCAxMDIuOTI3LDcuMTU3IDg2LjkwMywxMy4zODUgQzcwLjMzNywxOS44MjIgNTYuMjg4LDI4LjQzNiA0Mi4yODIsNDIuNDQxIEMyOC4yNzcsNTYuNDQ3IDE5LjY2Myw3MC40OTYgMTMuMjI2LDg3LjA2MiBDNi45OTgsMTAzLjA4NiAyLjczOSwxMjEuMzk5IDEuNTE2LDE0OC4yMTMgQzAuMjksMTc1LjA4MyAwLDE4My42NjIgMCwyNTIuMDggQzAsMzIwLjQ5NyAwLjI5LDMyOS4wNzYgMS41MTYsMzU1Ljk0NiBDMi43MzksMzgyLjc2IDYuOTk4LDQwMS4wNzMgMTMuMjI2LDQxNy4wOTcgQzE5LjY2Myw0MzMuNjYzIDI4LjI3Nyw0NDcuNzEyIDQyLjI4Miw0NjEuNzE4IEM1Ni4yODgsNDc1LjcyMyA3MC4zMzcsNDg0LjMzNyA4Ni45MDMsNDkwLjc3NSBDMTAyLjkyNyw0OTcuMDAyIDEyMS4yNCw1MDEuMjYxIDE0OC4wNTQsNTAyLjQ4NCBDMTc0LjkyNCw1MDMuNzEgMTgzLjUwMyw1MDQgMjUxLjkyMSw1MDQgQzMyMC4zMzgsNTA0IDMyOC45MTcsNTAzLjcxIDM1NS43ODcsNTAyLjQ4NCBDMzgyLjYwMSw1MDEuMjYxIDQwMC45MTQsNDk3LjAwMiA0MTYuOTM4LDQ5MC43NzUgQzQzMy41MDQsNDg0LjMzNyA0NDcuNTUzLDQ3NS43MjMgNDYxLjU1OSw0NjEuNzE4IEM0NzUuNTY0LDQ0Ny43MTIgNDg0LjE3OCw0MzMuNjYzIDQ5MC42MTYsNDE3LjA5NyBDNDk2Ljg0Myw0MDEuMDczIDUwMS4xMDIsMzgyLjc2IDUwMi4zMjUsMzU1Ljk0NiBDNTAzLjU1MSwzMjkuMDc2IDUwMy44NDEsMzIwLjQ5NyA1MDMuODQxLDI1Mi4wOCBDNTAzLjg0MSwxODMuNjYyIDUwMy41NTEsMTc1LjA4MyA1MDIuMzI1LDE0OC4yMTMgQzUwMS4xMDIsMTIxLjM5OSA0OTYuODQzLDEwMy4wODYgNDkwLjYxNiw4Ny4wNjIgQzQ4NC4xNzgsNzAuNDk2IDQ3NS41NjQsNTYuNDQ3IDQ2MS41NTksNDIuNDQxIEM0NDcuNTUzLDI4LjQzNiA0MzMuNTA0LDE5LjgyMiA0MTYuOTM4LDEzLjM4NSBDNDAwLjkxNCw3LjE1NyAzODIuNjAxLDIuODk4IDM1NS43ODcsMS42NzUgQzMyOC45MTcsMC40NDkgMzIwLjMzOCwwLjE1OSAyNTEuOTIxLDAuMTU5IFogTTI1MS45MjEsNDUuNTUgQzMxOS4xODYsNDUuNTUgMzI3LjE1NCw0NS44MDcgMzUzLjcxOCw0Ny4wMTkgQzM3OC4yOCw0OC4xMzkgMzkxLjYxOSw1Mi4yNDMgNDAwLjQ5Niw1NS42OTMgQzQxMi4yNTUsNjAuMjYzIDQyMC42NDcsNjUuNzIyIDQyOS40NjIsNzQuNTM4IEM0MzguMjc4LDgzLjM1MyA0NDMuNzM3LDkxLjc0NSA0NDguMzA3LDEwMy41MDQgQzQ1MS43NTcsMTEyLjM4MSA0NTUuODYxLDEyNS43MiA0NTYuOTgxLDE1MC4yODIgQzQ1OC4xOTMsMTc2Ljg0NiA0NTguNDUsMTg0LjgxNCA0NTguNDUsMjUyLjA4IEM0NTguNDUsMzE5LjM0NSA0NTguMTkzLDMyNy4zMTMgNDU2Ljk4MSwzNTMuODc3IEM0NTUuODYxLDM3OC40MzkgNDUxLjc1NywzOTEuNzc4IDQ0OC4zMDcsNDAwLjY1NSBDNDQzLjczNyw0MTIuNDE0IDQzOC4yNzgsNDIwLjgwNiA0MjkuNDYyLDQyOS42MjEgQzQyMC42NDcsNDM4LjQzNyA0MTIuMjU1LDQ0My44OTYgNDAwLjQ5Niw0NDguNDY2IEMzOTEuNjE5LDQ1MS45MTYgMzc4LjI4LDQ1Ni4wMiAzNTMuNzE4LDQ1Ny4xNCBDMzI3LjE1OCw0NTguMzUyIDMxOS4xOTEsNDU4LjYwOSAyNTEuOTIxLDQ1OC42MDkgQzE4NC42NSw0NTguNjA5IDE3Ni42ODQsNDU4LjM1MiAxNTAuMTIzLDQ1Ny4xNCBDMTI1LjU2MSw0NTYuMDIgMTEyLjIyMiw0NTEuOTE2IDEwMy4zNDUsNDQ4LjQ2NiBDOTEuNTg2LDQ0My44OTYgODMuMTk0LDQzOC40MzcgNzQuMzc5LDQyOS42MjEgQzY1LjU2NCw0MjAuODA2IDYwLjEwNCw0MTIuNDE0IDU1LjUzNCw0MDAuNjU1IEM1Mi4wODQsMzkxLjc3OCA0Ny45OCwzNzguNDM5IDQ2Ljg2LDM1My44NzcgQzQ1LjY0OCwzMjcuMzEzIDQ1LjM5MSwzMTkuMzQ1IDQ1LjM5MSwyNTIuMDggQzQ1LjM5MSwxODQuODE0IDQ1LjY0OCwxNzYuODQ2IDQ2Ljg2LDE1MC4yODIgQzQ3Ljk4LDEyNS43MiA1Mi4wODQsMTEyLjM4MSA1NS41MzQsMTAzLjUwNCBDNjAuMTA0LDkxLjc0NSA2NS41NjMsODMuMzUzIDc0LjM3OSw3NC41MzggQzgzLjE5NCw2NS43MjIgOTEuNTg2LDYwLjI2MyAxMDMuMzQ1LDU1LjY5MyBDMTEyLjIyMiw1Mi4yNDMgMTI1LjU2MSw0OC4xMzkgMTUwLjEyMyw0Ny4wMTkgQzE3Ni42ODcsNDUuODA3IDE4NC42NTUsNDUuNTUgMjUxLjkyMSw0NS41NSBaIiBpZD0iRmlsbC0xIiBmaWxsPSIjRkZGRkZGIiBtYXNrPSJ1cmwoI21hc2stMikiPjwvcGF0aD4gICAgICAgIDwvZz4gICAgICAgIDxwYXRoIGQ9Ik0yNTEuOTIxLDMzNi4wNTMgQzIwNS41NDMsMzM2LjA1MyAxNjcuOTQ3LDI5OC40NTcgMTY3Ljk0NywyNTIuMDggQzE2Ny45NDcsMjA1LjcwMiAyMDUuNTQzLDE2OC4xMDYgMjUxLjkyMSwxNjguMTA2IEMyOTguMjk4LDE2OC4xMDYgMzM1Ljg5NCwyMDUuNzAyIDMzNS44OTQsMjUyLjA4IEMzMzUuODk0LDI5OC40NTcgMjk4LjI5OCwzMzYuMDUzIDI1MS45MjEsMzM2LjA1MyBaIE0yNTEuOTIxLDEyMi43MTUgQzE4MC40NzQsMTIyLjcxNSAxMjIuNTU2LDE4MC42MzMgMTIyLjU1NiwyNTIuMDggQzEyMi41NTYsMzIzLjUyNiAxODAuNDc0LDM4MS40NDQgMjUxLjkyMSwzODEuNDQ0IEMzMjMuMzY3LDM4MS40NDQgMzgxLjI4NSwzMjMuNTI2IDM4MS4yODUsMjUyLjA4IEMzODEuMjg1LDE4MC42MzMgMzIzLjM2NywxMjIuNzE1IDI1MS45MjEsMTIyLjcxNSBaIiBpZD0iRmlsbC00IiBmaWxsPSIjRkZGRkZGIj48L3BhdGg+ICAgICAgICA8cGF0aCBkPSJNNDE2LjYyNywxMTcuNjA0IEM0MTYuNjI3LDEzNC4zIDQwMy4wOTIsMTQ3LjgzNCAzODYuMzk2LDE0Ny44MzQgQzM2OS43MDEsMTQ3LjgzNCAzNTYuMTY2LDEzNC4zIDM1Ni4xNjYsMTE3LjYwNCBDMzU2LjE2NiwxMDAuOTA4IDM2OS43MDEsODcuMzczIDM4Ni4zOTYsODcuMzczIEM0MDMuMDkyLDg3LjM3MyA0MTYuNjI3LDEwMC45MDggNDE2LjYyNywxMTcuNjA0IiBpZD0iRmlsbC01IiBmaWxsPSIjRkZGRkZGIj48L3BhdGg+ICAgIDwvZz48L3N2Zz4=);\n\t\t}\n\n\t\t/* stylelint-disable-next-line no-descending-specificity */\n\t\t& .ck-media__placeholder__url__text {\n\t\t\tcolor: hsl(302, 100%, 94%);\n\n\t\t\t&:hover {\n\t\t\t\tcolor: hsl(0, 0%, 100%);\n\t\t\t}\n\t\t}\n\t}\n\n\t&[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder {\n\t\t/* Use gradient to contrast with focused widget (ckeditor/ckeditor5-media-embed#22). */\n\t\tbackground: linear-gradient( to right, hsl(201, 85%, 70%), hsl(201, 85%, 35%) );\n\n\t\t& .ck-media__placeholder__icon {\n\t\t\tbackground-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48c3ZnIHZlcnNpb249IjEuMSIgaWQ9IldoaXRlIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCIgdmlld0JveD0iMCAwIDQwMCA0MDAiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDQwMCA0MDA7IiB4bWw6c3BhY2U9InByZXNlcnZlIj48c3R5bGUgdHlwZT0idGV4dC9jc3MiPi5zdDB7ZmlsbDojRkZGRkZGO308L3N0eWxlPjxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik00MDAsMjAwYzAsMTEwLjUtODkuNSwyMDAtMjAwLDIwMFMwLDMxMC41LDAsMjAwUzg5LjUsMCwyMDAsMFM0MDAsODkuNSw0MDAsMjAweiBNMTYzLjQsMzA1LjVjODguNywwLDEzNy4yLTczLjUsMTM3LjItMTM3LjJjMC0yLjEsMC00LjItMC4xLTYuMmM5LjQtNi44LDE3LjYtMTUuMywyNC4xLTI1Yy04LjYsMy44LTE3LjksNi40LTI3LjcsNy42YzEwLTYsMTcuNi0xNS40LDIxLjItMjYuN2MtOS4zLDUuNS0xOS42LDkuNS0zMC42LDExLjdjLTguOC05LjQtMjEuMy0xNS4yLTM1LjItMTUuMmMtMjYuNiwwLTQ4LjIsMjEuNi00OC4yLDQ4LjJjMCwzLjgsMC40LDcuNSwxLjMsMTFjLTQwLjEtMi03NS42LTIxLjItOTkuNC01MC40Yy00LjEsNy4xLTYuNSwxNS40LTYuNSwyNC4yYzAsMTYuNyw4LjUsMzEuNSwyMS41LDQwLjFjLTcuOS0wLjItMTUuMy0yLjQtMjEuOC02YzAsMC4yLDAsMC40LDAsMC42YzAsMjMuNCwxNi42LDQyLjgsMzguNyw0Ny4zYy00LDEuMS04LjMsMS43LTEyLjcsMS43Yy0zLjEsMC02LjEtMC4zLTkuMS0wLjljNi4xLDE5LjIsMjMuOSwzMy4xLDQ1LDMzLjVjLTE2LjUsMTIuOS0zNy4zLDIwLjYtNTkuOSwyMC42Yy0zLjksMC03LjctMC4yLTExLjUtMC43QzExMC44LDI5Ny41LDEzNi4yLDMwNS41LDE2My40LDMwNS41Ii8+PC9zdmc+);\n\t\t}\n\n\t\t& .ck-media__placeholder__url__text {\n\t\t\tcolor: hsl(201, 100%, 86%);\n\n\t\t\t&:hover {\n\t\t\t\tcolor: hsl(0, 0%, 100%);\n\t\t\t}\n\t\t}\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      7138: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          '.ck.ck-media-form{align-items:flex-start;display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-media-form .ck-labeled-field-view{display:inline-block}.ck.ck-media-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-media-form{flex-wrap:wrap}.ck.ck-media-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-media-form .ck-button{flex-basis:50%}}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-media-embed/theme/mediaform.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css',
            ],
            names: [],
            mappings:
              'AAOA,kBAEC,sBAAuB,CADvB,YAAa,CAEb,kBAAmB,CACnB,gBAqBD,CAnBC,yCACC,oBACD,CAEA,4BACC,YACD,CCbA,oCDCD,kBAeE,cAUF,CARE,yCACC,eACD,CAEA,6BACC,cACD,CCtBD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-media-form {\n\tdisplay: flex;\n\talign-items: flex-start;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\n\t& .ck-labeled-field-view {\n\t\tdisplay: inline-block;\n\t}\n\n\t& .ck-label {\n\t\tdisplay: none;\n\t}\n\n\t@mixin ck-media-phone {\n\t\tflex-wrap: wrap;\n\n\t\t& .ck-labeled-field-view {\n\t\t\tflex-basis: 100%;\n\t\t}\n\n\t\t& .ck-button {\n\t\t\tflex-basis: 50%;\n\t\t}\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      9953: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          '.ck.ck-input-color{display:flex;flex-direction:row-reverse;width:100%}.ck.ck-input-color>input.ck.ck-input-text{flex-grow:1;min-width:auto}.ck.ck-input-color>div.ck.ck-dropdown{min-width:auto}.ck.ck-input-color>div.ck.ck-dropdown>.ck-input-color__button .ck-dropdown__arrow{display:none}.ck.ck-input-color .ck.ck-input-color__button{display:flex}.ck.ck-input-color .ck.ck-input-color__button .ck.ck-input-color__button__preview{overflow:hidden;position:relative}.ck.ck-input-color .ck.ck-input-color__button .ck.ck-input-color__button__preview>.ck.ck-input-color__button__preview__no-color-indicator{display:block;position:absolute}[dir=ltr] .ck.ck-input-color>.ck.ck-input-text{border-bottom-right-radius:0;border-top-right-radius:0}[dir=rtl] .ck.ck-input-color>.ck.ck-input-text{border-bottom-left-radius:0;border-top-left-radius:0}.ck.ck-input-color>.ck.ck-input-text:focus{z-index:0}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button{padding:0}[dir=ltr] .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button{border-bottom-left-radius:0;border-top-left-radius:0}[dir=ltr] .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button:not(:focus){border-left:1px solid transparent}[dir=rtl] .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button{border-bottom-right-radius:0;border-top-right-radius:0}[dir=rtl] .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button:not(:focus){border-right:1px solid transparent}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button.ck-disabled{background:var(--ck-color-input-disabled-background)}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview{border-radius:0}.ck-rounded-corners .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview,.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview{border:1px solid var(--ck-color-input-border);height:20px;width:20px}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview>.ck.ck-input-color__button__preview__no-color-indicator{background:red;border-radius:2px;height:150%;left:50%;top:-30%;transform:rotate(45deg);transform-origin:50%;width:8%}.ck.ck-input-color .ck.ck-input-color__remove-color{border-bottom-left-radius:0;border-bottom-right-radius:0;padding:calc(var(--ck-spacing-standard)/2) var(--ck-spacing-standard);width:100%}.ck.ck-input-color .ck.ck-input-color__remove-color:not(:focus){border-bottom:1px solid var(--ck-color-input-border)}[dir=ltr] .ck.ck-input-color .ck.ck-input-color__remove-color{border-top-right-radius:0}[dir=rtl] .ck.ck-input-color .ck.ck-input-color__remove-color{border-top-left-radius:0}.ck.ck-input-color .ck.ck-input-color__remove-color .ck.ck-icon{margin-right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-input-color .ck.ck-input-color__remove-color .ck.ck-icon{margin-left:var(--ck-spacing-standard);margin-right:0}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-table/theme/colorinput.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-table/colorinput.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css',
            ],
            names: [],
            mappings:
              'AAKA,mBAEC,YAAa,CACb,0BAA2B,CAF3B,UAgCD,CA5BC,0CAEC,WAAY,CADZ,cAED,CAEA,sCACC,cAMD,CAHC,kFACC,YACD,CAGD,8CAEC,YAWD,CATC,kFAEC,eAAgB,CADhB,iBAOD,CAJC,0IAEC,aAAc,CADd,iBAED,CC1BF,+CAGE,4BAA6B,CAD7B,yBAcF,CAhBA,+CAQE,2BAA4B,CAD5B,wBASF,CAHC,2CACC,SACD,CAIA,wEACC,SA0CD,CA3CA,kFAKE,2BAA4B,CAD5B,wBAuCF,CApCE,8FACC,iCACD,CATF,kFAcE,4BAA6B,CAD7B,yBA8BF,CA3BE,8FACC,kCACD,CAGD,oFACC,oDACD,CAEA,4GC1CF,eD2DE,CAjBA,+PCtCD,qCDuDC,CAjBA,4GAKC,6CAA8C,CAD9C,WAAY,CADZ,UAcD,CAVC,oKAKC,cAA6B,CAC7B,iBAAkB,CAHlB,WAAY,CADZ,QAAS,CADT,QAAS,CAMT,uBAAwB,CACxB,oBAAqB,CAJrB,QAKD,CAKH,oDAIC,2BAA4B,CAC5B,4BAA6B,CAH7B,qEAAwE,CADxE,UA0BD,CApBC,gEACC,oDACD,CATD,8DAYE,yBAeF,CA3BA,8DAgBE,wBAWF,CARC,gEACC,uCAMD,CAPA,0EAKE,sCAAuC,CADvC,cAGF',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-input-color {\n\twidth: 100%;\n\tdisplay: flex;\n\tflex-direction: row-reverse;\n\n\t& > input.ck.ck-input-text {\n\t\tmin-width: auto;\n\t\tflex-grow: 1;\n\t}\n\n\t& > div.ck.ck-dropdown {\n\t\tmin-width: auto;\n\n\t\t/* This dropdown has no arrow but a color preview instead. */\n\t\t& > .ck-input-color__button .ck-dropdown__arrow {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n\n\t& .ck.ck-input-color__button {\n\t\t/* Resolving issue with misaligned buttons on Safari (see #10589) */\n\t\tdisplay: flex;\n\n\t\t& .ck.ck-input-color__button__preview {\n\t\t\tposition: relative;\n\t\t\toverflow: hidden;\n\n\t\t\t& > .ck.ck-input-color__button__preview__no-color-indicator {\n\t\t\t\tposition: absolute;\n\t\t\t\tdisplay: block;\n\t\t\t}\n\t\t}\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n@import "../mixins/_rounded.css";\n\n.ck.ck-input-color {\n\t& > .ck.ck-input-text {\n\t\t@mixin ck-dir ltr {\n\t\t\tborder-top-right-radius: 0;\n\t\t\tborder-bottom-right-radius: 0;\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\tborder-top-left-radius: 0;\n\t\t\tborder-bottom-left-radius: 0;\n\t\t}\n\n\t\t/* Make sure the focused input is always on top of the dropdown button so its\n\t\t   outline and border are never cropped (also when the input is read-only). */\n\t\t&:focus {\n\t\t\tz-index: 0;\n\t\t}\n\t}\n\n\t& > .ck.ck-dropdown {\n\t\t& > .ck.ck-button.ck-input-color__button {\n\t\t\tpadding: 0;\n\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tborder-top-left-radius: 0;\n\t\t\t\tborder-bottom-left-radius: 0;\n\n\t\t\t\t&:not(:focus) {\n\t\t\t\t\tborder-left: 1px solid transparent;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tborder-top-right-radius: 0;\n\t\t\t\tborder-bottom-right-radius: 0;\n\n\t\t\t\t&:not(:focus) {\n\t\t\t\t\tborder-right: 1px solid transparent;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t&.ck-disabled {\n\t\t\t\tbackground: var(--ck-color-input-disabled-background);\n\t\t\t}\n\n\t\t\t& > .ck.ck-input-color__button__preview {\n\t\t\t\t@mixin ck-rounded-corners;\n\n\t\t\t\twidth: 20px;\n\t\t\t\theight: 20px;\n\t\t\t\tborder: 1px solid var(--ck-color-input-border);\n\n\t\t\t\t& > .ck.ck-input-color__button__preview__no-color-indicator {\n\t\t\t\t\ttop: -30%;\n\t\t\t\t\tleft: 50%;\n\t\t\t\t\theight: 150%;\n\t\t\t\t\twidth: 8%;\n\t\t\t\t\tbackground: hsl(0, 100%, 50%);\n\t\t\t\t\tborder-radius: 2px;\n\t\t\t\t\ttransform: rotate(45deg);\n\t\t\t\t\ttransform-origin: 50%;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t& .ck.ck-input-color__remove-color {\n\t\twidth: 100%;\n\t\tpadding: calc(var(--ck-spacing-standard) / 2) var(--ck-spacing-standard);\n\n\t\tborder-bottom-left-radius: 0;\n\t\tborder-bottom-right-radius: 0;\n\n\t\t&:not(:focus) {\n\t\t\tborder-bottom: 1px solid var(--ck-color-input-border);\n\t\t}\n\n\t\t@mixin ck-dir ltr {\n\t\t\tborder-top-right-radius: 0;\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\tborder-top-left-radius: 0;\n\t\t}\n\n\t\t& .ck.ck-icon {\n\t\t\tmargin-right: var(--ck-spacing-standard);\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tmargin-right: 0;\n\t\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t\t}\n\t\t}\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      7502: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          '.ck.ck-form{padding:0 0 var(--ck-spacing-large)}.ck.ck-form:focus{outline:none}.ck.ck-form .ck.ck-input-text{min-width:100%;width:0}.ck.ck-form .ck.ck-dropdown{min-width:100%}.ck.ck-form .ck.ck-dropdown .ck-dropdown__button:not(:focus){border:1px solid var(--ck-color-base-border)}.ck.ck-form .ck.ck-dropdown .ck-dropdown__button .ck-button__label{width:100%}',
          '',
          {
            version: 3,
            sources: ['webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-table/form.css'],
            names: [],
            mappings:
              'AAKA,YACC,mCAyBD,CAvBC,kBAEC,YACD,CAEA,8BACC,cAAe,CACf,OACD,CAEA,4BACC,cAWD,CARE,6DACC,4CACD,CAEA,mEACC,UACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-form {\n\tpadding: 0 0 var(--ck-spacing-large);\n\n\t&:focus {\n\t\t/* See: https://github.com/ckeditor/ckeditor5/issues/4773 */\n\t\toutline: none;\n\t}\n\n\t& .ck.ck-input-text {\n\t\tmin-width: 100%;\n\t\twidth: 0;\n\t}\n\n\t& .ck.ck-dropdown {\n\t\tmin-width: 100%;\n\n\t\t& .ck-dropdown__button {\n\t\t\t&:not(:focus) {\n\t\t\t\tborder: 1px solid var(--ck-color-base-border);\n\t\t\t}\n\n\t\t\t& .ck-button__label {\n\t\t\t\twidth: 100%;\n\t\t\t}\n\t\t}\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      6908: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          '.ck.ck-form__row{display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between}.ck.ck-form__row>:not(.ck-label){flex-grow:1}.ck.ck-form__row.ck-table-form__action-row .ck-button-cancel,.ck.ck-form__row.ck-table-form__action-row .ck-button-save{justify-content:center}.ck.ck-form__row{padding:var(--ck-spacing-standard) var(--ck-spacing-large) 0}[dir=ltr] .ck.ck-form__row>:not(.ck-label)+*{margin-left:var(--ck-spacing-large)}[dir=rtl] .ck.ck-form__row>:not(.ck-label)+*{margin-right:var(--ck-spacing-large)}.ck.ck-form__row>.ck-label{min-width:100%;width:100%}.ck.ck-form__row.ck-table-form__action-row{margin-top:var(--ck-spacing-large)}.ck.ck-form__row.ck-table-form__action-row .ck-button .ck-button__label{color:var(--ck-color-text)}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-table/theme/formrow.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-table/formrow.css',
            ],
            names: [],
            mappings:
              'AAKA,iBACC,YAAa,CACb,kBAAmB,CACnB,gBAAiB,CACjB,6BAaD,CAVC,iCACC,WACD,CAGC,wHAEC,sBACD,CCbF,iBACC,4DA2BD,CAvBE,6CAEE,mCAMF,CARA,6CAME,oCAEF,CAGD,2BAEC,cAAe,CADf,UAED,CAEA,2CACC,kCAKD,CAHC,wEACC,0BACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-form__row {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\tjustify-content: space-between;\n\n\t/* Ignore labels that work as fieldset legends */\n\t& > *:not(.ck-label) {\n\t\tflex-grow: 1;\n\t}\n\n\t&.ck-table-form__action-row {\n\t\t& .ck-button-save,\n\t\t& .ck-button-cancel {\n\t\t\tjustify-content: center;\n\t\t}\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck.ck-form__row {\n\tpadding: var(--ck-spacing-standard) var(--ck-spacing-large) 0;\n\n\t/* Ignore labels that work as fieldset legends */\n\t& > *:not(.ck-label) {\n\t\t& + * {\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tmargin-left: var(--ck-spacing-large);\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tmargin-right: var(--ck-spacing-large);\n\t\t\t}\n\t\t}\n\t}\n\n\t& > .ck-label {\n\t\twidth: 100%;\n\t\tmin-width: 100%;\n\t}\n\n\t&.ck-table-form__action-row {\n\t\tmargin-top: var(--ck-spacing-large);\n\n\t\t& .ck-button .ck-button__label {\n\t\t\tcolor: var(--ck-color-text);\n\t\t}\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      468: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          '.ck .ck-insert-table-dropdown__grid{display:flex;flex-direction:row;flex-wrap:wrap}:root{--ck-insert-table-dropdown-padding:10px;--ck-insert-table-dropdown-box-height:11px;--ck-insert-table-dropdown-box-width:12px;--ck-insert-table-dropdown-box-margin:1px}.ck .ck-insert-table-dropdown__grid{padding:var(--ck-insert-table-dropdown-padding) var(--ck-insert-table-dropdown-padding) 0;width:calc(var(--ck-insert-table-dropdown-box-width)*10 + var(--ck-insert-table-dropdown-box-margin)*20 + var(--ck-insert-table-dropdown-padding)*2)}.ck .ck-insert-table-dropdown__label,.ck[dir=rtl] .ck-insert-table-dropdown__label{text-align:center}.ck .ck-insert-table-dropdown-grid-box{border:1px solid var(--ck-color-base-border);border-radius:1px;margin:var(--ck-insert-table-dropdown-box-margin);min-height:var(--ck-insert-table-dropdown-box-height);min-width:var(--ck-insert-table-dropdown-box-width);outline:none;transition:none}.ck .ck-insert-table-dropdown-grid-box:focus{box-shadow:none}.ck .ck-insert-table-dropdown-grid-box.ck-on{background:var(--ck-color-focus-outer-shadow);border-color:var(--ck-color-focus-border)}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-table/theme/inserttable.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-table/inserttable.css',
            ],
            names: [],
            mappings:
              'AAKA,oCACC,YAAa,CACb,kBAAmB,CACnB,cACD,CCJA,MACC,uCAAwC,CACxC,0CAA2C,CAC3C,yCAA0C,CAC1C,yCACD,CAEA,oCAGC,yFAA0F,CAD1F,oJAED,CAEA,mFAEC,iBACD,CAEA,uCAIC,4CAA6C,CAC7C,iBAAkB,CAFlB,iDAAkD,CADlD,qDAAsD,CADtD,mDAAoD,CAKpD,YAAa,CACb,eAUD,CARC,6CACC,eACD,CAEA,6CAEC,6CAA8C,CAD9C,yCAED',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-insert-table-dropdown__grid {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: wrap;\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-insert-table-dropdown-padding: 10px;\n\t--ck-insert-table-dropdown-box-height: 11px;\n\t--ck-insert-table-dropdown-box-width: 12px;\n\t--ck-insert-table-dropdown-box-margin: 1px;\n}\n\n.ck .ck-insert-table-dropdown__grid {\n\t/* The width of a container should match 10 items in a row so there will be a 10x10 grid. */\n\twidth: calc(var(--ck-insert-table-dropdown-box-width) * 10 + var(--ck-insert-table-dropdown-box-margin) * 20 + var(--ck-insert-table-dropdown-padding) * 2);\n\tpadding: var(--ck-insert-table-dropdown-padding) var(--ck-insert-table-dropdown-padding) 0;\n}\n\n.ck .ck-insert-table-dropdown__label,\n.ck[dir=rtl] .ck-insert-table-dropdown__label {\n\ttext-align: center;\n}\n\n.ck .ck-insert-table-dropdown-grid-box {\n\tmin-width: var(--ck-insert-table-dropdown-box-width);\n\tmin-height: var(--ck-insert-table-dropdown-box-height);\n\tmargin: var(--ck-insert-table-dropdown-box-margin);\n\tborder: 1px solid var(--ck-color-base-border);\n\tborder-radius: 1px;\n\toutline: none;\n\ttransition: none;\n\n\t&:focus {\n\t\tbox-shadow: none;\n\t}\n\n\t&.ck-on {\n\t\tborder-color: var(--ck-color-focus-border);\n\t\tbackground: var(--ck-color-focus-outer-shadow);\n\t}\n}\n\n',
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      2510: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          '.ck-content .table{display:table;margin:.9em auto}.ck-content .table table{border:1px double #b3b3b3;border-collapse:collapse;border-spacing:0;height:100%;width:100%}.ck-content .table table td,.ck-content .table table th{border:1px solid #bfbfbf;min-width:2em;padding:.4em}.ck-content .table table th{background:rgba(0,0,0,.05);font-weight:700}.ck-content[dir=rtl] .table th{text-align:right}.ck-content[dir=ltr] .table th{text-align:left}.ck-editor__editable .ck-table-bogus-paragraph{display:inline-block;width:100%}',
          '',
          {
            version: 3,
            sources: ['webpack://./node_modules/@ckeditor/ckeditor5-table/theme/table.css'],
            names: [],
            mappings:
              'AAKA,mBAKC,aAAc,CADd,gBAiCD,CA9BC,yBAYC,yBAAkC,CAVlC,wBAAyB,CACzB,gBAAiB,CAKjB,WAAY,CADZ,UAsBD,CAfC,wDAQC,wBAAiC,CANjC,aAAc,CACd,YAMD,CAEA,4BAEC,0BAA+B,CAD/B,eAED,CAMF,+BACC,gBACD,CAEA,+BACC,eACD,CAEA,+CAKC,oBAAqB,CAMrB,UACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content .table {\n\t/* Give the table widget some air and center it horizontally */\n\t/* The first value should be equal to --ck-spacing-large variable if used in the editor context\n\tto avoid the content jumping (See https://github.com/ckeditor/ckeditor5/issues/9825). */\n\tmargin: 0.9em auto;\n\tdisplay: table;\n\n\t& table {\n\t\t/* The table cells should have slight borders */\n\t\tborder-collapse: collapse;\n\t\tborder-spacing: 0;\n\n\t\t/* Table width and height are set on the parent <figure>. Make sure the table inside stretches\n\t\tto the full dimensions of the container (https://github.com/ckeditor/ckeditor5/issues/6186). */\n\t\twidth: 100%;\n\t\theight: 100%;\n\n\t\t/* The outer border of the table should be slightly darker than the inner lines.\n\t\tAlso see https://github.com/ckeditor/ckeditor5-table/issues/50. */\n\t\tborder: 1px double hsl(0, 0%, 70%);\n\n\t\t& td,\n\t\t& th {\n\t\t\tmin-width: 2em;\n\t\t\tpadding: .4em;\n\n\t\t\t/* The border is inherited from .ck-editor__nested-editable styles, so theoretically it\'s not necessary here.\n\t\t\tHowever, the border is a content style, so it should use .ck-content (so it works outside the editor).\n\t\t\tHence, the duplication. See https://github.com/ckeditor/ckeditor5/issues/6314 */\n\t\t\tborder: 1px solid hsl(0, 0%, 75%);\n\t\t}\n\n\t\t& th {\n\t\t\tfont-weight: bold;\n\t\t\tbackground: hsla(0, 0%, 0%, 5%);\n\t\t}\n\t}\n}\n\n/* Text alignment of the table header should match the editor settings and override the native browser styling,\nwhen content is available outside the editor. See https://github.com/ckeditor/ckeditor5/issues/6638 */\n.ck-content[dir="rtl"] .table th {\n\ttext-align: right;\n}\n\n.ck-content[dir="ltr"] .table th {\n\ttext-align: left;\n}\n\n.ck-editor__editable .ck-table-bogus-paragraph {\n\t/*\n\t * Use display:inline-block to force Chrome/Safari to limit text mutations to this element.\n\t * See https://github.com/ckeditor/ckeditor5/issues/6062.\n\t */\n\tdisplay: inline-block;\n\n\t/*\n\t * Inline HTML elements nested in the span should always be dimensioned in relation to the whole cell width.\n\t * See https://github.com/ckeditor/ckeditor5/issues/9117.\n\t */\n\twidth: 100%;\n}\n',
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      1111: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          ':root{--ck-color-selector-caption-background:#f7f7f7;--ck-color-selector-caption-text:#333;--ck-color-selector-caption-highlighted-background:#fd0}.ck-content .table>figcaption{background-color:var(--ck-color-selector-caption-background);caption-side:top;color:var(--ck-color-selector-caption-text);display:table-caption;font-size:.75em;outline-offset:-1px;padding:.6em;text-align:center;word-break:break-word}.ck.ck-editor__editable .table>figcaption.table__caption_highlighted{animation:ck-table-caption-highlight .6s ease-out}.ck.ck-editor__editable .table>figcaption.ck-placeholder:before{overflow:hidden;padding-left:inherit;padding-right:inherit;text-overflow:ellipsis;white-space:nowrap}@keyframes ck-table-caption-highlight{0%{background-color:var(--ck-color-selector-caption-highlighted-background)}to{background-color:var(--ck-color-selector-caption-background)}}',
          '',
          {
            version: 3,
            sources: ['webpack://./node_modules/@ckeditor/ckeditor5-table/theme/tablecaption.css'],
            names: [],
            mappings:
              'AAKA,MACC,8CAAuD,CACvD,qCAAiD,CACjD,uDACD,CAGA,8BAMC,4DAA6D,CAJ7D,gBAAiB,CAGjB,2CAA4C,CAJ5C,qBAAsB,CAOtB,eAAgB,CAChB,mBAAoB,CAFpB,YAAa,CAHb,iBAAkB,CADlB,qBAOD,CAIC,qEACC,iDACD,CAEA,gEASC,eAAgB,CARhB,oBAAqB,CACrB,qBAAsB,CAQtB,sBAAuB,CAFvB,kBAGD,CAGD,sCACC,GACC,wEACD,CAEA,GACC,4DACD,CACD',
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-selector-caption-background: hsl(0, 0%, 97%);\n\t--ck-color-selector-caption-text: hsl(0, 0%, 20%);\n\t--ck-color-selector-caption-highlighted-background: hsl(52deg 100% 50%);\n}\n\n/* Content styles */\n.ck-content .table > figcaption {\n\tdisplay: table-caption;\n\tcaption-side: top;\n\tword-break: break-word;\n\ttext-align: center;\n\tcolor: var(--ck-color-selector-caption-text);\n\tbackground-color: var(--ck-color-selector-caption-background);\n\tpadding: .6em;\n\tfont-size: .75em;\n\toutline-offset: -1px;\n}\n\n/* Editing styles */\n.ck.ck-editor__editable .table > figcaption {\n\t&.table__caption_highlighted {\n\t\tanimation: ck-table-caption-highlight .6s ease-out;\n\t}\n\n\t&.ck-placeholder::before {\n\t\tpadding-left: inherit;\n\t\tpadding-right: inherit;\n\n\t\t/*\n\t\t * Make sure the table caption placeholder doesn't overflow the placeholder area.\n\t\t * See https://github.com/ckeditor/ckeditor5/issues/9162.\n\t\t */\n\t\twhite-space: nowrap;\n\t\toverflow: hidden;\n\t\ttext-overflow: ellipsis;\n\t}\n}\n\n@keyframes ck-table-caption-highlight {\n\t0% {\n\t\tbackground-color: var(--ck-color-selector-caption-highlighted-background);\n\t}\n\n\t100% {\n\t\tbackground-color: var(--ck-color-selector-caption-background);\n\t}\n}\n",
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      3964: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          '.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row{flex-wrap:wrap}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row .ck.ck-toolbar:first-of-type{flex-grow:0.57}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row .ck.ck-toolbar:last-of-type{flex-grow:0.43}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row .ck.ck-toolbar .ck-button{flex-grow:1}.ck.ck-table-cell-properties-form{width:320px}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__padding-row{align-self:flex-end;padding:0;width:25%}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row .ck.ck-toolbar{background:none;margin-top:var(--ck-spacing-standard)}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-table/theme/tablecellproperties.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-table/tablecellproperties.css',
            ],
            names: [],
            mappings:
              'AAOE,6FACC,cAiBD,CAdE,0HAEC,cACD,CAEA,yHAEC,cACD,CAEA,uHACC,WACD,CClBJ,kCACC,WAkBD,CAfE,2FACC,mBAAoB,CACpB,SAAU,CACV,SACD,CAGC,4GACC,eAAgB,CAGhB,qCACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-table-cell-properties-form {\n\t& .ck-form__row {\n\t\t&.ck-table-cell-properties-form__alignment-row {\n\t\t\tflex-wrap: wrap;\n\n\t\t\t& .ck.ck-toolbar {\n\t\t\t\t&:first-of-type {\n\t\t\t\t\t/* 4 buttons out of 7 (h-alignment + v-alignment) = 0.57 */\n\t\t\t\t\tflex-grow: 0.57;\n\t\t\t\t}\n\n\t\t\t\t&:last-of-type {\n\t\t\t\t\t/* 3 buttons out of 7 (h-alignment + v-alignment) = 0.43 */\n\t\t\t\t\tflex-grow: 0.43;\n\t\t\t\t}\n\n\t\t\t\t& .ck-button {\n\t\t\t\t\tflex-grow: 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-table-cell-properties-form {\n\twidth: 320px;\n\n\t& .ck-form__row {\n\t\t&.ck-table-cell-properties-form__padding-row {\n\t\t\talign-self: flex-end;\n\t\t\tpadding: 0;\n\t\t\twidth: 25%;\n\t\t}\n\n\t\t&.ck-table-cell-properties-form__alignment-row {\n\t\t\t& .ck.ck-toolbar {\n\t\t\t\tbackground: none;\n\n\t\t\t\t/* Compensate for missing input label that would push the margin (toolbar has no inputs). */\n\t\t\t\tmargin-top: var(--ck-spacing-standard);\n\t\t\t}\n\t\t}\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      7176: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          ':root{--ck-color-selector-column-resizer-hover:var(--ck-color-base-active);--ck-table-column-resizer-width:7px;--ck-table-column-resizer-position-offset:calc(var(--ck-table-column-resizer-width)*-0.5 - 0.5px)}.ck-content .table .ck-table-resized{table-layout:fixed}.ck-content .table table{overflow:hidden}.ck-content .table td,.ck-content .table th{overflow-wrap:break-word;position:relative}.ck.ck-editor__editable .table .ck-table-column-resizer{bottom:-999999px;cursor:col-resize;position:absolute;right:var(--ck-table-column-resizer-position-offset);top:-999999px;user-select:none;width:var(--ck-table-column-resizer-width);z-index:var(--ck-z-default)}.ck.ck-editor__editable .table[draggable] .ck-table-column-resizer,.ck.ck-editor__editable.ck-column-resize_disabled .table .ck-table-column-resizer{display:none}.ck.ck-editor__editable .table .ck-table-column-resizer:hover,.ck.ck-editor__editable .table .ck-table-column-resizer__active{background-color:var(--ck-color-selector-column-resizer-hover);opacity:.25}.ck.ck-editor__editable[dir=rtl] .table .ck-table-column-resizer{left:var(--ck-table-column-resizer-position-offset);right:unset}',
          '',
          {
            version: 3,
            sources: ['webpack://./node_modules/@ckeditor/ckeditor5-table/theme/tablecolumnresize.css'],
            names: [],
            mappings:
              'AAKA,MACC,oEAAqE,CACrE,mCAAoC,CAIpC,iGACD,CAEA,qCACC,kBACD,CAEA,yBACC,eACD,CAEA,4CAIC,wBAAyB,CACzB,iBACD,CAEA,wDAOC,gBAAiB,CAGjB,iBAAkB,CATlB,iBAAkB,CAOlB,oDAAqD,CAFrD,aAAc,CAKd,gBAAiB,CAFjB,0CAA2C,CAG3C,2BACD,CAQA,qJACC,YACD,CAEA,8HAEC,8DAA+D,CAC/D,WACD,CAEA,iEACC,mDAAoD,CACpD,WACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-selector-column-resizer-hover: var(--ck-color-base-active);\n\t--ck-table-column-resizer-width: 7px;\n\n\t/* The offset used for absolute positioning of the resizer element, so that it is placed exactly above the cell border.\n\t   The value is: minus half the width of the resizer decreased additionaly by the half the width of the border (0.5px). */\n\t--ck-table-column-resizer-position-offset: calc(var(--ck-table-column-resizer-width) * -0.5 - 0.5px);\n}\n\n.ck-content .table .ck-table-resized {\n\ttable-layout: fixed;\n}\n\n.ck-content .table table {\n\toverflow: hidden;\n}\n\n.ck-content .table td,\n.ck-content .table th {\n\t/* To prevent text overflowing beyond its cell when columns are resized by resize handler\n\t(https://github.com/ckeditor/ckeditor5/pull/14379#issuecomment-1589460978). */\n\toverflow-wrap: break-word;\n\tposition: relative;\n}\n\n.ck.ck-editor__editable .table .ck-table-column-resizer {\n\tposition: absolute;\n\t/* The resizer element resides in each cell so to occupy the entire height of the table, which is unknown from a CSS point of view,\n\t   it is extended to an extremely high height. Even for screens with a very high pixel density, the resizer will fulfill its role as\n\t   it should, i.e. for a screen of 476 ppi the total height of the resizer will take over 350 sheets of A4 format, which is totally\n\t   unrealistic height for a single table. */\n\ttop: -999999px;\n\tbottom: -999999px;\n\tright: var(--ck-table-column-resizer-position-offset);\n\twidth: var(--ck-table-column-resizer-width);\n\tcursor: col-resize;\n\tuser-select: none;\n\tz-index: var(--ck-z-default);\n}\n\n.ck.ck-editor__editable.ck-column-resize_disabled .table .ck-table-column-resizer {\n\tdisplay: none;\n}\n\n/* The resizer elements, which are extended to an extremely high height, break the drag & drop feature in Chrome. To make it work again,\n   all resizers must be hidden while the table is dragged. */\n.ck.ck-editor__editable .table[draggable] .ck-table-column-resizer {\n\tdisplay: none;\n}\n\n.ck.ck-editor__editable .table .ck-table-column-resizer:hover,\n.ck.ck-editor__editable .table .ck-table-column-resizer__active {\n\tbackground-color: var(--ck-color-selector-column-resizer-hover);\n\topacity: 0.25;\n}\n\n.ck.ck-editor__editable[dir=rtl] .table .ck-table-column-resizer {\n\tleft: var(--ck-table-column-resizer-position-offset);\n\tright: unset;\n}\n',
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      8361: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          ':root{--ck-color-selector-focused-cell-background:rgba(158,201,250,.3)}.ck-widget.table td.ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck-widget.table td.ck-editor__nested-editable:focus,.ck-widget.table th.ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck-widget.table th.ck-editor__nested-editable:focus{background:var(--ck-color-selector-focused-cell-background);border-style:none;outline:1px solid var(--ck-color-focus-border);outline-offset:-1px}',
          '',
          {
            version: 3,
            sources: ['webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-table/tableediting.css'],
            names: [],
            mappings: 'AAKA,MACC,gEACD,CAKE,8QAGC,2DAA4D,CAK5D,iBAAkB,CAClB,8CAA+C,CAC/C,mBACD',
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-selector-focused-cell-background: hsla(212, 90%, 80%, .3);\n}\n\n.ck-widget.table {\n\t& td,\n\t& th {\n\t\t&.ck-editor__nested-editable.ck-editor__nested-editable_focused,\n\t\t&.ck-editor__nested-editable:focus {\n\t\t\t/* A very slight background to highlight the focused cell */\n\t\t\tbackground: var(--ck-color-selector-focused-cell-background);\n\n\t\t\t/* Fixes the problem where surrounding cells cover the focused cell's border.\n\t\t\tIt does not fix the problem in all places but the UX is improved.\n\t\t\tSee https://github.com/ckeditor/ckeditor5-table/issues/29. */\n\t\t\tborder-style: none;\n\t\t\toutline: 1px solid var(--ck-color-focus-border);\n\t\t\toutline-offset: -1px; /* progressive enhancement - no IE support */\n\t\t}\n\t}\n}\n",
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      9429: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          '.ck.ck-table-form .ck-form__row.ck-table-form__background-row,.ck.ck-table-form .ck-form__row.ck-table-form__border-row{flex-wrap:wrap}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row{align-items:center;flex-wrap:wrap}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-labeled-field-view{align-items:center;display:flex;flex-direction:column-reverse}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-labeled-field-view .ck.ck-dropdown,.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimension-operator{flex-grow:0}.ck.ck-table-form .ck.ck-labeled-field-view{position:relative}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status{bottom:calc(var(--ck-table-properties-error-arrow-size)*-1);left:50%;position:absolute;transform:translate(-50%,100%);z-index:1}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status:after{content:"";left:50%;position:absolute;top:calc(var(--ck-table-properties-error-arrow-size)*-1);transform:translateX(-50%)}:root{--ck-table-properties-error-arrow-size:6px;--ck-table-properties-min-error-width:150px}.ck.ck-table-form .ck-form__row.ck-table-form__border-row .ck-labeled-field-view>.ck-label{font-size:var(--ck-font-size-tiny);text-align:center}.ck.ck-table-form .ck-form__row.ck-table-form__border-row .ck-table-form__border-style,.ck.ck-table-form .ck-form__row.ck-table-form__border-row .ck-table-form__border-width{max-width:80px;min-width:80px;width:80px}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row{padding:0}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimensions-row__height,.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimensions-row__width{margin:0}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimension-operator{align-self:flex-end;display:inline-block;height:var(--ck-ui-component-min-height);line-height:var(--ck-ui-component-min-height);margin:0 var(--ck-spacing-small)}.ck.ck-table-form .ck.ck-labeled-field-view{padding-top:var(--ck-spacing-standard)}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status{border-radius:0}.ck-rounded-corners .ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status,.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status{background:var(--ck-color-base-error);color:var(--ck-color-base-background);min-width:var(--ck-table-properties-min-error-width);padding:var(--ck-spacing-small) var(--ck-spacing-medium);text-align:center}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status:after{border-color:transparent transparent var(--ck-color-base-error) transparent;border-style:solid;border-width:0 var(--ck-table-properties-error-arrow-size) var(--ck-table-properties-error-arrow-size) var(--ck-table-properties-error-arrow-size)}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status{animation:ck-table-form-labeled-view-status-appear .15s ease both}.ck.ck-table-form .ck.ck-labeled-field-view .ck-input.ck-error:not(:focus)+.ck.ck-labeled-field-view__status{display:none}@keyframes ck-table-form-labeled-view-status-appear{0%{opacity:0}to{opacity:1}}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-table/theme/tableform.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-table/tableform.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css',
            ],
            names: [],
            mappings:
              'AAWE,wHACC,cACD,CAEA,8DAEC,kBAAmB,CADnB,cAgBD,CAbC,qFAGC,kBAAmB,CAFnB,YAAa,CACb,6BAMD,CAEA,sMACC,WACD,CAIF,4CAEC,iBAoBD,CAlBC,8EAGC,2DAAgE,CADhE,QAAS,CADT,iBAAkB,CAGlB,8BAA+B,CAG/B,SAUD,CAPC,oFACC,UAAW,CAGX,QAAS,CAFT,iBAAkB,CAClB,wDAA6D,CAE7D,0BACD,CChDH,MACC,0CAA2C,CAC3C,2CACD,CAMI,2FACC,kCAAmC,CACnC,iBACD,CAGD,8KAIC,cAAe,CADf,cAAe,CADf,UAGD,CAGD,8DACC,SAcD,CAZC,yMAEC,QACD,CAEA,iGACC,mBAAoB,CACpB,oBAAqB,CACrB,wCAAyC,CACzC,6CAA8C,CAC9C,gCACD,CAIF,4CACC,sCAyBD,CAvBC,8ECxCD,eDyDC,CAjBA,mMCpCA,qCDqDA,CAjBA,8EAGC,qCAAsC,CACtC,qCAAsC,CAEtC,oDAAqD,CADrD,wDAAyD,CAEzD,iBAUD,CAPC,oFACC,2EAA4E,CAE5E,kBAAmB,CADnB,kJAED,CAdD,8EAgBC,iEACD,CAGA,6GACC,YACD,CAIF,oDACC,GACC,SACD,CAEA,GACC,SACD,CACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-table-form {\n\t& .ck-form__row {\n\t\t&.ck-table-form__border-row {\n\t\t\tflex-wrap: wrap;\n\t\t}\n\n\t\t&.ck-table-form__background-row {\n\t\t\tflex-wrap: wrap;\n\t\t}\n\n\t\t&.ck-table-form__dimensions-row {\n\t\t\tflex-wrap: wrap;\n\t\t\talign-items: center;\n\n\t\t\t& .ck-labeled-field-view {\n\t\t\t\tdisplay: flex;\n\t\t\t\tflex-direction: column-reverse;\n\t\t\t\talign-items: center;\n\n\t\t\t\t& .ck.ck-dropdown {\n\t\t\t\t\tflex-grow: 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t& .ck-table-form__dimension-operator {\n\t\t\t\tflex-grow: 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t& .ck.ck-labeled-field-view {\n\t\t/* Allow absolute positioning of the status (error) balloons. */\n\t\tposition: relative;\n\n\t\t& .ck.ck-labeled-field-view__status {\n\t\t\tposition: absolute;\n\t\t\tleft: 50%;\n\t\t\tbottom: calc( -1 * var(--ck-table-properties-error-arrow-size) );\n\t\t\ttransform: translate(-50%,100%);\n\n\t\t\t/* Make sure the balloon status stays on top of other form elements. */\n\t\t\tz-index: 1;\n\n\t\t\t/* The arrow pointing towards the field. */\n\t\t\t&::after {\n\t\t\t\tcontent: "";\n\t\t\t\tposition: absolute;\n\t\t\t\ttop: calc( -1 * var(--ck-table-properties-error-arrow-size) );\n\t\t\t\tleft: 50%;\n\t\t\t\ttransform: translateX( -50% );\n\t\t\t}\n\t\t}\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../mixins/_rounded.css";\n\n:root {\n\t--ck-table-properties-error-arrow-size: 6px;\n\t--ck-table-properties-min-error-width: 150px;\n}\n\n.ck.ck-table-form {\n\t& .ck-form__row {\n\t\t&.ck-table-form__border-row {\n\t\t\t& .ck-labeled-field-view {\n\t\t\t\t& > .ck-label {\n\t\t\t\t\tfont-size: var(--ck-font-size-tiny);\n\t\t\t\t\ttext-align: center;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t& .ck-table-form__border-style,\n\t\t\t& .ck-table-form__border-width {\n\t\t\t\twidth: 80px;\n\t\t\t\tmin-width: 80px;\n\t\t\t\tmax-width: 80px;\n\t\t\t}\n\t\t}\n\n\t\t&.ck-table-form__dimensions-row {\n\t\t\tpadding: 0;\n\n\t\t\t& .ck-table-form__dimensions-row__width,\n\t\t\t& .ck-table-form__dimensions-row__height {\n\t\t\t\tmargin: 0\n\t\t\t}\n\n\t\t\t& .ck-table-form__dimension-operator {\n\t\t\t\talign-self: flex-end;\n\t\t\t\tdisplay: inline-block;\n\t\t\t\theight: var(--ck-ui-component-min-height);\n\t\t\t\tline-height: var(--ck-ui-component-min-height);\n\t\t\t\tmargin: 0 var(--ck-spacing-small);\n\t\t\t}\n\t\t}\n\t}\n\n\t& .ck.ck-labeled-field-view {\n\t\tpadding-top: var(--ck-spacing-standard);\n\n\t\t& .ck.ck-labeled-field-view__status {\n\t\t\t@mixin ck-rounded-corners;\n\n\t\t\tbackground: var(--ck-color-base-error);\n\t\t\tcolor: var(--ck-color-base-background);\n\t\t\tpadding: var(--ck-spacing-small) var(--ck-spacing-medium);\n\t\t\tmin-width: var(--ck-table-properties-min-error-width);\n\t\t\ttext-align: center;\n\n\t\t\t/* The arrow pointing towards the field. */\n\t\t\t&::after {\n\t\t\t\tborder-color: transparent transparent var(--ck-color-base-error) transparent;\n\t\t\t\tborder-width: 0 var(--ck-table-properties-error-arrow-size) var(--ck-table-properties-error-arrow-size) var(--ck-table-properties-error-arrow-size);\n\t\t\t\tborder-style: solid;\n\t\t\t}\n\n\t\t\tanimation: ck-table-form-labeled-view-status-appear .15s ease both;\n\t\t}\n\n\t\t/* Hide the error balloon when the field is blurred. Makes the experience much more clear. */\n\t\t& .ck-input.ck-error:not(:focus) + .ck.ck-labeled-field-view__status {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n}\n\n@keyframes ck-table-form-labeled-view-status-appear {\n\t0% {\n\t\topacity: 0;\n\t}\n\n\t100% {\n\t\topacity: 1;\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      6596: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          '.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row{align-content:baseline;flex-basis:0;flex-wrap:wrap}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row .ck.ck-toolbar .ck-toolbar__items{flex-wrap:nowrap}.ck.ck-table-properties-form{width:320px}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row{align-self:flex-end;padding:0}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row .ck.ck-toolbar{background:none;margin-top:var(--ck-spacing-standard)}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row .ck.ck-toolbar .ck-toolbar__items>*{width:40px}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-table/theme/tableproperties.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-table/tableproperties.css',
            ],
            names: [],
            mappings:
              'AAOE,mFAGC,sBAAuB,CADvB,YAAa,CADb,cAOD,CAHC,qHACC,gBACD,CCTH,6BACC,WAmBD,CAhBE,mFACC,mBAAoB,CACpB,SAYD,CAVC,kGACC,eAAgB,CAGhB,qCAKD,CAHC,uHACC,UACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-table-properties-form {\n\t& .ck-form__row {\n\t\t&.ck-table-properties-form__alignment-row {\n\t\t\tflex-wrap: wrap;\n\t\t\tflex-basis: 0;\n\t\t\talign-content: baseline;\n\n\t\t\t& .ck.ck-toolbar .ck-toolbar__items {\n\t\t\t\tflex-wrap: nowrap;\n\t\t\t}\n\t\t}\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-table-properties-form {\n\twidth: 320px;\n\n\t& .ck-form__row {\n\t\t&.ck-table-properties-form__alignment-row {\n\t\t\talign-self: flex-end;\n\t\t\tpadding: 0;\n\n\t\t\t& .ck.ck-toolbar {\n\t\t\t\tbackground: none;\n\n\t\t\t\t/* Compensate for missing input label that would push the margin (toolbar has no inputs). */\n\t\t\t\tmargin-top: var(--ck-spacing-standard);\n\n\t\t\t\t& .ck-toolbar__items > * {\n\t\t\t\t\twidth: 40px;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      1546: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          ':root{--ck-table-selected-cell-background:rgba(158,207,250,.3)}.ck.ck-editor__editable .table table td.ck-editor__editable_selected,.ck.ck-editor__editable .table table th.ck-editor__editable_selected{box-shadow:unset;caret-color:transparent;outline:unset;position:relative}.ck.ck-editor__editable .table table td.ck-editor__editable_selected:after,.ck.ck-editor__editable .table table th.ck-editor__editable_selected:after{background-color:var(--ck-table-selected-cell-background);bottom:0;content:"";left:0;pointer-events:none;position:absolute;right:0;top:0}.ck.ck-editor__editable .table table td.ck-editor__editable_selected ::selection,.ck.ck-editor__editable .table table td.ck-editor__editable_selected:focus,.ck.ck-editor__editable .table table th.ck-editor__editable_selected ::selection,.ck.ck-editor__editable .table table th.ck-editor__editable_selected:focus{background-color:transparent}.ck.ck-editor__editable .table table td.ck-editor__editable_selected .ck-widget,.ck.ck-editor__editable .table table th.ck-editor__editable_selected .ck-widget{outline:unset}.ck.ck-editor__editable .table table td.ck-editor__editable_selected .ck-widget>.ck-widget__selection-handle,.ck.ck-editor__editable .table table th.ck-editor__editable_selected .ck-widget>.ck-widget__selection-handle{display:none}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-table/tableselection.css',
            ],
            names: [],
            mappings:
              'AAKA,MACC,wDACD,CAGC,0IAKC,gBAAiB,CAFjB,uBAAwB,CACxB,aAAc,CAFd,iBAiCD,CA3BC,sJAGC,yDAA0D,CAK1D,QAAS,CAPT,UAAW,CAKX,MAAO,CAJP,mBAAoB,CAEpB,iBAAkB,CAGlB,OAAQ,CAFR,KAID,CAEA,wTAEC,4BACD,CAMA,gKACC,aAKD,CAHC,0NACC,YACD',
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-table-selected-cell-background: hsla(208, 90%, 80%, .3);\n}\n\n.ck.ck-editor__editable .table table {\n\t& td.ck-editor__editable_selected,\n\t& th.ck-editor__editable_selected {\n\t\tposition: relative;\n\t\tcaret-color: transparent;\n\t\toutline: unset;\n\t\tbox-shadow: unset;\n\n\t\t/* https://github.com/ckeditor/ckeditor5/issues/6446 */\n\t\t&:after {\n\t\t\tcontent: '';\n\t\t\tpointer-events: none;\n\t\t\tbackground-color: var(--ck-table-selected-cell-background);\n\t\t\tposition: absolute;\n\t\t\ttop: 0;\n\t\t\tleft: 0;\n\t\t\tright: 0;\n\t\t\tbottom: 0;\n\t\t}\n\n\t\t& ::selection,\n\t\t&:focus {\n\t\t\tbackground-color: transparent;\n\t\t}\n\n\t\t/*\n\t\t * To reduce the amount of noise, all widgets in the table selection have no outline and no selection handle.\n\t\t * See https://github.com/ckeditor/ckeditor5/issues/9491.\n\t\t */\n\t\t& .ck-widget {\n\t\t\toutline: unset;\n\n\t\t\t& > .ck-widget__selection-handle {\n\t\t\t\tdisplay: none;\n\t\t\t}\n\t\t}\n\t}\n}\n",
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      4971: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          '.ck.ck-button,a.ck.ck-button{align-items:center;display:inline-flex;justify-content:left;position:relative;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-button .ck-button__label,a.ck.ck-button .ck-button__label{display:none}.ck.ck-button.ck-button_with-text .ck-button__label,a.ck.ck-button.ck-button_with-text .ck-button__label{display:inline-block}.ck.ck-button:not(.ck-button_with-text),a.ck.ck-button:not(.ck-button_with-text){justify-content:center}.ck.ck-button,a.ck.ck-button{background:var(--ck-color-button-default-background)}.ck.ck-button:not(.ck-disabled):hover,a.ck.ck-button:not(.ck-disabled):hover{background:var(--ck-color-button-default-hover-background)}.ck.ck-button:not(.ck-disabled):active,a.ck.ck-button:not(.ck-disabled):active{background:var(--ck-color-button-default-active-background)}.ck.ck-button.ck-disabled,a.ck.ck-button.ck-disabled{background:var(--ck-color-button-default-disabled-background)}.ck.ck-button,a.ck.ck-button{border-radius:0}.ck-rounded-corners .ck.ck-button,.ck-rounded-corners a.ck.ck-button,.ck.ck-button.ck-rounded-corners,a.ck.ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-button,a.ck.ck-button{-webkit-appearance:none;border:1px solid transparent;cursor:default;font-size:inherit;line-height:1;min-height:var(--ck-ui-component-min-height);min-width:var(--ck-ui-component-min-height);padding:var(--ck-spacing-tiny);text-align:center;transition:box-shadow .2s ease-in-out,border .2s ease-in-out;vertical-align:middle;white-space:nowrap}.ck.ck-button:active,.ck.ck-button:focus,a.ck.ck-button:active,a.ck.ck-button:focus{border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),0 0;outline:none}.ck.ck-button .ck-button__icon use,.ck.ck-button .ck-button__icon use *,a.ck.ck-button .ck-button__icon use,a.ck.ck-button .ck-button__icon use *{color:inherit}.ck.ck-button .ck-button__label,a.ck.ck-button .ck-button__label{color:inherit;cursor:inherit;font-size:inherit;font-weight:inherit;vertical-align:middle}[dir=ltr] .ck.ck-button .ck-button__label,[dir=ltr] a.ck.ck-button .ck-button__label{text-align:left}[dir=rtl] .ck.ck-button .ck-button__label,[dir=rtl] a.ck.ck-button .ck-button__label{text-align:right}.ck.ck-button .ck-button__keystroke,a.ck.ck-button .ck-button__keystroke{color:inherit}[dir=ltr] .ck.ck-button .ck-button__keystroke,[dir=ltr] a.ck.ck-button .ck-button__keystroke{margin-left:var(--ck-spacing-large)}[dir=rtl] .ck.ck-button .ck-button__keystroke,[dir=rtl] a.ck.ck-button .ck-button__keystroke{margin-right:var(--ck-spacing-large)}.ck.ck-button .ck-button__keystroke,a.ck.ck-button .ck-button__keystroke{font-weight:700;opacity:.7}.ck.ck-button.ck-disabled:active,.ck.ck-button.ck-disabled:focus,a.ck.ck-button.ck-disabled:active,a.ck.ck-button.ck-disabled:focus{box-shadow:var(--ck-focus-disabled-outer-shadow),0 0}.ck.ck-button.ck-disabled .ck-button__icon,.ck.ck-button.ck-disabled .ck-button__label,a.ck.ck-button.ck-disabled .ck-button__icon,a.ck.ck-button.ck-disabled .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-disabled .ck-button__keystroke,a.ck.ck-button.ck-disabled .ck-button__keystroke{opacity:.3}.ck.ck-button.ck-button_with-text,a.ck.ck-button.ck-button_with-text{padding:var(--ck-spacing-tiny) var(--ck-spacing-standard)}[dir=ltr] .ck.ck-button.ck-button_with-text .ck-button__icon,[dir=ltr] a.ck.ck-button.ck-button_with-text .ck-button__icon{margin-left:calc(var(--ck-spacing-small)*-1);margin-right:var(--ck-spacing-small)}[dir=rtl] .ck.ck-button.ck-button_with-text .ck-button__icon,[dir=rtl] a.ck.ck-button.ck-button_with-text .ck-button__icon{margin-left:var(--ck-spacing-small);margin-right:calc(var(--ck-spacing-small)*-1)}.ck.ck-button.ck-button_with-keystroke .ck-button__label,a.ck.ck-button.ck-button_with-keystroke .ck-button__label{flex-grow:1}.ck.ck-button.ck-on,a.ck.ck-button.ck-on{background:var(--ck-color-button-on-background)}.ck.ck-button.ck-on:not(.ck-disabled):hover,a.ck.ck-button.ck-on:not(.ck-disabled):hover{background:var(--ck-color-button-on-hover-background)}.ck.ck-button.ck-on:not(.ck-disabled):active,a.ck.ck-button.ck-on:not(.ck-disabled):active{background:var(--ck-color-button-on-active-background)}.ck.ck-button.ck-on.ck-disabled,a.ck.ck-button.ck-on.ck-disabled{background:var(--ck-color-button-on-disabled-background)}.ck.ck-button.ck-on,a.ck.ck-button.ck-on{color:var(--ck-color-button-on-color)}.ck.ck-button.ck-button-save,a.ck.ck-button.ck-button-save{color:var(--ck-color-button-save)}.ck.ck-button.ck-button-cancel,a.ck.ck-button.ck-button-cancel{color:var(--ck-color-button-cancel)}.ck.ck-button-action,a.ck.ck-button-action{background:var(--ck-color-button-action-background)}.ck.ck-button-action:not(.ck-disabled):hover,a.ck.ck-button-action:not(.ck-disabled):hover{background:var(--ck-color-button-action-hover-background)}.ck.ck-button-action:not(.ck-disabled):active,a.ck.ck-button-action:not(.ck-disabled):active{background:var(--ck-color-button-action-active-background)}.ck.ck-button-action.ck-disabled,a.ck.ck-button-action.ck-disabled{background:var(--ck-color-button-action-disabled-background)}.ck.ck-button-action,a.ck.ck-button-action{color:var(--ck-color-button-action-text)}.ck.ck-button-bold,a.ck.ck-button-bold{font-weight:700}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/button/button.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/button/button.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/mixins/_button.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_disabled.css',
            ],
            names: [],
            mappings:
              'AAOA,6BAMC,kBAAmB,CADnB,mBAAoB,CAEpB,oBAAqB,CAHrB,iBAAkB,CCFlB,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBDkBD,CAdC,iEACC,YACD,CAGC,yGACC,oBACD,CAID,iFACC,sBACD,CEjBD,6BCAC,oDD4ID,CCzIE,6EACC,0DACD,CAEA,+EACC,2DACD,CAID,qDACC,6DACD,CDfD,6BEDC,eF6ID,CA5IA,wIEGE,qCFyIF,CA5IA,6BA6BC,uBAAwB,CANxB,4BAA6B,CAjB7B,cAAe,CAcf,iBAAkB,CAHlB,aAAc,CAJd,4CAA6C,CAD7C,2CAA4C,CAJ5C,8BAA+B,CAC/B,iBAAkB,CAiBlB,4DAA8D,CAnB9D,qBAAsB,CAFtB,kBAuID,CA7GC,oFGhCA,2BAA2B,CCF3B,2CAA8B,CDC9B,YHqCA,CAIC,kJAEC,aACD,CAGD,iEAIC,aAAc,CACd,cAAe,CAHf,iBAAkB,CAClB,mBAAoB,CAMpB,qBASD,CAlBA,qFAYE,eAMF,CAlBA,qFAgBE,gBAEF,CAEA,yEACC,aAYD,CAbA,6FAIE,mCASF,CAbA,6FAQE,oCAKF,CAbA,yEAWC,eAAiB,CACjB,UACD,CAIC,oIIrFD,oDJyFC,CAOA,gLKhGD,kCLkGC,CAEA,iGACC,UACD,CAGD,qEACC,yDAcD,CAXC,2HAEE,4CAA+C,CAC/C,oCAOF,CAVA,2HAQE,mCAAoC,CADpC,6CAGF,CAKA,mHACC,WACD,CAID,yCC/HA,+CDmIA,CChIC,yFACC,qDACD,CAEA,2FACC,sDACD,CAID,iEACC,wDACD,CDgHA,yCAGC,qCACD,CAEA,2DACC,iCACD,CAEA,+DACC,mCACD,CAID,2CC/IC,mDDoJD,CCjJE,2FACC,yDACD,CAEA,6FACC,0DACD,CAID,mEACC,4DACD,CDgID,2CAIC,wCACD,CAEA,uCAEC,eACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../mixins/_unselectable.css";\n\n.ck.ck-button,\na.ck.ck-button {\n\t@mixin ck-unselectable;\n\n\tposition: relative;\n\tdisplay: inline-flex;\n\talign-items: center;\n\tjustify-content: left;\n\n\t& .ck-button__label {\n\t\tdisplay: none;\n\t}\n\n\t&.ck-button_with-text {\n\t\t& .ck-button__label {\n\t\t\tdisplay: inline-block;\n\t\t}\n\t}\n\n\t/* Center the icon horizontally in a button without text. */\n\t&:not(.ck-button_with-text)  {\n\t\tjustify-content: center;\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Makes element unselectable.\n */\n@define-mixin ck-unselectable {\n\t-moz-user-select: none;\n\t-webkit-user-select: none;\n\t-ms-user-select: none;\n\tuser-select: none\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_focus.css";\n@import "../../../mixins/_shadow.css";\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_rounded.css";\n@import "../../mixins/_button.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck.ck-button,\na.ck.ck-button {\n\t@mixin ck-button-colors --ck-color-button-default;\n\t@mixin ck-rounded-corners;\n\n\twhite-space: nowrap;\n\tcursor: default;\n\tvertical-align: middle;\n\tpadding: var(--ck-spacing-tiny);\n\ttext-align: center;\n\n\t/* A very important piece of styling. Go to variable declaration to learn more. */\n\tmin-width: var(--ck-ui-component-min-height);\n\tmin-height: var(--ck-ui-component-min-height);\n\n\t/* Normalize the height of the line. Removing this will break consistent height\n\tamong text and text-less buttons (with icons). */\n\tline-height: 1;\n\n\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\tfont-size: inherit;\n\n\t/* Avoid flickering when the foucs border shows up. */\n\tborder: 1px solid transparent;\n\n\t/* Apply some smooth transition to the box-shadow and border. */\n\ttransition: box-shadow .2s ease-in-out, border .2s ease-in-out;\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/189 */\n\t-webkit-appearance: none;\n\n\t&:active,\n\t&:focus {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-focus-outer-shadow);\n\t}\n\n\t/* Allow icon coloring using the text "color" property. */\n\t& .ck-button__icon {\n\t\t& use,\n\t\t& use * {\n\t\t\tcolor: inherit;\n\t\t}\n\t}\n\n\t& .ck-button__label {\n\t\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\t\tfont-size: inherit;\n\t\tfont-weight: inherit;\n\t\tcolor: inherit;\n\t\tcursor: inherit;\n\n\t\t/* Must be consistent with .ck-icon\'s vertical align. Otherwise, buttons with and\n\t\twithout labels (but with icons) have different sizes in Chrome */\n\t\tvertical-align: middle;\n\n\t\t@mixin ck-dir ltr {\n\t\t\ttext-align: left;\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\ttext-align: right;\n\t\t}\n\t}\n\n\t& .ck-button__keystroke {\n\t\tcolor: inherit;\n\n\t\t@mixin ck-dir ltr {\n\t\t\tmargin-left: var(--ck-spacing-large);\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\tmargin-right: var(--ck-spacing-large);\n\t\t}\n\n\t\tfont-weight: bold;\n\t\topacity: .7;\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/70 */\n\t&.ck-disabled {\n\t\t&:active,\n\t\t&:focus {\n\t\t\t/* The disabled button should have a slightly less visible shadow when focused. */\n\t\t\t@mixin ck-box-shadow var(--ck-focus-disabled-outer-shadow);\n\t\t}\n\n\t\t& .ck-button__icon {\n\t\t\t@mixin ck-disabled;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/98 */\n\t\t& .ck-button__label {\n\t\t\t@mixin ck-disabled;\n\t\t}\n\n\t\t& .ck-button__keystroke {\n\t\t\topacity: .3;\n\t\t}\n\t}\n\n\t&.ck-button_with-text {\n\t\tpadding: var(--ck-spacing-tiny) var(--ck-spacing-standard);\n\n\t\t/* stylelint-disable-next-line no-descending-specificity */\n\t\t& .ck-button__icon {\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tmargin-left: calc(-1 * var(--ck-spacing-small));\n\t\t\t\tmargin-right: var(--ck-spacing-small);\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tmargin-right: calc(-1 * var(--ck-spacing-small));\n\t\t\t\tmargin-left: var(--ck-spacing-small);\n\t\t\t}\n\t\t}\n\t}\n\n\t&.ck-button_with-keystroke {\n\t\t/* stylelint-disable-next-line no-descending-specificity */\n\t\t& .ck-button__label {\n\t\t\tflex-grow: 1;\n\t\t}\n\t}\n\n\t/* A style of the button which is currently on, e.g. its feature is active. */\n\t&.ck-on {\n\t\t@mixin ck-button-colors --ck-color-button-on;\n\n\t\tcolor: var(--ck-color-button-on-color);\n\t}\n\n\t&.ck-button-save {\n\t\tcolor: var(--ck-color-button-save);\n\t}\n\n\t&.ck-button-cancel {\n\t\tcolor: var(--ck-color-button-cancel);\n\t}\n}\n\n/* A style of the button which handles the primary action. */\n.ck.ck-button-action,\na.ck.ck-button-action {\n\t@mixin ck-button-colors --ck-color-button-action;\n\n\tcolor: var(--ck-color-button-action-text);\n}\n\n.ck.ck-button-bold,\na.ck.ck-button-bold {\n\tfont-weight: bold;\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements a button of given background color.\n *\n * @param {String} $background - Background color of the button.\n * @param {String} $border - Border color of the button.\n */\n@define-mixin ck-button-colors $prefix {\n\tbackground: var($(prefix)-background);\n\n\t&:not(.ck-disabled) {\n\t\t&:hover {\n\t\t\tbackground: var($(prefix)-hover-background);\n\t\t}\n\n\t\t&:active {\n\t\t\tbackground: var($(prefix)-active-background);\n\t\t}\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/98 */\n\t&.ck-disabled {\n\t\tbackground: var($(prefix)-disabled-background);\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n',
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n",
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which indicates that an element holding it is disabled.\n */\n@define-mixin ck-disabled {\n\topacity: var(--ck-disabled-opacity);\n}\n',
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      7258: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          '.ck.ck-button.ck-switchbutton .ck-button__toggle,.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{display:block}:root{--ck-switch-button-toggle-width:2.6153846154em;--ck-switch-button-toggle-inner-size:calc(1.07692em + 1px);--ck-switch-button-translation:calc(var(--ck-switch-button-toggle-width) - var(--ck-switch-button-toggle-inner-size) - 2px);--ck-switch-button-inner-hover-shadow:0 0 0 5px var(--ck-color-switch-button-inner-shadow)}.ck.ck-button.ck-switchbutton,.ck.ck-button.ck-switchbutton.ck-on:active,.ck.ck-button.ck-switchbutton.ck-on:focus,.ck.ck-button.ck-switchbutton.ck-on:hover,.ck.ck-button.ck-switchbutton:active,.ck.ck-button.ck-switchbutton:focus,.ck.ck-button.ck-switchbutton:hover{background:transparent;color:inherit}[dir=ltr] .ck.ck-button.ck-switchbutton .ck-button__label{margin-right:calc(var(--ck-spacing-large)*2)}[dir=rtl] .ck.ck-button.ck-switchbutton .ck-button__label{margin-left:calc(var(--ck-spacing-large)*2)}.ck.ck-button.ck-switchbutton .ck-button__toggle{border-radius:0}.ck-rounded-corners .ck.ck-button.ck-switchbutton .ck-button__toggle,.ck.ck-button.ck-switchbutton .ck-button__toggle.ck-rounded-corners{border-radius:var(--ck-border-radius)}[dir=ltr] .ck.ck-button.ck-switchbutton .ck-button__toggle{margin-left:auto}[dir=rtl] .ck.ck-button.ck-switchbutton .ck-button__toggle{margin-right:auto}.ck.ck-button.ck-switchbutton .ck-button__toggle{background:var(--ck-color-switch-button-off-background);border:1px solid transparent;transition:background .4s ease,box-shadow .2s ease-in-out,outline .2s ease-in-out;width:var(--ck-switch-button-toggle-width)}.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{border-radius:0}.ck-rounded-corners .ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner,.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner.ck-rounded-corners{border-radius:var(--ck-border-radius);border-radius:calc(var(--ck-border-radius)*.5)}.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{background:var(--ck-color-switch-button-inner-background);height:var(--ck-switch-button-toggle-inner-size);transition:all .3s ease;width:var(--ck-switch-button-toggle-inner-size)}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover{background:var(--ck-color-switch-button-off-hover-background)}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover .ck-button__toggle__inner{box-shadow:var(--ck-switch-button-inner-hover-shadow)}.ck.ck-button.ck-switchbutton.ck-disabled .ck-button__toggle{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-switchbutton:focus{border-color:transparent;box-shadow:none;outline:none}.ck.ck-button.ck-switchbutton:focus .ck-button__toggle{box-shadow:0 0 0 1px var(--ck-color-base-background),0 0 0 5px var(--ck-color-focus-outer-shadow);outline:var(--ck-focus-ring);outline-offset:1px}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle{background:var(--ck-color-switch-button-on-background)}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle:hover{background:var(--ck-color-switch-button-on-hover-background)}[dir=ltr] .ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner{transform:translateX(var( --ck-switch-button-translation ))}[dir=rtl] .ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner{transform:translateX(calc(var( --ck-switch-button-translation )*-1))}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/button/switchbutton.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/button/switchbutton.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_disabled.css',
            ],
            names: [],
            mappings:
              'AASE,4HACC,aACD,CCCF,MAEC,8CAA+C,CAE/C,0DAAgE,CAChE,2HAIC,CACD,0FACD,CAOC,0QAEC,sBAAuB,CADvB,aAED,CAEA,0DAGE,4CAOF,CAVA,0DAQE,2CAEF,CAEA,iDCpCA,eD4EA,CAxCA,yIChCC,qCDwED,CAxCA,2DAKE,gBAmCF,CAxCA,2DAUE,iBA8BF,CAxCA,iDAkBC,uDAAwD,CAFxD,4BAA6B,CAD7B,iFAAsF,CAEtF,0CAuBD,CApBC,2ECxDD,eDmEC,CAXA,6LCpDA,qCAAsC,CDsDpC,8CASF,CAXA,2EAOC,yDAA0D,CAD1D,gDAAiD,CAIjD,uBAA0B,CAL1B,+CAMD,CAEA,uDACC,6DAKD,CAHC,iFACC,qDACD,CAIF,6DEhFA,kCFkFA,CAGA,oCACC,wBAAyB,CAEzB,eAAgB,CADhB,YAQD,CALC,uDACC,iGAAmG,CAEnG,4BAA6B,CAD7B,kBAED,CAKA,uDACC,sDAkBD,CAhBC,6DACC,4DACD,CAEA,2FAKE,2DAMF,CAXA,2FASE,oEAEF',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-button.ck-switchbutton {\n\t& .ck-button__toggle {\n\t\tdisplay: block;\n\n\t\t& .ck-button__toggle__inner {\n\t\t\tdisplay: block;\n\t\t}\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_disabled.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n/* Note: To avoid rendering issues (aliasing) but to preserve the responsive nature\nof the component, floating–point numbers have been used which, for the default font size\n(see: --ck-font-size-base), will generate simple integers. */\n:root {\n\t/* 34px at 13px font-size */\n\t--ck-switch-button-toggle-width: 2.6153846154em;\n\t/* 14px at 13px font-size */\n\t--ck-switch-button-toggle-inner-size: calc(1.0769230769em + 1px);\n\t--ck-switch-button-translation: calc(\n\t\tvar(--ck-switch-button-toggle-width) -\n\t\tvar(--ck-switch-button-toggle-inner-size) -\n\t\t2px /* Border */\n\t);\n\t--ck-switch-button-inner-hover-shadow: 0 0 0 5px var(--ck-color-switch-button-inner-shadow);\n}\n\n.ck.ck-button.ck-switchbutton {\n\t/* Unlike a regular button, the switch button text color and background should never change.\n\t * Changing toggle switch (background, outline) is enough to carry the information about the\n\t * state of the entire component (https://github.com/ckeditor/ckeditor5/issues/12519)\n\t */\n\t&, &:hover, &:focus, &:active, &.ck-on:hover, &.ck-on:focus, &.ck-on:active {\n\t\tcolor: inherit;\n\t\tbackground: transparent;\n\t}\n\n\t& .ck-button__label {\n\t\t@mixin ck-dir ltr {\n\t\t\t/* Separate the label from the switch */\n\t\t\tmargin-right: calc(2 * var(--ck-spacing-large));\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\t/* Separate the label from the switch */\n\t\t\tmargin-left: calc(2 * var(--ck-spacing-large));\n\t\t}\n\t}\n\n\t& .ck-button__toggle {\n\t\t@mixin ck-rounded-corners;\n\n\t\t@mixin ck-dir ltr {\n\t\t\t/* Make sure the toggle is always to the right as far as possible. */\n\t\t\tmargin-left: auto;\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\t/* Make sure the toggle is always to the left as far as possible. */\n\t\t\tmargin-right: auto;\n\t\t}\n\n\t\t/* Apply some smooth transition to the box-shadow and border. */\n\t\t/* Gently animate the background color of the toggle switch */\n\t\ttransition: background 400ms ease, box-shadow .2s ease-in-out, outline .2s ease-in-out;\n\t\tborder: 1px solid transparent;\n\t\twidth: var(--ck-switch-button-toggle-width);\n\t\tbackground: var(--ck-color-switch-button-off-background);\n\n\t\t& .ck-button__toggle__inner {\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-radius: calc(.5 * var(--ck-border-radius));\n\t\t\t}\n\n\t\t\twidth: var(--ck-switch-button-toggle-inner-size);\n\t\t\theight: var(--ck-switch-button-toggle-inner-size);\n\t\t\tbackground: var(--ck-color-switch-button-inner-background);\n\n\t\t\t/* Gently animate the inner part of the toggle switch */\n\t\t\ttransition: all 300ms ease;\n\t\t}\n\n\t\t&:hover {\n\t\t\tbackground: var(--ck-color-switch-button-off-hover-background);\n\n\t\t\t& .ck-button__toggle__inner {\n\t\t\t\tbox-shadow: var(--ck-switch-button-inner-hover-shadow);\n\t\t\t}\n\t\t}\n\t}\n\n\t&.ck-disabled .ck-button__toggle {\n\t\t@mixin ck-disabled;\n\t}\n\n\t/* Overriding default .ck-button:focus styles + an outline around the toogle */\n\t&:focus {\n\t\tborder-color: transparent;\n\t\toutline: none;\n\t\tbox-shadow: none;\n\n\t\t& .ck-button__toggle {\n\t\t\tbox-shadow: 0 0 0 1px var(--ck-color-base-background), 0 0 0 5px var(--ck-color-focus-outer-shadow);\n\t\t\toutline-offset: 1px;\n\t\t\toutline: var(--ck-focus-ring);\n\t\t}\n\t}\n\n\t/* stylelint-disable-next-line no-descending-specificity */\n\t&.ck-on {\n\t\t& .ck-button__toggle {\n\t\t\tbackground: var(--ck-color-switch-button-on-background);\n\n\t\t\t&:hover {\n\t\t\t\tbackground: var(--ck-color-switch-button-on-hover-background);\n\t\t\t}\n\n\t\t\t& .ck-button__toggle__inner {\n\t\t\t\t/*\n\t\t\t\t* Move the toggle switch to the right. It will be animated.\n\t\t\t\t*/\n\t\t\t\t@mixin ck-dir ltr {\n\t\t\t\t\ttransform: translateX( var( --ck-switch-button-translation ) );\n\t\t\t\t}\n\n\t\t\t\t@mixin ck-dir rtl {\n\t\t\t\t\ttransform: translateX( calc( -1 * var( --ck-switch-button-translation ) ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which indicates that an element holding it is disabled.\n */\n@define-mixin ck-disabled {\n\topacity: var(--ck-disabled-opacity);\n}\n',
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      4923: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          '.ck.ck-color-grid{display:grid}:root{--ck-color-grid-tile-size:24px;--ck-color-color-grid-check-icon:#166fd4}.ck.ck-color-grid{grid-gap:5px;padding:8px}.ck.ck-color-grid__tile{border:0;height:var(--ck-color-grid-tile-size);min-height:var(--ck-color-grid-tile-size);min-width:var(--ck-color-grid-tile-size);padding:0;transition:box-shadow .2s ease;width:var(--ck-color-grid-tile-size)}.ck.ck-color-grid__tile.ck-disabled{cursor:unset;transition:unset}.ck.ck-color-grid__tile.ck-color-selector__color-tile_bordered{box-shadow:0 0 0 1px var(--ck-color-base-border)}.ck.ck-color-grid__tile .ck.ck-icon{color:var(--ck-color-color-grid-check-icon);display:none}.ck.ck-color-grid__tile.ck-on{box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-base-text)}.ck.ck-color-grid__tile.ck-on .ck.ck-icon{display:block}.ck.ck-color-grid__tile.ck-on,.ck.ck-color-grid__tile:focus:not(.ck-disabled),.ck.ck-color-grid__tile:hover:not(.ck-disabled){border:0}.ck.ck-color-grid__tile:focus:not(.ck-disabled),.ck.ck-color-grid__tile:hover:not(.ck-disabled){box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-focus-border)}.ck.ck-color-grid__label{padding:0 var(--ck-spacing-standard)}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/colorgrid/colorgrid.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/colorgrid/colorgrid.css',
            ],
            names: [],
            mappings:
              'AAKA,kBACC,YACD,CCAA,MACC,8BAA+B,CAK/B,wCACD,CAEA,kBACC,YAAa,CACb,WACD,CAEA,wBAOC,QAAS,CALT,qCAAsC,CAEtC,yCAA0C,CAD1C,wCAAyC,CAEzC,SAAU,CACV,8BAA+B,CAL/B,oCAyCD,CAjCC,oCACC,YAAa,CACb,gBACD,CAEA,+DACC,gDACD,CAEA,oCAEC,2CAA4C,CAD5C,YAED,CAEA,8BACC,8FAKD,CAHC,0CACC,aACD,CAGD,8HAIC,QACD,CAEA,gGAEC,iGACD,CAGD,yBACC,oCACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-color-grid {\n\tdisplay: grid;\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n:root {\n\t--ck-color-grid-tile-size: 24px;\n\n\t/* Not using global colors here because these may change but some colors in a pallette\n\t * require special treatment. For instance, this ensures no matter what the UI text color is,\n\t * the check icon will look good on the black color tile. */\n\t--ck-color-color-grid-check-icon: hsl(212, 81%, 46%);\n}\n\n.ck.ck-color-grid {\n\tgrid-gap: 5px;\n\tpadding: 8px;\n}\n\n.ck.ck-color-grid__tile {\n\twidth: var(--ck-color-grid-tile-size);\n\theight: var(--ck-color-grid-tile-size);\n\tmin-width: var(--ck-color-grid-tile-size);\n\tmin-height: var(--ck-color-grid-tile-size);\n\tpadding: 0;\n\ttransition: .2s ease box-shadow;\n\tborder: 0;\n\n\t&.ck-disabled {\n\t\tcursor: unset;\n\t\ttransition: unset;\n\t}\n\n\t&.ck-color-selector__color-tile_bordered {\n\t\tbox-shadow: 0 0 0 1px var(--ck-color-base-border);\n\t}\n\n\t& .ck.ck-icon {\n\t\tdisplay: none;\n\t\tcolor: var(--ck-color-color-grid-check-icon);\n\t}\n\n\t&.ck-on {\n\t\tbox-shadow: inset 0 0 0 1px var(--ck-color-base-background), 0 0 0 2px var(--ck-color-base-text);\n\n\t\t& .ck.ck-icon {\n\t\t\tdisplay: block;\n\t\t}\n\t}\n\n\t&.ck-on,\n\t&:focus:not( .ck-disabled ),\n\t&:hover:not( .ck-disabled ) {\n\t\t/* Disable the default .ck-button\'s border ring. */\n\t\tborder: 0;\n\t}\n\n\t&:focus:not( .ck-disabled ),\n\t&:hover:not( .ck-disabled ) {\n\t\tbox-shadow: inset 0 0 0 1px var(--ck-color-base-background), 0 0 0 2px var(--ck-color-focus-border);\n\t}\n}\n\n.ck.ck-color-grid__label {\n\tpadding: 0 var(--ck-spacing-standard);\n}\n',
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      4257: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          '.color-picker-hex-input{width:max-content}.color-picker-hex-input .ck.ck-input{min-width:unset}.ck.ck-color-picker__row{display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between;margin:var(--ck-spacing-large) 0 0;width:unset}.ck.ck-color-picker__row .ck.ck-labeled-field-view{padding-top:unset}.ck.ck-color-picker__row .ck.ck-input-text{width:unset}.ck.ck-color-picker__row .ck-color-picker__hash-view{padding-right:var(--ck-spacing-medium);padding-top:var(--ck-spacing-tiny)}',
          '',
          {
            version: 3,
            sources: ['webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/colorpicker/colorpicker.css'],
            names: [],
            mappings:
              'AAKA,wBACC,iBAKD,CAHC,qCACC,eACD,CAGD,yBACC,YAAa,CACb,kBAAmB,CACnB,gBAAiB,CACjB,6BAA8B,CAC9B,kCAAmC,CACnC,WAcD,CAZC,mDACC,iBACD,CAEA,2CACC,WACD,CAEA,qDAEC,sCAAuC,CADvC,kCAED',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.color-picker-hex-input {\n\twidth: max-content;\n\n\t& .ck.ck-input {\n\t\tmin-width: unset;\n\t}\n}\n\n.ck.ck-color-picker__row {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\tjustify-content: space-between;\n\tmargin: var(--ck-spacing-large) 0 0;\n\twidth: unset;\n\n\t& .ck.ck-labeled-field-view {\n\t\tpadding-top: unset;\n\t}\n\n\t& .ck.ck-input-text {\n\t\twidth: unset;\n\t}\n\n\t& .ck-color-picker__hash-view {\n\t\tpadding-top: var(--ck-spacing-tiny);\n\t\tpadding-right: var(--ck-spacing-medium);\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      6306: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          '.ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__color-picker,.ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__remove-color{align-items:center;display:flex}[dir=rtl] .ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__color-picker,[dir=rtl] .ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__remove-color{justify-content:flex-start}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-selector_action-bar{display:flex;flex-direction:row;justify-content:space-around}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-selector_action-bar .ck-button-cancel,.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-selector_action-bar .ck-button-save{flex:1}.ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__color-picker,.ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__remove-color{width:100%}.ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__color-picker{border-bottom-left-radius:0;border-bottom-right-radius:0;padding:calc(var(--ck-spacing-standard)/2) var(--ck-spacing-standard)}.ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__color-picker:not(:focus){border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__color-picker .ck.ck-icon{margin-right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__color-picker .ck.ck-icon{margin-left:var(--ck-spacing-standard)}.ck.ck-color-selector .ck-color-grids-fragment label.ck.ck-color-grid__label{font-weight:unset}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-picker{padding:8px}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-picker .hex-color-picker{height:100px;min-width:180px}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-picker .hex-color-picker::part(saturation){border-radius:var(--ck-border-radius) var(--ck-border-radius) 0 0}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-picker .hex-color-picker::part(hue){border-radius:0 0 var(--ck-border-radius) var(--ck-border-radius)}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-picker .hex-color-picker::part(hue-pointer),.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-picker .hex-color-picker::part(saturation-pointer){height:15px;width:15px}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-selector_action-bar{padding:0 8px 8px}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/colorselector/colorselector.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/colorselector/colorselector.css',
            ],
            names: [],
            mappings:
              'AAUE,oLAGC,kBAAmB,CADnB,YAMD,CARA,wMAME,0BAEF,CAKA,iFACC,YAAa,CACb,kBAAmB,CACnB,4BAMD,CAJC,oMAEC,MACD,CCrBD,oLAEC,UACD,CAEA,0FAEC,2BAA4B,CAC5B,4BAA6B,CAF7B,qEAiBD,CAbC,sGACC,gDACD,CAEA,gHAEE,uCAMF,CARA,gHAME,sCAEF,CAGD,6EACC,iBACD,CAKA,oEACC,WAoBD,CAlBC,sFACC,YAAa,CACb,eAeD,CAbC,wGACC,iEACD,CAEA,iGACC,iEACD,CAEA,yNAGC,WAAY,CADZ,UAED,CAIF,iFACC,iBACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck.ck-color-selector {\n\t/* View fragment with color grids. */\n\t& .ck-color-grids-fragment {\n\t\t& .ck-button.ck-color-selector__remove-color,\n\t\t& .ck-button.ck-color-selector__color-picker {\n\t\t\tdisplay: flex;\n\t\t\talign-items: center;\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tjustify-content: flex-start;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* View fragment with a color picker. */\n\t& .ck-color-picker-fragment {\n\t\t& .ck.ck-color-selector_action-bar {\n\t\t\tdisplay: flex;\n\t\t\tflex-direction: row;\n\t\t\tjustify-content: space-around;\n\n\t\t\t& .ck-button-save,\n\t\t\t& .ck-button-cancel {\n\t\t\t\tflex: 1\n\t\t\t}\n\t\t}\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck.ck-color-selector {\n\t/* View fragment with color grids. */\n\t& .ck-color-grids-fragment {\n\t\t& .ck-button.ck-color-selector__remove-color,\n\t\t& .ck-button.ck-color-selector__color-picker {\n\t\t\twidth: 100%;\n\t\t}\n\n\t\t& .ck-button.ck-color-selector__color-picker {\n\t\t\tpadding: calc(var(--ck-spacing-standard) / 2) var(--ck-spacing-standard);\n\t\t\tborder-bottom-left-radius: 0;\n\t\t\tborder-bottom-right-radius: 0;\n\n\t\t\t&:not(:focus) {\n\t\t\t\tborder-top: 1px solid var(--ck-color-base-border);\n\t\t\t}\n\n\t\t\t& .ck.ck-icon {\n\t\t\t\t@mixin ck-dir ltr {\n\t\t\t\t\tmargin-right: var(--ck-spacing-standard);\n\t\t\t\t}\n\n\t\t\t\t@mixin ck-dir rtl {\n\t\t\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t& label.ck.ck-color-grid__label {\n\t\t\tfont-weight: unset;\n\t\t}\n\t}\n\n\t/* View fragment with a color picker. */\n\t& .ck-color-picker-fragment {\n\t\t& .ck.ck-color-picker {\n\t\t\tpadding: 8px;\n\n\t\t\t& .hex-color-picker {\n\t\t\t\theight: 100px;\n\t\t\t\tmin-width: 180px;\n\n\t\t\t\t&::part(saturation) {\n\t\t\t\t\tborder-radius: var(--ck-border-radius) var(--ck-border-radius) 0 0;\n\t\t\t\t}\n\n\t\t\t\t&::part(hue) {\n\t\t\t\t\tborder-radius: 0 0 var(--ck-border-radius) var(--ck-border-radius);\n\t\t\t\t}\n\n\t\t\t\t&::part(saturation-pointer),\n\t\t\t\t&::part(hue-pointer) {\n\t\t\t\t\twidth: 15px;\n\t\t\t\t\theight: 15px;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t& .ck.ck-color-selector_action-bar {\n\t\t\tpadding: 0 8px 8px;\n\t\t}\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      5062: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          ':root{--ck-dropdown-max-width:75vw}.ck.ck-dropdown{display:inline-block;position:relative}.ck.ck-dropdown .ck-dropdown__arrow{pointer-events:none;z-index:var(--ck-z-default)}.ck.ck-dropdown .ck-button.ck-dropdown__button{width:100%}.ck.ck-dropdown .ck-dropdown__panel{display:none;max-width:var(--ck-dropdown-max-width);position:absolute;z-index:var(--ck-z-modal)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel-visible{display:inline-block}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_n,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nmw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw{bottom:100%}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_s,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_smw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{bottom:auto;top:100%}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se{left:0}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{right:0}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_n,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_s{left:50%;transform:translateX(-50%)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nmw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_smw{left:75%;transform:translateX(-75%)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sme{left:25%;transform:translateX(-25%)}.ck.ck-toolbar .ck-dropdown__panel{z-index:calc(var(--ck-z-modal) + 1)}:root{--ck-dropdown-arrow-size:calc(var(--ck-icon-size)*0.5)}.ck.ck-dropdown{font-size:inherit}.ck.ck-dropdown .ck-dropdown__arrow{width:var(--ck-dropdown-arrow-size)}[dir=ltr] .ck.ck-dropdown .ck-dropdown__arrow{margin-left:var(--ck-spacing-standard);right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-dropdown .ck-dropdown__arrow{left:var(--ck-spacing-standard);margin-right:var(--ck-spacing-small)}.ck.ck-dropdown.ck-disabled .ck-dropdown__arrow{opacity:var(--ck-disabled-opacity)}[dir=ltr] .ck.ck-dropdown .ck-button.ck-dropdown__button:not(.ck-button_with-text){padding-left:var(--ck-spacing-small)}[dir=rtl] .ck.ck-dropdown .ck-button.ck-dropdown__button:not(.ck-button_with-text){padding-right:var(--ck-spacing-small)}.ck.ck-dropdown .ck-button.ck-dropdown__button .ck-button__label{overflow:hidden;text-overflow:ellipsis;width:7em}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-disabled .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on{border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-dropdown__button_label-width_auto .ck-button__label{width:auto}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-off:active,.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on:active{box-shadow:none}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-off:active:focus,.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on:active:focus{box-shadow:var(--ck-focus-outer-shadow),0 0}.ck.ck-dropdown__panel{border-radius:0}.ck-rounded-corners .ck.ck-dropdown__panel,.ck.ck-dropdown__panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-dropdown__panel{background:var(--ck-color-dropdown-panel-background);border:1px solid var(--ck-color-dropdown-panel-border);bottom:0;box-shadow:var(--ck-drop-shadow),0 0;min-width:100%}.ck.ck-dropdown__panel.ck-dropdown__panel_se{border-top-left-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_sw{border-top-right-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_ne{border-bottom-left-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_nw{border-bottom-right-radius:0}.ck.ck-dropdown__panel:focus{outline:none}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/dropdown.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/dropdown.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_disabled.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css',
            ],
            names: [],
            mappings:
              'AAKA,MACC,4BACD,CAEA,gBACC,oBAAqB,CACrB,iBA2ED,CAzEC,oCACC,mBAAoB,CACpB,2BACD,CAGA,+CACC,UACD,CAEA,oCACC,YAAa,CAEb,sCAAuC,CAEvC,iBAAkB,CAHlB,yBA4DD,CAvDC,+DACC,oBACD,CAEA,mSAKC,WACD,CAEA,mSAUC,WAAY,CADZ,QAED,CAEA,oHAEC,MACD,CAEA,oHAEC,OACD,CAEA,kHAGC,QAAS,CACT,0BACD,CAEA,sHAGC,QAAS,CACT,0BACD,CAEA,sHAGC,QAAS,CACT,0BACD,CAQF,mCACC,mCACD,CCpFA,MACC,sDACD,CAEA,gBAEC,iBA2ED,CAzEC,oCACC,mCACD,CAGC,8CAIC,sCAAuC,CAHvC,gCAID,CAIA,8CACC,+BAAgC,CAGhC,oCACD,CAGD,gDC/BA,kCDiCA,CAIE,mFAEC,oCACD,CAIA,mFAEC,qCACD,CAID,iEAEC,eAAgB,CAChB,sBAAuB,CAFvB,SAGD,CAGA,6EC1DD,kCD4DC,CAGA,qDACC,2BAA4B,CAC5B,4BACD,CAEA,sGACC,UACD,CAGA,yHAEC,eAKD,CAHC,qIE7EF,2CF+EE,CAKH,uBGlFC,eHkHD,CAhCA,qFG9EE,qCH8GF,CAhCA,uBAIC,oDAAqD,CACrD,sDAAuD,CACvD,QAAS,CE1FT,oCAA8B,CF6F9B,cAuBD,CAnBC,6CACC,wBACD,CAEA,6CACC,yBACD,CAEA,6CACC,2BACD,CAEA,6CACC,4BACD,CAEA,6BACC,YACD',
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-dropdown-max-width: 75vw;\n}\n\n.ck.ck-dropdown {\n\tdisplay: inline-block;\n\tposition: relative;\n\n\t& .ck-dropdown__arrow {\n\t\tpointer-events: none;\n\t\tz-index: var(--ck-z-default);\n\t}\n\n\t/* Dropdown button should span horizontally, e.g. in vertical toolbars */\n\t& .ck-button.ck-dropdown__button {\n\t\twidth: 100%;\n\t}\n\n\t& .ck-dropdown__panel {\n\t\tdisplay: none;\n\t\tz-index: var(--ck-z-modal);\n\t\tmax-width: var(--ck-dropdown-max-width);\n\n\t\tposition: absolute;\n\n\t\t&.ck-dropdown__panel-visible {\n\t\t\tdisplay: inline-block;\n\t\t}\n\n\t\t&.ck-dropdown__panel_ne,\n\t\t&.ck-dropdown__panel_nw,\n\t\t&.ck-dropdown__panel_n,\n\t\t&.ck-dropdown__panel_nmw,\n\t\t&.ck-dropdown__panel_nme {\n\t\t\tbottom: 100%;\n\t\t}\n\n\t\t&.ck-dropdown__panel_se,\n\t\t&.ck-dropdown__panel_sw,\n\t\t&.ck-dropdown__panel_smw,\n\t\t&.ck-dropdown__panel_sme,\n\t\t&.ck-dropdown__panel_s {\n\t\t\t/*\n\t\t\t * Using transform: translate3d( 0, 100%, 0 ) causes blurry dropdown on Chrome 67-78+ on non-retina displays.\n\t\t\t * See https://github.com/ckeditor/ckeditor5/issues/1053.\n\t\t\t */\n\t\t\ttop: 100%;\n\t\t\tbottom: auto;\n\t\t}\n\n\t\t&.ck-dropdown__panel_ne,\n\t\t&.ck-dropdown__panel_se {\n\t\t\tleft: 0px;\n\t\t}\n\n\t\t&.ck-dropdown__panel_nw,\n\t\t&.ck-dropdown__panel_sw {\n\t\t\tright: 0px;\n\t\t}\n\n\t\t&.ck-dropdown__panel_s,\n\t\t&.ck-dropdown__panel_n {\n\t\t\t/* Positioning panels relative to the center of the button */\n\t\t\tleft: 50%;\n\t\t\ttransform: translateX(-50%);\n\t\t}\n\n\t\t&.ck-dropdown__panel_nmw,\n\t\t&.ck-dropdown__panel_smw {\n\t\t\t/* Positioning panels relative to the middle-west of the button */\n\t\t\tleft: 75%;\n\t\t\ttransform: translateX(-75%);\n\t\t}\n\n\t\t&.ck-dropdown__panel_nme,\n\t\t&.ck-dropdown__panel_sme {\n\t\t\t/* Positioning panels relative to the middle-east of the button */\n\t\t\tleft: 25%;\n\t\t\ttransform: translateX(-25%);\n\t\t}\n\t}\n}\n\n/*\n * Toolbar dropdown panels should be always above the UI (eg. other dropdown panels) from the editor's content.\n * See https://github.com/ckeditor/ckeditor5/issues/7874\n */\n.ck.ck-toolbar .ck-dropdown__panel {\n\tz-index: calc( var(--ck-z-modal) + 1 );\n}\n",
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_shadow.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n:root {\n\t--ck-dropdown-arrow-size: calc(0.5 * var(--ck-icon-size));\n}\n\n.ck.ck-dropdown {\n\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\tfont-size: inherit;\n\n\t& .ck-dropdown__arrow {\n\t\twidth: var(--ck-dropdown-arrow-size);\n\t}\n\n\t@mixin ck-dir ltr {\n\t\t& .ck-dropdown__arrow {\n\t\t\tright: var(--ck-spacing-standard);\n\n\t\t\t/* A space to accommodate the triangle. */\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-dir rtl {\n\t\t& .ck-dropdown__arrow {\n\t\t\tleft: var(--ck-spacing-standard);\n\n\t\t\t/* A space to accommodate the triangle. */\n\t\t\tmargin-right: var(--ck-spacing-small);\n\t\t}\n\t}\n\n\t&.ck-disabled .ck-dropdown__arrow {\n\t\t@mixin ck-disabled;\n\t}\n\n\t& .ck-button.ck-dropdown__button {\n\t\t@mixin ck-dir ltr {\n\t\t\t&:not(.ck-button_with-text) {\n\t\t\t\t/* Make sure dropdowns with just an icon have the right inner spacing */\n\t\t\t\tpadding-left: var(--ck-spacing-small);\n\t\t\t}\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\t&:not(.ck-button_with-text) {\n\t\t\t\t/* Make sure dropdowns with just an icon have the right inner spacing */\n\t\t\t\tpadding-right: var(--ck-spacing-small);\n\t\t\t}\n\t\t}\n\n\t\t/* #23 */\n\t\t& .ck-button__label {\n\t\t\twidth: 7em;\n\t\t\toverflow: hidden;\n\t\t\ttext-overflow: ellipsis;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/70 */\n\t\t&.ck-disabled .ck-button__label {\n\t\t\t@mixin ck-disabled;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5/issues/816 */\n\t\t&.ck-on {\n\t\t\tborder-bottom-left-radius: 0;\n\t\t\tborder-bottom-right-radius: 0;\n\t\t}\n\n\t\t&.ck-dropdown__button_label-width_auto .ck-button__label {\n\t\t\twidth: auto;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5/issues/8699 */\n\t\t&.ck-off:active,\n\t\t&.ck-on:active {\n\t\t\tbox-shadow: none;\n\n\t\t\t&:focus {\n\t\t\t\t@mixin ck-box-shadow var(--ck-focus-outer-shadow);\n\t\t\t}\n\t\t}\n\t}\n}\n\n.ck.ck-dropdown__panel {\n\t@mixin ck-rounded-corners;\n\t@mixin ck-drop-shadow;\n\n\tbackground: var(--ck-color-dropdown-panel-background);\n\tborder: 1px solid var(--ck-color-dropdown-panel-border);\n\tbottom: 0;\n\n\t/* Make sure the panel is at least as wide as the drop-down\'s button. */\n\tmin-width: 100%;\n\n\t/* Disabled corner border radius to be consistent with the .dropdown__button\n\thttps://github.com/ckeditor/ckeditor5/issues/816 */\n\t&.ck-dropdown__panel_se {\n\t\tborder-top-left-radius: 0;\n\t}\n\n\t&.ck-dropdown__panel_sw {\n\t\tborder-top-right-radius: 0;\n\t}\n\n\t&.ck-dropdown__panel_ne {\n\t\tborder-bottom-left-radius: 0;\n\t}\n\n\t&.ck-dropdown__panel_nw {\n\t\tborder-bottom-right-radius: 0;\n\t}\n\n\t&:focus {\n\t\toutline: none;\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which indicates that an element holding it is disabled.\n */\n@define-mixin ck-disabled {\n\topacity: var(--ck-disabled-opacity);\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      1883: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          '.ck.ck-dropdown .ck-dropdown__panel .ck-list{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list,.ck.ck-dropdown .ck-dropdown__panel .ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0}.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button,.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-bottom-left-radius:0;border-bottom-right-radius:0;border-top-left-radius:0}.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button,.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-top-right-radius:0}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/listdropdown.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css',
            ],
            names: [],
            mappings:
              'AAOA,6CCIC,eDqBD,CAzBA,iICQE,qCAAsC,CDJtC,wBAqBF,CAfE,mFCND,eDYC,CANA,6MCFA,qCAAsC,CDKpC,2BAA4B,CAC5B,4BAA6B,CAF7B,wBAIF,CAEA,kFCdD,eDmBC,CALA,2MCVA,qCAAsC,CDYpC,wBAAyB,CACzB,yBAEF',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n.ck.ck-dropdown .ck-dropdown__panel .ck-list {\n\t/* Disabled radius of top-left border to be consistent with .dropdown__button\n\thttps://github.com/ckeditor/ckeditor5/issues/816 */\n\t@mixin ck-rounded-corners {\n\t\tborder-top-left-radius: 0;\n\t}\n\n\t/* Make sure the button belonging to the first/last child of the list goes well with the\n\tborder radius of the entire panel. */\n\t& .ck-list__item {\n\t\t&:first-child .ck-button {\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-top-left-radius: 0;\n\t\t\t\tborder-bottom-left-radius: 0;\n\t\t\t\tborder-bottom-right-radius: 0;\n\t\t\t}\n\t\t}\n\n\t\t&:last-child .ck-button {\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-top-left-radius: 0;\n\t\t\t\tborder-top-right-radius: 0;\n\t\t\t}\n\t\t}\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      4791: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          '.ck.ck-splitbutton{font-size:inherit}.ck.ck-splitbutton .ck-splitbutton__action:focus{z-index:calc(var(--ck-z-default) + 1)}:root{--ck-color-split-button-hover-background:#ebebeb;--ck-color-split-button-hover-border:#b3b3b3}[dir=ltr] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,[dir=ltr] .ck.ck-splitbutton:hover>.ck-splitbutton__action{border-bottom-right-radius:unset;border-top-right-radius:unset}[dir=rtl] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,[dir=rtl] .ck.ck-splitbutton:hover>.ck-splitbutton__action{border-bottom-left-radius:unset;border-top-left-radius:unset}.ck.ck-splitbutton>.ck-splitbutton__arrow{min-width:unset}[dir=ltr] .ck.ck-splitbutton>.ck-splitbutton__arrow{border-bottom-left-radius:unset;border-top-left-radius:unset}[dir=rtl] .ck.ck-splitbutton>.ck-splitbutton__arrow{border-bottom-right-radius:unset;border-top-right-radius:unset}.ck.ck-splitbutton>.ck-splitbutton__arrow svg{width:var(--ck-dropdown-arrow-size)}.ck.ck-splitbutton>.ck-splitbutton__arrow:not(:focus){border-bottom-width:0;border-top-width:0}.ck.ck-splitbutton.ck-splitbutton_open>.ck-button:not(.ck-on):not(.ck-disabled):not(:hover),.ck.ck-splitbutton:hover>.ck-button:not(.ck-on):not(.ck-disabled):not(:hover){background:var(--ck-color-split-button-hover-background)}.ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,.ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{background-color:var(--ck-color-split-button-hover-border);content:"";height:100%;position:absolute;width:1px}.ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:focus:after,.ck.ck-splitbutton:hover>.ck-splitbutton__arrow:focus:after{--ck-color-split-button-hover-border:var(--ck-color-focus-border)}[dir=ltr] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,[dir=ltr] .ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{left:-1px}[dir=rtl] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,[dir=rtl] .ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{right:-1px}.ck.ck-splitbutton.ck-splitbutton_open{border-radius:0}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners>.ck-splitbutton__action{border-bottom-left-radius:0}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners>.ck-splitbutton__arrow{border-bottom-right-radius:0}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/splitbutton.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/splitbutton.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css',
            ],
            names: [],
            mappings:
              'AAKA,mBAEC,iBAKD,CAHC,iDACC,qCACD,CCJD,MACC,gDAAyD,CACzD,4CACD,CAMC,oIAKE,gCAAiC,CADjC,6BASF,CAbA,oIAWE,+BAAgC,CADhC,4BAGF,CAEA,0CAGC,eAiBD,CApBA,oDAQE,+BAAgC,CADhC,4BAaF,CApBA,oDAcE,gCAAiC,CADjC,6BAOF,CAHC,8CACC,mCACD,CAKD,sDAEC,qBAAwB,CADxB,kBAED,CAQC,0KACC,wDACD,CAIA,8JAKC,0DAA2D,CAJ3D,UAAW,CAGX,WAAY,CAFZ,iBAAkB,CAClB,SAGD,CAGA,sIACC,iEACD,CAGC,kLACC,SACD,CAIA,kLACC,UACD,CAMF,uCCzFA,eDmGA,CAVA,qHCrFC,qCD+FD,CARE,qKACC,2BACD,CAEA,mKACC,4BACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-splitbutton {\n\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\tfont-size: inherit;\n\n\t& .ck-splitbutton__action:focus {\n\t\tz-index: calc(var(--ck-z-default) + 1);\n\t}\n}\n\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n:root {\n\t--ck-color-split-button-hover-background: hsl(0, 0%, 92%);\n\t--ck-color-split-button-hover-border: hsl(0, 0%, 70%);\n}\n\n.ck.ck-splitbutton {\n\t/*\n\t * Note: ck-rounded and ck-dir mixins don\'t go together (because they both use @nest).\n\t */\n\t&:hover > .ck-splitbutton__action,\n\t&.ck-splitbutton_open > .ck-splitbutton__action {\n\t\t@nest [dir="ltr"] & {\n\t\t\t/* Don\'t round the action button on the right side */\n\t\t\tborder-top-right-radius: unset;\n\t\t\tborder-bottom-right-radius: unset;\n\t\t}\n\n\t\t@nest [dir="rtl"] & {\n\t\t\t/* Don\'t round the action button on the left side */\n\t\t\tborder-top-left-radius: unset;\n\t\t\tborder-bottom-left-radius: unset;\n\t\t}\n\t}\n\n\t& > .ck-splitbutton__arrow {\n\t\t/* It\'s a text-less button and since the icon is positioned absolutely in such situation,\n\t\tit must get some arbitrary min-width. */\n\t\tmin-width: unset;\n\n\t\t@nest [dir="ltr"] & {\n\t\t\t/* Don\'t round the arrow button on the left side */\n\t\t\tborder-top-left-radius: unset;\n\t\t\tborder-bottom-left-radius: unset;\n\t\t}\n\n\t\t@nest [dir="rtl"] & {\n\t\t\t/* Don\'t round the arrow button on the right side */\n\t\t\tborder-top-right-radius: unset;\n\t\t\tborder-bottom-right-radius: unset;\n\t\t}\n\n\t\t& svg {\n\t\t\twidth: var(--ck-dropdown-arrow-size);\n\t\t}\n\t}\n\n\t/* Make sure the divider stretches 100% height of the button\n\thttps://github.com/ckeditor/ckeditor5/issues/10936 */\n\t& > .ck-splitbutton__arrow:not(:focus) {\n\t\tborder-top-width: 0px;\n\t\tborder-bottom-width: 0px;\n\t}\n\n\t/* When the split button is "open" (the arrow is on) or being hovered, it should get some styling\n\tas a whole. The background of both buttons should stand out and there should be a visual\n\tseparation between both buttons. */\n\t&.ck-splitbutton_open,\n\t&:hover {\n\t\t/* When the split button hovered as a whole, not as individual buttons. */\n\t\t& > .ck-button:not(.ck-on):not(.ck-disabled):not(:hover) {\n\t\t\tbackground: var(--ck-color-split-button-hover-background);\n\t\t}\n\n\t\t/* Splitbutton separator needs to be set with the ::after pseudoselector\n\t\tto display properly the borders on focus */\n\t\t& > .ck-splitbutton__arrow:not(.ck-disabled)::after {\n\t\t\tcontent: \'\';\n\t\t\tposition: absolute;\n\t\t\twidth: 1px;\n\t\t\theight: 100%;\n\t\t\tbackground-color: var(--ck-color-split-button-hover-border);\n\t\t}\n\n\t\t/* Make sure the divider between the buttons looks fine when the button is focused */\n\t\t& > .ck-splitbutton__arrow:focus::after {\n\t\t\t--ck-color-split-button-hover-border: var(--ck-color-focus-border);\n\t\t}\n\n\t\t@nest [dir="ltr"] & {\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled)::after {\n\t\t\t\tleft: -1px;\n\t\t\t}\n\t\t}\n\n\t\t@nest [dir="rtl"] & {\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled)::after {\n\t\t\t\tright: -1px;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Don\'t round the bottom left and right corners of the buttons when "open"\n\thttps://github.com/ckeditor/ckeditor5/issues/816 */\n\t&.ck-splitbutton_open {\n\t\t@mixin ck-rounded-corners {\n\t\t\t& > .ck-splitbutton__action {\n\t\t\t\tborder-bottom-left-radius: 0;\n\t\t\t}\n\n\t\t\t& > .ck-splitbutton__arrow {\n\t\t\t\tborder-bottom-right-radius: 0;\n\t\t\t}\n\t\t}\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      2704: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          ':root{--ck-toolbar-dropdown-max-width:60vw}.ck.ck-toolbar-dropdown>.ck-dropdown__panel{max-width:var(--ck-toolbar-dropdown-max-width);width:max-content}.ck.ck-toolbar-dropdown>.ck-dropdown__panel .ck-button:focus{z-index:calc(var(--ck-z-default) + 1)}.ck.ck-toolbar-dropdown .ck-toolbar{border:0}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/toolbardropdown.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/toolbardropdown.css',
            ],
            names: [],
            mappings: 'AAKA,MACC,oCACD,CAEA,4CAGC,8CAA+C,CAD/C,iBAQD,CAJE,6DACC,qCACD,CCZF,oCACC,QACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-toolbar-dropdown-max-width: 60vw;\n}\n\n.ck.ck-toolbar-dropdown > .ck-dropdown__panel {\n\t/* https://github.com/ckeditor/ckeditor5/issues/5586 */\n\twidth: max-content;\n\tmax-width: var(--ck-toolbar-dropdown-max-width);\n\n\t& .ck-button {\n\t\t&:focus {\n\t\t\tz-index: calc(var(--ck-z-default) + 1);\n\t\t}\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-toolbar-dropdown .ck-toolbar {\n\tborder: 0;\n}\n',
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      9847: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          ':root{--ck-color-editable-blur-selection:#d9d9d9}.ck.ck-editor__editable:not(.ck-editor__nested-editable){border-radius:0}.ck-rounded-corners .ck.ck-editor__editable:not(.ck-editor__nested-editable),.ck.ck-editor__editable.ck-rounded-corners:not(.ck-editor__nested-editable){border-radius:var(--ck-border-radius)}.ck.ck-editor__editable.ck-focused:not(.ck-editor__nested-editable){border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0;outline:none}.ck.ck-editor__editable_inline{border:1px solid transparent;overflow:auto;padding:0 var(--ck-spacing-standard)}.ck.ck-editor__editable_inline[dir=ltr]{text-align:left}.ck.ck-editor__editable_inline[dir=rtl]{text-align:right}.ck.ck-editor__editable_inline>:first-child{margin-top:var(--ck-spacing-large)}.ck.ck-editor__editable_inline>:last-child{margin-bottom:var(--ck-spacing-large)}.ck.ck-editor__editable_inline.ck-blurred ::selection{background:var(--ck-color-editable-blur-selection)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_n]:after{border-bottom-color:var(--ck-color-panel-background)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_s]:after{border-top-color:var(--ck-color-panel-background)}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/editorui/editorui.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css',
            ],
            names: [],
            mappings:
              'AAWA,MACC,0CACD,CAEA,yDCJC,eDWD,CAPA,yJCAE,qCDOF,CAJC,oEEPA,2BAA2B,CCF3B,qCAA8B,CDC9B,YFWA,CAGD,+BAGC,4BAA6B,CAF7B,aAAc,CACd,oCA6BD,CA1BC,wCACC,eACD,CAEA,wCACC,gBACD,CAGA,4CACC,kCACD,CAGA,2CAKC,qCACD,CAGA,sDACC,kDACD,CAKA,gEACC,oDACD,CAIA,gEACC,iDACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_shadow.css";\n@import "../../../mixins/_focus.css";\n@import "../../mixins/_button.css";\n\n:root {\n\t--ck-color-editable-blur-selection: hsl(0, 0%, 85%);\n}\n\n.ck.ck-editor__editable:not(.ck-editor__nested-editable) {\n\t@mixin ck-rounded-corners;\n\n\t&.ck-focused {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-inner-shadow);\n\t}\n}\n\n.ck.ck-editor__editable_inline {\n\toverflow: auto;\n\tpadding: 0 var(--ck-spacing-standard);\n\tborder: 1px solid transparent;\n\n\t&[dir="ltr"] {\n\t\ttext-align: left;\n\t}\n\n\t&[dir="rtl"] {\n\t\ttext-align: right;\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/116 */\n\t& > *:first-child {\n\t\tmargin-top: var(--ck-spacing-large);\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5/issues/847 */\n\t& > *:last-child {\n\t\t/*\n\t\t * This value should match with the default margins of the block elements (like .media or .image)\n\t\t * to avoid a content jumping when the fake selection container shows up (See https://github.com/ckeditor/ckeditor5/issues/9825).\n\t\t */\n\t\tmargin-bottom: var(--ck-spacing-large);\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5/issues/6517 */\n\t&.ck-blurred ::selection {\n\t\tbackground: var(--ck-color-editable-blur-selection);\n\t}\n}\n\n/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/111 */\n.ck.ck-balloon-panel.ck-toolbar-container[class*="arrow_n"] {\n\t&::after {\n\t\tborder-bottom-color: var(--ck-color-panel-background);\n\t}\n}\n\n.ck.ck-balloon-panel.ck-toolbar-container[class*="arrow_s"] {\n\t&::after {\n\t\tborder-top-color: var(--ck-color-panel-background);\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n',
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n",
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n',
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      1874: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          '.ck.ck-form__header{align-items:center;display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between}:root{--ck-form-header-height:38px}.ck.ck-form__header{border-bottom:1px solid var(--ck-color-base-border);height:var(--ck-form-header-height);line-height:var(--ck-form-header-height);padding:var(--ck-spacing-small) var(--ck-spacing-large)}.ck.ck-form__header .ck-form__header__label{font-weight:700}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/formheader/formheader.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/formheader/formheader.css',
            ],
            names: [],
            mappings:
              'AAKA,oBAIC,kBAAmB,CAHnB,YAAa,CACb,kBAAmB,CACnB,gBAAiB,CAEjB,6BACD,CCNA,MACC,4BACD,CAEA,oBAIC,mDAAoD,CAFpD,mCAAoC,CACpC,wCAAyC,CAFzC,uDAQD,CAHC,4CACC,eACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-form__header {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\talign-items: center;\n\tjustify-content: space-between;\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-form-header-height: 38px;\n}\n\n.ck.ck-form__header {\n\tpadding: var(--ck-spacing-small) var(--ck-spacing-large);\n\theight: var(--ck-form-header-height);\n\tline-height: var(--ck-form-header-height);\n\tborder-bottom: 1px solid var(--ck-color-base-border);\n\n\t& .ck-form__header__label {\n\t\tfont-weight: bold;\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      1977: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          '.ck.ck-icon{vertical-align:middle}:root{--ck-icon-size:calc(var(--ck-line-height-base)*var(--ck-font-size-normal))}.ck.ck-icon{font-size:.8333350694em;height:var(--ck-icon-size);width:var(--ck-icon-size);will-change:transform}.ck.ck-icon,.ck.ck-icon *{cursor:inherit}.ck.ck-icon.ck-icon_inherit-color,.ck.ck-icon.ck-icon_inherit-color *{color:inherit}.ck.ck-icon.ck-icon_inherit-color :not([fill]){fill:currentColor}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/icon/icon.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/icon/icon.css',
            ],
            names: [],
            mappings:
              'AAKA,YACC,qBACD,CCFA,MACC,0EACD,CAEA,YAKC,uBAAwB,CAHxB,0BAA2B,CAD3B,yBAA0B,CAU1B,qBAoBD,CAlBC,0BALA,cAQA,CAMC,sEACC,aAMD,CAJC,+CAEC,iBACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-icon {\n\tvertical-align: middle;\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-icon-size: calc(var(--ck-line-height-base) * var(--ck-font-size-normal));\n}\n\n.ck.ck-icon {\n\twidth: var(--ck-icon-size);\n\theight: var(--ck-icon-size);\n\n\t/* Multiplied by the height of the line in "px" should give SVG "viewport" dimensions */\n\tfont-size: .8333350694em;\n\n\t/* Inherit cursor style (#5). */\n\tcursor: inherit;\n\n\t/* This will prevent blurry icons on Firefox. See #340. */\n\twill-change: transform;\n\n\t& * {\n\t\t/* Inherit cursor style (#5). */\n\t\tcursor: inherit;\n\t}\n\n\t/* Allows dynamic coloring of an icon by inheriting its color from the parent. */\n\t&.ck-icon_inherit-color {\n\t\tcolor: inherit;\n\n\t\t& * {\n\t\t\tcolor: inherit;\n\n\t\t\t&:not([fill]) {\n\t\t\t\t/* Needed by FF. */\n\t\t\t\tfill: currentColor;\n\t\t\t}\n\t\t}\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      2470: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          ':root{--ck-input-width:18em;--ck-input-text-width:var(--ck-input-width)}.ck.ck-input{border-radius:0}.ck-rounded-corners .ck.ck-input,.ck.ck-input.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-input{background:var(--ck-color-input-background);border:1px solid var(--ck-color-input-border);min-height:var(--ck-ui-component-min-height);min-width:var(--ck-input-width);padding:var(--ck-spacing-extra-tiny) var(--ck-spacing-medium);transition:box-shadow .1s ease-in-out,border .1s ease-in-out}.ck.ck-input:focus{border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),0 0;outline:none}.ck.ck-input[readonly]{background:var(--ck-color-input-disabled-background);border:1px solid var(--ck-color-input-disabled-border);color:var(--ck-color-input-disabled-text)}.ck.ck-input[readonly]:focus{box-shadow:var(--ck-focus-disabled-outer-shadow),0 0}.ck.ck-input.ck-error{animation:ck-input-shake .3s ease both;border-color:var(--ck-color-input-error-border)}.ck.ck-input.ck-error:focus{box-shadow:var(--ck-focus-error-outer-shadow),0 0}@keyframes ck-input-shake{20%{transform:translateX(-2px)}40%{transform:translateX(2px)}60%{transform:translateX(-1px)}80%{transform:translateX(1px)}}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/input/input.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css',
            ],
            names: [],
            mappings:
              'AASA,MACC,qBAAsB,CAGtB,2CACD,CAEA,aCLC,eD2CD,CAtCA,iECDE,qCDuCF,CAtCA,aAGC,2CAA4C,CAC5C,6CAA8C,CAK9C,4CAA6C,CAH7C,+BAAgC,CADhC,6DAA8D,CAO9D,4DA0BD,CAxBC,mBEnBA,2BAA2B,CCF3B,2CAA8B,CDC9B,YFuBA,CAEA,uBAEC,oDAAqD,CADrD,sDAAuD,CAEvD,yCAMD,CAJC,6BG/BD,oDHkCC,CAGD,sBAEC,sCAAuC,CADvC,+CAMD,CAHC,4BGzCD,iDH2CC,CAIF,0BACC,IACC,0BACD,CAEA,IACC,yBACD,CAEA,IACC,0BACD,CAEA,IACC,yBACD,CACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_focus.css";\n@import "../../../mixins/_shadow.css";\n\n:root {\n\t--ck-input-width: 18em;\n\n\t/* Backward compatibility. */\n\t--ck-input-text-width: var(--ck-input-width);\n}\n\n.ck.ck-input {\n\t@mixin ck-rounded-corners;\n\n\tbackground: var(--ck-color-input-background);\n\tborder: 1px solid var(--ck-color-input-border);\n\tpadding: var(--ck-spacing-extra-tiny) var(--ck-spacing-medium);\n\tmin-width: var(--ck-input-width);\n\n\t/* This is important to stay of the same height as surrounding buttons */\n\tmin-height: var(--ck-ui-component-min-height);\n\n\t/* Apply some smooth transition to the box-shadow and border. */\n\ttransition: box-shadow .1s ease-in-out, border .1s ease-in-out;\n\n\t&:focus {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-focus-outer-shadow);\n\t}\n\n\t&[readonly] {\n\t\tborder: 1px solid var(--ck-color-input-disabled-border);\n\t\tbackground: var(--ck-color-input-disabled-background);\n\t\tcolor: var(--ck-color-input-disabled-text);\n\n\t\t&:focus {\n\t\t\t/* The read-only input should have a slightly less visible shadow when focused. */\n\t\t\t@mixin ck-box-shadow var(--ck-focus-disabled-outer-shadow);\n\t\t}\n\t}\n\n\t&.ck-error {\n\t\tborder-color: var(--ck-color-input-error-border);\n\t\tanimation: ck-input-shake .3s ease both;\n\n\t\t&:focus {\n\t\t\t@mixin ck-box-shadow var(--ck-focus-error-outer-shadow);\n\t\t}\n\t}\n}\n\n@keyframes ck-input-shake {\n\t20% {\n\t\ttransform: translateX(-2px);\n\t}\n\n\t40% {\n\t\ttransform: translateX(2px);\n\t}\n\n\t60% {\n\t\ttransform: translateX(-1px);\n\t}\n\n\t80% {\n\t\ttransform: translateX(1px);\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n',
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n",
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n',
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      3525: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          '.ck.ck-label{display:block}.ck.ck-voice-label{display:none}.ck.ck-label{font-weight:700}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/label/label.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/label/label.css',
            ],
            names: [],
            mappings: 'AAKA,aACC,aACD,CAEA,mBACC,YACD,CCNA,aACC,eACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-label {\n\tdisplay: block;\n}\n\n.ck.ck-voice-label {\n\tdisplay: none;\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-label {\n\tfont-weight: bold;\n}\n',
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      2933: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          '.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper{display:flex;position:relative}.ck.ck-labeled-field-view .ck.ck-label{display:block;position:absolute}:root{--ck-labeled-field-view-transition:.1s cubic-bezier(0,0,0.24,0.95);--ck-labeled-field-empty-unfocused-max-width:100% - 2 * var(--ck-spacing-medium);--ck-labeled-field-label-default-position-x:var(--ck-spacing-medium);--ck-labeled-field-label-default-position-y:calc(var(--ck-font-size-base)*0.6);--ck-color-labeled-field-label-background:var(--ck-color-base-background)}.ck.ck-labeled-field-view{border-radius:0}.ck-rounded-corners .ck.ck-labeled-field-view,.ck.ck-labeled-field-view.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper{width:100%}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{top:0}[dir=ltr] .ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{left:0}[dir=rtl] .ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{right:0}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{background:var(--ck-color-labeled-field-label-background);font-weight:400;line-height:normal;max-width:100%;overflow:hidden;padding:0 calc(var(--ck-font-size-tiny)*.5);pointer-events:none;text-overflow:ellipsis;transform:translate(var(--ck-spacing-medium),-6px) scale(.75);transform-origin:0 0;transition:transform var(--ck-labeled-field-view-transition),padding var(--ck-labeled-field-view-transition),background var(--ck-labeled-field-view-transition)}.ck.ck-labeled-field-view.ck-error .ck-input:not([readonly])+.ck.ck-label,.ck.ck-labeled-field-view.ck-error>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{color:var(--ck-color-base-error)}.ck.ck-labeled-field-view .ck-labeled-field-view__status{font-size:var(--ck-font-size-small);margin-top:var(--ck-spacing-small);white-space:normal}.ck.ck-labeled-field-view .ck-labeled-field-view__status.ck-labeled-field-view__status_error{color:var(--ck-color-base-error)}.ck.ck-labeled-field-view.ck-disabled>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{color:var(--ck-color-input-disabled-text)}[dir=ltr] .ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,[dir=ltr] .ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{transform:translate(var(--ck-labeled-field-label-default-position-x),var(--ck-labeled-field-label-default-position-y)) scale(1)}[dir=rtl] .ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,[dir=rtl] .ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{transform:translate(calc(var(--ck-labeled-field-label-default-position-x)*-1),var(--ck-labeled-field-label-default-position-y)) scale(1)}.ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{background:transparent;max-width:calc(var(--ck-labeled-field-empty-unfocused-max-width));padding:0}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown>.ck.ck-button{background:transparent}.ck.ck-labeled-field-view.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown>.ck-button>.ck-button__label{opacity:0}.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown+.ck-label{max-width:calc(var(--ck-labeled-field-empty-unfocused-max-width) - var(--ck-dropdown-arrow-size) - var(--ck-spacing-standard))}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/labeledfield/labeledfieldview.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/labeledfield/labeledfieldview.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css',
            ],
            names: [],
            mappings:
              'AAMC,mEACC,YAAa,CACb,iBACD,CAEA,uCACC,aAAc,CACd,iBACD,CCND,MACC,kEAAsE,CACtE,gFAAiF,CACjF,oEAAqE,CACrE,8EAAiF,CACjF,yEACD,CAEA,0BCLC,eD8GD,CAzGA,2FCDE,qCD0GF,CAtGC,mEACC,UAmCD,CAjCC,gFACC,KA+BD,CAhCA,0FAIE,MA4BF,CAhCA,0FAQE,OAwBF,CAhCA,gFAiBC,yDAA0D,CAG1D,eAAmB,CADnB,kBAAoB,CAOpB,cAAe,CAFf,eAAgB,CANhB,2CAA8C,CAP9C,mBAAoB,CAYpB,sBAAuB,CARvB,6DAA+D,CAH/D,oBAAqB,CAgBrB,+JAID,CAQA,mKACC,gCACD,CAGD,yDACC,mCAAoC,CACpC,kCAAmC,CAInC,kBAKD,CAHC,6FACC,gCACD,CAID,4OAEC,yCACD,CAIA,oUAGE,+HAYF,CAfA,oUAOE,wIAQF,CAfA,gTAaC,sBAAuB,CAFvB,iEAAkE,CAGlE,SACD,CAKA,8FACC,sBACD,CAGA,yIACC,SACD,CAGA,kMACC,8HACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-labeled-field-view {\n\t& > .ck.ck-labeled-field-view__input-wrapper {\n\t\tdisplay: flex;\n\t\tposition: relative;\n\t}\n\n\t& .ck.ck-label {\n\t\tdisplay: block;\n\t\tposition: absolute;\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n@import "../../../mixins/_rounded.css";\n\n:root {\n\t--ck-labeled-field-view-transition: .1s cubic-bezier(0, 0, 0.24, 0.95);\n\t--ck-labeled-field-empty-unfocused-max-width: 100% - 2 * var(--ck-spacing-medium);\n\t--ck-labeled-field-label-default-position-x: var(--ck-spacing-medium);\n\t--ck-labeled-field-label-default-position-y: calc(0.6 * var(--ck-font-size-base));\n\t--ck-color-labeled-field-label-background: var(--ck-color-base-background);\n}\n\n.ck.ck-labeled-field-view {\n\t@mixin ck-rounded-corners;\n\n\t& > .ck.ck-labeled-field-view__input-wrapper {\n\t\twidth: 100%;\n\n\t\t& > .ck.ck-label {\n\t\t\ttop: 0px;\n\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tleft: 0px;\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tright: 0px;\n\t\t\t}\n\n\t\t\tpointer-events: none;\n\t\t\ttransform-origin: 0 0;\n\n\t\t\t/* By default, display the label scaled down above the field. */\n\t\t\ttransform: translate(var(--ck-spacing-medium), -6px) scale(.75);\n\n\t\t\tbackground: var(--ck-color-labeled-field-label-background);\n\t\t\tpadding: 0 calc(.5 * var(--ck-font-size-tiny));\n\t\t\tline-height: initial;\n\t\t\tfont-weight: normal;\n\n\t\t\t/* Prevent overflow when the label is longer than the input */\n\t\t\ttext-overflow: ellipsis;\n\t\t\toverflow: hidden;\n\n\t\t\tmax-width: 100%;\n\n\t\t\ttransition:\n\t\t\t\ttransform var(--ck-labeled-field-view-transition),\n\t\t\t\tpadding var(--ck-labeled-field-view-transition),\n\t\t\t\tbackground var(--ck-labeled-field-view-transition);\n\t\t}\n\t}\n\n\t&.ck-error {\n\t\t& > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {\n\t\t\tcolor: var(--ck-color-base-error);\n\t\t}\n\n\t\t& .ck-input:not([readonly]) + .ck.ck-label {\n\t\t\tcolor: var(--ck-color-base-error);\n\t\t}\n\t}\n\n\t& .ck-labeled-field-view__status {\n\t\tfont-size: var(--ck-font-size-small);\n\t\tmargin-top: var(--ck-spacing-small);\n\n\t\t/* Let the info wrap to the next line to avoid stretching the layout horizontally.\n\t\tThe status could be very long. */\n\t\twhite-space: normal;\n\n\t\t&.ck-labeled-field-view__status_error {\n\t\t\tcolor: var(--ck-color-base-error);\n\t\t}\n\t}\n\n\t/* Disabled fields and fields that have no focus should fade out. */\n\t&.ck-disabled > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label,\n\t&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused) > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {\n\t\tcolor: var(--ck-color-input-disabled-text);\n\t}\n\n\t/* Fields that are disabled or not focused and without a placeholder should have full-sized labels. */\n\t/* stylelint-disable-next-line no-descending-specificity */\n\t&.ck-disabled.ck-labeled-field-view_empty > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label,\n\t&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder) > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {\n\t\t@mixin ck-dir ltr {\n\t\t\ttransform: translate(var(--ck-labeled-field-label-default-position-x), var(--ck-labeled-field-label-default-position-y)) scale(1);\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\ttransform: translate(calc(-1 * var(--ck-labeled-field-label-default-position-x)), var(--ck-labeled-field-label-default-position-y)) scale(1);\n\t\t}\n\n\t\t/* Compensate for the default translate position. */\n\t\tmax-width: calc(var(--ck-labeled-field-empty-unfocused-max-width));\n\n\t\tbackground: transparent;\n\t\tpadding: 0;\n\t}\n\n\t/*------ DropdownView integration ----------------------------------------------------------------------------------- */\n\n\t/* Make sure dropdown\' background color in any of dropdown\'s state does not collide with labeled field. */\n\t& > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown > .ck.ck-button {\n\t\tbackground: transparent;\n\t}\n\n\t/* When the dropdown is "empty", the labeled field label replaces its label. */\n\t&.ck-labeled-field-view_empty > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown > .ck-button > .ck-button__label {\n\t\topacity: 0;\n\t}\n\n\t/* Make sure the label of the empty, unfocused input does not cover the dropdown arrow. */\n\t&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder) > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown + .ck-label {\n\t\tmax-width: calc(var(--ck-labeled-field-empty-unfocused-max-width) - var(--ck-dropdown-arrow-size) - var(--ck-spacing-standard));\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      179: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          '.ck.ck-list{display:flex;flex-direction:column;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-list .ck-list__item,.ck.ck-list .ck-list__separator{display:block}.ck.ck-list .ck-list__item>:focus{position:relative;z-index:var(--ck-z-default)}.ck.ck-list{border-radius:0}.ck-rounded-corners .ck.ck-list,.ck.ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-list{background:var(--ck-color-list-background);list-style-type:none}.ck.ck-list__item{cursor:default;min-width:12em}.ck.ck-list__item .ck-button{border-radius:0;min-height:unset;padding:calc(var(--ck-line-height-base)*.2*var(--ck-font-size-base)) calc(var(--ck-line-height-base)*.4*var(--ck-font-size-base));text-align:left;width:100%}.ck.ck-list__item .ck-button .ck-button__label{line-height:calc(var(--ck-line-height-base)*1.2*var(--ck-font-size-base))}.ck.ck-list__item .ck-button:active{box-shadow:none}.ck.ck-list__item .ck-button.ck-on{background:var(--ck-color-list-button-on-background);color:var(--ck-color-list-button-on-text)}.ck.ck-list__item .ck-button.ck-on:active{box-shadow:none}.ck.ck-list__item .ck-button.ck-on:hover:not(.ck-disabled){background:var(--ck-color-list-button-on-background-focus)}.ck.ck-list__item .ck-button.ck-on:focus:not(.ck-switchbutton):not(.ck-disabled){border-color:var(--ck-color-base-background)}.ck.ck-list__item .ck-button:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background)}.ck.ck-list__item .ck-switchbutton.ck-on{background:var(--ck-color-list-background);color:inherit}.ck.ck-list__item .ck-switchbutton.ck-on:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background);color:inherit}.ck.ck-list__separator{background:var(--ck-color-base-border);height:1px;width:100%}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/list/list.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/list/list.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css',
            ],
            names: [],
            mappings:
              'AAOA,YAGC,YAAa,CACb,qBAAsB,CCFtB,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBDaD,CAZC,2DAEC,aACD,CAKA,kCACC,iBAAkB,CAClB,2BACD,CEfD,YCEC,eDGD,CALA,+DCME,qCDDF,CALA,YAIC,0CAA2C,CAD3C,oBAED,CAEA,kBACC,cAAe,CACf,cA2DD,CAzDC,6BAIC,eAAgB,CAHhB,gBAAiB,CAQjB,iIAEiE,CARjE,eAAgB,CADhB,UAwCD,CA7BC,+CAEC,yEACD,CAEA,oCACC,eACD,CAEA,mCACC,oDAAqD,CACrD,yCAaD,CAXC,0CACC,eACD,CAEA,2DACC,0DACD,CAEA,iFACC,4CACD,CAGD,qDACC,uDACD,CAMA,yCACC,0CAA2C,CAC3C,aAMD,CAJC,iEACC,uDAAwD,CACxD,aACD,CAKH,uBAGC,sCAAuC,CAFvC,UAAW,CACX,UAED',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../mixins/_unselectable.css";\n\n.ck.ck-list {\n\t@mixin ck-unselectable;\n\n\tdisplay: flex;\n\tflex-direction: column;\n\n\t& .ck-list__item,\n\t& .ck-list__separator {\n\t\tdisplay: block;\n\t}\n\n\t/* Make sure that whatever child of the list item gets focus, it remains on the\n\ttop. Thanks to that, styles like box-shadow, outline, etc. are not masked by\n\tadjacent list items. */\n\t& .ck-list__item > *:focus {\n\t\tposition: relative;\n\t\tz-index: var(--ck-z-default);\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Makes element unselectable.\n */\n@define-mixin ck-unselectable {\n\t-moz-user-select: none;\n\t-webkit-user-select: none;\n\t-ms-user-select: none;\n\tuser-select: none\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_shadow.css";\n\n.ck.ck-list {\n\t@mixin ck-rounded-corners;\n\n\tlist-style-type: none;\n\tbackground: var(--ck-color-list-background);\n}\n\n.ck.ck-list__item {\n\tcursor: default;\n\tmin-width: 12em;\n\n\t& .ck-button {\n\t\tmin-height: unset;\n\t\twidth: 100%;\n\t\ttext-align: left;\n\t\tborder-radius: 0;\n\n\t\t/* List items should have the same height. Use absolute units to make sure it is so\n\t\t   because e.g. different heading styles may have different height\n\t\t   https://github.com/ckeditor/ckeditor5-heading/issues/63 */\n\t\tpadding:\n\t\t\tcalc(.2 * var(--ck-line-height-base) * var(--ck-font-size-base))\n\t\t\tcalc(.4 * var(--ck-line-height-base) * var(--ck-font-size-base));\n\n\t\t& .ck-button__label {\n\t\t\t/* https://github.com/ckeditor/ckeditor5-heading/issues/63 */\n\t\t\tline-height: calc(1.2 * var(--ck-line-height-base) * var(--ck-font-size-base));\n\t\t}\n\n\t\t&:active {\n\t\t\tbox-shadow: none;\n\t\t}\n\n\t\t&.ck-on {\n\t\t\tbackground: var(--ck-color-list-button-on-background);\n\t\t\tcolor: var(--ck-color-list-button-on-text);\n\n\t\t\t&:active {\n\t\t\t\tbox-shadow: none;\n\t\t\t}\n\n\t\t\t&:hover:not(.ck-disabled) {\n\t\t\t\tbackground: var(--ck-color-list-button-on-background-focus);\n\t\t\t}\n\n\t\t\t&:focus:not(.ck-switchbutton):not(.ck-disabled) {\n\t\t\t\tborder-color: var(--ck-color-base-background);\n\t\t\t}\n\t\t}\n\n\t\t&:hover:not(.ck-disabled) {\n\t\t\tbackground: var(--ck-color-list-button-hover-background);\n\t\t}\n\t}\n\n\t/* It\'s unnecessary to change the background/text of a switch toggle; it has different ways\n\tof conveying its state (like the switcher) */\n\t& .ck-switchbutton {\n\t\t&.ck-on {\n\t\t\tbackground: var(--ck-color-list-background);\n\t\t\tcolor: inherit;\n\n\t\t\t&:hover:not(.ck-disabled) {\n\t\t\t\tbackground: var(--ck-color-list-button-hover-background);\n\t\t\t\tcolor: inherit;\n\t\t\t}\n\t\t}\n\t}\n}\n\n.ck.ck-list__separator {\n\theight: 1px;\n\twidth: 100%;\n\tbackground: var(--ck-color-base-border);\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      4460: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          ':root{--ck-balloon-panel-arrow-z-index:calc(var(--ck-z-default) - 3)}.ck.ck-balloon-panel{display:none;position:absolute;z-index:var(--ck-z-modal)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{content:"";position:absolute}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_n]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_n]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_s]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_s]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel.ck-balloon-panel_visible{display:block}:root{--ck-balloon-border-width:1px;--ck-balloon-arrow-offset:2px;--ck-balloon-arrow-height:10px;--ck-balloon-arrow-half-width:8px;--ck-balloon-arrow-drop-shadow:0 2px 2px var(--ck-color-shadow-drop)}.ck.ck-balloon-panel{border-radius:0}.ck-rounded-corners .ck.ck-balloon-panel,.ck.ck-balloon-panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-balloon-panel{background:var(--ck-color-panel-background);border:var(--ck-balloon-border-width) solid var(--ck-color-panel-border);box-shadow:var(--ck-drop-shadow),0 0;min-height:15px}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{border-style:solid;height:0;width:0}.ck.ck-balloon-panel[class*=arrow_n]:after,.ck.ck-balloon-panel[class*=arrow_n]:before{border-width:0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width)}.ck.ck-balloon-panel[class*=arrow_n]:before{border-color:transparent transparent var(--ck-color-panel-border) transparent;margin-top:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_n]:after{border-color:transparent transparent var(--ck-color-panel-background) transparent;margin-top:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel[class*=arrow_s]:after,.ck.ck-balloon-panel[class*=arrow_s]:before{border-width:var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width)}.ck.ck-balloon-panel[class*=arrow_s]:before{border-color:var(--ck-color-panel-border) transparent transparent;filter:drop-shadow(var(--ck-balloon-arrow-drop-shadow));margin-bottom:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_s]:after{border-color:var(--ck-color-panel-background) transparent transparent transparent;margin-bottom:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel[class*=arrow_e]:after,.ck.ck-balloon-panel[class*=arrow_e]:before{border-width:var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height)}.ck.ck-balloon-panel[class*=arrow_e]:before{border-color:transparent transparent transparent var(--ck-color-panel-border);margin-right:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_e]:after{border-color:transparent transparent transparent var(--ck-color-panel-background);margin-right:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel[class*=arrow_w]:after,.ck.ck-balloon-panel[class*=arrow_w]:before{border-width:var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0}.ck.ck-balloon-panel[class*=arrow_w]:before{border-color:transparent var(--ck-color-panel-border) transparent transparent;margin-left:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_w]:after{border-color:transparent var(--ck-color-panel-background) transparent transparent;margin-left:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:before{left:50%;margin-left:calc(var(--ck-balloon-arrow-half-width)*-1);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:before{left:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:before{right:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);left:50%;margin-left:calc(var(--ck-balloon-arrow-half-width)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);left:calc(var(--ck-balloon-arrow-half-width)*2)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);right:calc(var(--ck-balloon-arrow-half-width)*2)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_sme:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_sme:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);margin-right:calc(var(--ck-balloon-arrow-half-width)*2);right:25%}.ck.ck-balloon-panel.ck-balloon-panel_arrow_smw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_smw:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);left:25%;margin-left:calc(var(--ck-balloon-arrow-half-width)*2)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nme:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nme:before{margin-right:calc(var(--ck-balloon-arrow-half-width)*2);right:25%;top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nmw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nmw:before{left:25%;margin-left:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_e:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_e:before{margin-top:calc(var(--ck-balloon-arrow-half-width)*-1);right:calc(var(--ck-balloon-arrow-height)*-1);top:50%}.ck.ck-balloon-panel.ck-balloon-panel_arrow_w:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_w:before{left:calc(var(--ck-balloon-arrow-height)*-1);margin-top:calc(var(--ck-balloon-arrow-half-width)*-1);top:50%}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/balloonpanel.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/balloonpanel.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css',
            ],
            names: [],
            mappings:
              'AAKA,MAEC,8DACD,CAEA,qBACC,YAAa,CACb,iBAAkB,CAElB,yBAyCD,CAtCE,+GAEC,UAAW,CACX,iBACD,CAEA,wDACC,6CACD,CAEA,uDACC,uDACD,CAIA,4CACC,6CACD,CAEA,2CACC,uDACD,CAIA,4CACC,6CACD,CAEA,2CACC,uDACD,CAGD,8CACC,aACD,CC9CD,MACC,6BAA8B,CAC9B,6BAA8B,CAC9B,8BAA+B,CAC/B,iCAAkC,CAClC,oEACD,CAEA,qBCLC,eDmMD,CA9LA,iFCDE,qCD+LF,CA9LA,qBAMC,2CAA4C,CAC5C,wEAAyE,CEdzE,oCAA8B,CFW9B,eA0LD,CApLE,+GAIC,kBAAmB,CADnB,QAAS,CADT,OAGD,CAIA,uFAEC,mHACD,CAEA,4CACC,6EAA8E,CAC9E,kDACD,CAEA,2CACC,iFAAkF,CAClF,gFACD,CAIA,uFAEC,mHACD,CAEA,4CACC,iEAAkE,CAClE,uDAAwD,CACxD,qDACD,CAEA,2CACC,iFAAkF,CAClF,mFACD,CAIA,uFAEC,mHACD,CAEA,4CACC,6EAA8E,CAC9E,oDACD,CAEA,2CACC,iFAAkF,CAClF,kFACD,CAIA,uFAEC,mHACD,CAEA,4CACC,6EAA8E,CAC9E,mDACD,CAEA,2CACC,iFAAkF,CAClF,iFACD,CAIA,yGAEC,QAAS,CACT,uDAA0D,CAC1D,2CACD,CAIA,2GAEC,+CAAkD,CAClD,2CACD,CAIA,2GAEC,gDAAmD,CACnD,2CACD,CAIA,yGAIC,8CAAiD,CAFjD,QAAS,CACT,uDAED,CAIA,2GAGC,8CAAiD,CADjD,+CAED,CAIA,2GAGC,8CAAiD,CADjD,gDAED,CAIA,6GAIC,8CAAiD,CADjD,uDAA0D,CAD1D,SAGD,CAIA,6GAIC,8CAAiD,CAFjD,QAAS,CACT,sDAED,CAIA,6GAGC,uDAA0D,CAD1D,SAAU,CAEV,2CACD,CAIA,6GAEC,QAAS,CACT,sDAAyD,CACzD,2CACD,CAIA,yGAGC,sDAAyD,CADzD,6CAAgD,CAEhD,OACD,CAIA,yGAEC,4CAA+C,CAC/C,sDAAyD,CACzD,OACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/* Make sure the balloon arrow does not float over its children. */\n\t--ck-balloon-panel-arrow-z-index: calc(var(--ck-z-default) - 3);\n}\n\n.ck.ck-balloon-panel {\n\tdisplay: none;\n\tposition: absolute;\n\n\tz-index: var(--ck-z-modal);\n\n\t&.ck-balloon-panel_with-arrow {\n\t\t&::before,\n\t\t&::after {\n\t\t\tcontent: "";\n\t\t\tposition: absolute;\n\t\t}\n\n\t\t&::before {\n\t\t\tz-index: var(--ck-balloon-panel-arrow-z-index);\n\t\t}\n\n\t\t&::after {\n\t\t\tz-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);\n\t\t}\n\t}\n\n\t&[class*="arrow_n"] {\n\t\t&::before {\n\t\t\tz-index: var(--ck-balloon-panel-arrow-z-index);\n\t\t}\n\n\t\t&::after {\n\t\t\tz-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);\n\t\t}\n\t}\n\n\t&[class*="arrow_s"] {\n\t\t&::before {\n\t\t\tz-index: var(--ck-balloon-panel-arrow-z-index);\n\t\t}\n\n\t\t&::after {\n\t\t\tz-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_visible {\n\t\tdisplay: block;\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_shadow.css";\n\n:root {\n\t--ck-balloon-border-width: 1px;\n\t--ck-balloon-arrow-offset: 2px;\n\t--ck-balloon-arrow-height: 10px;\n\t--ck-balloon-arrow-half-width: 8px;\n\t--ck-balloon-arrow-drop-shadow: 0 2px 2px var(--ck-color-shadow-drop);\n}\n\n.ck.ck-balloon-panel {\n\t@mixin ck-rounded-corners;\n\t@mixin ck-drop-shadow;\n\n\tmin-height: 15px;\n\n\tbackground: var(--ck-color-panel-background);\n\tborder: var(--ck-balloon-border-width) solid var(--ck-color-panel-border);\n\n\t&.ck-balloon-panel_with-arrow {\n\t\t&::before,\n\t\t&::after {\n\t\t\twidth: 0;\n\t\t\theight: 0;\n\t\t\tborder-style: solid;\n\t\t}\n\t}\n\n\t&[class*="arrow_n"] {\n\t\t&::before,\n\t\t&::after {\n\t\t\tborder-width: 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width);\n\t\t}\n\n\t\t&::before {\n\t\t\tborder-color: transparent transparent var(--ck-color-panel-border) transparent;\n\t\t\tmargin-top: calc( -1 * var(--ck-balloon-border-width) );\n\t\t}\n\n\t\t&::after {\n\t\t\tborder-color: transparent transparent var(--ck-color-panel-background) transparent;\n\t\t\tmargin-top: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );\n\t\t}\n\t}\n\n\t&[class*="arrow_s"] {\n\t\t&::before,\n\t\t&::after {\n\t\t\tborder-width: var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width);\n\t\t}\n\n\t\t&::before {\n\t\t\tborder-color: var(--ck-color-panel-border) transparent transparent;\n\t\t\tfilter: drop-shadow(var(--ck-balloon-arrow-drop-shadow));\n\t\t\tmargin-bottom: calc( -1 * var(--ck-balloon-border-width) );\n\t\t}\n\n\t\t&::after {\n\t\t\tborder-color: var(--ck-color-panel-background) transparent transparent transparent;\n\t\t\tmargin-bottom: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );\n\t\t}\n\t}\n\n\t&[class*="arrow_e"] {\n\t\t&::before,\n\t\t&::after {\n\t\t\tborder-width: var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height);\n\t\t}\n\n\t\t&::before {\n\t\t\tborder-color: transparent transparent transparent var(--ck-color-panel-border);\n\t\t\tmargin-right: calc( -1 * var(--ck-balloon-border-width) );\n\t\t}\n\n\t\t&::after {\n\t\t\tborder-color: transparent transparent transparent var(--ck-color-panel-background);\n\t\t\tmargin-right: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );\n\t\t}\n\t}\n\n\t&[class*="arrow_w"] {\n\t\t&::before,\n\t\t&::after {\n\t\t\tborder-width: var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0;\n\t\t}\n\n\t\t&::before {\n\t\t\tborder-color: transparent var(--ck-color-panel-border) transparent transparent;\n\t\t\tmargin-left: calc( -1 * var(--ck-balloon-border-width) );\n\t\t}\n\n\t\t&::after {\n\t\t\tborder-color: transparent var(--ck-color-panel-background) transparent transparent;\n\t\t\tmargin-left: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_n {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 50%;\n\t\t\tmargin-left: calc(-1 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_nw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_ne {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_s {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 50%;\n\t\t\tmargin-left: calc(-1 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_sw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_se {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_sme {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: 25%;\n\t\t\tmargin-right: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_smw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 25%;\n\t\t\tmargin-left: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_nme {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: 25%;\n\t\t\tmargin-right: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_nmw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 25%;\n\t\t\tmargin-left: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_e {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t\tmargin-top: calc(-1 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: 50%;\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_w {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t\tmargin-top: calc(-1 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: 50%;\n\t\t}\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n',
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      7592: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          '.ck .ck-balloon-rotator__navigation{align-items:center;display:flex;justify-content:center}.ck .ck-balloon-rotator__content .ck-toolbar{justify-content:center}.ck .ck-balloon-rotator__navigation{background:var(--ck-color-toolbar-background);border-bottom:1px solid var(--ck-color-toolbar-border);padding:0 var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation>*{margin-bottom:var(--ck-spacing-small);margin-right:var(--ck-spacing-small);margin-top:var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation .ck-balloon-rotator__counter{margin-left:var(--ck-spacing-small);margin-right:var(--ck-spacing-standard)}.ck .ck-balloon-rotator__content .ck.ck-annotation-wrapper{box-shadow:none}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/balloonrotator.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/balloonrotator.css',
            ],
            names: [],
            mappings:
              'AAKA,oCAEC,kBAAmB,CADnB,YAAa,CAEb,sBACD,CAKA,6CACC,sBACD,CCXA,oCACC,6CAA8C,CAC9C,sDAAuD,CACvD,iCAgBD,CAbC,sCAGC,qCAAsC,CAFtC,oCAAqC,CACrC,kCAED,CAGA,iEAIC,mCAAoC,CAHpC,uCAID,CAMA,2DACC,eACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-balloon-rotator__navigation {\n\tdisplay: flex;\n\talign-items: center;\n\tjustify-content: center;\n}\n\n/* Buttons inside a toolbar should be centered when rotator bar is wider.\n * See: https://github.com/ckeditor/ckeditor5-ui/issues/495\n */\n.ck .ck-balloon-rotator__content .ck-toolbar {\n\tjustify-content: center;\n}\n',
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-balloon-rotator__navigation {\n\tbackground: var(--ck-color-toolbar-background);\n\tborder-bottom: 1px solid var(--ck-color-toolbar-border);\n\tpadding: 0 var(--ck-spacing-small);\n\n\t/* Let's keep similar appearance to `ck-toolbar`. */\n\t& > * {\n\t\tmargin-right: var(--ck-spacing-small);\n\t\tmargin-top: var(--ck-spacing-small);\n\t\tmargin-bottom: var(--ck-spacing-small);\n\t}\n\n\t/* Gives counter more breath than buttons. */\n\t& .ck-balloon-rotator__counter {\n\t\tmargin-right: var(--ck-spacing-standard);\n\n\t\t/* We need to use smaller margin because of previous button's right margin. */\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n}\n\n.ck .ck-balloon-rotator__content {\n\n\t/* Disable default annotation shadow inside rotator with fake panels. */\n\t& .ck.ck-annotation-wrapper {\n\t\tbox-shadow: none;\n\t}\n}\n",
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      6356: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          '.ck .ck-fake-panel{position:absolute;z-index:calc(var(--ck-z-modal) - 1)}.ck .ck-fake-panel div{position:absolute}.ck .ck-fake-panel div:first-child{z-index:2}.ck .ck-fake-panel div:nth-child(2){z-index:1}:root{--ck-balloon-fake-panel-offset-horizontal:6px;--ck-balloon-fake-panel-offset-vertical:6px}.ck .ck-fake-panel div{background:var(--ck-color-panel-background);border:1px solid var(--ck-color-panel-border);border-radius:var(--ck-border-radius);box-shadow:var(--ck-drop-shadow),0 0;height:100%;min-height:15px;width:100%}.ck .ck-fake-panel div:first-child{margin-left:var(--ck-balloon-fake-panel-offset-horizontal);margin-top:var(--ck-balloon-fake-panel-offset-vertical)}.ck .ck-fake-panel div:nth-child(2){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*2);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*2)}.ck .ck-fake-panel div:nth-child(3){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*3);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*3)}.ck .ck-balloon-panel_arrow_s+.ck-fake-panel,.ck .ck-balloon-panel_arrow_se+.ck-fake-panel,.ck .ck-balloon-panel_arrow_sw+.ck-fake-panel{--ck-balloon-fake-panel-offset-vertical:-6px}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/fakepanel.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/fakepanel.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css',
            ],
            names: [],
            mappings:
              'AAKA,mBACC,iBAAkB,CAGlB,mCACD,CAEA,uBACC,iBACD,CAEA,mCACC,SACD,CAEA,oCACC,SACD,CCfA,MACC,6CAA8C,CAC9C,2CACD,CAGA,uBAKC,2CAA4C,CAC5C,6CAA8C,CAC9C,qCAAsC,CCXtC,oCAA8B,CDc9B,WAAY,CAPZ,eAAgB,CAMhB,UAED,CAEA,mCACC,0DAA2D,CAC3D,uDACD,CAEA,oCACC,kEAAqE,CACrE,+DACD,CACA,oCACC,kEAAqE,CACrE,+DACD,CAGA,yIAGC,4CACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-fake-panel {\n\tposition: absolute;\n\n\t/* Fake panels should be placed under main balloon content. */\n\tz-index: calc(var(--ck-z-modal) - 1);\n}\n\n.ck .ck-fake-panel div {\n\tposition: absolute;\n}\n\n.ck .ck-fake-panel div:nth-child( 1 ) {\n\tz-index: 2;\n}\n\n.ck .ck-fake-panel div:nth-child( 2 ) {\n\tz-index: 1;\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_shadow.css";\n\n:root {\n\t--ck-balloon-fake-panel-offset-horizontal: 6px;\n\t--ck-balloon-fake-panel-offset-vertical: 6px;\n}\n\n/* Let\'s use `.ck-balloon-panel` appearance. See: balloonpanel.css. */\n.ck .ck-fake-panel div {\n\t@mixin ck-drop-shadow;\n\n\tmin-height: 15px;\n\n\tbackground: var(--ck-color-panel-background);\n\tborder: 1px solid var(--ck-color-panel-border);\n\tborder-radius: var(--ck-border-radius);\n\n\twidth: 100%;\n\theight: 100%;\n}\n\n.ck .ck-fake-panel div:nth-child( 1 ) {\n\tmargin-left: var(--ck-balloon-fake-panel-offset-horizontal);\n\tmargin-top: var(--ck-balloon-fake-panel-offset-vertical);\n}\n\n.ck .ck-fake-panel div:nth-child( 2 ) {\n\tmargin-left: calc(var(--ck-balloon-fake-panel-offset-horizontal) * 2);\n\tmargin-top: calc(var(--ck-balloon-fake-panel-offset-vertical) * 2);\n}\n.ck .ck-fake-panel div:nth-child( 3 ) {\n\tmargin-left: calc(var(--ck-balloon-fake-panel-offset-horizontal) * 3);\n\tmargin-top: calc(var(--ck-balloon-fake-panel-offset-vertical) * 3);\n}\n\n/* If balloon is positioned above element, we need to move fake panel to the top. */\n.ck .ck-balloon-panel_arrow_s + .ck-fake-panel,\n.ck .ck-balloon-panel_arrow_se + .ck-fake-panel,\n.ck .ck-balloon-panel_arrow_sw + .ck-fake-panel {\n\t--ck-balloon-fake-panel-offset-vertical: -6px;\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n',
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      3707: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          '.ck.ck-sticky-panel .ck-sticky-panel__content_sticky{position:fixed;top:0;z-index:var(--ck-z-modal)}.ck.ck-sticky-panel .ck-sticky-panel__content_sticky_bottom-limit{position:absolute;top:auto}.ck.ck-sticky-panel .ck-sticky-panel__content_sticky{border-top-left-radius:0;border-top-right-radius:0;border-width:0 1px 1px;box-shadow:var(--ck-drop-shadow),0 0}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/stickypanel.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/stickypanel.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css',
            ],
            names: [],
            mappings:
              'AAMC,qDAEC,cAAe,CACf,KAAM,CAFN,yBAGD,CAEA,kEAEC,iBAAkB,CADlB,QAED,CCPA,qDAIC,wBAAyB,CACzB,yBAA0B,CAF1B,sBAAuB,CCFxB,oCDKA',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-sticky-panel {\n\t& .ck-sticky-panel__content_sticky {\n\t\tz-index: var(--ck-z-modal); /* #315 */\n\t\tposition: fixed;\n\t\ttop: 0;\n\t}\n\n\t& .ck-sticky-panel__content_sticky_bottom-limit {\n\t\ttop: auto;\n\t\tposition: absolute;\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_shadow.css";\n\n.ck.ck-sticky-panel {\n\t& .ck-sticky-panel__content_sticky {\n\t\t@mixin ck-drop-shadow;\n\n\t\tborder-width: 0 1px 1px;\n\t\tborder-top-left-radius: 0;\n\t\tborder-top-right-radius: 0;\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n',
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      6603: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          '.ck-vertical-form .ck-button:after{bottom:-1px;content:"";position:absolute;right:-1px;top:-1px;width:0;z-index:1}.ck-vertical-form .ck-button:focus:after{display:none}@media screen and (max-width:600px){.ck.ck-responsive-form .ck-button:after{bottom:-1px;content:"";position:absolute;right:-1px;top:-1px;width:0;z-index:1}.ck.ck-responsive-form .ck-button:focus:after{display:none}}.ck-vertical-form>.ck-button:nth-last-child(2):after{border-right:1px solid var(--ck-color-base-border)}.ck.ck-responsive-form{padding:var(--ck-spacing-large)}.ck.ck-responsive-form:focus{outline:none}[dir=ltr] .ck.ck-responsive-form>:not(:first-child),[dir=rtl] .ck.ck-responsive-form>:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-responsive-form{padding:0;width:calc(var(--ck-input-width)*.8)}.ck.ck-responsive-form .ck-labeled-field-view{margin:var(--ck-spacing-large) var(--ck-spacing-large) 0}.ck.ck-responsive-form .ck-labeled-field-view .ck-input-text{min-width:0;width:100%}.ck.ck-responsive-form .ck-labeled-field-view .ck-labeled-field-view__error{white-space:normal}.ck.ck-responsive-form>.ck-button:nth-last-child(2):after{border-right:1px solid var(--ck-color-base-border)}.ck.ck-responsive-form>.ck-button:last-child,.ck.ck-responsive-form>.ck-button:nth-last-child(2){border-radius:0;margin-top:var(--ck-spacing-large);padding:var(--ck-spacing-standard)}.ck.ck-responsive-form>.ck-button:last-child:not(:focus),.ck.ck-responsive-form>.ck-button:nth-last-child(2):not(:focus){border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck.ck-responsive-form>.ck-button:last-child,[dir=ltr] .ck.ck-responsive-form>.ck-button:nth-last-child(2),[dir=rtl] .ck.ck-responsive-form>.ck-button:last-child,[dir=rtl] .ck.ck-responsive-form>.ck-button:nth-last-child(2){margin-left:0}[dir=rtl] .ck.ck-responsive-form>.ck-button:last-child:last-of-type,[dir=rtl] .ck.ck-responsive-form>.ck-button:nth-last-child(2):last-of-type{border-right:1px solid var(--ck-color-base-border)}}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/responsive-form/responsiveform.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/responsive-form/responsiveform.css',
            ],
            names: [],
            mappings:
              'AAQC,mCAMC,WAAY,CALZ,UAAW,CAEX,iBAAkB,CAClB,UAAW,CACX,QAAS,CAHT,OAAQ,CAKR,SACD,CAEA,yCACC,YACD,CCdA,oCDoBE,wCAMC,WAAY,CALZ,UAAW,CAEX,iBAAkB,CAClB,UAAW,CACX,QAAS,CAHT,OAAQ,CAKR,SACD,CAEA,8CACC,YACD,CC9BF,CCAD,qDACC,kDACD,CAEA,uBACC,+BAmED,CAjEC,6BAEC,YACD,CASC,uGACC,sCACD,CDvBD,oCCMD,uBAqBE,SAAU,CACV,oCA8CF,CA5CE,8CACC,wDAWD,CATC,6DACC,WAAY,CACZ,UACD,CAGA,4EACC,kBACD,CAKA,0DACC,kDACD,CAGD,iGAIC,eAAgB,CADhB,kCAAmC,CADnC,kCAmBD,CAfC,yHACC,gDACD,CARD,0OAeE,aAMF,CAJE,+IACC,kDACD,CDpEH',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck-vertical-form .ck-button {\n\t&::after {\n\t\tcontent: "";\n\t\twidth: 0;\n\t\tposition: absolute;\n\t\tright: -1px;\n\t\ttop: -1px;\n\t\tbottom: -1px;\n\t\tz-index: 1;\n\t}\n\n\t&:focus::after {\n\t\tdisplay: none;\n\t}\n}\n\n.ck.ck-responsive-form {\n\t@mixin ck-media-phone {\n\t\t& .ck-button {\n\t\t\t&::after {\n\t\t\t\tcontent: "";\n\t\t\t\twidth: 0;\n\t\t\t\tposition: absolute;\n\t\t\t\tright: -1px;\n\t\t\t\ttop: -1px;\n\t\t\t\tbottom: -1px;\n\t\t\t\tz-index: 1;\n\t\t\t}\n\n\t\t\t&:focus::after {\n\t\t\t\tdisplay: none;\n\t\t\t}\n\t\t}\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck-vertical-form > .ck-button:nth-last-child(2)::after {\n\tborder-right: 1px solid var(--ck-color-base-border);\n}\n\n.ck.ck-responsive-form {\n\tpadding: var(--ck-spacing-large);\n\n\t&:focus {\n\t\t/* See: https://github.com/ckeditor/ckeditor5/issues/4773 */\n\t\toutline: none;\n\t}\n\n\t@mixin ck-dir ltr {\n\t\t& > :not(:first-child) {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-dir rtl {\n\t\t& > :not(:last-child) {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-media-phone {\n\t\tpadding: 0;\n\t\twidth: calc(.8 * var(--ck-input-width));\n\n\t\t& .ck-labeled-field-view {\n\t\t\tmargin: var(--ck-spacing-large) var(--ck-spacing-large) 0;\n\n\t\t\t& .ck-input-text {\n\t\t\t\tmin-width: 0;\n\t\t\t\twidth: 100%;\n\t\t\t}\n\n\t\t\t/* Let the long error messages wrap in the narrow form. */\n\t\t\t& .ck-labeled-field-view__error {\n\t\t\t\twhite-space: normal;\n\t\t\t}\n\t\t}\n\n\t\t/* Styles for two last buttons in the form (save&cancel, edit&unlink, etc.). */\n\t\t& > .ck-button:nth-last-child(2) {\n\t\t\t&::after {\n\t\t\t\tborder-right: 1px solid var(--ck-color-base-border);\n\t\t\t}\n\t\t}\n\n\t\t& > .ck-button:nth-last-child(1),\n\t\t& > .ck-button:nth-last-child(2) {\n\t\t\tpadding: var(--ck-spacing-standard);\n\t\t\tmargin-top: var(--ck-spacing-large);\n\t\t\tborder-radius: 0;\n\n\t\t\t&:not(:focus) {\n\t\t\t\tborder-top: 1px solid var(--ck-color-base-border);\n\t\t\t}\n\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tmargin-left: 0;\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tmargin-left: 0;\n\n\t\t\t\t&:last-of-type {\n\t\t\t\t\tborder-right: 1px solid var(--ck-color-base-border);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      4176: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          '.ck.ck-block-toolbar-button{position:absolute;z-index:var(--ck-z-default)}:root{--ck-color-block-toolbar-button:var(--ck-color-text);--ck-block-toolbar-button-size:var(--ck-font-size-normal)}.ck.ck-block-toolbar-button{color:var(--ck-color-block-toolbar-button);font-size:var(--ck-block-toolbar-size)}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/toolbar/blocktoolbar.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/toolbar/blocktoolbar.css',
            ],
            names: [],
            mappings: 'AAKA,4BACC,iBAAkB,CAClB,2BACD,CCHA,MACC,oDAAqD,CACrD,yDACD,CAEA,4BACC,0CAA2C,CAC3C,sCACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-block-toolbar-button {\n\tposition: absolute;\n\tz-index: var(--ck-z-default);\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-block-toolbar-button: var(--ck-color-text);\n\t--ck-block-toolbar-button-size: var(--ck-font-size-normal);\n}\n\n.ck.ck-block-toolbar-button {\n\tcolor: var(--ck-color-block-toolbar-button);\n\tfont-size: var(--ck-block-toolbar-size);\n}\n',
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      4768: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          '.ck.ck-toolbar{align-items:center;display:flex;flex-flow:row nowrap;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-toolbar>.ck-toolbar__items{align-items:center;display:flex;flex-flow:row wrap;flex-grow:1}.ck.ck-toolbar .ck.ck-toolbar__separator{display:inline-block}.ck.ck-toolbar .ck.ck-toolbar__separator:first-child,.ck.ck-toolbar .ck.ck-toolbar__separator:last-child{display:none}.ck.ck-toolbar .ck-toolbar__line-break{flex-basis:100%}.ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items{flex-direction:column}.ck.ck-toolbar.ck-toolbar_floating>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck-dropdown__button .ck-dropdown__arrow{display:none}.ck.ck-toolbar{border-radius:0}.ck-rounded-corners .ck.ck-toolbar,.ck.ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-toolbar{background:var(--ck-color-toolbar-background);border:1px solid var(--ck-color-toolbar-border);padding:0 var(--ck-spacing-small)}.ck.ck-toolbar .ck.ck-toolbar__separator{align-self:stretch;background:var(--ck-color-toolbar-border);margin-bottom:var(--ck-spacing-small);margin-top:var(--ck-spacing-small);min-width:1px;width:1px}.ck.ck-toolbar .ck-toolbar__line-break{height:0}.ck.ck-toolbar>.ck-toolbar__items>:not(.ck-toolbar__line-break){margin-right:var(--ck-spacing-small)}.ck.ck-toolbar>.ck-toolbar__items:empty+.ck.ck-toolbar__separator{display:none}.ck.ck-toolbar>.ck-toolbar__items>:not(.ck-toolbar__line-break),.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown{margin-bottom:var(--ck-spacing-small);margin-top:var(--ck-spacing-small)}.ck.ck-toolbar.ck-toolbar_vertical{padding:0}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items>.ck{border-radius:0;margin:0;width:100%}.ck.ck-toolbar.ck-toolbar_compact{padding:0}.ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>*{margin:0}.ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>:not(:first-child):not(:last-child){border-radius:0}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck.ck-button.ck-dropdown__button{padding-left:var(--ck-spacing-tiny)}.ck.ck-toolbar .ck-toolbar__nested-toolbar-dropdown>.ck-dropdown__panel{min-width:auto}.ck.ck-toolbar .ck-toolbar__nested-toolbar-dropdown>.ck-button>.ck-button__label{max-width:7em;width:auto}.ck.ck-toolbar:focus{outline:none}.ck-toolbar-container .ck.ck-toolbar{border:0}.ck.ck-toolbar[dir=rtl]>.ck-toolbar__items>.ck,[dir=rtl] .ck.ck-toolbar>.ck-toolbar__items>.ck{margin-right:0}.ck.ck-toolbar[dir=rtl]:not(.ck-toolbar_compact)>.ck-toolbar__items>.ck,[dir=rtl] .ck.ck-toolbar:not(.ck-toolbar_compact)>.ck-toolbar__items>.ck{margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=rtl]>.ck-toolbar__items>.ck:last-child,[dir=rtl] .ck.ck-toolbar>.ck-toolbar__items>.ck:last-child{margin-left:0}.ck.ck-toolbar.ck-toolbar_compact[dir=rtl]>.ck-toolbar__items>.ck:first-child,[dir=rtl] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:first-child{border-bottom-left-radius:0;border-top-left-radius:0}.ck.ck-toolbar.ck-toolbar_compact[dir=rtl]>.ck-toolbar__items>.ck:last-child,[dir=rtl] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:last-child{border-bottom-right-radius:0;border-top-right-radius:0}.ck.ck-toolbar.ck-toolbar_grouping[dir=rtl]>.ck-toolbar__items:not(:empty):not(:only-child),.ck.ck-toolbar[dir=rtl]>.ck.ck-toolbar__separator,[dir=rtl] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child),[dir=rtl] .ck.ck-toolbar>.ck.ck-toolbar__separator{margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=ltr]>.ck-toolbar__items>.ck:last-child,[dir=ltr] .ck.ck-toolbar>.ck-toolbar__items>.ck:last-child{margin-right:0}.ck.ck-toolbar.ck-toolbar_compact[dir=ltr]>.ck-toolbar__items>.ck:first-child,[dir=ltr] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:first-child{border-bottom-right-radius:0;border-top-right-radius:0}.ck.ck-toolbar.ck-toolbar_compact[dir=ltr]>.ck-toolbar__items>.ck:last-child,[dir=ltr] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:last-child{border-bottom-left-radius:0;border-top-left-radius:0}.ck.ck-toolbar.ck-toolbar_grouping[dir=ltr]>.ck-toolbar__items:not(:empty):not(:only-child),.ck.ck-toolbar[dir=ltr]>.ck.ck-toolbar__separator,[dir=ltr] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child),[dir=ltr] .ck.ck-toolbar>.ck.ck-toolbar__separator{margin-right:var(--ck-spacing-small)}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/toolbar/toolbar.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/toolbar/toolbar.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css',
            ],
            names: [],
            mappings:
              'AAOA,eAKC,kBAAmB,CAFnB,YAAa,CACb,oBAAqB,CCFrB,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBD6CD,CA3CC,kCAGC,kBAAmB,CAFnB,YAAa,CACb,kBAAmB,CAEnB,WAED,CAEA,yCACC,oBAWD,CAJC,yGAEC,YACD,CAGD,uCACC,eACD,CAEA,sDACC,gBACD,CAEA,sDACC,qBACD,CAEA,sDACC,gBACD,CAGC,yFACC,YACD,CE/CF,eCGC,eDwGD,CA3GA,qECOE,qCDoGF,CA3GA,eAGC,6CAA8C,CAE9C,+CAAgD,CADhD,iCAuGD,CApGC,yCACC,kBAAmB,CAGnB,yCAA0C,CAO1C,qCAAsC,CADtC,kCAAmC,CAPnC,aAAc,CADd,SAUD,CAEA,uCACC,QACD,CAGC,gEAEC,oCACD,CAIA,kEACC,YACD,CAGD,gHAIC,qCAAsC,CADtC,kCAED,CAEA,mCAEC,SAaD,CAVC,0DAQC,eAAgB,CAHhB,QAAS,CAHT,UAOD,CAGD,kCAEC,SAWD,CATC,uDAEC,QAMD,CAHC,yFACC,eACD,CASD,kFACC,mCACD,CAMA,wEACC,cACD,CAEA,iFACC,aAAc,CACd,UACD,CAGD,qBACC,YACD,CAtGD,qCAyGE,QAEF,CAYC,+FACC,cACD,CAEA,iJAEC,mCACD,CAEA,qHACC,aACD,CAIC,6JAEC,2BAA4B,CAD5B,wBAED,CAGA,2JAEC,4BAA6B,CAD7B,yBAED,CASD,8RACC,mCACD,CAWA,qHACC,cACD,CAIC,6JAEC,4BAA6B,CAD7B,yBAED,CAGA,2JAEC,2BAA4B,CAD5B,wBAED,CASD,8RACC,oCACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../mixins/_unselectable.css";\n\n.ck.ck-toolbar {\n\t@mixin ck-unselectable;\n\n\tdisplay: flex;\n\tflex-flow: row nowrap;\n\talign-items: center;\n\n\t& > .ck-toolbar__items {\n\t\tdisplay: flex;\n\t\tflex-flow: row wrap;\n\t\talign-items: center;\n\t\tflex-grow: 1;\n\n\t}\n\n\t& .ck.ck-toolbar__separator {\n\t\tdisplay: inline-block;\n\n\t\t/*\n\t\t * A leading or trailing separator makes no sense (separates from nothing on one side).\n\t\t * For instance, it can happen when toolbar items (also separators) are getting grouped one by one and\n\t\t * moved to another toolbar in the dropdown.\n\t\t */\n\t\t&:first-child,\n\t\t&:last-child {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n\n\t& .ck-toolbar__line-break {\n\t\tflex-basis: 100%;\n\t}\n\n\t&.ck-toolbar_grouping > .ck-toolbar__items {\n\t\tflex-wrap: nowrap;\n\t}\n\n\t&.ck-toolbar_vertical > .ck-toolbar__items {\n\t\tflex-direction: column;\n\t}\n\n\t&.ck-toolbar_floating > .ck-toolbar__items {\n\t\tflex-wrap: nowrap;\n\t}\n\n\t& > .ck.ck-toolbar__grouped-dropdown {\n\t\t& > .ck-dropdown__button .ck-dropdown__arrow {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Makes element unselectable.\n */\n@define-mixin ck-unselectable {\n\t-moz-user-select: none;\n\t-webkit-user-select: none;\n\t-ms-user-select: none;\n\tuser-select: none\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck.ck-toolbar {\n\t@mixin ck-rounded-corners;\n\n\tbackground: var(--ck-color-toolbar-background);\n\tpadding: 0 var(--ck-spacing-small);\n\tborder: 1px solid var(--ck-color-toolbar-border);\n\n\t& .ck.ck-toolbar__separator {\n\t\talign-self: stretch;\n\t\twidth: 1px;\n\t\tmin-width: 1px;\n\t\tbackground: var(--ck-color-toolbar-border);\n\n\t\t/*\n\t\t * These margins make the separators look better in balloon toolbars (when aligned with the "tip").\n\t\t * See https://github.com/ckeditor/ckeditor5/issues/7493.\n\t\t */\n\t\tmargin-top: var(--ck-spacing-small);\n\t\tmargin-bottom: var(--ck-spacing-small);\n\t}\n\n\t& .ck-toolbar__line-break {\n\t\theight: 0;\n\t}\n\n\t& > .ck-toolbar__items {\n\t\t& > *:not(.ck-toolbar__line-break) {\n\t\t\t/* (#11) Separate toolbar items. */\n\t\t\tmargin-right: var(--ck-spacing-small);\n\t\t}\n\n\t\t/* Don\'t display a separator after an empty items container, for instance,\n\t\twhen all items were grouped */\n\t\t&:empty + .ck.ck-toolbar__separator {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n\n\t& > .ck-toolbar__items > *:not(.ck-toolbar__line-break),\n\t& > .ck.ck-toolbar__grouped-dropdown {\n\t\t/* Make sure items wrapped to the next line have v-spacing */\n\t\tmargin-top: var(--ck-spacing-small);\n\t\tmargin-bottom: var(--ck-spacing-small);\n\t}\n\n\t&.ck-toolbar_vertical {\n\t\t/* Items in a vertical toolbar span the entire width. */\n\t\tpadding: 0;\n\n\t\t/* Specificity matters here. See https://github.com/ckeditor/ckeditor5-theme-lark/issues/168. */\n\t\t& > .ck-toolbar__items > .ck {\n\t\t\t/* Items in a vertical toolbar should span the horizontal space. */\n\t\t\twidth: 100%;\n\n\t\t\t/* Items in a vertical toolbar should have no margin. */\n\t\t\tmargin: 0;\n\n\t\t\t/* Items in a vertical toolbar span the entire width so rounded corners are pointless. */\n\t\t\tborder-radius: 0;\n\t\t}\n\t}\n\n\t&.ck-toolbar_compact {\n\t\t/* No spacing around items. */\n\t\tpadding: 0;\n\n\t\t& > .ck-toolbar__items > * {\n\t\t\t/* Compact toolbar items have no spacing between them. */\n\t\t\tmargin: 0;\n\n\t\t\t/* "Middle" children should have no rounded corners. */\n\t\t\t&:not(:first-child):not(:last-child) {\n\t\t\t\tborder-radius: 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t& > .ck.ck-toolbar__grouped-dropdown {\n\t\t/*\n\t\t * Dropdown button has asymmetric padding to fit the arrow.\n\t\t * This button has no arrow so let\'s revert that padding back to normal.\n\t\t */\n\t\t& > .ck.ck-button.ck-dropdown__button {\n\t\t\tpadding-left: var(--ck-spacing-tiny);\n\t\t}\n\t}\n\n\t/* A drop-down containing the nested toolbar with configured items. */\n\t& .ck-toolbar__nested-toolbar-dropdown {\n\t\t/* Prevent empty space in the panel when the dropdown label is visible and long but the toolbar has few items. */\n\t\t& > .ck-dropdown__panel {\n\t\t\tmin-width: auto;\n\t\t}\n\n\t\t& > .ck-button > .ck-button__label {\n\t\t\tmax-width: 7em;\n\t\t\twidth: auto;\n\t\t}\n\t}\n\n\t&:focus {\n\t\toutline: none;\n\t}\n\n\t@nest .ck-toolbar-container & {\n\t\tborder: 0;\n\t}\n}\n\n/* stylelint-disable */\n\n/*\n * Styles for RTL toolbars.\n *\n * Note: In some cases (e.g. a decoupled editor), the toolbar has its own "dir"\n * because its parent is not controlled by the editor framework.\n */\n[dir="rtl"] .ck.ck-toolbar,\n.ck.ck-toolbar[dir="rtl"] {\n\t& > .ck-toolbar__items > .ck {\n\t\tmargin-right: 0;\n\t}\n\n\t&:not(.ck-toolbar_compact) > .ck-toolbar__items > .ck {\n\t\t/* (#11) Separate toolbar items. */\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n\n\t& > .ck-toolbar__items > .ck:last-child {\n\t\tmargin-left: 0;\n\t}\n\n\t&.ck-toolbar_compact > .ck-toolbar__items > .ck {\n\t\t/* No rounded corners on the right side of the first child. */\n\t\t&:first-child {\n\t\t\tborder-top-left-radius: 0;\n\t\t\tborder-bottom-left-radius: 0;\n\t\t}\n\n\t\t/* No rounded corners on the left side of the last child. */\n\t\t&:last-child {\n\t\t\tborder-top-right-radius: 0;\n\t\t\tborder-bottom-right-radius: 0;\n\t\t}\n\t}\n\n\t/* Separate the the separator form the grouping dropdown when some items are grouped. */\n\t& > .ck.ck-toolbar__separator {\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n\n\t/* Some spacing between the items and the separator before the grouped items dropdown. */\n\t&.ck-toolbar_grouping > .ck-toolbar__items:not(:empty):not(:only-child) {\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n}\n\n/*\n * Styles for LTR toolbars.\n *\n * Note: In some cases (e.g. a decoupled editor), the toolbar has its own "dir"\n * because its parent is not controlled by the editor framework.\n */\n[dir="ltr"] .ck.ck-toolbar,\n.ck.ck-toolbar[dir="ltr"] {\n\t& > .ck-toolbar__items > .ck:last-child {\n\t\tmargin-right: 0;\n\t}\n\n\t&.ck-toolbar_compact > .ck-toolbar__items > .ck {\n\t\t/* No rounded corners on the right side of the first child. */\n\t\t&:first-child {\n\t\t\tborder-top-right-radius: 0;\n\t\t\tborder-bottom-right-radius: 0;\n\t\t}\n\n\t\t/* No rounded corners on the left side of the last child. */\n\t\t&:last-child {\n\t\t\tborder-top-left-radius: 0;\n\t\t\tborder-bottom-left-radius: 0;\n\t\t}\n\t}\n\n\t/* Separate the the separator form the grouping dropdown when some items are grouped. */\n\t& > .ck.ck-toolbar__separator {\n\t\tmargin-right: var(--ck-spacing-small);\n\t}\n\n\t/* Some spacing between the items and the separator before the grouped items dropdown. */\n\t&.ck-toolbar_grouping > .ck-toolbar__items:not(:empty):not(:only-child) {\n\t\tmargin-right: var(--ck-spacing-small);\n\t}\n}\n\n/* stylelint-enable */\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      3888: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          '.ck.ck-balloon-panel.ck-tooltip{--ck-balloon-border-width:0px;--ck-balloon-arrow-offset:0px;--ck-balloon-arrow-half-width:4px;--ck-balloon-arrow-height:4px;--ck-color-panel-background:var(--ck-color-tooltip-background);padding:0 var(--ck-spacing-medium);pointer-events:none;z-index:calc(var(--ck-z-modal) + 100)}.ck.ck-balloon-panel.ck-tooltip .ck-tooltip__text{color:var(--ck-color-tooltip-text);font-size:.9em;line-height:1.5}.ck.ck-balloon-panel.ck-tooltip{box-shadow:none}.ck.ck-balloon-panel.ck-tooltip:before{display:none}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/tooltip/tooltip.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/tooltip/tooltip.css',
            ],
            names: [],
            mappings:
              'AAKA,gCCGC,6BAA8B,CAC9B,6BAA8B,CAC9B,iCAAkC,CAClC,6BAA8B,CAC9B,8DAA+D,CAE/D,kCAAmC,CDPnC,mBAAoB,CAEpB,qCACD,CCMC,kDAGC,kCAAmC,CAFnC,cAAe,CACf,eAED,CAbD,gCAgBC,eAMD,CAHC,uCACC,YACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-balloon-panel.ck-tooltip {\n\t/* Keep tooltips transparent for any interactions. */\n\tpointer-events: none;\n\n\tz-index: calc( var(--ck-z-modal) + 100 );\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n.ck.ck-balloon-panel.ck-tooltip {\n\t--ck-balloon-border-width: 0px;\n\t--ck-balloon-arrow-offset: 0px;\n\t--ck-balloon-arrow-half-width: 4px;\n\t--ck-balloon-arrow-height: 4px;\n\t--ck-color-panel-background: var(--ck-color-tooltip-background);\n\n\tpadding: 0 var(--ck-spacing-medium);\n\n\t& .ck-tooltip__text {\n\t\tfont-size: .9em;\n\t\tline-height: 1.5;\n\t\tcolor: var(--ck-color-tooltip-text);\n\t}\n\n\t/* Reset balloon panel styles */\n\tbox-shadow: none;\n\n\t/* Hide the default shadow of the .ck-balloon-panel tip */\n\t&::before {\n\t\tdisplay: none;\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      5167: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          '.ck-hidden{display:none!important}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset,.ck.ck-reset_all{box-sizing:border-box;height:auto;position:static;width:auto}:root{--ck-z-default:1;--ck-z-modal:calc(var(--ck-z-default) + 999)}.ck-transitions-disabled,.ck-transitions-disabled *{transition:none!important}:root{--ck-powered-by-line-height:10px;--ck-powered-by-padding-vertical:2px;--ck-powered-by-padding-horizontal:4px;--ck-powered-by-text-color:#4f4f4f;--ck-powered-by-border-radius:var(--ck-border-radius);--ck-powered-by-background:#fff;--ck-powered-by-border-color:var(--ck-color-focus-border)}.ck.ck-balloon-panel.ck-powered-by-balloon{--ck-border-radius:var(--ck-powered-by-border-radius);background:var(--ck-powered-by-background);box-shadow:none;min-height:unset;z-index:calc(var(--ck-z-modal) - 1)}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by{line-height:var(--ck-powered-by-line-height)}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by a{align-items:center;cursor:pointer;display:flex;filter:grayscale(80%);line-height:var(--ck-powered-by-line-height);opacity:.66;padding:var(--ck-powered-by-padding-vertical) var(--ck-powered-by-padding-horizontal)}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by .ck-powered-by__label{color:var(--ck-powered-by-text-color);cursor:pointer;font-size:7.5px;font-weight:700;letter-spacing:-.2px;line-height:normal;margin-right:4px;padding-left:2px;text-transform:uppercase}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by .ck-icon{cursor:pointer;display:block}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by:hover a{filter:grayscale(0);opacity:1}.ck.ck-balloon-panel.ck-powered-by-balloon[class*=position_inside]{border-color:transparent}.ck.ck-balloon-panel.ck-powered-by-balloon[class*=position_border]{border:var(--ck-focus-ring);border-color:var(--ck-powered-by-border-color)}:root{--ck-color-base-foreground:#fafafa;--ck-color-base-background:#fff;--ck-color-base-border:#ccced1;--ck-color-base-action:#53a336;--ck-color-base-focus:#6cb5f9;--ck-color-base-text:#333;--ck-color-base-active:#2977ff;--ck-color-base-active-focus:#0d65ff;--ck-color-base-error:#db3700;--ck-color-focus-border-coordinates:218,81.8%,56.9%;--ck-color-focus-border:hsl(var(--ck-color-focus-border-coordinates));--ck-color-focus-outer-shadow:#cae1fc;--ck-color-focus-disabled-shadow:rgba(119,186,248,.3);--ck-color-focus-error-shadow:rgba(255,64,31,.3);--ck-color-text:var(--ck-color-base-text);--ck-color-shadow-drop:rgba(0,0,0,.15);--ck-color-shadow-drop-active:rgba(0,0,0,.2);--ck-color-shadow-inner:rgba(0,0,0,.1);--ck-color-button-default-background:transparent;--ck-color-button-default-hover-background:#f0f0f0;--ck-color-button-default-active-background:#f0f0f0;--ck-color-button-default-disabled-background:transparent;--ck-color-button-on-background:#f0f7ff;--ck-color-button-on-hover-background:#dbecff;--ck-color-button-on-active-background:#dbecff;--ck-color-button-on-disabled-background:#f0f2f4;--ck-color-button-on-color:#2977ff;--ck-color-button-action-background:var(--ck-color-base-action);--ck-color-button-action-hover-background:#4d9d30;--ck-color-button-action-active-background:#4d9d30;--ck-color-button-action-disabled-background:#7ec365;--ck-color-button-action-text:var(--ck-color-base-background);--ck-color-button-save:#008a00;--ck-color-button-cancel:#db3700;--ck-color-switch-button-off-background:#939393;--ck-color-switch-button-off-hover-background:#7d7d7d;--ck-color-switch-button-on-background:var(--ck-color-button-action-background);--ck-color-switch-button-on-hover-background:#4d9d30;--ck-color-switch-button-inner-background:var(--ck-color-base-background);--ck-color-switch-button-inner-shadow:rgba(0,0,0,.1);--ck-color-dropdown-panel-background:var(--ck-color-base-background);--ck-color-dropdown-panel-border:var(--ck-color-base-border);--ck-color-input-background:var(--ck-color-base-background);--ck-color-input-border:var(--ck-color-base-border);--ck-color-input-error-border:var(--ck-color-base-error);--ck-color-input-text:var(--ck-color-base-text);--ck-color-input-disabled-background:#f2f2f2;--ck-color-input-disabled-border:var(--ck-color-base-border);--ck-color-input-disabled-text:#757575;--ck-color-list-background:var(--ck-color-base-background);--ck-color-list-button-hover-background:var(--ck-color-button-default-hover-background);--ck-color-list-button-on-background:var(--ck-color-button-on-color);--ck-color-list-button-on-background-focus:var(--ck-color-button-on-color);--ck-color-list-button-on-text:var(--ck-color-base-background);--ck-color-panel-background:var(--ck-color-base-background);--ck-color-panel-border:var(--ck-color-base-border);--ck-color-toolbar-background:var(--ck-color-base-background);--ck-color-toolbar-border:var(--ck-color-base-border);--ck-color-tooltip-background:var(--ck-color-base-text);--ck-color-tooltip-text:var(--ck-color-base-background);--ck-color-engine-placeholder-text:#707070;--ck-color-upload-bar-background:#6cb5f9;--ck-color-link-default:#0000f0;--ck-color-link-selected-background:rgba(31,176,255,.1);--ck-color-link-fake-selection:rgba(31,176,255,.3);--ck-color-highlight-background:#ff0;--ck-disabled-opacity:.5;--ck-focus-outer-shadow-geometry:0 0 0 3px;--ck-focus-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-outer-shadow);--ck-focus-disabled-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-disabled-shadow);--ck-focus-error-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-error-shadow);--ck-focus-ring:1px solid var(--ck-color-focus-border);--ck-font-size-base:13px;--ck-line-height-base:1.84615;--ck-font-face:Helvetica,Arial,Tahoma,Verdana,Sans-Serif;--ck-font-size-tiny:0.7em;--ck-font-size-small:0.75em;--ck-font-size-normal:1em;--ck-font-size-big:1.4em;--ck-font-size-large:1.8em;--ck-ui-component-min-height:2.3em}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset,.ck.ck-reset_all{word-wrap:break-word;background:transparent;border:0;margin:0;padding:0;text-decoration:none;transition:none;vertical-align:middle}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset_all{border-collapse:collapse;color:var(--ck-color-text);cursor:auto;float:none;font:normal normal normal var(--ck-font-size-base)/var(--ck-line-height-base) var(--ck-font-face);text-align:left;white-space:nowrap}.ck-reset_all .ck-rtl :not(.ck-reset_all-excluded *){text-align:right}.ck-reset_all iframe:not(.ck-reset_all-excluded *){vertical-align:inherit}.ck-reset_all textarea:not(.ck-reset_all-excluded *){white-space:pre-wrap}.ck-reset_all input[type=password]:not(.ck-reset_all-excluded *),.ck-reset_all input[type=text]:not(.ck-reset_all-excluded *),.ck-reset_all textarea:not(.ck-reset_all-excluded *){cursor:text}.ck-reset_all input[type=password][disabled]:not(.ck-reset_all-excluded *),.ck-reset_all input[type=text][disabled]:not(.ck-reset_all-excluded *),.ck-reset_all textarea[disabled]:not(.ck-reset_all-excluded *){cursor:default}.ck-reset_all fieldset:not(.ck-reset_all-excluded *){border:2px groove #dfdee3;padding:10px}.ck-reset_all button:not(.ck-reset_all-excluded *)::-moz-focus-inner{border:0;padding:0}.ck[dir=rtl],.ck[dir=rtl] .ck{text-align:right}:root{--ck-border-radius:2px;--ck-inner-shadow:2px 2px 3px var(--ck-color-shadow-inner) inset;--ck-drop-shadow:0 1px 2px 1px var(--ck-color-shadow-drop);--ck-drop-shadow-active:0 3px 6px 1px var(--ck-color-shadow-drop-active);--ck-spacing-unit:0.6em;--ck-spacing-large:calc(var(--ck-spacing-unit)*1.5);--ck-spacing-standard:var(--ck-spacing-unit);--ck-spacing-medium:calc(var(--ck-spacing-unit)*0.8);--ck-spacing-small:calc(var(--ck-spacing-unit)*0.5);--ck-spacing-tiny:calc(var(--ck-spacing-unit)*0.3);--ck-spacing-extra-tiny:calc(var(--ck-spacing-unit)*0.16)}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/globals/_hidden.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/globals/_reset.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/globals/_zindex.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/globals/_transition.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/globals/_poweredby.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_colors.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_disabled.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_focus.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_fonts.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_reset.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_rounded.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_shadow.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_spacing.css',
            ],
            names: [],
            mappings:
              'AAQA,WAGC,sBACD,CCPA,2EAGC,qBAAsB,CAEtB,WAAY,CACZ,eAAgB,CAFhB,UAGD,CCPA,MACC,gBAAiB,CACjB,4CACD,CCAA,oDAEC,yBACD,CCNA,MACC,gCAAiC,CACjC,oCAAqC,CACrC,sCAAuC,CACvC,kCAA2C,CAC3C,qDAAsD,CACtD,+BAA4C,CAC5C,yDACD,CAEA,2CACC,qDAAsD,CAGtD,0CAA2C,CAD3C,eAAgB,CAEhB,gBAAiB,CACjB,mCAiDD,CA/CC,6DACC,4CAoCD,CAlCC,+DAGC,kBAAmB,CAFnB,cAAe,CACf,YAAa,CAGb,qBAAsB,CACtB,4CAA6C,CAF7C,WAAY,CAGZ,qFACD,CAEA,mFASC,qCAAsC,CAFtC,cAAe,CANf,eAAgB,CAIhB,eAAiB,CAHjB,oBAAqB,CAMrB,kBAAmB,CAFnB,gBAAiB,CAHjB,gBAAiB,CACjB,wBAOD,CAEA,sEAEC,cAAe,CADf,aAED,CAGC,qEACC,mBAAqB,CACrB,SACD,CAIF,mEACC,wBACD,CAEA,mEACC,2BAA4B,CAC5B,8CACD,CChED,MACC,kCAAmD,CACnD,+BAAoD,CACpD,8BAAkD,CAClD,8BAAuD,CACvD,6BAAmD,CACnD,yBAA+C,CAC/C,8BAAsD,CACtD,oCAA4D,CAC5D,6BAAkD,CAIlD,mDAA4D,CAC5D,qEAA+E,CAC/E,qCAA4D,CAC5D,qDAA8D,CAC9D,gDAAyD,CACzD,yCAAqD,CACrD,sCAAsD,CACtD,4CAA0D,CAC1D,sCAAsD,CAItD,gDAAuD,CACvD,kDAAiE,CACjE,mDAAkE,CAClE,yDAA8D,CAE9D,uCAA6D,CAC7D,6CAAoE,CACpE,8CAAoE,CACpE,gDAAiE,CACjE,kCAAyD,CAGzD,+DAAsE,CACtE,iDAAsE,CACtE,kDAAsE,CACtE,oDAAoE,CACpE,6DAAsE,CAEtE,8BAAoD,CACpD,gCAAqD,CAErD,+CAA8D,CAC9D,qDAAiE,CACjE,+EAAqF,CACrF,oDAAuE,CACvE,yEAA8E,CAC9E,oDAAgE,CAIhE,oEAA2E,CAC3E,4DAAoE,CAIpE,2DAAoE,CACpE,mDAA6D,CAC7D,wDAAgE,CAChE,+CAA0D,CAC1D,4CAA2D,CAC3D,4DAAoE,CACpE,sCAAsD,CAItD,0DAAmE,CACnE,uFAA6F,CAC7F,oEAA2E,CAC3E,0EAA+E,CAC/E,8DAAsE,CAItE,2DAAoE,CACpE,mDAA6D,CAI7D,6DAAsE,CACtE,qDAA+D,CAI/D,uDAAgE,CAChE,uDAAiE,CAIjE,0CAAyD,CAIzD,wCAA2D,CAI3D,+BAAoD,CACpD,uDAAmE,CACnE,kDAAgE,CAIhE,oCAAwD,CCvGxD,wBAAyB,CCAzB,0CAA2C,CAK3C,gGAAiG,CAKjG,4GAA6G,CAK7G,sGAAuG,CAKvG,sDAAuD,CCvBvD,wBAAyB,CACzB,6BAA8B,CAC9B,wDAA6D,CAE7D,yBAA0B,CAC1B,2BAA4B,CAC5B,yBAA0B,CAC1B,wBAAyB,CACzB,0BAA2B,CCJ3B,kCJuGD,CIjGA,2EAaC,oBAAqB,CANrB,sBAAuB,CADvB,QAAS,CAFT,QAAS,CACT,SAAU,CAGV,oBAAqB,CAErB,eAAgB,CADhB,qBAKD,CAKA,8DAGC,wBAAyB,CAEzB,0BAA2B,CAG3B,WAAY,CACZ,UAAW,CALX,iGAAkG,CAElG,eAAgB,CAChB,kBAGD,CAGC,qDACC,gBACD,CAEA,mDAEC,sBACD,CAEA,qDACC,oBACD,CAEA,mLAGC,WACD,CAEA,iNAGC,cACD,CAEA,qDAEC,yBAAoC,CADpC,YAED,CAEA,qEAGC,QAAQ,CADR,SAED,CAMD,8BAEC,gBACD,CCnFA,MACC,sBAAuB,CCAvB,gEAAiE,CAKjE,0DAA2D,CAK3D,wEAAyE,CCbzE,uBAA8B,CAC9B,mDAA2D,CAC3D,4CAAkD,CAClD,oDAA4D,CAC5D,mDAA2D,CAC3D,kDAA2D,CAC3D,yDFFD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which hides an element in DOM.\n */\n.ck-hidden {\n\t/* Override selector specificity. Otherwise, all elements with some display\n\tstyle defined will override this one, which is not a desired result. */\n\tdisplay: none !important;\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-reset,\n.ck.ck-reset_all,\n.ck-reset_all *:not(.ck-reset_all-excluded *) {\n\tbox-sizing: border-box;\n\twidth: auto;\n\theight: auto;\n\tposition: static;\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-z-default: 1;\n\t--ck-z-modal: calc( var(--ck-z-default) + 999 );\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class that disables all transitions of the element and its children.\n */\n.ck-transitions-disabled,\n.ck-transitions-disabled * {\n\ttransition: none !important;\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-powered-by-line-height: 10px;\n\t--ck-powered-by-padding-vertical: 2px;\n\t--ck-powered-by-padding-horizontal: 4px;\n\t--ck-powered-by-text-color: hsl(0, 0%, 31%);\n\t--ck-powered-by-border-radius: var(--ck-border-radius);\n\t--ck-powered-by-background: hsl(0, 0%, 100%);\n\t--ck-powered-by-border-color: var(--ck-color-focus-border);\n}\n\n.ck.ck-balloon-panel.ck-powered-by-balloon {\n\t--ck-border-radius: var(--ck-powered-by-border-radius);\n\n\tbox-shadow: none;\n\tbackground: var(--ck-powered-by-background);\n\tmin-height: unset;\n\tz-index: calc( var(--ck-z-modal) - 1 );\n\n\t& .ck.ck-powered-by {\n\t\tline-height: var(--ck-powered-by-line-height);\n\n\t\t& a {\n\t\t\tcursor: pointer;\n\t\t\tdisplay: flex;\n\t\t\talign-items: center;\n\t\t\topacity: .66;\n\t\t\tfilter: grayscale(80%);\n\t\t\tline-height: var(--ck-powered-by-line-height);\n\t\t\tpadding: var(--ck-powered-by-padding-vertical) var(--ck-powered-by-padding-horizontal);\n\t\t}\n\n\t\t& .ck-powered-by__label {\n\t\t\tfont-size: 7.5px;\n\t\t\tletter-spacing: -.2px;\n\t\t\tpadding-left: 2px;\n\t\t\ttext-transform: uppercase;\n\t\t\tfont-weight: bold;\n\t\t\tmargin-right: 4px;\n\t\t\tcursor: pointer;\n\t\t\tline-height: normal;\n\t\t\tcolor: var(--ck-powered-by-text-color);\n\n\t\t}\n\n\t\t& .ck-icon {\n\t\t\tdisplay: block;\n\t\t\tcursor: pointer;\n\t\t}\n\n\t\t&:hover {\n\t\t\t& a {\n\t\t\t\tfilter: grayscale(0%);\n\t\t\t\topacity: 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t&[class*="position_inside"] {\n\t\tborder-color: transparent;\n\t}\n\n\t&[class*="position_border"] {\n\t\tborder: var(--ck-focus-ring);\n\t\tborder-color: var(--ck-powered-by-border-color);\n\t}\n}\n\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-base-foreground: \t\t\t\t\t\t\t\thsl(0, 0%, 98%);\n\t--ck-color-base-background: \t\t\t\t\t\t\t\thsl(0, 0%, 100%);\n\t--ck-color-base-border: \t\t\t\t\t\t\t\t\thsl(220, 6%, 81%);\n\t--ck-color-base-action: \t\t\t\t\t\t\t\t\thsl(104, 50.2%, 42.5%);\n\t--ck-color-base-focus: \t\t\t\t\t\t\t\t\t\thsl(209, 92%, 70%);\n\t--ck-color-base-text: \t\t\t\t\t\t\t\t\t\thsl(0, 0%, 20%);\n\t--ck-color-base-active: \t\t\t\t\t\t\t\t\thsl(218.1, 100%, 58%);\n\t--ck-color-base-active-focus:\t\t\t\t\t\t\t\thsl(218.2, 100%, 52.5%);\n\t--ck-color-base-error:\t\t\t\t\t\t\t\t\t\thsl(15, 100%, 43%);\n\n\t/* -- Generic colors ------------------------------------------------------------------------ */\n\n\t--ck-color-focus-border-coordinates: \t\t\t\t\t\t218, 81.8%, 56.9%;\n\t--ck-color-focus-border: \t\t\t\t\t\t\t\t\thsl(var(--ck-color-focus-border-coordinates));\n\t--ck-color-focus-outer-shadow:\t\t\t\t\t\t\t\thsl(212.4, 89.3%, 89%);\n\t--ck-color-focus-disabled-shadow:\t\t\t\t\t\t\thsla(209, 90%, 72%,.3);\n\t--ck-color-focus-error-shadow:\t\t\t\t\t\t\t\thsla(9,100%,56%,.3);\n\t--ck-color-text: \t\t\t\t\t\t\t\t\t\t\tvar(--ck-color-base-text);\n\t--ck-color-shadow-drop: \t\t\t\t\t\t\t\t\thsla(0, 0%, 0%, 0.15);\n\t--ck-color-shadow-drop-active:\t\t\t\t\t\t\t\thsla(0, 0%, 0%, 0.2);\n\t--ck-color-shadow-inner: \t\t\t\t\t\t\t\t\thsla(0, 0%, 0%, 0.1);\n\n\t/* -- Buttons ------------------------------------------------------------------------------- */\n\n\t--ck-color-button-default-background: \t\t\t\t\t\ttransparent;\n\t--ck-color-button-default-hover-background: \t\t\t\thsl(0, 0%, 94.1%);\n\t--ck-color-button-default-active-background: \t\t\t\thsl(0, 0%, 94.1%);\n\t--ck-color-button-default-disabled-background: \t\t\t\ttransparent;\n\n\t--ck-color-button-on-background: \t\t\t\t\t\t\thsl(212, 100%, 97.1%);\n\t--ck-color-button-on-hover-background: \t\t\t\t\t\thsl(211.7, 100%, 92.9%);\n\t--ck-color-button-on-active-background: \t\t\t\t\thsl(211.7, 100%, 92.9%);\n\t--ck-color-button-on-disabled-background: \t\t\t\t\thsl(211, 15%, 95%);\n\t--ck-color-button-on-color:\t\t\t\t\t\t\t\t\thsl(218.1, 100%, 58%);\n\n\n\t--ck-color-button-action-background: \t\t\t\t\t\tvar(--ck-color-base-action);\n\t--ck-color-button-action-hover-background: \t\t\t\t\thsl(104, 53.2%, 40.2%);\n\t--ck-color-button-action-active-background: \t\t\t\thsl(104, 53.2%, 40.2%);\n\t--ck-color-button-action-disabled-background: \t\t\t\thsl(104, 44%, 58%);\n\t--ck-color-button-action-text: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\n\t--ck-color-button-save: \t\t\t\t\t\t\t\t\thsl(120, 100%, 27%);\n\t--ck-color-button-cancel: \t\t\t\t\t\t\t\t\thsl(15, 100%, 43%);\n\n\t--ck-color-switch-button-off-background:\t\t\t\t\thsl(0, 0%, 57.6%);\n\t--ck-color-switch-button-off-hover-background:\t\t\t\thsl(0, 0%, 49%);\n\t--ck-color-switch-button-on-background:\t\t\t\t\t\tvar(--ck-color-button-action-background);\n\t--ck-color-switch-button-on-hover-background:\t\t\t\thsl(104, 53.2%, 40.2%);\n\t--ck-color-switch-button-inner-background:\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-switch-button-inner-shadow:\t\t\t\t\t\thsla(0, 0%, 0%, 0.1);\n\n\t/* -- Dropdown ------------------------------------------------------------------------------ */\n\n\t--ck-color-dropdown-panel-background: \t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-dropdown-panel-border: \t\t\t\t\t\t\tvar(--ck-color-base-border);\n\n\t/* -- Input --------------------------------------------------------------------------------- */\n\n\t--ck-color-input-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-input-border: \t\t\t\t\t\t\t\t\tvar(--ck-color-base-border);\n\t--ck-color-input-error-border:\t\t\t\t\t\t\t\tvar(--ck-color-base-error);\n\t--ck-color-input-text: \t\t\t\t\t\t\t\t\t\tvar(--ck-color-base-text);\n\t--ck-color-input-disabled-background: \t\t\t\t\t\thsl(0, 0%, 95%);\n\t--ck-color-input-disabled-border: \t\t\t\t\t\t\tvar(--ck-color-base-border);\n\t--ck-color-input-disabled-text: \t\t\t\t\t\t\thsl(0, 0%, 46%);\n\n\t/* -- List ---------------------------------------------------------------------------------- */\n\n\t--ck-color-list-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-list-button-hover-background: \t\t\t\t\tvar(--ck-color-button-default-hover-background);\n\t--ck-color-list-button-on-background: \t\t\t\t\t\tvar(--ck-color-button-on-color);\n\t--ck-color-list-button-on-background-focus: \t\t\t\tvar(--ck-color-button-on-color);\n\t--ck-color-list-button-on-text:\t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\n\t/* -- Panel --------------------------------------------------------------------------------- */\n\n\t--ck-color-panel-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-panel-border: \t\t\t\t\t\t\t\t\tvar(--ck-color-base-border);\n\n\t/* -- Toolbar ------------------------------------------------------------------------------- */\n\n\t--ck-color-toolbar-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-toolbar-border: \t\t\t\t\t\t\t\t\tvar(--ck-color-base-border);\n\n\t/* -- Tooltip ------------------------------------------------------------------------------- */\n\n\t--ck-color-tooltip-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-text);\n\t--ck-color-tooltip-text: \t\t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\n\t/* -- Engine -------------------------------------------------------------------------------- */\n\n\t--ck-color-engine-placeholder-text: \t\t\t\t\t\thsl(0, 0%, 44%);\n\n\t/* -- Upload -------------------------------------------------------------------------------- */\n\n\t--ck-color-upload-bar-background:\t\t \t\t\t\t\thsl(209, 92%, 70%);\n\n\t/* -- Link -------------------------------------------------------------------------------- */\n\n\t--ck-color-link-default:\t\t\t\t\t\t\t\t\thsl(240, 100%, 47%);\n\t--ck-color-link-selected-background:\t\t\t\t\t\thsla(201, 100%, 56%, 0.1);\n\t--ck-color-link-fake-selection:\t\t\t\t\t\t\t\thsla(201, 100%, 56%, 0.3);\n\n\t/* -- Search result highlight ---------------------------------------------------------------- */\n\n\t--ck-color-highlight-background:\t\t\t\t\t\t\thsl(60, 100%, 50%)\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/**\n\t * An opacity value of disabled UI item.\n\t */\n\t--ck-disabled-opacity: .5;\n}\n',
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/**\n\t * The geometry of the of focused element's outer shadow.\n\t */\n\t--ck-focus-outer-shadow-geometry: 0 0 0 3px;\n\n\t/**\n\t * A visual style of focused element's outer shadow.\n\t */\n\t--ck-focus-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-outer-shadow);\n\n\t/**\n\t * A visual style of focused element's outer shadow (when disabled).\n\t */\n\t--ck-focus-disabled-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-disabled-shadow);\n\n\t/**\n\t * A visual style of focused element's outer shadow (when has errors).\n\t */\n\t--ck-focus-error-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-error-shadow);\n\n\t/**\n\t * A visual style of focused element's border or outline.\n\t */\n\t--ck-focus-ring: 1px solid var(--ck-color-focus-border);\n}\n",
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-font-size-base: 13px;\n\t--ck-line-height-base: 1.84615;\n\t--ck-font-face: Helvetica, Arial, Tahoma, Verdana, Sans-Serif;\n\n\t--ck-font-size-tiny: 0.7em;\n\t--ck-font-size-small: 0.75em;\n\t--ck-font-size-normal: 1em;\n\t--ck-font-size-big: 1.4em;\n\t--ck-font-size-large: 1.8em;\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/* This is super-important. This is **manually** adjusted so a button without an icon\n\tis never smaller than a button with icon, additionally making sure that text-less buttons\n\tare perfect squares. The value is also shared by other components which should stay "in-line"\n\twith buttons. */\n\t--ck-ui-component-min-height: 2.3em;\n}\n\n/**\n * Resets an element, ignoring its children.\n */\n.ck.ck-reset,\n.ck.ck-reset_all,\n.ck-reset_all *:not(.ck-reset_all-excluded *) {\n\t/* Do not include inheritable rules here. */\n\tmargin: 0;\n\tpadding: 0;\n\tborder: 0;\n\tbackground: transparent;\n\ttext-decoration: none;\n\tvertical-align: middle;\n\ttransition: none;\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/105 */\n\tword-wrap: break-word;\n}\n\n/**\n * Resets an element AND its children.\n */\n.ck.ck-reset_all,\n.ck-reset_all *:not(.ck-reset_all-excluded *) {\n\t/* These are rule inherited by all children elements. */\n\tborder-collapse: collapse;\n\tfont: normal normal normal var(--ck-font-size-base)/var(--ck-line-height-base) var(--ck-font-face);\n\tcolor: var(--ck-color-text);\n\ttext-align: left;\n\twhite-space: nowrap;\n\tcursor: auto;\n\tfloat: none;\n}\n\n.ck-reset_all {\n\t& .ck-rtl *:not(.ck-reset_all-excluded *) {\n\t\ttext-align: right;\n\t}\n\n\t& iframe:not(.ck-reset_all-excluded *) {\n\t\t/* For IE */\n\t\tvertical-align: inherit;\n\t}\n\n\t& textarea:not(.ck-reset_all-excluded *) {\n\t\twhite-space: pre-wrap;\n\t}\n\n\t& textarea:not(.ck-reset_all-excluded *),\n\t& input[type="text"]:not(.ck-reset_all-excluded *),\n\t& input[type="password"]:not(.ck-reset_all-excluded *) {\n\t\tcursor: text;\n\t}\n\n\t& textarea[disabled]:not(.ck-reset_all-excluded *),\n\t& input[type="text"][disabled]:not(.ck-reset_all-excluded *),\n\t& input[type="password"][disabled]:not(.ck-reset_all-excluded *) {\n\t\tcursor: default;\n\t}\n\n\t& fieldset:not(.ck-reset_all-excluded *) {\n\t\tpadding: 10px;\n\t\tborder: 2px groove hsl(255, 7%, 88%);\n\t}\n\n\t& button:not(.ck-reset_all-excluded *)::-moz-focus-inner {\n\t\t/* See http://stackoverflow.com/questions/5517744/remove-extra-button-spacing-padding-in-firefox */\n\t\tpadding: 0;\n\t\tborder: 0\n\t}\n}\n\n/**\n * Default UI rules for RTL languages.\n */\n.ck[dir="rtl"],\n.ck[dir="rtl"] .ck {\n\ttext-align: right;\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Default border-radius value.\n */\n:root{\n\t--ck-border-radius: 2px;\n}\n',
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/**\n\t * A visual style of element's inner shadow (i.e. input).\n\t */\n\t--ck-inner-shadow: 2px 2px 3px var(--ck-color-shadow-inner) inset;\n\n\t/**\n\t * A visual style of element's drop shadow (i.e. panel).\n\t */\n\t--ck-drop-shadow: 0 1px 2px 1px var(--ck-color-shadow-drop);\n\n\t/**\n\t * A visual style of element's active shadow (i.e. comment or suggestion).\n\t */\n\t--ck-drop-shadow-active: 0 3px 6px 1px var(--ck-color-shadow-drop-active);\n}\n",
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-spacing-unit: \t\t\t\t\t\t0.6em;\n\t--ck-spacing-large: \t\t\t\t\tcalc(var(--ck-spacing-unit) * 1.5);\n\t--ck-spacing-standard: \t\t\t\t\tvar(--ck-spacing-unit);\n\t--ck-spacing-medium: \t\t\t\t\tcalc(var(--ck-spacing-unit) * 0.8);\n\t--ck-spacing-small: \t\t\t\t\tcalc(var(--ck-spacing-unit) * 0.5);\n\t--ck-spacing-tiny: \t\t\t\t\t\tcalc(var(--ck-spacing-unit) * 0.3);\n\t--ck-spacing-extra-tiny: \t\t\t\tcalc(var(--ck-spacing-unit) * 0.16);\n}\n',
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      7153: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          ':root{--ck-color-resizer:var(--ck-color-focus-border);--ck-color-resizer-tooltip-background:#262626;--ck-color-resizer-tooltip-text:#f2f2f2;--ck-resizer-border-radius:var(--ck-border-radius);--ck-resizer-tooltip-offset:10px;--ck-resizer-tooltip-height:calc(var(--ck-spacing-small)*2 + 10px)}.ck .ck-widget,.ck .ck-widget.ck-widget_with-selection-handle{position:relative}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{position:absolute}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{display:block}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle{visibility:visible}.ck .ck-size-view{background:var(--ck-color-resizer-tooltip-background);border:1px solid var(--ck-color-resizer-tooltip-text);border-radius:var(--ck-resizer-border-radius);color:var(--ck-color-resizer-tooltip-text);display:block;font-size:var(--ck-font-size-tiny);height:var(--ck-resizer-tooltip-height);line-height:var(--ck-resizer-tooltip-height);padding:0 var(--ck-spacing-small)}.ck .ck-size-view.ck-orientation-above-center,.ck .ck-size-view.ck-orientation-bottom-left,.ck .ck-size-view.ck-orientation-bottom-right,.ck .ck-size-view.ck-orientation-top-left,.ck .ck-size-view.ck-orientation-top-right{position:absolute}.ck .ck-size-view.ck-orientation-top-left{left:var(--ck-resizer-tooltip-offset);top:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-top-right{right:var(--ck-resizer-tooltip-offset);top:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-right{bottom:var(--ck-resizer-tooltip-offset);right:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-left{bottom:var(--ck-resizer-tooltip-offset);left:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-above-center{left:50%;top:calc(var(--ck-resizer-tooltip-height)*-1);transform:translate(-50%)}:root{--ck-widget-outline-thickness:3px;--ck-widget-handler-icon-size:16px;--ck-widget-handler-animation-duration:200ms;--ck-widget-handler-animation-curve:ease;--ck-color-widget-blurred-border:#dedede;--ck-color-widget-hover-border:#ffc83d;--ck-color-widget-editable-focus-background:var(--ck-color-base-background);--ck-color-widget-drag-handler-icon-color:var(--ck-color-base-background)}.ck .ck-widget{outline-color:transparent;outline-style:solid;outline-width:var(--ck-widget-outline-thickness);transition:outline-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_selected,.ck .ck-widget.ck-widget_selected:hover{outline:var(--ck-widget-outline-thickness) solid var(--ck-color-focus-border)}.ck .ck-widget:hover{outline-color:var(--ck-color-widget-hover-border)}.ck .ck-editor__nested-editable{border:1px solid transparent}.ck .ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck .ck-editor__nested-editable:focus{background-color:var(--ck-color-widget-editable-focus-background);border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0;outline:none}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{background-color:transparent;border-radius:var(--ck-border-radius) var(--ck-border-radius) 0 0;box-sizing:border-box;left:calc(0px - var(--ck-widget-outline-thickness));opacity:0;padding:4px;top:0;transform:translateY(-100%);transition:background-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),visibility var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{color:var(--ck-color-widget-drag-handler-icon-color);height:var(--ck-widget-handler-icon-size);width:var(--ck-widget-handler-icon-size)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:0;transition:opacity .3s var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle:hover .ck-icon .ck-icon__selected-indicator{opacity:1}.ck .ck-widget.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle{background-color:var(--ck-color-widget-hover-border);opacity:1}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle{background-color:var(--ck-color-focus-border);opacity:1}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:1}.ck[dir=rtl] .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{left:auto;right:calc(0px - var(--ck-widget-outline-thickness))}.ck.ck-editor__editable.ck-read-only .ck-widget{transition:none}.ck.ck-editor__editable.ck-read-only .ck-widget:not(.ck-widget_selected){--ck-widget-outline-thickness:0px}.ck.ck-editor__editable.ck-read-only .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle,.ck.ck-editor__editable.ck-read-only .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle:hover{background:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected:hover{outline-color:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle:hover,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle>.ck-widget__selection-handle,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle>.ck-widget__selection-handle:hover{background:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable blockquote>.ck-widget.ck-widget_with-selection-handle:first-child,.ck.ck-editor__editable>.ck-widget.ck-widget_with-selection-handle:first-child{margin-top:calc(1em + var(--ck-widget-handler-icon-size))}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-widget/theme/widget.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-widget/widget.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css',
            ],
            names: [],
            mappings:
              'AAKA,MACC,+CAAgD,CAChD,6CAAsD,CACtD,uCAAgD,CAEhD,kDAAmD,CACnD,gCAAiC,CACjC,kEACD,CAOA,8DAEC,iBAqBD,CAnBC,4EACC,iBAOD,CALC,qFAGC,aACD,CASD,iLACC,kBACD,CAGD,kBACC,qDAAsD,CAEtD,qDAAsD,CACtD,6CAA8C,CAF9C,0CAA2C,CAI3C,aAAc,CADd,kCAAmC,CAGnC,uCAAwC,CACxC,4CAA6C,CAF7C,iCAsCD,CAlCC,8NAKC,iBACD,CAEA,0CAEC,qCAAsC,CADtC,oCAED,CAEA,2CAEC,sCAAuC,CADvC,oCAED,CAEA,8CACC,uCAAwC,CACxC,sCACD,CAEA,6CACC,uCAAwC,CACxC,qCACD,CAGA,8CAEC,QAAS,CADT,6CAAgD,CAEhD,yBACD,CCjFD,MACC,iCAAkC,CAClC,kCAAmC,CACnC,4CAA6C,CAC7C,wCAAyC,CAEzC,wCAAiD,CACjD,sCAAkD,CAClD,2EAA4E,CAC5E,yEACD,CAEA,eAGC,yBAA0B,CAD1B,mBAAoB,CADpB,gDAAiD,CAGjD,6GAUD,CARC,0EAEC,6EACD,CAEA,qBACC,iDACD,CAGD,gCACC,4BAWD,CAPC,yGAKC,iEAAkE,CCnCnE,2BAA2B,CCF3B,qCAA8B,CDC9B,YDqCA,CAIA,4EAKC,4BAA6B,CAa7B,iEAAkE,CAhBlE,qBAAsB,CAoBtB,mDAAoD,CAhBpD,SAAU,CALV,WAAY,CAsBZ,KAAM,CAFN,2BAA4B,CAT5B,6SAgCD,CAnBC,qFAIC,oDAAqD,CADrD,yCAA0C,CAD1C,wCAWD,CANC,kHACC,SAAU,CAGV,+DACD,CAID,wHACC,SACD,CAID,kFAEC,oDAAqD,CADrD,SAED,CAKC,oMAEC,6CAA8C,CAD9C,SAOD,CAHC,gRACC,SACD,CAOH,qFACC,SAAU,CACV,oDACD,CAGA,gDAEC,eAkBD,CAhBC,yEAOC,iCACD,CAGC,gOAEC,gDACD,CAOD,wIAEC,mDAQD,CALE,ghBAEC,gDACD,CAKH,yKAOC,yDACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-resizer: var(--ck-color-focus-border);\n\t--ck-color-resizer-tooltip-background: hsl(0, 0%, 15%);\n\t--ck-color-resizer-tooltip-text: hsl(0, 0%, 95%);\n\n\t--ck-resizer-border-radius: var(--ck-border-radius);\n\t--ck-resizer-tooltip-offset: 10px;\n\t--ck-resizer-tooltip-height: calc(var(--ck-spacing-small) * 2 + 10px);\n}\n\n.ck .ck-widget {\n\t/* This is neccessary for type around UI to be positioned properly. */\n\tposition: relative;\n}\n\n.ck .ck-widget.ck-widget_with-selection-handle {\n\t/* Make the widget wrapper a relative positioning container for the drag handle. */\n\tposition: relative;\n\n\t& .ck-widget__selection-handle {\n\t\tposition: absolute;\n\n\t\t& .ck-icon {\n\t\t\t/* Make sure the icon in not a subject to font-size or line-height to avoid\n\t\t\tunnecessary spacing around it. */\n\t\t\tdisplay: block;\n\t\t}\n\t}\n\n\t/* Show the selection handle on mouse hover over the widget, but not for nested widgets. */\n\t&:hover > .ck-widget__selection-handle {\n\t\tvisibility: visible;\n\t}\n\n\t/* Show the selection handle when the widget is selected, but not for nested widgets. */\n\t&.ck-widget_selected > .ck-widget__selection-handle {\n\t\tvisibility: visible;\n\t}\n}\n\n.ck .ck-size-view {\n\tbackground: var(--ck-color-resizer-tooltip-background);\n\tcolor: var(--ck-color-resizer-tooltip-text);\n\tborder: 1px solid var(--ck-color-resizer-tooltip-text);\n\tborder-radius: var(--ck-resizer-border-radius);\n\tfont-size: var(--ck-font-size-tiny);\n\tdisplay: block;\n\tpadding: 0 var(--ck-spacing-small);\n\theight: var(--ck-resizer-tooltip-height);\n\tline-height: var(--ck-resizer-tooltip-height);\n\n\t&.ck-orientation-top-left,\n\t&.ck-orientation-top-right,\n\t&.ck-orientation-bottom-right,\n\t&.ck-orientation-bottom-left,\n\t&.ck-orientation-above-center {\n\t\tposition: absolute;\n\t}\n\n\t&.ck-orientation-top-left {\n\t\ttop: var(--ck-resizer-tooltip-offset);\n\t\tleft: var(--ck-resizer-tooltip-offset);\n\t}\n\n\t&.ck-orientation-top-right {\n\t\ttop: var(--ck-resizer-tooltip-offset);\n\t\tright: var(--ck-resizer-tooltip-offset);\n\t}\n\n\t&.ck-orientation-bottom-right {\n\t\tbottom: var(--ck-resizer-tooltip-offset);\n\t\tright: var(--ck-resizer-tooltip-offset);\n\t}\n\n\t&.ck-orientation-bottom-left {\n\t\tbottom: var(--ck-resizer-tooltip-offset);\n\t\tleft: var(--ck-resizer-tooltip-offset);\n\t}\n\n\t/* Class applied if the widget is too small to contain the size label */\n\t&.ck-orientation-above-center {\n\t\ttop: calc(var(--ck-resizer-tooltip-height) * -1);\n\t\tleft: 50%;\n\t\ttransform: translate(-50%);\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../mixins/_focus.css";\n@import "../mixins/_shadow.css";\n\n:root {\n\t--ck-widget-outline-thickness: 3px;\n\t--ck-widget-handler-icon-size: 16px;\n\t--ck-widget-handler-animation-duration: 200ms;\n\t--ck-widget-handler-animation-curve: ease;\n\n\t--ck-color-widget-blurred-border: hsl(0, 0%, 87%);\n\t--ck-color-widget-hover-border: hsl(43, 100%, 62%);\n\t--ck-color-widget-editable-focus-background: var(--ck-color-base-background);\n\t--ck-color-widget-drag-handler-icon-color: var(--ck-color-base-background);\n}\n\n.ck .ck-widget {\n\toutline-width: var(--ck-widget-outline-thickness);\n\toutline-style: solid;\n\toutline-color: transparent;\n\ttransition: outline-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\n\n\t&.ck-widget_selected,\n\t&.ck-widget_selected:hover {\n\t\toutline: var(--ck-widget-outline-thickness) solid var(--ck-color-focus-border);\n\t}\n\n\t&:hover {\n\t\toutline-color: var(--ck-color-widget-hover-border);\n\t}\n}\n\n.ck .ck-editor__nested-editable {\n\tborder: 1px solid transparent;\n\n\t/* The :focus style is applied before .ck-editor__nested-editable_focused class is rendered in the view.\n\tThese styles show a different border for a blink of an eye, so `:focus` need to have same styles applied. */\n\t&.ck-editor__nested-editable_focused,\n\t&:focus {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-inner-shadow);\n\n\t\tbackground-color: var(--ck-color-widget-editable-focus-background);\n\t}\n}\n\n.ck .ck-widget.ck-widget_with-selection-handle {\n\t& .ck-widget__selection-handle {\n\t\tpadding: 4px;\n\t\tbox-sizing: border-box;\n\n\t\t/* Background and opacity will be animated as the handler shows up or the widget gets selected. */\n\t\tbackground-color: transparent;\n\t\topacity: 0;\n\n\t\t/* Transition:\n\t\t   * background-color for the .ck-widget_selected state change,\n\t\t   * visibility for hiding the handler,\n\t\t   * opacity for the proper look of the icon when the handler disappears. */\n\t\ttransition:\n\t\t\tbackground-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),\n\t\t\tvisibility var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),\n\t\t\topacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\n\n\t\t/* Make only top corners round. */\n\t\tborder-radius: var(--ck-border-radius) var(--ck-border-radius) 0 0;\n\n\t\t/* Place the drag handler outside the widget wrapper. */\n\t\ttransform: translateY(-100%);\n\t\tleft: calc(0px - var(--ck-widget-outline-thickness));\n\t\ttop: 0;\n\n\t\t& .ck-icon {\n\t\t\t/* Make sure the dimensions of the icon are independent of the fon-size of the content. */\n\t\t\twidth: var(--ck-widget-handler-icon-size);\n\t\t\theight: var(--ck-widget-handler-icon-size);\n\t\t\tcolor: var(--ck-color-widget-drag-handler-icon-color);\n\n\t\t\t/* The "selected" part of the icon is invisible by default */\n\t\t\t& .ck-icon__selected-indicator {\n\t\t\t\topacity: 0;\n\n\t\t\t\t/* Note: The animation is longer on purpose. Simply feels better. */\n\t\t\t\ttransition: opacity 300ms var(--ck-widget-handler-animation-curve);\n\t\t\t}\n\t\t}\n\n\t\t/* Advertise using the look of the icon that once clicked the handler, the widget will be selected. */\n\t\t&:hover .ck-icon .ck-icon__selected-indicator {\n\t\t\topacity: 1;\n\t\t}\n\t}\n\n\t/* Show the selection handler on mouse hover over the widget, but not for nested widgets. */\n\t&:hover > .ck-widget__selection-handle {\n\t\topacity: 1;\n\t\tbackground-color: var(--ck-color-widget-hover-border);\n\t}\n\n\t/* Show the selection handler when the widget is selected, but not for nested widgets. */\n\t&.ck-widget_selected,\n\t&.ck-widget_selected:hover {\n\t\t& > .ck-widget__selection-handle {\n\t\t\topacity: 1;\n\t\t\tbackground-color: var(--ck-color-focus-border);\n\n\t\t\t/* When the widget is selected, notify the user using the proper look of the icon. */\n\t\t\t& .ck-icon .ck-icon__selected-indicator {\n\t\t\t\topacity: 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/* In a RTL environment, align the selection handler to the right side of the widget */\n/* stylelint-disable-next-line no-descending-specificity */\n.ck[dir="rtl"] .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle {\n\tleft: auto;\n\tright: calc(0px - var(--ck-widget-outline-thickness));\n}\n\n/* https://github.com/ckeditor/ckeditor5/issues/6415 */\n.ck.ck-editor__editable.ck-read-only .ck-widget {\n\t/* Prevent the :hover outline from showing up because of the used outline-color transition. */\n\ttransition: none;\n\n\t&:not(.ck-widget_selected) {\n\t\t/* Disable visual effects of hover/active widget when CKEditor is in readOnly mode.\n\t\t * See: https://github.com/ckeditor/ckeditor5/issues/1261\n\t\t *\n\t\t * Leave the unit because this custom property is used in calc() by other features.\n\t\t * See: https://github.com/ckeditor/ckeditor5/issues/6775\n\t\t */\n\t\t--ck-widget-outline-thickness: 0px;\n\t}\n\n\t&.ck-widget_with-selection-handle {\n\t\t& .ck-widget__selection-handle,\n\t\t& .ck-widget__selection-handle:hover {\n\t\t\tbackground: var(--ck-color-widget-blurred-border);\n\t\t}\n\t}\n}\n\n/* Style the widget when it\'s selected but the editable it belongs to lost focus. */\n/* stylelint-disable-next-line no-descending-specificity */\n.ck.ck-editor__editable.ck-blurred .ck-widget {\n\t&.ck-widget_selected,\n\t&.ck-widget_selected:hover {\n\t\toutline-color: var(--ck-color-widget-blurred-border);\n\n\t\t&.ck-widget_with-selection-handle {\n\t\t\t& > .ck-widget__selection-handle,\n\t\t\t& > .ck-widget__selection-handle:hover {\n\t\t\t\tbackground: var(--ck-color-widget-blurred-border);\n\t\t\t}\n\t\t}\n\t}\n}\n\n.ck.ck-editor__editable > .ck-widget.ck-widget_with-selection-handle:first-child,\n.ck.ck-editor__editable blockquote > .ck-widget.ck-widget_with-selection-handle:first-child {\n\t/* Do not crop selection handler if a widget is a first-child in the blockquote or in the root editable.\n\tIn fact, anything with overflow: hidden.\n\thttps://github.com/ckeditor/ckeditor5-block-quote/issues/28\n\thttps://github.com/ckeditor/ckeditor5-widget/issues/44\n\thttps://github.com/ckeditor/ckeditor5-widget/issues/66 */\n\tmargin-top: calc(1em + var(--ck-widget-handler-icon-size));\n}\n',
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n",
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n',
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      4875: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          '.ck .ck-widget_with-resizer{position:relative}.ck .ck-widget__resizer{display:none;left:0;pointer-events:none;position:absolute;top:0}.ck-focused .ck-widget_with-resizer.ck-widget_selected>.ck-widget__resizer{display:block}.ck .ck-widget__resizer__handle{pointer-events:all;position:absolute}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-right,.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-left{cursor:nwse-resize}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-left,.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-right{cursor:nesw-resize}:root{--ck-resizer-size:10px;--ck-resizer-offset:calc(var(--ck-resizer-size)/-2 - 2px);--ck-resizer-border-width:1px}.ck .ck-widget__resizer{outline:1px solid var(--ck-color-resizer)}.ck .ck-widget__resizer__handle{background:var(--ck-color-focus-border);border:var(--ck-resizer-border-width) solid #fff;border-radius:var(--ck-resizer-border-radius);height:var(--ck-resizer-size);width:var(--ck-resizer-size)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-left{left:var(--ck-resizer-offset);top:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-right{right:var(--ck-resizer-offset);top:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-right{bottom:var(--ck-resizer-offset);right:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-left{bottom:var(--ck-resizer-offset);left:var(--ck-resizer-offset)}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-widget/theme/widgetresize.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-widget/widgetresize.css',
            ],
            names: [],
            mappings:
              'AAKA,4BAEC,iBACD,CAEA,wBACC,YAAa,CAMb,MAAO,CAFP,mBAAoB,CAHpB,iBAAkB,CAMlB,KACD,CAGC,2EACC,aACD,CAGD,gCAIC,kBAAmB,CAHnB,iBAcD,CATC,4IAEC,kBACD,CAEA,4IAEC,kBACD,CCpCD,MACC,sBAAuB,CAGvB,yDAAiE,CACjE,6BACD,CAEA,wBACC,yCACD,CAEA,gCAGC,uCAAwC,CACxC,gDAA6D,CAC7D,6CAA8C,CAH9C,6BAA8B,CAD9B,4BAyBD,CAnBC,oEAEC,6BAA8B,CAD9B,4BAED,CAEA,qEAEC,8BAA+B,CAD/B,4BAED,CAEA,wEACC,+BAAgC,CAChC,8BACD,CAEA,uEACC,+BAAgC,CAChC,6BACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-widget_with-resizer {\n\t/* Make the widget wrapper a relative positioning container for the drag handle. */\n\tposition: relative;\n}\n\n.ck .ck-widget__resizer {\n\tdisplay: none;\n\tposition: absolute;\n\n\t/* The wrapper itself should not interfere with the pointer device, only the handles should. */\n\tpointer-events: none;\n\n\tleft: 0;\n\ttop: 0;\n}\n\n.ck-focused .ck-widget_with-resizer.ck-widget_selected {\n\t& > .ck-widget__resizer {\n\t\tdisplay: block;\n\t}\n}\n\n.ck .ck-widget__resizer__handle {\n\tposition: absolute;\n\n\t/* Resizers are the only UI elements that should interfere with a pointer device. */\n\tpointer-events: all;\n\n\t&.ck-widget__resizer__handle-top-left,\n\t&.ck-widget__resizer__handle-bottom-right {\n\t\tcursor: nwse-resize;\n\t}\n\n\t&.ck-widget__resizer__handle-top-right,\n\t&.ck-widget__resizer__handle-bottom-left {\n\t\tcursor: nesw-resize;\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-resizer-size: 10px;\n\n\t/* Set the resizer with a 50% offset. */\n\t--ck-resizer-offset: calc( ( var(--ck-resizer-size) / -2 ) - 2px);\n\t--ck-resizer-border-width: 1px;\n}\n\n.ck .ck-widget__resizer {\n\toutline: 1px solid var(--ck-color-resizer);\n}\n\n.ck .ck-widget__resizer__handle {\n\twidth: var(--ck-resizer-size);\n\theight: var(--ck-resizer-size);\n\tbackground: var(--ck-color-focus-border);\n\tborder: var(--ck-resizer-border-width) solid hsl(0, 0%, 100%);\n\tborder-radius: var(--ck-resizer-border-radius);\n\n\t&.ck-widget__resizer__handle-top-left {\n\t\ttop: var(--ck-resizer-offset);\n\t\tleft: var(--ck-resizer-offset);\n\t}\n\n\t&.ck-widget__resizer__handle-top-right {\n\t\ttop: var(--ck-resizer-offset);\n\t\tright: var(--ck-resizer-offset);\n\t}\n\n\t&.ck-widget__resizer__handle-bottom-right {\n\t\tbottom: var(--ck-resizer-offset);\n\t\tright: var(--ck-resizer-offset);\n\t}\n\n\t&.ck-widget__resizer__handle-bottom-left {\n\t\tbottom: var(--ck-resizer-offset);\n\t\tleft: var(--ck-resizer-offset);\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      2347: (t, e, n) => {
        'use strict'
        n.d(e, { Z: () => c })
        var o = n(4015)
        var i = n.n(o)
        var r = n(3645)
        var s = n.n(r)
        var a = s()(i())
        a.push([
          t.id,
          '.ck .ck-widget .ck-widget__type-around__button{display:block;overflow:hidden;position:absolute;z-index:var(--ck-z-default)}.ck .ck-widget .ck-widget__type-around__button svg{left:50%;position:absolute;top:50%;z-index:calc(var(--ck-z-default) + 2)}.ck .ck-widget .ck-widget__type-around__button.ck-widget__type-around__button_before{left:min(10%,30px);top:calc(var(--ck-widget-outline-thickness)*-.5);transform:translateY(-50%)}.ck .ck-widget .ck-widget__type-around__button.ck-widget__type-around__button_after{bottom:calc(var(--ck-widget-outline-thickness)*-.5);right:min(10%,30px);transform:translateY(50%)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:after,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover:after{content:"";display:block;left:1px;position:absolute;top:1px;z-index:calc(var(--ck-z-default) + 1)}.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__fake-caret{display:none;left:0;position:absolute;right:0}.ck .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__fake-caret{left:calc(var(--ck-widget-outline-thickness)*-1);right:calc(var(--ck-widget-outline-thickness)*-1)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_before>.ck-widget__type-around>.ck-widget__type-around__fake-caret{display:block;top:calc(var(--ck-widget-outline-thickness)*-1 - 1px)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after>.ck-widget__type-around>.ck-widget__type-around__fake-caret{bottom:calc(var(--ck-widget-outline-thickness)*-1 - 1px);display:block}.ck.ck-editor__editable.ck-read-only .ck-widget__type-around,.ck.ck-editor__editable.ck-restricted-editing_mode_restricted .ck-widget__type-around,.ck.ck-editor__editable.ck-widget__type-around_disabled .ck-widget__type-around{display:none}:root{--ck-widget-type-around-button-size:20px;--ck-color-widget-type-around-button-active:var(--ck-color-focus-border);--ck-color-widget-type-around-button-hover:var(--ck-color-widget-hover-border);--ck-color-widget-type-around-button-blurred-editable:var(--ck-color-widget-blurred-border);--ck-color-widget-type-around-button-radar-start-alpha:0;--ck-color-widget-type-around-button-radar-end-alpha:.3;--ck-color-widget-type-around-button-icon:var(--ck-color-base-background)}.ck .ck-widget .ck-widget__type-around__button{background:var(--ck-color-widget-type-around-button);border-radius:100px;height:var(--ck-widget-type-around-button-size);opacity:0;pointer-events:none;transition:opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);width:var(--ck-widget-type-around-button-size)}.ck .ck-widget .ck-widget__type-around__button svg{height:8px;margin-top:1px;transform:translate(-50%,-50%);transition:transform .5s ease;width:10px}.ck .ck-widget .ck-widget__type-around__button svg *{stroke-dasharray:10;stroke-dashoffset:0;fill:none;stroke:var(--ck-color-widget-type-around-button-icon);stroke-width:1.5px;stroke-linecap:round;stroke-linejoin:round}.ck .ck-widget .ck-widget__type-around__button svg line{stroke-dasharray:7}.ck .ck-widget .ck-widget__type-around__button:hover{animation:ck-widget-type-around-button-sonar 1s ease infinite}.ck .ck-widget .ck-widget__type-around__button:hover svg polyline{animation:ck-widget-type-around-arrow-dash 2s linear}.ck .ck-widget .ck-widget__type-around__button:hover svg line{animation:ck-widget-type-around-arrow-tip-dash 2s linear}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__button{opacity:1;pointer-events:auto}.ck .ck-widget:not(.ck-widget_selected)>.ck-widget__type-around>.ck-widget__type-around__button{background:var(--ck-color-widget-type-around-button-hover)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover{background:var(--ck-color-widget-type-around-button-active)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:after,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover:after{background:linear-gradient(135deg,hsla(0,0%,100%,0),hsla(0,0%,100%,.3));border-radius:100px;height:calc(var(--ck-widget-type-around-button-size) - 2px);width:calc(var(--ck-widget-type-around-button-size) - 2px)}.ck .ck-widget.ck-widget_with-selection-handle>.ck-widget__type-around>.ck-widget__type-around__button_before{margin-left:20px}.ck .ck-widget .ck-widget__type-around__fake-caret{animation:ck-widget-type-around-fake-caret-pulse 1s linear infinite normal forwards;background:var(--ck-color-base-text);height:1px;outline:1px solid hsla(0,0%,100%,.5);pointer-events:none}.ck .ck-widget.ck-widget_selected.ck-widget_type-around_show-fake-caret_after,.ck .ck-widget.ck-widget_selected.ck-widget_type-around_show-fake-caret_before{outline-color:transparent}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_selected:hover,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_selected:hover{outline-color:var(--ck-color-widget-hover-border)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before>.ck-widget__type-around>.ck-widget__type-around__button{opacity:0;pointer-events:none}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_selected.ck-widget_with-resizer>.ck-widget__resizer,.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_selected.ck-widget_with-resizer>.ck-widget__resizer,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle{opacity:0}.ck[dir=rtl] .ck-widget.ck-widget_with-selection-handle .ck-widget__type-around>.ck-widget__type-around__button_before{margin-left:0;margin-right:20px}.ck-editor__nested-editable.ck-editor__editable_selected .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck-editor__nested-editable.ck-editor__editable_selected .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__button{opacity:0;pointer-events:none}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:not(:hover){background:var(--ck-color-widget-type-around-button-blurred-editable)}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:not(:hover) svg *{stroke:#999}@keyframes ck-widget-type-around-arrow-dash{0%{stroke-dashoffset:10}20%,to{stroke-dashoffset:0}}@keyframes ck-widget-type-around-arrow-tip-dash{0%,20%{stroke-dashoffset:7}40%,to{stroke-dashoffset:0}}@keyframes ck-widget-type-around-button-sonar{0%{box-shadow:0 0 0 0 hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-start-alpha))}50%{box-shadow:0 0 0 5px hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-end-alpha))}to{box-shadow:0 0 0 5px hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-start-alpha))}}@keyframes ck-widget-type-around-fake-caret-pulse{0%{opacity:1}49%{opacity:1}50%{opacity:0}99%{opacity:0}to{opacity:1}}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-widget/theme/widgettypearound.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-widget/widgettypearound.css',
            ],
            names: [],
            mappings:
              'AASC,+CACC,aAAc,CAEd,eAAgB,CADhB,iBAAkB,CAElB,2BAwBD,CAtBC,mDAGC,QAAS,CAFT,iBAAkB,CAClB,OAAQ,CAER,qCACD,CAEA,qFAGC,kBAAoB,CADpB,gDAAoD,CAGpD,0BACD,CAEA,oFAEC,mDAAuD,CACvD,mBAAqB,CAErB,yBACD,CAUA,mLACC,UAAW,CACX,aAAc,CAGd,QAAS,CAFT,iBAAkB,CAClB,OAAQ,CAER,qCACD,CAMD,2EACC,YAAa,CAEb,MAAO,CADP,iBAAkB,CAElB,OACD,CAOA,iFACC,gDAAqD,CACrD,iDACD,CAKA,wHAEC,aAAc,CADd,qDAED,CAKA,uHACC,wDAA6D,CAC7D,aACD,CAoBD,mOACC,YACD,CC3GA,MACC,wCAAyC,CACzC,wEAAyE,CACzE,8EAA+E,CAC/E,2FAA4F,CAC5F,wDAAyD,CACzD,uDAAwD,CACxD,yEACD,CAgBC,+CAGC,oDAAqD,CACrD,mBAAoB,CAFpB,+CAAgD,CAVjD,SAAU,CACV,mBAAoB,CAYnB,uMAAyM,CAJzM,8CAkDD,CA1CC,mDAEC,UAAW,CAGX,cAAe,CAFf,8BAA+B,CAC/B,6BAA8B,CAH9B,UAoBD,CAdC,qDACC,mBAAoB,CACpB,mBAAoB,CAEpB,SAAU,CACV,qDAAsD,CACtD,kBAAmB,CACnB,oBAAqB,CACrB,qBACD,CAEA,wDACC,kBACD,CAGD,qDAIC,6DAcD,CARE,kEACC,oDACD,CAEA,8DACC,wDACD,CAUF,uKAvED,SAAU,CACV,mBAwEC,CAOD,gGACC,0DACD,CAOA,uKAEC,2DAQD,CANC,mLAIC,uEAAkF,CADlF,mBAAoB,CADpB,2DAA4D,CAD5D,0DAID,CAOD,8GACC,gBACD,CAKA,mDAGC,mFAAoF,CAOpF,oCAAqC,CARrC,UAAW,CAOX,oCAAwC,CARxC,mBAUD,CAOC,6JAEC,yBACD,CAUA,yKACC,iDACD,CAMA,uOAlJD,SAAU,CACV,mBAmJC,CAoBA,6yBACC,SACD,CASF,uHACC,aAAc,CACd,iBACD,CAYG,iRAlMF,SAAU,CACV,mBAmME,CAQH,kIACC,qEAKD,CAHC,wIACC,WACD,CAGD,4CACC,GACC,oBACD,CACA,OACC,mBACD,CACD,CAEA,gDACC,OACC,mBACD,CACA,OACC,mBACD,CACD,CAEA,8CACC,GACC,6HACD,CACA,IACC,6HACD,CACA,GACC,+HACD,CACD,CAEA,kDACC,GACC,SACD,CACA,IACC,SACD,CACA,IACC,SACD,CACA,IACC,SACD,CACA,GACC,SACD,CACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-widget {\n\t/*\n\t * Styles of the type around buttons\n\t */\n\t& .ck-widget__type-around__button {\n\t\tdisplay: block;\n\t\tposition: absolute;\n\t\toverflow: hidden;\n\t\tz-index: var(--ck-z-default);\n\n\t\t& svg {\n\t\t\tposition: absolute;\n\t\t\ttop: 50%;\n\t\t\tleft: 50%;\n\t\t\tz-index: calc(var(--ck-z-default) + 2);\n\t\t}\n\n\t\t&.ck-widget__type-around__button_before {\n\t\t\t/* Place it in the middle of the outline */\n\t\t\ttop: calc(-0.5 * var(--ck-widget-outline-thickness));\n\t\t\tleft: min(10%, 30px);\n\n\t\t\ttransform: translateY(-50%);\n\t\t}\n\n\t\t&.ck-widget__type-around__button_after {\n\t\t\t/* Place it in the middle of the outline */\n\t\t\tbottom: calc(-0.5 * var(--ck-widget-outline-thickness));\n\t\t\tright: min(10%, 30px);\n\n\t\t\ttransform: translateY(50%);\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the buttons when:\n\t * - the widget is selected,\n\t * - or the button is being hovered (regardless of the widget state).\n\t */\n\t&.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button,\n\t& > .ck-widget__type-around > .ck-widget__type-around__button:hover {\n\t\t&::after {\n\t\t\tcontent: "";\n\t\t\tdisplay: block;\n\t\t\tposition: absolute;\n\t\t\ttop: 1px;\n\t\t\tleft: 1px;\n\t\t\tz-index: calc(var(--ck-z-default) + 1);\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" which is displayed when the user navigates using the keyboard.\n\t */\n\t& > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\tdisplay: none;\n\t\tposition: absolute;\n\t\tleft: 0;\n\t\tright: 0;\n\t}\n\n\t/*\n\t * When the widget is hovered the "fake caret" would normally be narrower than the\n\t * extra outline displayed around the widget. Let\'s extend the "fake caret" to match\n\t * the full width of the widget.\n\t */\n\t&:hover > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\tleft: calc( -1 * var(--ck-widget-outline-thickness) );\n\t\tright: calc( -1 * var(--ck-widget-outline-thickness) );\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" when it should be displayed before the widget (backward keyboard navigation).\n\t */\n\t&.ck-widget_type-around_show-fake-caret_before > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\ttop: calc( -1 * var(--ck-widget-outline-thickness) - 1px );\n\t\tdisplay: block;\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" when it should be displayed after the widget (forward keyboard navigation).\n\t */\n\t&.ck-widget_type-around_show-fake-caret_after > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\tbottom: calc( -1 * var(--ck-widget-outline-thickness) - 1px );\n\t\tdisplay: block;\n\t}\n}\n\n/*\n * Integration with the read-only mode of the editor.\n */\n.ck.ck-editor__editable.ck-read-only .ck-widget__type-around {\n\tdisplay: none;\n}\n\n/*\n * Integration with the restricted editing mode (feature) of the editor.\n */\n.ck.ck-editor__editable.ck-restricted-editing_mode_restricted .ck-widget__type-around {\n\tdisplay: none;\n}\n\n/*\n * Integration with the #isEnabled property of the WidgetTypeAround plugin.\n */\n.ck.ck-editor__editable.ck-widget__type-around_disabled .ck-widget__type-around {\n\tdisplay: none;\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-widget-type-around-button-size: 20px;\n\t--ck-color-widget-type-around-button-active: var(--ck-color-focus-border);\n\t--ck-color-widget-type-around-button-hover: var(--ck-color-widget-hover-border);\n\t--ck-color-widget-type-around-button-blurred-editable: var(--ck-color-widget-blurred-border);\n\t--ck-color-widget-type-around-button-radar-start-alpha: 0;\n\t--ck-color-widget-type-around-button-radar-end-alpha: .3;\n\t--ck-color-widget-type-around-button-icon: var(--ck-color-base-background);\n}\n\n@define-mixin ck-widget-type-around-button-visible {\n\topacity: 1;\n\tpointer-events: auto;\n}\n\n@define-mixin ck-widget-type-around-button-hidden {\n\topacity: 0;\n\tpointer-events: none;\n}\n\n.ck .ck-widget {\n\t/*\n\t * Styles of the type around buttons\n\t */\n\t& .ck-widget__type-around__button {\n\t\twidth: var(--ck-widget-type-around-button-size);\n\t\theight: var(--ck-widget-type-around-button-size);\n\t\tbackground: var(--ck-color-widget-type-around-button);\n\t\tborder-radius: 100px;\n\t\ttransition: opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve), background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\n\n\t\t@mixin ck-widget-type-around-button-hidden;\n\n\t\t& svg {\n\t\t\twidth: 10px;\n\t\t\theight: 8px;\n\t\t\ttransform: translate(-50%,-50%);\n\t\t\ttransition: transform .5s ease;\n\t\t\tmargin-top: 1px;\n\n\t\t\t& * {\n\t\t\t\tstroke-dasharray: 10;\n\t\t\t\tstroke-dashoffset: 0;\n\n\t\t\t\tfill: none;\n\t\t\t\tstroke: var(--ck-color-widget-type-around-button-icon);\n\t\t\t\tstroke-width: 1.5px;\n\t\t\t\tstroke-linecap: round;\n\t\t\t\tstroke-linejoin: round;\n\t\t\t}\n\n\t\t\t& line {\n\t\t\t\tstroke-dasharray: 7;\n\t\t\t}\n\t\t}\n\n\t\t&:hover {\n\t\t\t/*\n\t\t\t * Display the "sonar" around the button when hovered.\n\t\t\t */\n\t\t\tanimation: ck-widget-type-around-button-sonar 1s ease infinite;\n\n\t\t\t/*\n\t\t\t * Animate active button\'s icon.\n\t\t\t */\n\t\t\t& svg {\n\t\t\t\t& polyline {\n\t\t\t\t\tanimation: ck-widget-type-around-arrow-dash 2s linear;\n\t\t\t\t}\n\n\t\t\t\t& line {\n\t\t\t\t\tanimation: ck-widget-type-around-arrow-tip-dash 2s linear;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Show type around buttons when the widget gets selected or being hovered.\n\t */\n\t&.ck-widget_selected,\n\t&:hover {\n\t\t& > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\t\t@mixin ck-widget-type-around-button-visible;\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the buttons when the widget is NOT selected (but the buttons are visible\n\t * and still can be hovered).\n\t */\n\t&:not(.ck-widget_selected) > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\tbackground: var(--ck-color-widget-type-around-button-hover);\n\t}\n\n\t/*\n\t * Styles for the buttons when:\n\t * - the widget is selected,\n\t * - or the button is being hovered (regardless of the widget state).\n\t */\n\t&.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button,\n\t& > .ck-widget__type-around > .ck-widget__type-around__button:hover {\n\t\tbackground: var(--ck-color-widget-type-around-button-active);\n\n\t\t&::after {\n\t\t\twidth: calc(var(--ck-widget-type-around-button-size) - 2px);\n\t\t\theight: calc(var(--ck-widget-type-around-button-size) - 2px);\n\t\t\tborder-radius: 100px;\n\t\t\tbackground: linear-gradient(135deg, hsla(0,0%,100%,0) 0%, hsla(0,0%,100%,.3) 100%);\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the "before" button when the widget has a selection handle. Because some space\n\t * is consumed by the handle, the button must be moved slightly to the right to let it breathe.\n\t */\n\t&.ck-widget_with-selection-handle > .ck-widget__type-around > .ck-widget__type-around__button_before {\n\t\tmargin-left: 20px;\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" which is displayed when the user navigates using the keyboard.\n\t */\n\t& .ck-widget__type-around__fake-caret {\n\t\tpointer-events: none;\n\t\theight: 1px;\n\t\tanimation: ck-widget-type-around-fake-caret-pulse linear 1s infinite normal forwards;\n\n\t\t/*\n\t\t * The semi-transparent-outline+background combo improves the contrast\n\t\t * when the background underneath the fake caret is dark.\n\t\t */\n\t\toutline: solid 1px hsla(0, 0%, 100%, .5);\n\t\tbackground: var(--ck-color-base-text);\n\t}\n\n\t/*\n\t * Styles of the widget when the "fake caret" is blinking (e.g. upon keyboard navigation).\n\t * Despite the widget being physically selected in the model, its outline should disappear.\n\t */\n\t&.ck-widget_selected {\n\t\t&.ck-widget_type-around_show-fake-caret_before,\n\t\t&.ck-widget_type-around_show-fake-caret_after {\n\t\t\toutline-color: transparent;\n\t\t}\n\t}\n\n\t&.ck-widget_type-around_show-fake-caret_before,\n\t&.ck-widget_type-around_show-fake-caret_after {\n\t\t/*\n\t\t * When the "fake caret" is visible we simulate that the widget is not selected\n\t\t * (despite being physically selected), so the outline color should be for the\n\t\t * unselected widget.\n\t\t */\n\t\t&.ck-widget_selected:hover {\n\t\t\toutline-color: var(--ck-color-widget-hover-border);\n\t\t}\n\n\t\t/*\n\t\t * Styles of the type around buttons when the "fake caret" is blinking (e.g. upon keyboard navigation).\n\t\t * In this state, the type around buttons would collide with the fake carets so they should disappear.\n\t\t */\n\t\t& > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\t\t@mixin ck-widget-type-around-button-hidden;\n\t\t}\n\n\t\t/*\n\t\t * Fake horizontal caret integration with the selection handle. When the caret is visible, simply\n\t\t * hide the handle because it intersects with the caret (and does not make much sense anyway).\n\t\t */\n\t\t&.ck-widget_with-selection-handle {\n\t\t\t&.ck-widget_selected,\n\t\t\t&.ck-widget_selected:hover {\n\t\t\t\t& > .ck-widget__selection-handle {\n\t\t\t\t\topacity: 0\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Fake horizontal caret integration with the resize UI. When the caret is visible, simply\n\t\t * hide the resize UI because it creates too much noise. It can be visible when the user\n\t\t * hovers the widget, though.\n\t\t */\n\t\t&.ck-widget_selected.ck-widget_with-resizer > .ck-widget__resizer {\n\t\t\topacity: 0\n\t\t}\n\t}\n}\n\n/*\n * Styles for the "before" button when the widget has a selection handle in an RTL environment.\n * The selection handler is aligned to the right side of the widget so there is no need to create\n * additional space for it next to the "before" button.\n */\n.ck[dir="rtl"] .ck-widget.ck-widget_with-selection-handle .ck-widget__type-around > .ck-widget__type-around__button_before {\n\tmargin-left: 0;\n\tmargin-right: 20px;\n}\n\n/*\n * Hide type around buttons when the widget is selected as a child of a selected\n * nested editable (e.g. mulit-cell table selection).\n *\n * See https://github.com/ckeditor/ckeditor5/issues/7263.\n */\n.ck-editor__nested-editable.ck-editor__editable_selected {\n\t& .ck-widget {\n\t\t&.ck-widget_selected,\n\t\t&:hover {\n\t\t\t& > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\t\t\t@mixin ck-widget-type-around-button-hidden;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*\n * Styles for the buttons when the widget is selected but the user clicked outside of the editor (blurred the editor).\n */\n.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button:not(:hover) {\n\tbackground: var(--ck-color-widget-type-around-button-blurred-editable);\n\n\t& svg * {\n\t\tstroke: hsl(0,0%,60%);\n\t}\n}\n\n@keyframes ck-widget-type-around-arrow-dash {\n\t0% {\n\t\tstroke-dashoffset: 10;\n\t}\n\t20%, 100% {\n\t\tstroke-dashoffset: 0;\n\t}\n}\n\n@keyframes ck-widget-type-around-arrow-tip-dash {\n\t0%, 20% {\n\t\tstroke-dashoffset: 7;\n\t}\n\t40%, 100% {\n\t\tstroke-dashoffset: 0;\n\t}\n}\n\n@keyframes ck-widget-type-around-button-sonar {\n\t0% {\n\t\tbox-shadow: 0 0 0 0 hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-start-alpha));\n\t}\n\t50% {\n\t\tbox-shadow: 0 0 0 5px hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-end-alpha));\n\t}\n\t100% {\n\t\tbox-shadow: 0 0 0 5px hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-start-alpha));\n\t}\n}\n\n@keyframes ck-widget-type-around-fake-caret-pulse {\n\t0% {\n\t\topacity: 1;\n\t}\n\t49% {\n\t\topacity: 1;\n\t}\n\t50% {\n\t\topacity: 0;\n\t}\n\t99% {\n\t\topacity: 0;\n\t}\n\t100% {\n\t\topacity: 1;\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ])
        const c = a
      },
      3645: (t) => {
        'use strict'
        t.exports = function (t) {
          var e = []
          e.toString = function e() {
            return this.map(function (e) {
              var n = t(e)
              if (e[2]) {
                return '@media '.concat(e[2], ' {').concat(n, '}')
              }
              return n
            }).join('')
          }
          e.i = function (t, n, o) {
            if (typeof t === 'string') {
              t = [[null, t, '']]
            }
            var i = {}
            if (o) {
              for (var r = 0; r < this.length; r++) {
                var s = this[r][0]
                if (s != null) {
                  i[s] = true
                }
              }
            }
            for (var a = 0; a < t.length; a++) {
              var c = [].concat(t[a])
              if (o && i[c[0]]) {
                continue
              }
              if (n) {
                if (!c[2]) {
                  c[2] = n
                } else {
                  c[2] = ''.concat(n, ' and ').concat(c[2])
                }
              }
              e.push(c)
            }
          }
          return e
        }
      },
      4015: (t) => {
        'use strict'
        function e(t, e) {
          return s(t) || r(t, e) || o(t, e) || n()
        }
        function n() {
          throw new TypeError(
            'Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.',
          )
        }
        function o(t, e) {
          if (!t) return
          if (typeof t === 'string') return i(t, e)
          var n = Object.prototype.toString.call(t).slice(8, -1)
          if (n === 'Object' && t.constructor) n = t.constructor.name
          if (n === 'Map' || n === 'Set') return Array.from(t)
          if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return i(t, e)
        }
        function i(t, e) {
          if (e == null || e > t.length) e = t.length
          for (var n = 0, o = new Array(e); n < e; n++) {
            o[n] = t[n]
          }
          return o
        }
        function r(t, e) {
          var n = t && ((typeof Symbol !== 'undefined' && t[Symbol.iterator]) || t['@@iterator'])
          if (n == null) return
          var o = []
          var i = true
          var r = false
          var s, a
          try {
            for (n = n.call(t); !(i = (s = n.next()).done); i = true) {
              o.push(s.value)
              if (e && o.length === e) break
            }
          } catch (t) {
            r = true
            a = t
          } finally {
            try {
              if (!i && n['return'] != null) n['return']()
            } finally {
              if (r) throw a
            }
          }
          return o
        }
        function s(t) {
          if (Array.isArray(t)) return t
        }
        t.exports = function t(n) {
          var o = e(n, 4),
            i = o[1],
            r = o[3]
          if (!r) {
            return i
          }
          if (typeof btoa === 'function') {
            var s = btoa(unescape(encodeURIComponent(JSON.stringify(r))))
            var a = 'sourceMappingURL=data:application/json;charset=utf-8;base64,'.concat(s)
            var c = '/*# '.concat(a, ' */')
            var l = r.sources.map(function (t) {
              return '/*# sourceURL='.concat(r.sourceRoot || '').concat(t, ' */')
            })
            return [i].concat(l).concat([c]).join('\n')
          }
          return [i].join('\n')
        }
      },
      3379: (t, e, n) => {
        'use strict'
        var o = (function t() {
          var e
          return function t() {
            if (typeof e === 'undefined') {
              e = Boolean(window && document && document.all && !window.atob)
            }
            return e
          }
        })()
        var i = (function t() {
          var e = {}
          return function t(n) {
            if (typeof e[n] === 'undefined') {
              var o = document.querySelector(n)
              if (window.HTMLIFrameElement && o instanceof window.HTMLIFrameElement) {
                try {
                  o = o.contentDocument.head
                } catch (t) {
                  o = null
                }
              }
              e[n] = o
            }
            return e[n]
          }
        })()
        var r = []
        function s(t) {
          var e = -1
          for (var n = 0; n < r.length; n++) {
            if (r[n].identifier === t) {
              e = n
              break
            }
          }
          return e
        }
        function a(t, e) {
          var n = {}
          var o = []
          for (var i = 0; i < t.length; i++) {
            var a = t[i]
            var c = e.base ? a[0] + e.base : a[0]
            var l = n[c] || 0
            var d = ''.concat(c, ' ').concat(l)
            n[c] = l + 1
            var u = s(d)
            var h = { css: a[1], media: a[2], sourceMap: a[3] }
            if (u !== -1) {
              r[u].references++
              r[u].updater(h)
            } else {
              r.push({ identifier: d, updater: m(h, e), references: 1 })
            }
            o.push(d)
          }
          return o
        }
        function c(t) {
          var e = document.createElement('style')
          var o = t.attributes || {}
          if (typeof o.nonce === 'undefined') {
            var r = true ? n.nc : 0
            if (r) {
              o.nonce = r
            }
          }
          Object.keys(o).forEach(function (t) {
            e.setAttribute(t, o[t])
          })
          if (typeof t.insert === 'function') {
            t.insert(e)
          } else {
            var s = i(t.insert || 'head')
            if (!s) {
              throw new Error(
                "Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.",
              )
            }
            s.appendChild(e)
          }
          return e
        }
        function l(t) {
          if (t.parentNode === null) {
            return false
          }
          t.parentNode.removeChild(t)
        }
        var d = (function t() {
          var e = []
          return function t(n, o) {
            e[n] = o
            return e.filter(Boolean).join('\n')
          }
        })()
        function u(t, e, n, o) {
          var i = n ? '' : o.media ? '@media '.concat(o.media, ' {').concat(o.css, '}') : o.css
          if (t.styleSheet) {
            t.styleSheet.cssText = d(e, i)
          } else {
            var r = document.createTextNode(i)
            var s = t.childNodes
            if (s[e]) {
              t.removeChild(s[e])
            }
            if (s.length) {
              t.insertBefore(r, s[e])
            } else {
              t.appendChild(r)
            }
          }
        }
        function h(t, e, n) {
          var o = n.css
          var i = n.media
          var r = n.sourceMap
          if (i) {
            t.setAttribute('media', i)
          } else {
            t.removeAttribute('media')
          }
          if (r && typeof btoa !== 'undefined') {
            o += '\n/*# sourceMappingURL=data:application/json;base64,'.concat(
              btoa(unescape(encodeURIComponent(JSON.stringify(r)))),
              ' */',
            )
          }
          if (t.styleSheet) {
            t.styleSheet.cssText = o
          } else {
            while (t.firstChild) {
              t.removeChild(t.firstChild)
            }
            t.appendChild(document.createTextNode(o))
          }
        }
        var g = null
        var f = 0
        function m(t, e) {
          var n
          var o
          var i
          if (e.singleton) {
            var r = f++
            n = g || (g = c(e))
            o = u.bind(null, n, r, false)
            i = u.bind(null, n, r, true)
          } else {
            n = c(e)
            o = h.bind(null, n, e)
            i = function t() {
              l(n)
            }
          }
          o(t)
          return function e(n) {
            if (n) {
              if (n.css === t.css && n.media === t.media && n.sourceMap === t.sourceMap) {
                return
              }
              o((t = n))
            } else {
              i()
            }
          }
        }
        t.exports = function (t, e) {
          e = e || {}
          if (!e.singleton && typeof e.singleton !== 'boolean') {
            e.singleton = o()
          }
          t = t || []
          var n = a(t, e)
          return function t(o) {
            o = o || []
            if (Object.prototype.toString.call(o) !== '[object Array]') {
              return
            }
            for (var i = 0; i < n.length; i++) {
              var c = n[i]
              var l = s(c)
              r[l].references--
            }
            var d = a(o, e)
            for (var u = 0; u < n.length; u++) {
              var h = n[u]
              var g = s(h)
              if (r[g].references === 0) {
                r[g].updater()
                r.splice(g, 1)
              }
            }
            n = d
          }
        }
      },
    }
    var e = {}
    function n(o) {
      var i = e[o]
      if (i !== undefined) {
        return i.exports
      }
      var r = (e[o] = { id: o, exports: {} })
      t[o](r, r.exports, n)
      return r.exports
    }
    ;(() => {
      n.n = (t) => {
        var e = t && t.__esModule ? () => t['default'] : () => t
        n.d(e, { a: e })
        return e
      }
    })()
    ;(() => {
      n.d = (t, e) => {
        for (var o in e) {
          if (n.o(e, o) && !n.o(t, o)) {
            Object.defineProperty(t, o, { enumerable: true, get: e[o] })
          }
        }
      }
    })()
    ;(() => {
      n.g = (function () {
        if (typeof globalThis === 'object') return globalThis
        try {
          return this || new Function('return this')()
        } catch (t) {
          if (typeof window === 'object') return window
        }
      })()
    })()
    ;(() => {
      n.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e)
    })()
    ;(() => {
      n.nc = undefined
    })()
    var o = {}
    ;(() => {
      'use strict'
      n.d(o, { default: () => eK })
      function t({ emitter: t, activator: e, callback: n, contextElements: o }) {
        t.listenTo(document, 'mousedown', (t, i) => {
          if (!e()) {
            return
          }
          const r = typeof i.composedPath == 'function' ? i.composedPath() : []
          const s = typeof o == 'function' ? o() : o
          for (const t of s) {
            if (t.contains(i.target) || r.includes(t)) {
              return
            }
          }
          n()
        })
      }
      function e(t) {
        class e extends t {
          disableCssTransitions() {
            this._isCssTransitionsDisabled = true
          }
          enableCssTransitions() {
            this._isCssTransitionsDisabled = false
          }
          constructor(...t) {
            super(...t)
            this.set('_isCssTransitionsDisabled', false)
            this.initializeCssTransitionDisablerMixin()
          }
          initializeCssTransitionDisablerMixin() {
            this.extendTemplate({
              attributes: { class: [this.bindTemplate.if('_isCssTransitionsDisabled', 'ck-transitions-disabled')] },
            })
          }
        }
        return e
      }
      function i({ view: t }) {
        t.listenTo(
          t.element,
          'submit',
          (e, n) => {
            n.preventDefault()
            t.fire('submit')
          },
          { useCapture: true },
        )
      }
      function r({ keystrokeHandler: t, focusTracker: e, gridItems: n, numberOfColumns: o, uiLanguageDirection: i }) {
        const r = typeof o === 'number' ? () => o : o
        t.set(
          'arrowright',
          s((t, e) => (i === 'rtl' ? c(t, e.length) : a(t, e.length))),
        )
        t.set(
          'arrowleft',
          s((t, e) => (i === 'rtl' ? a(t, e.length) : c(t, e.length))),
        )
        t.set(
          'arrowup',
          s((t, e) => {
            let n = t - r()
            if (n < 0) {
              n = t + r() * Math.floor(e.length / r())
              if (n > e.length - 1) {
                n -= r()
              }
            }
            return n
          }),
        )
        t.set(
          'arrowdown',
          s((t, e) => {
            let n = t + r()
            if (n > e.length - 1) {
              n = t % r()
            }
            return n
          }),
        )
        function s(t) {
          return (o) => {
            const i = n.find((t) => t.element === e.focusedElement)
            const r = n.getIndex(i)
            const s = t(r, n)
            n.get(s).focus()
            o.stopPropagation()
            o.preventDefault()
          }
        }
        function a(t, e) {
          if (t === e - 1) {
            return 0
          } else {
            return t + 1
          }
        }
        function c(t, e) {
          if (t === 0) {
            return e - 1
          } else {
            return t - 1
          }
        }
      }
      function s() {
        try {
          return navigator.userAgent.toLowerCase()
        } catch (t) {
          return ''
        }
      }
      const a = s()
      const c = {
        isMac: d(a),
        isWindows: u(a),
        isGecko: h(a),
        isSafari: g(a),
        isiOS: f(a),
        isAndroid: m(a),
        isBlink: p(a),
        features: { isRegExpUnicodePropertySupported: b() },
      }
      const l = c
      function d(t) {
        return t.indexOf('macintosh') > -1
      }
      function u(t) {
        return t.indexOf('windows') > -1
      }
      function h(t) {
        return !!t.match(/gecko\/\d+/)
      }
      function g(t) {
        return t.indexOf(' applewebkit/') > -1 && t.indexOf('chrome') === -1
      }
      function f(t) {
        return !!t.match(/iphone|ipad/i) || (d(t) && navigator.maxTouchPoints > 0)
      }
      function m(t) {
        return t.indexOf('android') > -1
      }
      function p(t) {
        return t.indexOf('chrome/') > -1 && t.indexOf('edge/') < 0
      }
      function b() {
        let t = false
        try {
          t = 'ć'.search(new RegExp('[\\p{L}]', 'u')) === 0
        } catch (t) {}
        return t
      }
      function k(t, e, n, o) {
        n =
          n ||
          function (t, e) {
            return t === e
          }
        const i = Array.isArray(t) ? t : Array.prototype.slice.call(t)
        const r = Array.isArray(e) ? e : Array.prototype.slice.call(e)
        const s = w(i, r, n)
        const a = o ? v(s, r.length) : C(r, s)
        return a
      }
      function w(t, e, n) {
        const o = A(t, e, n)
        if (o === -1) {
          return { firstIndex: -1, lastIndexOld: -1, lastIndexNew: -1 }
        }
        const i = _(t, o)
        const r = _(e, o)
        const s = A(i, r, n)
        const a = t.length - s
        const c = e.length - s
        return { firstIndex: o, lastIndexOld: a, lastIndexNew: c }
      }
      function A(t, e, n) {
        for (let o = 0; o < Math.max(t.length, e.length); o++) {
          if (t[o] === undefined || e[o] === undefined || !n(t[o], e[o])) {
            return o
          }
        }
        return -1
      }
      function _(t, e) {
        return t.slice(e).reverse()
      }
      function C(t, e) {
        const n = []
        const { firstIndex: o, lastIndexOld: i, lastIndexNew: r } = e
        if (r - o > 0) {
          n.push({ index: o, type: 'insert', values: t.slice(o, r) })
        }
        if (i - o > 0) {
          n.push({ index: o + (r - o), type: 'delete', howMany: i - o })
        }
        return n
      }
      function v(t, e) {
        const { firstIndex: n, lastIndexOld: o, lastIndexNew: i } = t
        if (n === -1) {
          return Array(e).fill('equal')
        }
        let r = []
        if (n > 0) {
          r = r.concat(Array(n).fill('equal'))
        }
        if (i - n > 0) {
          r = r.concat(Array(i - n).fill('insert'))
        }
        if (o - n > 0) {
          r = r.concat(Array(o - n).fill('delete'))
        }
        if (i < e) {
          r = r.concat(Array(e - i).fill('equal'))
        }
        return r
      }
      function y(t, e, n) {
        n =
          n ||
          function (t, e) {
            return t === e
          }
        const o = t.length
        const i = e.length
        if (o > 200 || i > 200 || o + i > 300) {
          return y.fastDiff(t, e, n, true)
        }
        let r, s
        if (i < o) {
          const n = t
          t = e
          e = n
          r = 'delete'
          s = 'insert'
        } else {
          r = 'insert'
          s = 'delete'
        }
        const a = t.length
        const c = e.length
        const l = c - a
        const d = {}
        const u = {}
        function h(o) {
          const i = (u[o - 1] !== undefined ? u[o - 1] : -1) + 1
          const l = u[o + 1] !== undefined ? u[o + 1] : -1
          const h = i > l ? -1 : 1
          if (d[o + h]) {
            d[o] = d[o + h].slice(0)
          }
          if (!d[o]) {
            d[o] = []
          }
          d[o].push(i > l ? r : s)
          let g = Math.max(i, l)
          let f = g - o
          while (f < a && g < c && n(t[f], e[g])) {
            f++
            g++
            d[o].push('equal')
          }
          return g
        }
        let g = 0
        let f
        do {
          for (f = -g; f < l; f++) {
            u[f] = h(f)
          }
          for (f = l + g; f > l; f--) {
            u[f] = h(f)
          }
          u[l] = h(l)
          g++
        } while (u[l] !== c)
        return d[l].slice(1)
      }
      y.fastDiff = k
      function x() {
        return function t() {
          t.called = true
        }
      }
      const E = x
      class D {
        constructor(t, e) {
          this.source = t
          this.name = e
          this.path = []
          this.stop = E()
          this.off = E()
        }
      }
      const T = new Array(256).fill('').map((t, e) => ('0' + e.toString(16)).slice(-2))
      function I() {
        const t = (Math.random() * 4294967296) >>> 0
        const e = (Math.random() * 4294967296) >>> 0
        const n = (Math.random() * 4294967296) >>> 0
        const o = (Math.random() * 4294967296) >>> 0
        return (
          'e' +
          T[(t >> 0) & 255] +
          T[(t >> 8) & 255] +
          T[(t >> 16) & 255] +
          T[(t >> 24) & 255] +
          T[(e >> 0) & 255] +
          T[(e >> 8) & 255] +
          T[(e >> 16) & 255] +
          T[(e >> 24) & 255] +
          T[(n >> 0) & 255] +
          T[(n >> 8) & 255] +
          T[(n >> 16) & 255] +
          T[(n >> 24) & 255] +
          T[(o >> 0) & 255] +
          T[(o >> 8) & 255] +
          T[(o >> 16) & 255] +
          T[(o >> 24) & 255]
        )
      }
      const S = {
        get(t = 'normal') {
          if (typeof t != 'number') {
            return this[t] || this.normal
          } else {
            return t
          }
        },
        highest: 1e5,
        high: 1e3,
        normal: 0,
        low: -1e3,
        lowest: -1e5,
      }
      const M = S
      function B(t, e) {
        const n = M.get(e.priority)
        for (let o = 0; o < t.length; o++) {
          if (M.get(t[o].priority) < n) {
            t.splice(o, 0, e)
            return
          }
        }
        t.push(e)
      }
      const N = 'https://ckeditor.com/docs/ckeditor5/latest/support/error-codes.html'
      class P extends Error {
        constructor(t, e, n) {
          super(O(t, n))
          this.name = 'CKEditorError'
          this.context = e
          this.data = n
        }
        is(t) {
          return t === 'CKEditorError'
        }
        static rethrowUnexpectedError(t, e) {
          if (t.is && t.is('CKEditorError')) {
            throw t
          }
          const n = new P(t.message, e)
          n.stack = t.stack
          throw n
        }
      }
      function L(t, e) {
        console.warn(...V(t, e))
      }
      function z(t, e) {
        console.error(...V(t, e))
      }
      function R(t) {
        return `\nRead more: ${N}#error-${t}`
      }
      function O(t, e) {
        const n = new WeakSet()
        const o = (t, e) => {
          if (typeof e === 'object' && e !== null) {
            if (n.has(e)) {
              return `[object ${e.constructor.name}]`
            }
            n.add(e)
          }
          return e
        }
        const i = e ? ` ${JSON.stringify(e, o)}` : ''
        const r = R(t)
        return t + i + r
      }
      function V(t, e) {
        const n = R(t)
        return e ? [t, e, n] : [t, n]
      }
      const F = '39.0.0'
      const j = null && F
      const H = new Date(2023, 7, 2)
      const U = typeof window === 'object' ? window : n.g
      if (U.CKEDITOR_VERSION) {
        throw new P('ckeditor-duplicated-modules', null)
      } else {
        U.CKEDITOR_VERSION = F
      }
      const W = Symbol('listeningTo')
      const G = Symbol('emitterId')
      const q = Symbol('delegations')
      const $ = K(Object)
      function K(t) {
        if (!t) {
          return $
        }
        class e extends t {
          on(t, e, n) {
            this.listenTo(this, t, e, n)
          }
          once(t, e, n) {
            let o = false
            const i = (t, ...n) => {
              if (!o) {
                o = true
                t.off()
                e.call(this, t, ...n)
              }
            }
            this.listenTo(this, t, i, n)
          }
          off(t, e) {
            this.stopListening(this, t, e)
          }
          listenTo(t, e, n, o = {}) {
            let i, r
            if (!this[W]) {
              this[W] = {}
            }
            const s = this[W]
            if (!Q(t)) {
              Z(t)
            }
            const a = Q(t)
            if (!(i = s[a])) {
              i = s[a] = { emitter: t, callbacks: {} }
            }
            if (!(r = i.callbacks[e])) {
              r = i.callbacks[e] = []
            }
            r.push(n)
            it(this, t, e, n, o)
          }
          stopListening(t, e, n) {
            const o = this[W]
            let i = t && Q(t)
            const r = o && i ? o[i] : undefined
            const s = r && e ? r.callbacks[e] : undefined
            if (!o || (t && !r) || (e && !s)) {
              return
            }
            if (n) {
              rt(this, t, e, n)
              const o = s.indexOf(n)
              if (o !== -1) {
                if (s.length === 1) {
                  delete r.callbacks[e]
                } else {
                  rt(this, t, e, n)
                }
              }
            } else if (s) {
              while ((n = s.pop())) {
                rt(this, t, e, n)
              }
              delete r.callbacks[e]
            } else if (r) {
              for (e in r.callbacks) {
                this.stopListening(t, e)
              }
              delete o[i]
            } else {
              for (i in o) {
                this.stopListening(o[i].emitter)
              }
              delete this[W]
            }
          }
          fire(t, ...e) {
            try {
              const n = t instanceof D ? t : new D(this, t)
              const o = n.name
              let i = nt(this, o)
              n.path.push(this)
              if (i) {
                const t = [n, ...e]
                i = Array.from(i)
                for (let e = 0; e < i.length; e++) {
                  i[e].callback.apply(this, t)
                  if (n.off.called) {
                    delete n.off.called
                    this._removeEventListener(o, i[e].callback)
                  }
                  if (n.stop.called) {
                    break
                  }
                }
              }
              const r = this[q]
              if (r) {
                const t = r.get(o)
                const i = r.get('*')
                if (t) {
                  ot(t, n, e)
                }
                if (i) {
                  ot(i, n, e)
                }
              }
              return n.return
            } catch (t) {
              P.rethrowUnexpectedError(t, this)
            }
          }
          delegate(...t) {
            return {
              to: (e, n) => {
                if (!this[q]) {
                  this[q] = new Map()
                }
                t.forEach((t) => {
                  const o = this[q].get(t)
                  if (!o) {
                    this[q].set(t, new Map([[e, n]]))
                  } else {
                    o.set(e, n)
                  }
                })
              },
            }
          }
          stopDelegating(t, e) {
            if (!this[q]) {
              return
            }
            if (!t) {
              this[q].clear()
            } else if (!e) {
              this[q].delete(t)
            } else {
              const n = this[q].get(t)
              if (n) {
                n.delete(e)
              }
            }
          }
          _addEventListener(t, e, n) {
            tt(this, t)
            const o = et(this, t)
            const i = M.get(n.priority)
            const r = { callback: e, priority: i }
            for (const t of o) {
              B(t, r)
            }
          }
          _removeEventListener(t, e) {
            const n = et(this, t)
            for (const t of n) {
              for (let n = 0; n < t.length; n++) {
                if (t[n].callback == e) {
                  t.splice(n, 1)
                  n--
                }
              }
            }
          }
        }
        return e
      }
      ;[
        'on',
        'once',
        'off',
        'listenTo',
        'stopListening',
        'fire',
        'delegate',
        'stopDelegating',
        '_addEventListener',
        '_removeEventListener',
      ].forEach((t) => {
        K[t] = $.prototype[t]
      })
      function Y(t, e) {
        const n = t[W]
        if (n && n[e]) {
          return n[e].emitter
        }
        return null
      }
      function Z(t, e) {
        if (!t[G]) {
          t[G] = e || I()
        }
      }
      function Q(t) {
        return t[G]
      }
      function J(t) {
        if (!t._events) {
          Object.defineProperty(t, '_events', { value: {} })
        }
        return t._events
      }
      function X() {
        return { callbacks: [], childEvents: [] }
      }
      function tt(t, e) {
        const n = J(t)
        if (n[e]) {
          return
        }
        let o = e
        let i = null
        const r = []
        while (o !== '') {
          if (n[o]) {
            break
          }
          n[o] = X()
          r.push(n[o])
          if (i) {
            n[o].childEvents.push(i)
          }
          i = o
          o = o.substr(0, o.lastIndexOf(':'))
        }
        if (o !== '') {
          for (const t of r) {
            t.callbacks = n[o].callbacks.slice()
          }
          n[o].childEvents.push(i)
        }
      }
      function et(t, e) {
        const n = J(t)[e]
        if (!n) {
          return []
        }
        let o = [n.callbacks]
        for (let e = 0; e < n.childEvents.length; e++) {
          const i = et(t, n.childEvents[e])
          o = o.concat(i)
        }
        return o
      }
      function nt(t, e) {
        let n
        if (!t._events || !(n = t._events[e]) || !n.callbacks.length) {
          if (e.indexOf(':') > -1) {
            return nt(t, e.substr(0, e.lastIndexOf(':')))
          } else {
            return null
          }
        }
        return n.callbacks
      }
      function ot(t, e, n) {
        for (let [o, i] of t) {
          if (!i) {
            i = e.name
          } else if (typeof i == 'function') {
            i = i(e.name)
          }
          const t = new D(e.source, i)
          t.path = [...e.path]
          o.fire(t, ...n)
        }
      }
      function it(t, e, n, o, i) {
        if (e._addEventListener) {
          e._addEventListener(n, o, i)
        } else {
          t._addEventListener.call(e, n, o, i)
        }
      }
      function rt(t, e, n, o) {
        if (e._removeEventListener) {
          e._removeEventListener(n, o)
        } else {
          t._removeEventListener.call(e, n, o)
        }
      }
      function st(t) {
        var e = typeof t
        return t != null && (e == 'object' || e == 'function')
      }
      const at = st
      const ct = Symbol('observableProperties')
      const lt = Symbol('boundObservables')
      const dt = Symbol('boundProperties')
      const ut = Symbol('decoratedMethods')
      const ht = Symbol('decoratedOriginal')
      const gt = ft(K())
      function ft(t) {
        if (!t) {
          return gt
        }
        class e extends t {
          set(t, e) {
            if (at(t)) {
              Object.keys(t).forEach((e) => {
                this.set(e, t[e])
              }, this)
              return
            }
            mt(this)
            const n = this[ct]
            if (t in this && !n.has(t)) {
              throw new P('observable-set-cannot-override', this)
            }
            Object.defineProperty(this, t, {
              enumerable: true,
              configurable: true,
              get() {
                return n.get(t)
              },
              set(e) {
                const o = n.get(t)
                let i = this.fire(`set:${t}`, t, e, o)
                if (i === undefined) {
                  i = e
                }
                if (o !== i || !n.has(t)) {
                  n.set(t, i)
                  this.fire(`change:${t}`, t, i, o)
                }
              },
            })
            this[t] = e
          }
          bind(...t) {
            if (!t.length || !wt(t)) {
              throw new P('observable-bind-wrong-properties', this)
            }
            if (new Set(t).size !== t.length) {
              throw new P('observable-bind-duplicate-properties', this)
            }
            mt(this)
            const e = this[dt]
            t.forEach((t) => {
              if (e.has(t)) {
                throw new P('observable-bind-rebind', this)
              }
            })
            const n = new Map()
            t.forEach((t) => {
              const o = { property: t, to: [] }
              e.set(t, o)
              n.set(t, o)
            })
            return { to: pt, toMany: bt, _observable: this, _bindProperties: t, _to: [], _bindings: n }
          }
          unbind(...t) {
            if (!this[ct]) {
              return
            }
            const e = this[dt]
            const n = this[lt]
            if (t.length) {
              if (!wt(t)) {
                throw new P('observable-unbind-wrong-properties', this)
              }
              t.forEach((t) => {
                const o = e.get(t)
                if (!o) {
                  return
                }
                o.to.forEach(([t, e]) => {
                  const i = n.get(t)
                  const r = i[e]
                  r.delete(o)
                  if (!r.size) {
                    delete i[e]
                  }
                  if (!Object.keys(i).length) {
                    n.delete(t)
                    this.stopListening(t, 'change')
                  }
                })
                e.delete(t)
              })
            } else {
              n.forEach((t, e) => {
                this.stopListening(e, 'change')
              })
              n.clear()
              e.clear()
            }
          }
          decorate(t) {
            mt(this)
            const e = this[t]
            if (!e) {
              throw new P('observablemixin-cannot-decorate-undefined', this, { object: this, methodName: t })
            }
            this.on(t, (t, n) => {
              t.return = e.apply(this, n)
            })
            this[t] = function (...e) {
              return this.fire(t, e)
            }
            this[t][ht] = e
            if (!this[ut]) {
              this[ut] = []
            }
            this[ut].push(t)
          }
          stopListening(t, e, n) {
            if (!t && this[ut]) {
              for (const t of this[ut]) {
                this[t] = this[t][ht]
              }
              delete this[ut]
            }
            super.stopListening(t, e, n)
          }
        }
        return e
      }
      ;[
        'set',
        'bind',
        'unbind',
        'decorate',
        'on',
        'once',
        'off',
        'listenTo',
        'stopListening',
        'fire',
        'delegate',
        'stopDelegating',
        '_addEventListener',
        '_removeEventListener',
      ].forEach((t) => {
        ft[t] = gt.prototype[t]
      })
      function mt(t) {
        if (t[ct]) {
          return
        }
        Object.defineProperty(t, ct, { value: new Map() })
        Object.defineProperty(t, lt, { value: new Map() })
        Object.defineProperty(t, dt, { value: new Map() })
      }
      function pt(...t) {
        const e = At(...t)
        const n = Array.from(this._bindings.keys())
        const o = n.length
        if (!e.callback && e.to.length > 1) {
          throw new P('observable-bind-to-no-callback', this)
        }
        if (o > 1 && e.callback) {
          throw new P('observable-bind-to-extra-callback', this)
        }
        e.to.forEach((t) => {
          if (t.properties.length && t.properties.length !== o) {
            throw new P('observable-bind-to-properties-length', this)
          }
          if (!t.properties.length) {
            t.properties = this._bindProperties
          }
        })
        this._to = e.to
        if (e.callback) {
          this._bindings.get(n[0]).callback = e.callback
        }
        yt(this._observable, this._to)
        Ct(this)
        this._bindProperties.forEach((t) => {
          vt(this._observable, t)
        })
      }
      function bt(t, e, n) {
        if (this._bindings.size > 1) {
          throw new P('observable-bind-to-many-not-one-binding', this)
        }
        this.to(...kt(t, e), n)
      }
      function kt(t, e) {
        const n = t.map((t) => [t, e])
        return Array.prototype.concat.apply([], n)
      }
      function wt(t) {
        return t.every((t) => typeof t == 'string')
      }
      function At(...t) {
        if (!t.length) {
          throw new P('observable-bind-to-parse-error', null)
        }
        const e = { to: [] }
        let n
        if (typeof t[t.length - 1] == 'function') {
          e.callback = t.pop()
        }
        t.forEach((t) => {
          if (typeof t == 'string') {
            n.properties.push(t)
          } else if (typeof t == 'object') {
            n = { observable: t, properties: [] }
            e.to.push(n)
          } else {
            throw new P('observable-bind-to-parse-error', null)
          }
        })
        return e
      }
      function _t(t, e, n, o) {
        const i = t[lt]
        const r = i.get(n)
        const s = r || {}
        if (!s[o]) {
          s[o] = new Set()
        }
        s[o].add(e)
        if (!r) {
          i.set(n, s)
        }
      }
      function Ct(t) {
        let e
        t._bindings.forEach((n, o) => {
          t._to.forEach((i) => {
            e = i.properties[n.callback ? 0 : t._bindProperties.indexOf(o)]
            n.to.push([i.observable, e])
            _t(t._observable, n, i.observable, e)
          })
        })
      }
      function vt(t, e) {
        const n = t[dt]
        const o = n.get(e)
        let i
        if (o.callback) {
          i = o.callback.apply(
            t,
            o.to.map((t) => t[0][t[1]]),
          )
        } else {
          i = o.to[0]
          i = i[0][i[1]]
        }
        if (Object.prototype.hasOwnProperty.call(t, e)) {
          t[e] = i
        } else {
          t.set(e, i)
        }
      }
      function yt(t, e) {
        e.forEach((e) => {
          const n = t[lt]
          let o
          if (!n.get(e.observable)) {
            t.listenTo(e.observable, 'change', (i, r) => {
              o = n.get(e.observable)[r]
              if (o) {
                o.forEach((e) => {
                  vt(t, e.property)
                })
              }
            })
          }
        })
      }
      class xt {
        constructor() {
          this._replacedElements = []
        }
        replace(t, e) {
          this._replacedElements.push({ element: t, newElement: e })
          t.style.display = 'none'
          if (e) {
            t.parentNode.insertBefore(e, t.nextSibling)
          }
        }
        restore() {
          this._replacedElements.forEach(({ element: t, newElement: e }) => {
            t.style.display = ''
            if (e) {
              e.remove()
            }
          })
          this._replacedElements = []
        }
      }
      function Et(t) {
        let e = 0
        for (const n of t) {
          e++
        }
        return e
      }
      function Dt(t, e) {
        const n = Math.min(t.length, e.length)
        for (let o = 0; o < n; o++) {
          if (t[o] != e[o]) {
            return o
          }
        }
        if (t.length == e.length) {
          return 'same'
        } else if (t.length < e.length) {
          return 'prefix'
        } else {
          return 'extension'
        }
      }
      function Tt(t) {
        return !!(t && t[Symbol.iterator])
      }
      var It = typeof global == 'object' && global && global.Object === Object && global
      const St = It
      var Mt = typeof self == 'object' && self && self.Object === Object && self
      var Bt = St || Mt || Function('return this')()
      const Nt = Bt
      var Pt = Nt.Symbol
      const Lt = Pt
      var zt = Object.prototype
      var Rt = zt.hasOwnProperty
      var Ot = zt.toString
      var Vt = Lt ? Lt.toStringTag : undefined
      function Ft(t) {
        var e = Rt.call(t, Vt),
          n = t[Vt]
        try {
          t[Vt] = undefined
          var o = true
        } catch (t) {}
        var i = Ot.call(t)
        if (o) {
          if (e) {
            t[Vt] = n
          } else {
            delete t[Vt]
          }
        }
        return i
      }
      const jt = Ft
      var Ht = Object.prototype
      var Ut = Ht.toString
      function Wt(t) {
        return Ut.call(t)
      }
      const Gt = Wt
      var qt = '[object Null]',
        $t = '[object Undefined]'
      var Kt = Lt ? Lt.toStringTag : undefined
      function Yt(t) {
        if (t == null) {
          return t === undefined ? $t : qt
        }
        return Kt && Kt in Object(t) ? jt(t) : Gt(t)
      }
      const Zt = Yt
      var Qt = Array.isArray
      const Jt = Qt
      function Xt(t) {
        return t != null && typeof t == 'object'
      }
      const te = Xt
      var ee = '[object String]'
      function ne(t) {
        return typeof t == 'string' || (!Jt(t) && te(t) && Zt(t) == ee)
      }
      const oe = ne
      function ie(t, e, n = {}, o = []) {
        const i = n && n.xmlns
        const r = i ? t.createElementNS(i, e) : t.createElement(e)
        for (const t in n) {
          r.setAttribute(t, n[t])
        }
        if (oe(o) || !Tt(o)) {
          o = [o]
        }
        for (let e of o) {
          if (oe(e)) {
            e = t.createTextNode(e)
          }
          r.appendChild(e)
        }
        return r
      }
      function re(t, e) {
        return function (n) {
          return t(e(n))
        }
      }
      const se = re
      var ae = se(Object.getPrototypeOf, Object)
      const ce = ae
      var le = '[object Object]'
      var de = Function.prototype,
        ue = Object.prototype
      var he = de.toString
      var ge = ue.hasOwnProperty
      var fe = he.call(Object)
      function me(t) {
        if (!te(t) || Zt(t) != le) {
          return false
        }
        var e = ce(t)
        if (e === null) {
          return true
        }
        var n = ge.call(e, 'constructor') && e.constructor
        return typeof n == 'function' && n instanceof n && he.call(n) == fe
      }
      const pe = me
      function be() {
        this.__data__ = []
        this.size = 0
      }
      const ke = be
      function we(t, e) {
        return t === e || (t !== t && e !== e)
      }
      const Ae = we
      function _e(t, e) {
        var n = t.length
        while (n--) {
          if (Ae(t[n][0], e)) {
            return n
          }
        }
        return -1
      }
      const Ce = _e
      var ve = Array.prototype
      var ye = ve.splice
      function xe(t) {
        var e = this.__data__,
          n = Ce(e, t)
        if (n < 0) {
          return false
        }
        var o = e.length - 1
        if (n == o) {
          e.pop()
        } else {
          ye.call(e, n, 1)
        }
        --this.size
        return true
      }
      const Ee = xe
      function De(t) {
        var e = this.__data__,
          n = Ce(e, t)
        return n < 0 ? undefined : e[n][1]
      }
      const Te = De
      function Ie(t) {
        return Ce(this.__data__, t) > -1
      }
      const Se = Ie
      function Me(t, e) {
        var n = this.__data__,
          o = Ce(n, t)
        if (o < 0) {
          ++this.size
          n.push([t, e])
        } else {
          n[o][1] = e
        }
        return this
      }
      const Be = Me
      function Ne(t) {
        var e = -1,
          n = t == null ? 0 : t.length
        this.clear()
        while (++e < n) {
          var o = t[e]
          this.set(o[0], o[1])
        }
      }
      Ne.prototype.clear = ke
      Ne.prototype['delete'] = Ee
      Ne.prototype.get = Te
      Ne.prototype.has = Se
      Ne.prototype.set = Be
      const Pe = Ne
      function Le() {
        this.__data__ = new Pe()
        this.size = 0
      }
      const ze = Le
      function Re(t) {
        var e = this.__data__,
          n = e['delete'](t)
        this.size = e.size
        return n
      }
      const Oe = Re
      function Ve(t) {
        return this.__data__.get(t)
      }
      const Fe = Ve
      function je(t) {
        return this.__data__.has(t)
      }
      const He = je
      var Ue = '[object AsyncFunction]',
        We = '[object Function]',
        Ge = '[object GeneratorFunction]',
        qe = '[object Proxy]'
      function $e(t) {
        if (!at(t)) {
          return false
        }
        var e = Zt(t)
        return e == We || e == Ge || e == Ue || e == qe
      }
      const Ke = $e
      var Ye = Nt['__core-js_shared__']
      const Ze = Ye
      var Qe = (function () {
        var t = /[^.]+$/.exec((Ze && Ze.keys && Ze.keys.IE_PROTO) || '')
        return t ? 'Symbol(src)_1.' + t : ''
      })()
      function Je(t) {
        return !!Qe && Qe in t
      }
      const Xe = Je
      var tn = Function.prototype
      var en = tn.toString
      function nn(t) {
        if (t != null) {
          try {
            return en.call(t)
          } catch (t) {}
          try {
            return t + ''
          } catch (t) {}
        }
        return ''
      }
      const on = nn
      var rn = /[\\^$.*+?()[\]{}|]/g
      var sn = /^\[object .+?Constructor\]$/
      var an = Function.prototype,
        cn = Object.prototype
      var ln = an.toString
      var dn = cn.hasOwnProperty
      var un = RegExp(
        '^' +
          ln
            .call(dn)
            .replace(rn, '\\$&')
            .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') +
          '$',
      )
      function hn(t) {
        if (!at(t) || Xe(t)) {
          return false
        }
        var e = Ke(t) ? un : sn
        return e.test(on(t))
      }
      const gn = hn
      function fn(t, e) {
        return t == null ? undefined : t[e]
      }
      const mn = fn
      function pn(t, e) {
        var n = mn(t, e)
        return gn(n) ? n : undefined
      }
      const bn = pn
      var kn = bn(Nt, 'Map')
      const wn = kn
      var An = bn(Object, 'create')
      const _n = An
      function Cn() {
        this.__data__ = _n ? _n(null) : {}
        this.size = 0
      }
      const vn = Cn
      function yn(t) {
        var e = this.has(t) && delete this.__data__[t]
        this.size -= e ? 1 : 0
        return e
      }
      const xn = yn
      var En = '__lodash_hash_undefined__'
      var Dn = Object.prototype
      var Tn = Dn.hasOwnProperty
      function In(t) {
        var e = this.__data__
        if (_n) {
          var n = e[t]
          return n === En ? undefined : n
        }
        return Tn.call(e, t) ? e[t] : undefined
      }
      const Sn = In
      var Mn = Object.prototype
      var Bn = Mn.hasOwnProperty
      function Nn(t) {
        var e = this.__data__
        return _n ? e[t] !== undefined : Bn.call(e, t)
      }
      const Pn = Nn
      var Ln = '__lodash_hash_undefined__'
      function zn(t, e) {
        var n = this.__data__
        this.size += this.has(t) ? 0 : 1
        n[t] = _n && e === undefined ? Ln : e
        return this
      }
      const Rn = zn
      function On(t) {
        var e = -1,
          n = t == null ? 0 : t.length
        this.clear()
        while (++e < n) {
          var o = t[e]
          this.set(o[0], o[1])
        }
      }
      On.prototype.clear = vn
      On.prototype['delete'] = xn
      On.prototype.get = Sn
      On.prototype.has = Pn
      On.prototype.set = Rn
      const Vn = On
      function Fn() {
        this.size = 0
        this.__data__ = { hash: new Vn(), map: new (wn || Pe)(), string: new Vn() }
      }
      const jn = Fn
      function Hn(t) {
        var e = typeof t
        return e == 'string' || e == 'number' || e == 'symbol' || e == 'boolean' ? t !== '__proto__' : t === null
      }
      const Un = Hn
      function Wn(t, e) {
        var n = t.__data__
        return Un(e) ? n[typeof e == 'string' ? 'string' : 'hash'] : n.map
      }
      const Gn = Wn
      function qn(t) {
        var e = Gn(this, t)['delete'](t)
        this.size -= e ? 1 : 0
        return e
      }
      const $n = qn
      function Kn(t) {
        return Gn(this, t).get(t)
      }
      const Yn = Kn
      function Zn(t) {
        return Gn(this, t).has(t)
      }
      const Qn = Zn
      function Jn(t, e) {
        var n = Gn(this, t),
          o = n.size
        n.set(t, e)
        this.size += n.size == o ? 0 : 1
        return this
      }
      const Xn = Jn
      function to(t) {
        var e = -1,
          n = t == null ? 0 : t.length
        this.clear()
        while (++e < n) {
          var o = t[e]
          this.set(o[0], o[1])
        }
      }
      to.prototype.clear = jn
      to.prototype['delete'] = $n
      to.prototype.get = Yn
      to.prototype.has = Qn
      to.prototype.set = Xn
      const eo = to
      var no = 200
      function oo(t, e) {
        var n = this.__data__
        if (n instanceof Pe) {
          var o = n.__data__
          if (!wn || o.length < no - 1) {
            o.push([t, e])
            this.size = ++n.size
            return this
          }
          n = this.__data__ = new eo(o)
        }
        n.set(t, e)
        this.size = n.size
        return this
      }
      const io = oo
      function ro(t) {
        var e = (this.__data__ = new Pe(t))
        this.size = e.size
      }
      ro.prototype.clear = ze
      ro.prototype['delete'] = Oe
      ro.prototype.get = Fe
      ro.prototype.has = He
      ro.prototype.set = io
      const so = ro
      function ao(t, e) {
        var n = -1,
          o = t == null ? 0 : t.length
        while (++n < o) {
          if (e(t[n], n, t) === false) {
            break
          }
        }
        return t
      }
      const co = ao
      var lo = (function () {
        try {
          var t = bn(Object, 'defineProperty')
          t({}, '', {})
          return t
        } catch (t) {}
      })()
      const uo = lo
      function ho(t, e, n) {
        if (e == '__proto__' && uo) {
          uo(t, e, { configurable: true, enumerable: true, value: n, writable: true })
        } else {
          t[e] = n
        }
      }
      const go = ho
      var fo = Object.prototype
      var mo = fo.hasOwnProperty
      function po(t, e, n) {
        var o = t[e]
        if (!(mo.call(t, e) && Ae(o, n)) || (n === undefined && !(e in t))) {
          go(t, e, n)
        }
      }
      const bo = po
      function ko(t, e, n, o) {
        var i = !n
        n || (n = {})
        var r = -1,
          s = e.length
        while (++r < s) {
          var a = e[r]
          var c = o ? o(n[a], t[a], a, n, t) : undefined
          if (c === undefined) {
            c = t[a]
          }
          if (i) {
            go(n, a, c)
          } else {
            bo(n, a, c)
          }
        }
        return n
      }
      const wo = ko
      function Ao(t, e) {
        var n = -1,
          o = Array(t)
        while (++n < t) {
          o[n] = e(n)
        }
        return o
      }
      const _o = Ao
      var Co = '[object Arguments]'
      function vo(t) {
        return te(t) && Zt(t) == Co
      }
      const yo = vo
      var xo = Object.prototype
      var Eo = xo.hasOwnProperty
      var Do = xo.propertyIsEnumerable
      var To = yo(
        (function () {
          return arguments
        })(),
      )
        ? yo
        : function (t) {
            return te(t) && Eo.call(t, 'callee') && !Do.call(t, 'callee')
          }
      const Io = To
      function So() {
        return false
      }
      const Mo = So
      var Bo = typeof exports == 'object' && exports && !exports.nodeType && exports
      var No = Bo && typeof module == 'object' && module && !module.nodeType && module
      var Po = No && No.exports === Bo
      var Lo = Po ? Nt.Buffer : undefined
      var zo = Lo ? Lo.isBuffer : undefined
      var Ro = zo || Mo
      const Oo = Ro
      var Vo = 9007199254740991
      var Fo = /^(?:0|[1-9]\d*)$/
      function jo(t, e) {
        var n = typeof t
        e = e == null ? Vo : e
        return !!e && (n == 'number' || (n != 'symbol' && Fo.test(t))) && t > -1 && t % 1 == 0 && t < e
      }
      const Ho = jo
      var Uo = 9007199254740991
      function Wo(t) {
        return typeof t == 'number' && t > -1 && t % 1 == 0 && t <= Uo
      }
      const Go = Wo
      var qo = '[object Arguments]',
        $o = '[object Array]',
        Ko = '[object Boolean]',
        Yo = '[object Date]',
        Zo = '[object Error]',
        Qo = '[object Function]',
        Jo = '[object Map]',
        Xo = '[object Number]',
        ti = '[object Object]',
        ei = '[object RegExp]',
        ni = '[object Set]',
        oi = '[object String]',
        ii = '[object WeakMap]'
      var ri = '[object ArrayBuffer]',
        si = '[object DataView]',
        ai = '[object Float32Array]',
        ci = '[object Float64Array]',
        li = '[object Int8Array]',
        di = '[object Int16Array]',
        ui = '[object Int32Array]',
        hi = '[object Uint8Array]',
        gi = '[object Uint8ClampedArray]',
        fi = '[object Uint16Array]',
        mi = '[object Uint32Array]'
      var pi = {}
      pi[ai] = pi[ci] = pi[li] = pi[di] = pi[ui] = pi[hi] = pi[gi] = pi[fi] = pi[mi] = true
      pi[qo] =
        pi[$o] =
        pi[ri] =
        pi[Ko] =
        pi[si] =
        pi[Yo] =
        pi[Zo] =
        pi[Qo] =
        pi[Jo] =
        pi[Xo] =
        pi[ti] =
        pi[ei] =
        pi[ni] =
        pi[oi] =
        pi[ii] =
          false
      function bi(t) {
        return te(t) && Go(t.length) && !!pi[Zt(t)]
      }
      const ki = bi
      function wi(t) {
        return function (e) {
          return t(e)
        }
      }
      const Ai = wi
      var _i = typeof exports == 'object' && exports && !exports.nodeType && exports
      var Ci = _i && typeof module == 'object' && module && !module.nodeType && module
      var vi = Ci && Ci.exports === _i
      var yi = vi && St.process
      var xi = (function () {
        try {
          var t = Ci && Ci.require && Ci.require('util').types
          if (t) {
            return t
          }
          return yi && yi.binding && yi.binding('util')
        } catch (t) {}
      })()
      const Ei = xi
      var Di = Ei && Ei.isTypedArray
      var Ti = Di ? Ai(Di) : ki
      const Ii = Ti
      var Si = Object.prototype
      var Mi = Si.hasOwnProperty
      function Bi(t, e) {
        var n = Jt(t),
          o = !n && Io(t),
          i = !n && !o && Oo(t),
          r = !n && !o && !i && Ii(t),
          s = n || o || i || r,
          a = s ? _o(t.length, String) : [],
          c = a.length
        for (var l in t) {
          if (
            (e || Mi.call(t, l)) &&
            !(
              s &&
              (l == 'length' ||
                (i && (l == 'offset' || l == 'parent')) ||
                (r && (l == 'buffer' || l == 'byteLength' || l == 'byteOffset')) ||
                Ho(l, c))
            )
          ) {
            a.push(l)
          }
        }
        return a
      }
      const Ni = Bi
      var Pi = Object.prototype
      function Li(t) {
        var e = t && t.constructor,
          n = (typeof e == 'function' && e.prototype) || Pi
        return t === n
      }
      const zi = Li
      var Ri = se(Object.keys, Object)
      const Oi = Ri
      var Vi = Object.prototype
      var Fi = Vi.hasOwnProperty
      function ji(t) {
        if (!zi(t)) {
          return Oi(t)
        }
        var e = []
        for (var n in Object(t)) {
          if (Fi.call(t, n) && n != 'constructor') {
            e.push(n)
          }
        }
        return e
      }
      const Hi = ji
      function Ui(t) {
        return t != null && Go(t.length) && !Ke(t)
      }
      const Wi = Ui
      function Gi(t) {
        return Wi(t) ? Ni(t) : Hi(t)
      }
      const qi = Gi
      function $i(t, e) {
        return t && wo(e, qi(e), t)
      }
      const Ki = $i
      function Yi(t) {
        var e = []
        if (t != null) {
          for (var n in Object(t)) {
            e.push(n)
          }
        }
        return e
      }
      const Zi = Yi
      var Qi = Object.prototype
      var Ji = Qi.hasOwnProperty
      function Xi(t) {
        if (!at(t)) {
          return Zi(t)
        }
        var e = zi(t),
          n = []
        for (var o in t) {
          if (!(o == 'constructor' && (e || !Ji.call(t, o)))) {
            n.push(o)
          }
        }
        return n
      }
      const tr = Xi
      function er(t) {
        return Wi(t) ? Ni(t, true) : tr(t)
      }
      const nr = er
      function or(t, e) {
        return t && wo(e, nr(e), t)
      }
      const ir = or
      var rr = typeof exports == 'object' && exports && !exports.nodeType && exports
      var sr = rr && typeof module == 'object' && module && !module.nodeType && module
      var ar = sr && sr.exports === rr
      var cr = ar ? Nt.Buffer : undefined,
        lr = cr ? cr.allocUnsafe : undefined
      function dr(t, e) {
        if (e) {
          return t.slice()
        }
        var n = t.length,
          o = lr ? lr(n) : new t.constructor(n)
        t.copy(o)
        return o
      }
      const ur = dr
      function hr(t, e) {
        var n = -1,
          o = t.length
        e || (e = Array(o))
        while (++n < o) {
          e[n] = t[n]
        }
        return e
      }
      const gr = hr
      function fr(t, e) {
        var n = -1,
          o = t == null ? 0 : t.length,
          i = 0,
          r = []
        while (++n < o) {
          var s = t[n]
          if (e(s, n, t)) {
            r[i++] = s
          }
        }
        return r
      }
      const mr = fr
      function pr() {
        return []
      }
      const br = pr
      var kr = Object.prototype
      var wr = kr.propertyIsEnumerable
      var Ar = Object.getOwnPropertySymbols
      var _r = !Ar
        ? br
        : function (t) {
            if (t == null) {
              return []
            }
            t = Object(t)
            return mr(Ar(t), function (e) {
              return wr.call(t, e)
            })
          }
      const Cr = _r
      function vr(t, e) {
        return wo(t, Cr(t), e)
      }
      const yr = vr
      function xr(t, e) {
        var n = -1,
          o = e.length,
          i = t.length
        while (++n < o) {
          t[i + n] = e[n]
        }
        return t
      }
      const Er = xr
      var Dr = Object.getOwnPropertySymbols
      var Tr = !Dr
        ? br
        : function (t) {
            var e = []
            while (t) {
              Er(e, Cr(t))
              t = ce(t)
            }
            return e
          }
      const Ir = Tr
      function Sr(t, e) {
        return wo(t, Ir(t), e)
      }
      const Mr = Sr
      function Br(t, e, n) {
        var o = e(t)
        return Jt(t) ? o : Er(o, n(t))
      }
      const Nr = Br
      function Pr(t) {
        return Nr(t, qi, Cr)
      }
      const Lr = Pr
      function zr(t) {
        return Nr(t, nr, Ir)
      }
      const Rr = zr
      var Or = bn(Nt, 'DataView')
      const Vr = Or
      var Fr = bn(Nt, 'Promise')
      const jr = Fr
      var Hr = bn(Nt, 'Set')
      const Ur = Hr
      var Wr = bn(Nt, 'WeakMap')
      const Gr = Wr
      var qr = '[object Map]',
        $r = '[object Object]',
        Kr = '[object Promise]',
        Yr = '[object Set]',
        Zr = '[object WeakMap]'
      var Qr = '[object DataView]'
      var Jr = on(Vr),
        Xr = on(wn),
        ts = on(jr),
        es = on(Ur),
        ns = on(Gr)
      var os = Zt
      if (
        (Vr && os(new Vr(new ArrayBuffer(1))) != Qr) ||
        (wn && os(new wn()) != qr) ||
        (jr && os(jr.resolve()) != Kr) ||
        (Ur && os(new Ur()) != Yr) ||
        (Gr && os(new Gr()) != Zr)
      ) {
        os = function (t) {
          var e = Zt(t),
            n = e == $r ? t.constructor : undefined,
            o = n ? on(n) : ''
          if (o) {
            switch (o) {
              case Jr:
                return Qr
              case Xr:
                return qr
              case ts:
                return Kr
              case es:
                return Yr
              case ns:
                return Zr
            }
          }
          return e
        }
      }
      const is = os
      var rs = Object.prototype
      var ss = rs.hasOwnProperty
      function as(t) {
        var e = t.length,
          n = new t.constructor(e)
        if (e && typeof t[0] == 'string' && ss.call(t, 'index')) {
          n.index = t.index
          n.input = t.input
        }
        return n
      }
      const cs = as
      var ls = Nt.Uint8Array
      const ds = ls
      function us(t) {
        var e = new t.constructor(t.byteLength)
        new ds(e).set(new ds(t))
        return e
      }
      const hs = us
      function gs(t, e) {
        var n = e ? hs(t.buffer) : t.buffer
        return new t.constructor(n, t.byteOffset, t.byteLength)
      }
      const fs = gs
      var ms = /\w*$/
      function ps(t) {
        var e = new t.constructor(t.source, ms.exec(t))
        e.lastIndex = t.lastIndex
        return e
      }
      const bs = ps
      var ks = Lt ? Lt.prototype : undefined,
        ws = ks ? ks.valueOf : undefined
      function As(t) {
        return ws ? Object(ws.call(t)) : {}
      }
      const _s = As
      function Cs(t, e) {
        var n = e ? hs(t.buffer) : t.buffer
        return new t.constructor(n, t.byteOffset, t.length)
      }
      const vs = Cs
      var ys = '[object Boolean]',
        xs = '[object Date]',
        Es = '[object Map]',
        Ds = '[object Number]',
        Ts = '[object RegExp]',
        Is = '[object Set]',
        Ss = '[object String]',
        Ms = '[object Symbol]'
      var Bs = '[object ArrayBuffer]',
        Ns = '[object DataView]',
        Ps = '[object Float32Array]',
        Ls = '[object Float64Array]',
        zs = '[object Int8Array]',
        Rs = '[object Int16Array]',
        Os = '[object Int32Array]',
        Vs = '[object Uint8Array]',
        Fs = '[object Uint8ClampedArray]',
        js = '[object Uint16Array]',
        Hs = '[object Uint32Array]'
      function Us(t, e, n) {
        var o = t.constructor
        switch (e) {
          case Bs:
            return hs(t)
          case ys:
          case xs:
            return new o(+t)
          case Ns:
            return fs(t, n)
          case Ps:
          case Ls:
          case zs:
          case Rs:
          case Os:
          case Vs:
          case Fs:
          case js:
          case Hs:
            return vs(t, n)
          case Es:
            return new o()
          case Ds:
          case Ss:
            return new o(t)
          case Ts:
            return bs(t)
          case Is:
            return new o()
          case Ms:
            return _s(t)
        }
      }
      const Ws = Us
      var Gs = Object.create
      var qs = (function () {
        function t() {}
        return function (e) {
          if (!at(e)) {
            return {}
          }
          if (Gs) {
            return Gs(e)
          }
          t.prototype = e
          var n = new t()
          t.prototype = undefined
          return n
        }
      })()
      const $s = qs
      function Ks(t) {
        return typeof t.constructor == 'function' && !zi(t) ? $s(ce(t)) : {}
      }
      const Ys = Ks
      var Zs = '[object Map]'
      function Qs(t) {
        return te(t) && is(t) == Zs
      }
      const Js = Qs
      var Xs = Ei && Ei.isMap
      var ta = Xs ? Ai(Xs) : Js
      const ea = ta
      var na = '[object Set]'
      function oa(t) {
        return te(t) && is(t) == na
      }
      const ia = oa
      var ra = Ei && Ei.isSet
      var sa = ra ? Ai(ra) : ia
      const aa = sa
      var ca = 1,
        la = 2,
        da = 4
      var ua = '[object Arguments]',
        ha = '[object Array]',
        ga = '[object Boolean]',
        fa = '[object Date]',
        ma = '[object Error]',
        pa = '[object Function]',
        ba = '[object GeneratorFunction]',
        ka = '[object Map]',
        wa = '[object Number]',
        Aa = '[object Object]',
        _a = '[object RegExp]',
        Ca = '[object Set]',
        va = '[object String]',
        ya = '[object Symbol]',
        xa = '[object WeakMap]'
      var Ea = '[object ArrayBuffer]',
        Da = '[object DataView]',
        Ta = '[object Float32Array]',
        Ia = '[object Float64Array]',
        Sa = '[object Int8Array]',
        Ma = '[object Int16Array]',
        Ba = '[object Int32Array]',
        Na = '[object Uint8Array]',
        Pa = '[object Uint8ClampedArray]',
        La = '[object Uint16Array]',
        za = '[object Uint32Array]'
      var Ra = {}
      Ra[ua] =
        Ra[ha] =
        Ra[Ea] =
        Ra[Da] =
        Ra[ga] =
        Ra[fa] =
        Ra[Ta] =
        Ra[Ia] =
        Ra[Sa] =
        Ra[Ma] =
        Ra[Ba] =
        Ra[ka] =
        Ra[wa] =
        Ra[Aa] =
        Ra[_a] =
        Ra[Ca] =
        Ra[va] =
        Ra[ya] =
        Ra[Na] =
        Ra[Pa] =
        Ra[La] =
        Ra[za] =
          true
      Ra[ma] = Ra[pa] = Ra[xa] = false
      function Oa(t, e, n, o, i, r) {
        var s,
          a = e & ca,
          c = e & la,
          l = e & da
        if (n) {
          s = i ? n(t, o, i, r) : n(t)
        }
        if (s !== undefined) {
          return s
        }
        if (!at(t)) {
          return t
        }
        var d = Jt(t)
        if (d) {
          s = cs(t)
          if (!a) {
            return gr(t, s)
          }
        } else {
          var u = is(t),
            h = u == pa || u == ba
          if (Oo(t)) {
            return ur(t, a)
          }
          if (u == Aa || u == ua || (h && !i)) {
            s = c || h ? {} : Ys(t)
            if (!a) {
              return c ? Mr(t, ir(s, t)) : yr(t, Ki(s, t))
            }
          } else {
            if (!Ra[u]) {
              return i ? t : {}
            }
            s = Ws(t, u, a)
          }
        }
        r || (r = new so())
        var g = r.get(t)
        if (g) {
          return g
        }
        r.set(t, s)
        if (aa(t)) {
          t.forEach(function (o) {
            s.add(Oa(o, e, n, o, t, r))
          })
        } else if (ea(t)) {
          t.forEach(function (o, i) {
            s.set(i, Oa(o, e, n, i, t, r))
          })
        }
        var f = l ? (c ? Rr : Lr) : c ? nr : qi
        var m = d ? undefined : f(t)
        co(m || t, function (o, i) {
          if (m) {
            i = o
            o = t[i]
          }
          bo(s, i, Oa(o, e, n, i, t, r))
        })
        return s
      }
      const Va = Oa
      var Fa = 1,
        ja = 4
      function Ha(t, e) {
        e = typeof e == 'function' ? e : undefined
        return Va(t, Fa | ja, e)
      }
      const Ua = Ha
      function Wa(t) {
        return te(t) && t.nodeType === 1 && !pe(t)
      }
      const Ga = Wa
      class qa {
        constructor(t, e) {
          this._config = {}
          if (e) {
            this.define($a(e))
          }
          if (t) {
            this._setObjectToTarget(this._config, t)
          }
        }
        set(t, e) {
          this._setToTarget(this._config, t, e)
        }
        define(t, e) {
          const n = true
          this._setToTarget(this._config, t, e, n)
        }
        get(t) {
          return this._getFromSource(this._config, t)
        }
        *names() {
          for (const t of Object.keys(this._config)) {
            yield t
          }
        }
        _setToTarget(t, e, n, o = false) {
          if (pe(e)) {
            this._setObjectToTarget(t, e, o)
            return
          }
          const i = e.split('.')
          e = i.pop()
          for (const e of i) {
            if (!pe(t[e])) {
              t[e] = {}
            }
            t = t[e]
          }
          if (pe(n)) {
            if (!pe(t[e])) {
              t[e] = {}
            }
            t = t[e]
            this._setObjectToTarget(t, n, o)
            return
          }
          if (o && typeof t[e] != 'undefined') {
            return
          }
          t[e] = n
        }
        _getFromSource(t, e) {
          const n = e.split('.')
          e = n.pop()
          for (const e of n) {
            if (!pe(t[e])) {
              t = null
              break
            }
            t = t[e]
          }
          return t ? $a(t[e]) : undefined
        }
        _setObjectToTarget(t, e, n) {
          Object.keys(e).forEach((o) => {
            this._setToTarget(t, o, e[o], n)
          })
        }
      }
      function $a(t) {
        return Ua(t, Ka)
      }
      function Ka(t) {
        return Ga(t) ? t : undefined
      }
      function Ya(t) {
        if (t) {
          if (t.defaultView) {
            return t instanceof t.defaultView.Document
          } else if (t.ownerDocument && t.ownerDocument.defaultView) {
            return t instanceof t.ownerDocument.defaultView.Node
          }
        }
        return false
      }
      function Za(t) {
        const e = Object.prototype.toString.apply(t)
        if (e == '[object Window]') {
          return true
        }
        if (e == '[object global]') {
          return true
        }
        return false
      }
      const Qa = Ja(K())
      function Ja(t) {
        if (!t) {
          return Qa
        }
        class e extends t {
          listenTo(t, e, n, o = {}) {
            if (Ya(t) || Za(t)) {
              const i = { capture: !!o.useCapture, passive: !!o.usePassive }
              const r = this._getProxyEmitter(t, i) || new Xa(t, i)
              this.listenTo(r, e, n, o)
            } else {
              super.listenTo(t, e, n, o)
            }
          }
          stopListening(t, e, n) {
            if (Ya(t) || Za(t)) {
              const o = this._getAllProxyEmitters(t)
              for (const t of o) {
                this.stopListening(t, e, n)
              }
            } else {
              super.stopListening(t, e, n)
            }
          }
          _getProxyEmitter(t, e) {
            return Y(this, ec(t, e))
          }
          _getAllProxyEmitters(t) {
            return [
              { capture: false, passive: false },
              { capture: false, passive: true },
              { capture: true, passive: false },
              { capture: true, passive: true },
            ]
              .map((e) => this._getProxyEmitter(t, e))
              .filter((t) => !!t)
          }
        }
        return e
      }
      ;[
        '_getProxyEmitter',
        '_getAllProxyEmitters',
        'on',
        'once',
        'off',
        'listenTo',
        'stopListening',
        'fire',
        'delegate',
        'stopDelegating',
        '_addEventListener',
        '_removeEventListener',
      ].forEach((t) => {
        Ja[t] = Qa.prototype[t]
      })
      class Xa extends K() {
        constructor(t, e) {
          super()
          Z(this, ec(t, e))
          this._domNode = t
          this._options = e
        }
        attach(t) {
          if (this._domListeners && this._domListeners[t]) {
            return
          }
          const e = this._createDomListener(t)
          this._domNode.addEventListener(t, e, this._options)
          if (!this._domListeners) {
            this._domListeners = {}
          }
          this._domListeners[t] = e
        }
        detach(t) {
          let e
          if (this._domListeners[t] && (!(e = this._events[t]) || !e.callbacks.length)) {
            this._domListeners[t].removeListener()
          }
        }
        _addEventListener(t, e, n) {
          this.attach(t)
          K().prototype._addEventListener.call(this, t, e, n)
        }
        _removeEventListener(t, e) {
          K().prototype._removeEventListener.call(this, t, e)
          this.detach(t)
        }
        _createDomListener(t) {
          const e = (e) => {
            this.fire(t, e)
          }
          e.removeListener = () => {
            this._domNode.removeEventListener(t, e, this._options)
            delete this._domListeners[t]
          }
          return e
        }
      }
      function tc(t) {
        return t['data-ck-expando'] || (t['data-ck-expando'] = I())
      }
      function ec(t, e) {
        let n = tc(t)
        for (const t of Object.keys(e).sort()) {
          if (e[t]) {
            n += '-' + t
          }
        }
        return n
      }
      let nc
      try {
        nc = { window, document }
      } catch (t) {
        nc = { window: {}, document: {} }
      }
      const oc = nc
      function ic(t) {
        let e = t.parentElement
        if (!e) {
          return null
        }
        while (e.tagName != 'BODY') {
          const t = e.style.overflowY || oc.window.getComputedStyle(e).overflowY
          if (t === 'auto' || t === 'scroll') {
            break
          }
          e = e.parentElement
          if (!e) {
            return null
          }
        }
        return e
      }
      function rc(t) {
        const e = []
        let n = t
        while (n && n.nodeType != Node.DOCUMENT_NODE) {
          e.unshift(n)
          n = n.parentNode
        }
        return e
      }
      function sc(t) {
        return Object.prototype.toString.apply(t) == '[object Range]'
      }
      function ac(t) {
        const e = t.ownerDocument.defaultView.getComputedStyle(t)
        return {
          top: parseInt(e.borderTopWidth, 10),
          right: parseInt(e.borderRightWidth, 10),
          bottom: parseInt(e.borderBottomWidth, 10),
          left: parseInt(e.borderLeftWidth, 10),
        }
      }
      function cc(t) {
        return Object.prototype.toString.call(t) == '[object Text]'
      }
      const lc = ['top', 'right', 'bottom', 'left', 'width', 'height']
      class dc {
        constructor(t) {
          const e = sc(t)
          Object.defineProperty(this, '_source', { value: t._source || t, writable: true, enumerable: false })
          if (gc(t) || e) {
            if (e) {
              const e = dc.getDomRangeRects(t)
              uc(this, dc.getBoundingRect(e))
            } else {
              uc(this, t.getBoundingClientRect())
            }
          } else if (Za(t)) {
            const { innerWidth: e, innerHeight: n } = t
            uc(this, { top: 0, right: e, bottom: n, left: 0, width: e, height: n })
          } else {
            uc(this, t)
          }
        }
        clone() {
          return new dc(this)
        }
        moveTo(t, e) {
          this.top = e
          this.right = t + this.width
          this.bottom = e + this.height
          this.left = t
          return this
        }
        moveBy(t, e) {
          this.top += e
          this.right += t
          this.left += t
          this.bottom += e
          return this
        }
        getIntersection(t) {
          const e = {
            top: Math.max(this.top, t.top),
            right: Math.min(this.right, t.right),
            bottom: Math.min(this.bottom, t.bottom),
            left: Math.max(this.left, t.left),
            width: 0,
            height: 0,
          }
          e.width = e.right - e.left
          e.height = e.bottom - e.top
          if (e.width < 0 || e.height < 0) {
            return null
          } else {
            return new dc(e)
          }
        }
        getIntersectionArea(t) {
          const e = this.getIntersection(t)
          if (e) {
            return e.getArea()
          } else {
            return 0
          }
        }
        getArea() {
          return this.width * this.height
        }
        getVisible() {
          const t = this._source
          let e = this.clone()
          if (hc(t)) {
            return e
          }
          let n = t
          let o = t.parentNode || t.commonAncestorContainer
          let i
          while (o && !hc(o)) {
            if (n instanceof HTMLElement && fc(n) === 'absolute') {
              i = n
            }
            if (i && (fc(o) !== 'relative' || mc(o) === 'visible')) {
              n = o
              o = o.parentNode
              continue
            }
            const t = new dc(o)
            const r = e.getIntersection(t)
            if (r) {
              if (r.getArea() < e.getArea()) {
                e = r
              }
            } else {
              return null
            }
            n = o
            o = o.parentNode
          }
          return e
        }
        isEqual(t) {
          for (const e of lc) {
            if (this[e] !== t[e]) {
              return false
            }
          }
          return true
        }
        contains(t) {
          const e = this.getIntersection(t)
          return !!(e && e.isEqual(t))
        }
        excludeScrollbarsAndBorders() {
          const t = this._source
          let e, n, o
          if (Za(t)) {
            e = t.innerWidth - t.document.documentElement.clientWidth
            n = t.innerHeight - t.document.documentElement.clientHeight
            o = t.getComputedStyle(t.document.documentElement).direction
          } else {
            const i = ac(t)
            e = t.offsetWidth - t.clientWidth - i.left - i.right
            n = t.offsetHeight - t.clientHeight - i.top - i.bottom
            o = t.ownerDocument.defaultView.getComputedStyle(t).direction
            this.left += i.left
            this.top += i.top
            this.right -= i.right
            this.bottom -= i.bottom
            this.width = this.right - this.left
            this.height = this.bottom - this.top
          }
          this.width -= e
          if (o === 'ltr') {
            this.right -= e
          } else {
            this.left += e
          }
          this.height -= n
          this.bottom -= n
          return this
        }
        static getDomRangeRects(t) {
          const e = []
          const n = Array.from(t.getClientRects())
          if (n.length) {
            for (const t of n) {
              e.push(new dc(t))
            }
          } else {
            let n = t.startContainer
            if (cc(n)) {
              n = n.parentNode
            }
            const o = new dc(n.getBoundingClientRect())
            o.right = o.left
            o.width = 0
            e.push(o)
          }
          return e
        }
        static getBoundingRect(t) {
          const e = {
            left: Number.POSITIVE_INFINITY,
            top: Number.POSITIVE_INFINITY,
            right: Number.NEGATIVE_INFINITY,
            bottom: Number.NEGATIVE_INFINITY,
            width: 0,
            height: 0,
          }
          let n = 0
          for (const o of t) {
            n++
            e.left = Math.min(e.left, o.left)
            e.top = Math.min(e.top, o.top)
            e.right = Math.max(e.right, o.right)
            e.bottom = Math.max(e.bottom, o.bottom)
          }
          if (n == 0) {
            return null
          }
          e.width = e.right - e.left
          e.height = e.bottom - e.top
          return new dc(e)
        }
      }
      function uc(t, e) {
        for (const n of lc) {
          t[n] = e[n]
        }
      }
      function hc(t) {
        if (!gc(t)) {
          return false
        }
        return t === t.ownerDocument.body
      }
      function gc(t) {
        return t !== null && typeof t === 'object' && t.nodeType === 1 && typeof t.getBoundingClientRect === 'function'
      }
      function fc(t) {
        return t.ownerDocument.defaultView.getComputedStyle(t).position
      }
      function mc(t) {
        return t.ownerDocument.defaultView.getComputedStyle(t).overflow
      }
      function pc(t, e = 0) {
        const o = t.map((t) => {
          if (t instanceof Document) {
            const t = new dc(n.g.window)
            t.top += e
            t.height -= e
            return t
          } else {
            return new dc(t)
          }
        })
        let i = o[0]
        for (const t of o.slice(1)) {
          if (i) {
            i = i.getIntersection(t)
          }
        }
        return i
      }
      function bc(t) {
        const e = []
        let n = ic(t)
        while (n && n !== oc.document.body) {
          e.push(n)
          n = ic(n)
        }
        e.push(oc.document)
        return e
      }
      function kc(t) {
        if (t instanceof HTMLTextAreaElement) {
          return t.value
        }
        return t.innerHTML
      }
      class wc {
        constructor(t, e) {
          if (!wc._observerInstance) {
            wc._createObserver()
          }
          this._element = t
          this._callback = e
          wc._addElementCallback(t, e)
          wc._observerInstance.observe(t)
        }
        get element() {
          return this._element
        }
        destroy() {
          wc._deleteElementCallback(this._element, this._callback)
        }
        static _addElementCallback(t, e) {
          if (!wc._elementCallbacks) {
            wc._elementCallbacks = new Map()
          }
          let n = wc._elementCallbacks.get(t)
          if (!n) {
            n = new Set()
            wc._elementCallbacks.set(t, n)
          }
          n.add(e)
        }
        static _deleteElementCallback(t, e) {
          const n = wc._getElementCallbacks(t)
          if (n) {
            n.delete(e)
            if (!n.size) {
              wc._elementCallbacks.delete(t)
              wc._observerInstance.unobserve(t)
            }
          }
          if (wc._elementCallbacks && !wc._elementCallbacks.size) {
            wc._observerInstance = null
            wc._elementCallbacks = null
          }
        }
        static _getElementCallbacks(t) {
          if (!wc._elementCallbacks) {
            return null
          }
          return wc._elementCallbacks.get(t)
        }
        static _createObserver() {
          wc._observerInstance = new oc.window.ResizeObserver((t) => {
            for (const e of t) {
              const t = wc._getElementCallbacks(e.target)
              if (t) {
                for (const n of t) {
                  n(e)
                }
              }
            }
          })
        }
      }
      wc._observerInstance = null
      wc._elementCallbacks = null
      function Ac(t, e) {
        if (t instanceof HTMLTextAreaElement) {
          t.value = e
        }
        t.innerHTML = e
      }
      function _c(t) {
        return (e) => e + t
      }
      function Cc(t) {
        let e = 0
        while (t.previousSibling) {
          t = t.previousSibling
          e++
        }
        return e
      }
      function vc(t, e, n) {
        t.insertBefore(n, t.childNodes[e] || null)
      }
      function yc(t) {
        return t && t.nodeType === Node.COMMENT_NODE
      }
      function xc(t) {
        try {
          oc.document.createAttribute(t)
        } catch (t) {
          return false
        }
        return true
      }
      function Ec(t) {
        return !!(t && t.getClientRects && t.getClientRects().length)
      }
      function Dc(t) {
        if (!t || !t.parentNode) {
          return null
        }
        if (t.offsetParent === oc.document.body) {
          return null
        }
        return t.offsetParent
      }
      function Tc({ element: t, target: e, positions: n, limiter: o, fitInViewport: i, viewportOffsetConfig: r }) {
        if (Ke(e)) {
          e = e()
        }
        if (Ke(o)) {
          o = o()
        }
        const s = Dc(t)
        const a = new dc(t)
        const c = new dc(e)
        let l
        const d = (i && Ic(r)) || null
        const u = { targetRect: c, elementRect: a, positionedElementAncestor: s, viewportRect: d }
        if (!o && !i) {
          l = new Nc(n[0], u)
        } else {
          const t = o && new dc(o).getVisible()
          Object.assign(u, { limiterRect: t, viewportRect: d })
          l = Sc(n, u) || new Nc(n[0], u)
        }
        return l
      }
      function Ic(t) {
        t = Object.assign({ top: 0, bottom: 0, left: 0, right: 0 }, t)
        const e = new dc(oc.window)
        e.top += t.top
        e.height -= t.top
        e.bottom -= t.bottom
        e.height -= t.bottom
        return e
      }
      function Sc(t, e) {
        const { elementRect: n } = e
        const o = n.getArea()
        const i = t.map((t) => new Nc(t, e)).filter((t) => !!t.name)
        let r = 0
        let s = null
        for (const t of i) {
          const { limiterIntersectionArea: e, viewportIntersectionArea: n } = t
          if (e === o) {
            return t
          }
          const i = n ** 2 + e ** 2
          if (i > r) {
            r = i
            s = t
          }
        }
        return s
      }
      function Mc(t, e) {
        const n = Bc(new dc(e))
        const o = ac(e)
        let i = 0
        let r = 0
        i -= n.left
        r -= n.top
        i += e.scrollLeft
        r += e.scrollTop
        i -= o.left
        r -= o.top
        t.moveBy(i, r)
      }
      function Bc(t) {
        const { scrollX: e, scrollY: n } = oc.window
        return t.clone().moveBy(e, n)
      }
      class Nc {
        constructor(t, e) {
          const n = t(e.targetRect, e.elementRect, e.viewportRect)
          if (!n) {
            return
          }
          const { left: o, top: i, name: r, config: s } = n
          this.name = r
          this.config = s
          this._positioningFunctionCorrdinates = { left: o, top: i }
          this._options = e
        }
        get left() {
          return this._absoluteRect.left
        }
        get top() {
          return this._absoluteRect.top
        }
        get limiterIntersectionArea() {
          const t = this._options.limiterRect
          if (t) {
            const e = this._options.viewportRect
            if (e) {
              const n = t.getIntersection(e)
              if (n) {
                return n.getIntersectionArea(this._rect)
              }
            } else {
              return t.getIntersectionArea(this._rect)
            }
          }
          return 0
        }
        get viewportIntersectionArea() {
          const t = this._options.viewportRect
          if (t) {
            return t.getIntersectionArea(this._rect)
          }
          return 0
        }
        get _rect() {
          if (this._cachedRect) {
            return this._cachedRect
          }
          this._cachedRect = this._options.elementRect
            .clone()
            .moveTo(this._positioningFunctionCorrdinates.left, this._positioningFunctionCorrdinates.top)
          return this._cachedRect
        }
        get _absoluteRect() {
          if (this._cachedAbsoluteRect) {
            return this._cachedAbsoluteRect
          }
          this._cachedAbsoluteRect = Bc(this._rect)
          if (this._options.positionedElementAncestor) {
            Mc(this._cachedAbsoluteRect, this._options.positionedElementAncestor)
          }
          return this._cachedAbsoluteRect
        }
      }
      function Pc(t) {
        const e = t.parentNode
        if (e) {
          e.removeChild(t)
        }
      }
      function Lc({ target: t, viewportOffset: e = 0, ancestorOffset: n = 0, alignToTop: o, forceScroll: i }) {
        const r = Uc(t)
        let s = r
        let a = null
        e = qc(e)
        while (s) {
          let c
          if (s == r) {
            c = Wc(t)
          } else {
            c = Wc(a)
          }
          Oc({ parent: c, getRect: () => Gc(t, s), alignToTop: o, ancestorOffset: n, forceScroll: i })
          const l = Gc(t, s)
          Rc({ window: s, rect: l, viewportOffset: e, alignToTop: o, forceScroll: i })
          if (s.parent != s) {
            a = s.frameElement
            s = s.parent
            if (!a) {
              return
            }
          } else {
            s = null
          }
        }
      }
      function zc(t, e, n) {
        const o = Wc(t)
        Oc({ parent: o, getRect: () => new Rect(t), ancestorOffset: e, limiterElement: n })
      }
      function Rc({ window: t, rect: e, alignToTop: n, forceScroll: o, viewportOffset: i }) {
        const r = e.clone().moveBy(0, i.bottom)
        const s = e.clone().moveBy(0, -i.top)
        const a = new dc(t).excludeScrollbarsAndBorders()
        const c = [s, r]
        const l = n && o
        const d = c.every((t) => a.contains(t))
        let { scrollX: u, scrollY: h } = t
        const g = u
        const f = h
        if (l) {
          h -= a.top - e.top + i.top
        } else if (!d) {
          if (Fc(s, a)) {
            h -= a.top - e.top + i.top
          } else if (Vc(r, a)) {
            if (n) {
              h += e.top - a.top - i.top
            } else {
              h += e.bottom - a.bottom + i.bottom
            }
          }
        }
        if (!d) {
          if (jc(e, a)) {
            u -= a.left - e.left + i.left
          } else if (Hc(e, a)) {
            u += e.right - a.right + i.right
          }
        }
        if (u != g || h !== f) {
          t.scrollTo(u, h)
        }
      }
      function Oc({ parent: t, getRect: e, alignToTop: n, forceScroll: o, ancestorOffset: i = 0, limiterElement: r }) {
        const s = Uc(t)
        const a = n && o
        let c, l, d
        const u = r || s.document.body
        while (t != u) {
          l = e()
          c = new dc(t).excludeScrollbarsAndBorders()
          d = c.contains(l)
          if (a) {
            t.scrollTop -= c.top - l.top + i
          } else if (!d) {
            if (Fc(l, c)) {
              t.scrollTop -= c.top - l.top + i
            } else if (Vc(l, c)) {
              if (n) {
                t.scrollTop += l.top - c.top - i
              } else {
                t.scrollTop += l.bottom - c.bottom + i
              }
            }
          }
          if (!d) {
            if (jc(l, c)) {
              t.scrollLeft -= c.left - l.left + i
            } else if (Hc(l, c)) {
              t.scrollLeft += l.right - c.right + i
            }
          }
          t = t.parentNode
        }
      }
      function Vc(t, e) {
        return t.bottom > e.bottom
      }
      function Fc(t, e) {
        return t.top < e.top
      }
      function jc(t, e) {
        return t.left < e.left
      }
      function Hc(t, e) {
        return t.right > e.right
      }
      function Uc(t) {
        if (sc(t)) {
          return t.startContainer.ownerDocument.defaultView
        } else {
          return t.ownerDocument.defaultView
        }
      }
      function Wc(t) {
        if (sc(t)) {
          let e = t.commonAncestorContainer
          if (cc(e)) {
            e = e.parentNode
          }
          return e
        } else {
          return t.parentNode
        }
      }
      function Gc(t, e) {
        const n = Uc(t)
        const o = new dc(t)
        if (n === e) {
          return o
        } else {
          let t = n
          while (t != e) {
            const e = t.frameElement
            const n = new dc(e).excludeScrollbarsAndBorders()
            o.moveBy(n.left, n.top)
            t = t.parent
          }
        }
        return o
      }
      function qc(t) {
        if (typeof t === 'number') {
          return { top: t, bottom: t, left: t, right: t }
        }
        return t
      }
      const $c = { ctrl: '⌃', cmd: '⌘', alt: '⌥', shift: '⇧' }
      const Kc = { ctrl: 'Ctrl+', alt: 'Alt+', shift: 'Shift+' }
      const Yc = il()
      const Zc = Object.fromEntries(Object.entries(Yc).map(([t, e]) => [e, t.charAt(0).toUpperCase() + t.slice(1)]))
      function Qc(t) {
        let e
        if (typeof t == 'string') {
          e = Yc[t.toLowerCase()]
          if (!e) {
            throw new P('keyboard-unknown-key', null, { key: t })
          }
        } else {
          e =
            t.keyCode +
            (t.altKey ? Yc.alt : 0) +
            (t.ctrlKey ? Yc.ctrl : 0) +
            (t.shiftKey ? Yc.shift : 0) +
            (t.metaKey ? Yc.cmd : 0)
        }
        return e
      }
      function Jc(t) {
        if (typeof t == 'string') {
          t = rl(t)
        }
        return t.map((t) => (typeof t == 'string' ? nl(t) : t)).reduce((t, e) => e + t, 0)
      }
      function Xc(t) {
        let e = Jc(t)
        const n = Object.entries(l.isMac ? $c : Kc)
        const o = n.reduce((t, [n, o]) => {
          if ((e & Yc[n]) != 0) {
            e &= ~Yc[n]
            t += o
          }
          return t
        }, '')
        return o + (e ? Zc[e] : '')
      }
      function tl(t) {
        return t == Yc.arrowright || t == Yc.arrowleft || t == Yc.arrowup || t == Yc.arrowdown
      }
      function el(t, e) {
        const n = e === 'ltr'
        switch (t) {
          case Yc.arrowleft:
            return n ? 'left' : 'right'
          case Yc.arrowright:
            return n ? 'right' : 'left'
          case Yc.arrowup:
            return 'up'
          case Yc.arrowdown:
            return 'down'
        }
      }
      function nl(t) {
        if (t.endsWith('!')) {
          return Qc(t.slice(0, -1))
        }
        const e = Qc(t)
        return l.isMac && e == Yc.ctrl ? Yc.cmd : e
      }
      function ol(t, e) {
        const n = el(t, e)
        return n === 'down' || n === 'right'
      }
      function il() {
        const t = {
          arrowleft: 37,
          arrowup: 38,
          arrowright: 39,
          arrowdown: 40,
          backspace: 8,
          delete: 46,
          enter: 13,
          space: 32,
          esc: 27,
          tab: 9,
          ctrl: 1114112,
          shift: 2228224,
          alt: 4456448,
          cmd: 8912896,
        }
        for (let e = 65; e <= 90; e++) {
          const n = String.fromCharCode(e)
          t[n.toLowerCase()] = e
        }
        for (let e = 48; e <= 57; e++) {
          t[e - 48] = e
        }
        for (let e = 112; e <= 123; e++) {
          t['f' + (e - 111)] = e
        }
        for (const e of "`-=[];',./\\") {
          t[e] = e.charCodeAt(0)
        }
        return t
      }
      function rl(t) {
        return t.split('+').map((t) => t.trim())
      }
      function sl(t) {
        return Array.isArray(t) ? t : [t]
      }
      if (!oc.window.CKEDITOR_TRANSLATIONS) {
        oc.window.CKEDITOR_TRANSLATIONS = {}
      }
      function al(t, e, n) {
        if (!global.window.CKEDITOR_TRANSLATIONS[t]) {
          global.window.CKEDITOR_TRANSLATIONS[t] = {}
        }
        const o = global.window.CKEDITOR_TRANSLATIONS[t]
        o.dictionary = o.dictionary || {}
        o.getPluralForm = n || o.getPluralForm
        Object.assign(o.dictionary, e)
      }
      function cl(t, e, n = 1) {
        if (typeof n !== 'number') {
          throw new P('translation-service-quantity-not-a-number', null, { quantity: n })
        }
        const o = ul()
        if (o === 1) {
          t = Object.keys(oc.window.CKEDITOR_TRANSLATIONS)[0]
        }
        const i = e.id || e.string
        if (o === 0 || !dl(t, i)) {
          if (n !== 1) {
            return e.plural
          }
          return e.string
        }
        const r = oc.window.CKEDITOR_TRANSLATIONS[t].dictionary
        const s = oc.window.CKEDITOR_TRANSLATIONS[t].getPluralForm || ((t) => (t === 1 ? 0 : 1))
        const a = r[i]
        if (typeof a === 'string') {
          return a
        }
        const c = Number(s(n))
        return a[c]
      }
      function ll() {
        global.window.CKEDITOR_TRANSLATIONS = {}
      }
      function dl(t, e) {
        return !!oc.window.CKEDITOR_TRANSLATIONS[t] && !!oc.window.CKEDITOR_TRANSLATIONS[t].dictionary[e]
      }
      function ul() {
        return Object.keys(oc.window.CKEDITOR_TRANSLATIONS).length
      }
      const hl = ['ar', 'ara', 'fa', 'per', 'fas', 'he', 'heb', 'ku', 'kur', 'ug', 'uig']
      function gl(t) {
        return hl.includes(t) ? 'rtl' : 'ltr'
      }
      class fl {
        constructor({ uiLanguage: t = 'en', contentLanguage: e } = {}) {
          this.uiLanguage = t
          this.contentLanguage = e || this.uiLanguage
          this.uiLanguageDirection = gl(this.uiLanguage)
          this.contentLanguageDirection = gl(this.contentLanguage)
          this.t = (t, e) => this._t(t, e)
        }
        get language() {
          console.warn(
            'locale-deprecated-language-property: ' +
              'The Locale#language property has been deprecated and will be removed in the near future. ' +
              'Please use #uiLanguage and #contentLanguage properties instead.',
          )
          return this.uiLanguage
        }
        _t(t, e = []) {
          e = sl(e)
          if (typeof t === 'string') {
            t = { string: t }
          }
          const n = !!t.plural
          const o = n ? e[0] : 1
          const i = cl(this.uiLanguage, t, o)
          return ml(i, e)
        }
      }
      function ml(t, e) {
        return t.replace(/%(\d+)/g, (t, n) => (n < e.length ? e[n] : t))
      }
      class pl extends K() {
        constructor(t = {}, e = {}) {
          super()
          const n = Tt(t)
          if (!n) {
            e = t
          }
          this._items = []
          this._itemMap = new Map()
          this._idProperty = e.idProperty || 'id'
          this._bindToExternalToInternalMap = new WeakMap()
          this._bindToInternalToExternalMap = new WeakMap()
          this._skippedIndexesFromExternal = []
          if (n) {
            for (const e of t) {
              this._items.push(e)
              this._itemMap.set(this._getItemIdBeforeAdding(e), e)
            }
          }
        }
        get length() {
          return this._items.length
        }
        get first() {
          return this._items[0] || null
        }
        get last() {
          return this._items[this.length - 1] || null
        }
        add(t, e) {
          return this.addMany([t], e)
        }
        addMany(t, e) {
          if (e === undefined) {
            e = this._items.length
          } else if (e > this._items.length || e < 0) {
            throw new P('collection-add-item-invalid-index', this)
          }
          let n = 0
          for (const o of t) {
            const t = this._getItemIdBeforeAdding(o)
            const i = e + n
            this._items.splice(i, 0, o)
            this._itemMap.set(t, o)
            this.fire('add', o, i)
            n++
          }
          this.fire('change', { added: t, removed: [], index: e })
          return this
        }
        get(t) {
          let e
          if (typeof t == 'string') {
            e = this._itemMap.get(t)
          } else if (typeof t == 'number') {
            e = this._items[t]
          } else {
            throw new P('collection-get-invalid-arg', this)
          }
          return e || null
        }
        has(t) {
          if (typeof t == 'string') {
            return this._itemMap.has(t)
          } else {
            const e = this._idProperty
            const n = t[e]
            return n && this._itemMap.has(n)
          }
        }
        getIndex(t) {
          let e
          if (typeof t == 'string') {
            e = this._itemMap.get(t)
          } else {
            e = t
          }
          return e ? this._items.indexOf(e) : -1
        }
        remove(t) {
          const [e, n] = this._remove(t)
          this.fire('change', { added: [], removed: [e], index: n })
          return e
        }
        map(t, e) {
          return this._items.map(t, e)
        }
        find(t, e) {
          return this._items.find(t, e)
        }
        filter(t, e) {
          return this._items.filter(t, e)
        }
        clear() {
          if (this._bindToCollection) {
            this.stopListening(this._bindToCollection)
            this._bindToCollection = null
          }
          const t = Array.from(this._items)
          while (this.length) {
            this._remove(0)
          }
          this.fire('change', { added: [], removed: t, index: 0 })
        }
        bindTo(t) {
          if (this._bindToCollection) {
            throw new P('collection-bind-to-rebind', this)
          }
          this._bindToCollection = t
          return {
            as: (t) => {
              this._setUpBindToBinding((e) => new t(e))
            },
            using: (t) => {
              if (typeof t == 'function') {
                this._setUpBindToBinding(t)
              } else {
                this._setUpBindToBinding((e) => e[t])
              }
            },
          }
        }
        _setUpBindToBinding(t) {
          const e = this._bindToCollection
          const n = (n, o, i) => {
            const r = e._bindToCollection == this
            const s = e._bindToInternalToExternalMap.get(o)
            if (r && s) {
              this._bindToExternalToInternalMap.set(o, s)
              this._bindToInternalToExternalMap.set(s, o)
            } else {
              const n = t(o)
              if (!n) {
                this._skippedIndexesFromExternal.push(i)
                return
              }
              let r = i
              for (const t of this._skippedIndexesFromExternal) {
                if (i > t) {
                  r--
                }
              }
              for (const t of e._skippedIndexesFromExternal) {
                if (r >= t) {
                  r++
                }
              }
              this._bindToExternalToInternalMap.set(o, n)
              this._bindToInternalToExternalMap.set(n, o)
              this.add(n, r)
              for (let t = 0; t < e._skippedIndexesFromExternal.length; t++) {
                if (r <= e._skippedIndexesFromExternal[t]) {
                  e._skippedIndexesFromExternal[t]++
                }
              }
            }
          }
          for (const t of e) {
            n(null, t, e.getIndex(t))
          }
          this.listenTo(e, 'add', n)
          this.listenTo(e, 'remove', (t, e, n) => {
            const o = this._bindToExternalToInternalMap.get(e)
            if (o) {
              this.remove(o)
            }
            this._skippedIndexesFromExternal = this._skippedIndexesFromExternal.reduce((t, e) => {
              if (n < e) {
                t.push(e - 1)
              }
              if (n > e) {
                t.push(e)
              }
              return t
            }, [])
          })
        }
        _getItemIdBeforeAdding(t) {
          const e = this._idProperty
          let n
          if (e in t) {
            n = t[e]
            if (typeof n != 'string') {
              throw new P('collection-add-invalid-id', this)
            }
            if (this.get(n)) {
              throw new P('collection-add-item-already-exists', this)
            }
          } else {
            t[e] = n = I()
          }
          return n
        }
        _remove(t) {
          let e, n, o
          let i = false
          const r = this._idProperty
          if (typeof t == 'string') {
            n = t
            o = this._itemMap.get(n)
            i = !o
            if (o) {
              e = this._items.indexOf(o)
            }
          } else if (typeof t == 'number') {
            e = t
            o = this._items[e]
            i = !o
            if (o) {
              n = o[r]
            }
          } else {
            o = t
            n = o[r]
            e = this._items.indexOf(o)
            i = e == -1 || !this._itemMap.get(n)
          }
          if (i) {
            throw new P('collection-remove-404', this)
          }
          this._items.splice(e, 1)
          this._itemMap.delete(n)
          const s = this._bindToInternalToExternalMap.get(o)
          this._bindToInternalToExternalMap.delete(o)
          this._bindToExternalToInternalMap.delete(s)
          this.fire('remove', o, e)
          return [o, e]
        }
        [Symbol.iterator]() {
          return this._items[Symbol.iterator]()
        }
      }
      function bl(t) {
        const e = t.next()
        if (e.done) {
          return null
        }
        return e.value
      }
      class kl extends Ja(ft()) {
        constructor() {
          super()
          this._elements = new Set()
          this._nextEventLoopTimeout = null
          this.set('isFocused', false)
          this.set('focusedElement', null)
        }
        add(t) {
          if (this._elements.has(t)) {
            throw new P('focustracker-add-element-already-exist', this)
          }
          this.listenTo(t, 'focus', () => this._focus(t), { useCapture: true })
          this.listenTo(t, 'blur', () => this._blur(), { useCapture: true })
          this._elements.add(t)
        }
        remove(t) {
          if (t === this.focusedElement) {
            this._blur()
          }
          if (this._elements.has(t)) {
            this.stopListening(t)
            this._elements.delete(t)
          }
        }
        destroy() {
          this.stopListening()
        }
        _focus(t) {
          clearTimeout(this._nextEventLoopTimeout)
          this.focusedElement = t
          this.isFocused = true
        }
        _blur() {
          clearTimeout(this._nextEventLoopTimeout)
          this._nextEventLoopTimeout = setTimeout(() => {
            this.focusedElement = null
            this.isFocused = false
          }, 0)
        }
      }
      class wl {
        constructor() {
          this._listener = new (Ja())()
        }
        listenTo(t) {
          this._listener.listenTo(t, 'keydown', (t, e) => {
            this._listener.fire('_keydown:' + Qc(e), e)
          })
        }
        set(t, e, n = {}) {
          const o = Jc(t)
          const i = n.priority
          this._listener.listenTo(
            this._listener,
            '_keydown:' + o,
            (t, n) => {
              e(n, () => {
                n.preventDefault()
                n.stopPropagation()
                t.stop()
              })
              t.return = true
            },
            { priority: i },
          )
        }
        press(t) {
          return !!this._listener.fire('_keydown:' + Qc(t), t)
        }
        stopListening(t) {
          this._listener.stopListening(t)
        }
        destroy() {
          this.stopListening()
        }
      }
      function Al(t) {
        const e = new Map()
        for (const n in t) {
          e.set(n, t[n])
        }
        return e
      }
      function _l(t) {
        if (Tt(t)) {
          return new Map(t)
        } else {
          return Al(t)
        }
      }
      const Cl = 1e4
      function vl(t, e, n, o) {
        if (Math.max(e.length, t.length) > Cl) {
          return t
            .slice(0, n)
            .concat(e)
            .concat(t.slice(n + o, t.length))
        } else {
          const i = Array.from(t)
          i.splice(n, o, ...e)
          return i
        }
      }
      function yl(t, e) {
        let n
        function o(...i) {
          o.cancel()
          n = setTimeout(() => t(...i), e)
        }
        o.cancel = () => {
          clearTimeout(n)
        }
        return o
      }
      function xl(t) {
        function e(t) {
          if (t.length >= 40 && t.length <= 255) {
            return 'VALID'
          } else {
            return 'INVALID'
          }
        }
        if (!t) {
          return 'INVALID'
        }
        let n = ''
        try {
          n = atob(t)
        } catch (t) {
          return 'INVALID'
        }
        const o = n.split('-')
        const i = o[0]
        const r = o[1]
        if (!r) {
          return e(t)
        }
        try {
          atob(r)
        } catch (n) {
          try {
            atob(i)
            if (!atob(i).length) {
              return e(t)
            }
          } catch (n) {
            return e(t)
          }
        }
        if (i.length < 40 || i.length > 255) {
          return 'INVALID'
        }
        let s = ''
        try {
          atob(i)
          s = atob(r)
        } catch (t) {
          return 'INVALID'
        }
        if (s.length !== 8) {
          return 'INVALID'
        }
        const a = Number(s.substring(0, 4))
        const c = Number(s.substring(4, 6)) - 1
        const l = Number(s.substring(6, 8))
        const d = new Date(a, c, l)
        if (d < H || isNaN(Number(d))) {
          return 'INVALID'
        }
        return 'VALID'
      }
      function El(t) {
        return !!t && t.length == 1 && /[\u0300-\u036f\u1ab0-\u1aff\u1dc0-\u1dff\u20d0-\u20ff\ufe20-\ufe2f]/.test(t)
      }
      function Dl(t) {
        return !!t && t.length == 1 && /[\ud800-\udbff]/.test(t)
      }
      function Tl(t) {
        return !!t && t.length == 1 && /[\udc00-\udfff]/.test(t)
      }
      function Il(t, e) {
        return Dl(t.charAt(e - 1)) && Tl(t.charAt(e))
      }
      function Sl(t, e) {
        return El(t.charAt(e))
      }
      const Ml = Nl()
      function Bl(t, e) {
        const n = String(t).matchAll(Ml)
        return Array.from(n).some((t) => t.index < e && e < t.index + t[0].length)
      }
      function Nl() {
        const t = [
          /\p{Emoji}[\u{E0020}-\u{E007E}]+\u{E007F}/u,
          /\p{Emoji}\u{FE0F}?\u{20E3}/u,
          /\p{Emoji}\u{FE0F}/u,
          /(?=\p{General_Category=Other_Symbol})\p{Emoji}\p{Emoji_Modifier}*/u,
        ]
        const e = /\p{Regional_Indicator}{2}/u.source
        const n = '(?:' + t.map((t) => t.source).join('|') + ')'
        const o = `${e}|${n}(?:‍${n})*`
        return new RegExp(o, 'ug')
      }
      class Pl extends pl {
        constructor(t = []) {
          super(t, { idProperty: 'viewUid' })
          this.on('add', (t, e, n) => {
            this._renderViewIntoCollectionParent(e, n)
          })
          this.on('remove', (t, e) => {
            if (e.element && this._parentElement) {
              e.element.remove()
            }
          })
          this._parentElement = null
        }
        destroy() {
          this.map((t) => t.destroy())
        }
        setParent(t) {
          this._parentElement = t
          for (const t of this) {
            this._renderViewIntoCollectionParent(t)
          }
        }
        delegate(...t) {
          if (!t.length || !Ll(t)) {
            throw new P('ui-viewcollection-delegate-wrong-events', this)
          }
          return {
            to: (e) => {
              for (const n of this) {
                for (const o of t) {
                  n.delegate(o).to(e)
                }
              }
              this.on('add', (n, o) => {
                for (const n of t) {
                  o.delegate(n).to(e)
                }
              })
              this.on('remove', (n, o) => {
                for (const n of t) {
                  o.stopDelegating(n, e)
                }
              })
            },
          }
        }
        _renderViewIntoCollectionParent(t, e) {
          if (!t.isRendered) {
            t.render()
          }
          if (t.element && this._parentElement) {
            this._parentElement.insertBefore(t.element, this._parentElement.children[e])
          }
        }
        remove(t) {
          return super.remove(t)
        }
      }
      function Ll(t) {
        return t.every((t) => typeof t == 'string')
      }
      var zl = n(3379)
      var Rl = n.n(zl)
      var Ol = n(5167)
      var Vl = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      Vl.insert = 'head'
      Vl.singleton = true
      var Fl = Rl()(Ol.Z, Vl)
      const jl = Ol.Z.locals || {}
      class Hl extends Ja(ft()) {
        constructor(t) {
          super()
          this.element = null
          this.isRendered = false
          this.locale = t
          this.t = t && t.t
          this._viewCollections = new pl()
          this._unboundChildren = this.createCollection()
          this._viewCollections.on('add', (e, n) => {
            n.locale = t
            n.t = t && t.t
          })
          this.decorate('render')
        }
        get bindTemplate() {
          if (this._bindTemplate) {
            return this._bindTemplate
          }
          return (this._bindTemplate = Wl.bind(this, this))
        }
        createCollection(t) {
          const e = new Pl(t)
          this._viewCollections.add(e)
          return e
        }
        registerChild(t) {
          if (!Tt(t)) {
            t = [t]
          }
          for (const e of t) {
            this._unboundChildren.add(e)
          }
        }
        deregisterChild(t) {
          if (!Tt(t)) {
            t = [t]
          }
          for (const e of t) {
            this._unboundChildren.remove(e)
          }
        }
        setTemplate(t) {
          this.template = new Wl(t)
        }
        extendTemplate(t) {
          Wl.extend(this.template, t)
        }
        render() {
          if (this.isRendered) {
            throw new P('ui-view-render-already-rendered', this)
          }
          if (this.template) {
            this.element = this.template.render()
            this.registerChild(this.template.getViews())
          }
          this.isRendered = true
        }
        destroy() {
          this.stopListening()
          this._viewCollections.map((t) => t.destroy())
          if (this.template && this.template._revertData) {
            this.template.revert(this.element)
          }
        }
      }
      const Ul = 'http://www.w3.org/1999/xhtml'
      class Wl extends K() {
        constructor(t) {
          super()
          Object.assign(this, ed(td(t)))
          this._isRendered = false
          this._revertData = null
        }
        render() {
          const t = this._renderNode({ intoFragment: true })
          this._isRendered = true
          return t
        }
        apply(t) {
          this._revertData = md()
          this._renderNode({ node: t, intoFragment: false, isApplying: true, revertData: this._revertData })
          return t
        }
        revert(t) {
          if (!this._revertData) {
            throw new P('ui-template-revert-not-applied', [this, t])
          }
          this._revertTemplateFromNode(t, this._revertData)
        }
        *getViews() {
          function* t(e) {
            if (e.children) {
              for (const n of e.children) {
                if (ud(n)) {
                  yield n
                } else if (hd(n)) {
                  yield* t(n)
                }
              }
            }
          }
          yield* t(this)
        }
        static bind(t, e) {
          return {
            to(n, o) {
              return new ql({ eventNameOrFunction: n, attribute: n, observable: t, emitter: e, callback: o })
            },
            if(n, o, i) {
              return new $l({ observable: t, emitter: e, attribute: n, valueIfTrue: o, callback: i })
            },
          }
        }
        static extend(t, e) {
          if (t._isRendered) {
            throw new P('template-extend-render', [this, t])
          }
          ld(t, ed(td(e)))
        }
        _renderNode(t) {
          let e
          if (t.node) {
            e = this.tag && this.text
          } else {
            e = this.tag ? this.text : !this.text
          }
          if (e) {
            throw new P('ui-template-wrong-syntax', this)
          }
          if (this.text) {
            return this._renderText(t)
          } else {
            return this._renderElement(t)
          }
        }
        _renderElement(t) {
          let e = t.node
          if (!e) {
            e = t.node = document.createElementNS(this.ns || Ul, this.tag)
          }
          this._renderAttributes(t)
          this._renderElementChildren(t)
          this._setUpListeners(t)
          return e
        }
        _renderText(t) {
          let e = t.node
          if (e) {
            t.revertData.text = e.textContent
          } else {
            e = t.node = document.createTextNode('')
          }
          if (Kl(this.text)) {
            this._bindToObservable({ schema: this.text, updater: Ql(e), data: t })
          } else {
            e.textContent = this.text.join('')
          }
          return e
        }
        _renderAttributes(t) {
          if (!this.attributes) {
            return
          }
          const e = t.node
          const n = t.revertData
          for (const o in this.attributes) {
            const i = e.getAttribute(o)
            const r = this.attributes[o]
            if (n) {
              n.attributes[o] = i
            }
            const s = fd(r) ? r[0].ns : null
            if (Kl(r)) {
              const a = fd(r) ? r[0].value : r
              if (n && pd(o)) {
                a.unshift(i)
              }
              this._bindToObservable({ schema: a, updater: Jl(e, o, s), data: t })
            } else if (o == 'style' && typeof r[0] !== 'string') {
              this._renderStyleAttribute(r[0], t)
            } else {
              if (n && i && pd(o)) {
                r.unshift(i)
              }
              const t = r
                .map((t) => (t ? t.value || t : t))
                .reduce((t, e) => t.concat(e), [])
                .reduce(ad, '')
              if (!dd(t)) {
                e.setAttributeNS(s, o, t)
              }
            }
          }
        }
        _renderStyleAttribute(t, e) {
          const n = e.node
          for (const o in t) {
            const i = t[o]
            if (Kl(i)) {
              this._bindToObservable({ schema: [i], updater: Xl(n, o), data: e })
            } else {
              n.style[o] = i
            }
          }
        }
        _renderElementChildren(t) {
          const e = t.node
          const n = t.intoFragment ? document.createDocumentFragment() : e
          const o = t.isApplying
          let i = 0
          for (const r of this.children) {
            if (gd(r)) {
              if (!o) {
                r.setParent(e)
                for (const t of r) {
                  n.appendChild(t.element)
                }
              }
            } else if (ud(r)) {
              if (!o) {
                if (!r.isRendered) {
                  r.render()
                }
                n.appendChild(r.element)
              }
            } else if (Ya(r)) {
              n.appendChild(r)
            } else {
              if (o) {
                const e = t.revertData
                const o = md()
                e.children.push(o)
                r._renderNode({ intoFragment: false, node: n.childNodes[i++], isApplying: true, revertData: o })
              } else {
                n.appendChild(r.render())
              }
            }
          }
          if (t.intoFragment) {
            e.appendChild(n)
          }
        }
        _setUpListeners(t) {
          if (!this.eventListeners) {
            return
          }
          for (const e in this.eventListeners) {
            const n = this.eventListeners[e].map((n) => {
              const [o, i] = e.split('@')
              return n.activateDomEventListener(o, i, t)
            })
            if (t.revertData) {
              t.revertData.bindings.push(n)
            }
          }
        }
        _bindToObservable({ schema: t, updater: e, data: n }) {
          const o = n.revertData
          Zl(t, e, n)
          const i = t
            .filter((t) => !dd(t))
            .filter((t) => t.observable)
            .map((o) => o.activateAttributeListener(t, e, n))
          if (o) {
            o.bindings.push(i)
          }
        }
        _revertTemplateFromNode(t, e) {
          for (const t of e.bindings) {
            for (const e of t) {
              e()
            }
          }
          if (e.text) {
            t.textContent = e.text
            return
          }
          const n = t
          for (const t in e.attributes) {
            const o = e.attributes[t]
            if (o === null) {
              n.removeAttribute(t)
            } else {
              n.setAttribute(t, o)
            }
          }
          for (let t = 0; t < e.children.length; ++t) {
            this._revertTemplateFromNode(n.childNodes[t], e.children[t])
          }
        }
      }
      class Gl {
        constructor(t) {
          this.attribute = t.attribute
          this.observable = t.observable
          this.emitter = t.emitter
          this.callback = t.callback
        }
        getValue(t) {
          const e = this.observable[this.attribute]
          return this.callback ? this.callback(e, t) : e
        }
        activateAttributeListener(t, e, n) {
          const o = () => Zl(t, e, n)
          this.emitter.listenTo(this.observable, `change:${this.attribute}`, o)
          return () => {
            this.emitter.stopListening(this.observable, `change:${this.attribute}`, o)
          }
        }
      }
      class ql extends Gl {
        constructor(t) {
          super(t)
          this.eventNameOrFunction = t.eventNameOrFunction
        }
        activateDomEventListener(t, e, n) {
          const o = (t, n) => {
            if (!e || n.target.matches(e)) {
              if (typeof this.eventNameOrFunction == 'function') {
                this.eventNameOrFunction(n)
              } else {
                this.observable.fire(this.eventNameOrFunction, n)
              }
            }
          }
          this.emitter.listenTo(n.node, t, o)
          return () => {
            this.emitter.stopListening(n.node, t, o)
          }
        }
      }
      class $l extends Gl {
        constructor(t) {
          super(t)
          this.valueIfTrue = t.valueIfTrue
        }
        getValue(t) {
          const e = super.getValue(t)
          return dd(e) ? false : this.valueIfTrue || true
        }
      }
      function Kl(t) {
        if (!t) {
          return false
        }
        if (t.value) {
          t = t.value
        }
        if (Array.isArray(t)) {
          return t.some(Kl)
        } else if (t instanceof Gl) {
          return true
        }
        return false
      }
      function Yl(t, e) {
        return t.map((t) => {
          if (t instanceof Gl) {
            return t.getValue(e)
          }
          return t
        })
      }
      function Zl(t, e, { node: n }) {
        const o = Yl(t, n)
        let i
        if (t.length == 1 && t[0] instanceof $l) {
          i = o[0]
        } else {
          i = o.reduce(ad, '')
        }
        if (dd(i)) {
          e.remove()
        } else {
          e.set(i)
        }
      }
      function Ql(t) {
        return {
          set(e) {
            t.textContent = e
          },
          remove() {
            t.textContent = ''
          },
        }
      }
      function Jl(t, e, n) {
        return {
          set(o) {
            t.setAttributeNS(n, e, o)
          },
          remove() {
            t.removeAttributeNS(n, e)
          },
        }
      }
      function Xl(t, e) {
        return {
          set(n) {
            t.style[e] = n
          },
          remove() {
            t.style[e] = null
          },
        }
      }
      function td(t) {
        const e = Ua(t, (t) => {
          if (t && (t instanceof Gl || hd(t) || ud(t) || gd(t))) {
            return t
          }
        })
        return e
      }
      function ed(t) {
        if (typeof t == 'string') {
          t = id(t)
        } else if (t.text) {
          rd(t)
        }
        if (t.on) {
          t.eventListeners = od(t.on)
          delete t.on
        }
        if (!t.text) {
          if (t.attributes) {
            nd(t.attributes)
          }
          const e = []
          if (t.children) {
            if (gd(t.children)) {
              e.push(t.children)
            } else {
              for (const n of t.children) {
                if (hd(n) || ud(n) || Ya(n)) {
                  e.push(n)
                } else {
                  e.push(new Wl(n))
                }
              }
            }
          }
          t.children = e
        }
        return t
      }
      function nd(t) {
        for (const e in t) {
          if (t[e].value) {
            t[e].value = sl(t[e].value)
          }
          sd(t, e)
        }
      }
      function od(t) {
        for (const e in t) {
          sd(t, e)
        }
        return t
      }
      function id(t) {
        return { text: [t] }
      }
      function rd(t) {
        t.text = sl(t.text)
      }
      function sd(t, e) {
        t[e] = sl(t[e])
      }
      function ad(t, e) {
        if (dd(e)) {
          return t
        } else if (dd(t)) {
          return e
        } else {
          return `${t} ${e}`
        }
      }
      function cd(t, e) {
        for (const n in e) {
          if (t[n]) {
            t[n].push(...e[n])
          } else {
            t[n] = e[n]
          }
        }
      }
      function ld(t, e) {
        if (e.attributes) {
          if (!t.attributes) {
            t.attributes = {}
          }
          cd(t.attributes, e.attributes)
        }
        if (e.eventListeners) {
          if (!t.eventListeners) {
            t.eventListeners = {}
          }
          cd(t.eventListeners, e.eventListeners)
        }
        if (e.text) {
          t.text.push(...e.text)
        }
        if (e.children && e.children.length) {
          if (t.children.length != e.children.length) {
            throw new P('ui-template-extend-children-mismatch', t)
          }
          let n = 0
          for (const o of e.children) {
            ld(t.children[n++], o)
          }
        }
      }
      function dd(t) {
        return !t && t !== 0
      }
      function ud(t) {
        return t instanceof Hl
      }
      function hd(t) {
        return t instanceof Wl
      }
      function gd(t) {
        return t instanceof Pl
      }
      function fd(t) {
        return at(t[0]) && t[0].ns
      }
      function md() {
        return { children: [], bindings: [], attributes: {} }
      }
      function pd(t) {
        return t == 'class' || t == 'style'
      }
      class bd extends Pl {
        constructor(t, e = []) {
          super(e)
          this.locale = t
        }
        get bodyCollectionContainer() {
          return this._bodyCollectionContainer
        }
        attachToDom() {
          this._bodyCollectionContainer = new Wl({
            tag: 'div',
            attributes: {
              class: ['ck', 'ck-reset_all', 'ck-body', 'ck-rounded-corners'],
              dir: this.locale.uiLanguageDirection,
            },
            children: this,
          }).render()
          let t = document.querySelector('.ck-body-wrapper')
          if (!t) {
            t = ie(document, 'div', { class: 'ck-body-wrapper' })
            document.body.appendChild(t)
          }
          t.appendChild(this._bodyCollectionContainer)
        }
        detachFromDom() {
          super.destroy()
          if (this._bodyCollectionContainer) {
            this._bodyCollectionContainer.remove()
          }
          const t = document.querySelector('.ck-body-wrapper')
          if (t && t.childElementCount == 0) {
            t.remove()
          }
        }
      }
      var kd = n(1977)
      var wd = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      wd.insert = 'head'
      wd.singleton = true
      var Ad = Rl()(kd.Z, wd)
      const _d = kd.Z.locals || {}
      class Cd extends Hl {
        constructor() {
          super()
          const t = this.bindTemplate
          this.set('content', '')
          this.set('viewBox', '0 0 20 20')
          this.set('fillColor', '')
          this.set('isColorInherited', true)
          this.setTemplate({
            tag: 'svg',
            ns: 'http://www.w3.org/2000/svg',
            attributes: {
              class: ['ck', 'ck-icon', 'ck-reset_all-excluded', t.if('isColorInherited', 'ck-icon_inherit-color')],
              viewBox: t.to('viewBox'),
            },
          })
        }
        render() {
          super.render()
          this._updateXMLContent()
          this._colorFillPaths()
          this.on('change:content', () => {
            this._updateXMLContent()
            this._colorFillPaths()
          })
          this.on('change:fillColor', () => {
            this._colorFillPaths()
          })
        }
        _updateXMLContent() {
          if (this.content) {
            const t = new DOMParser().parseFromString(this.content.trim(), 'image/svg+xml')
            const e = t.querySelector('svg')
            const n = e.getAttribute('viewBox')
            if (n) {
              this.viewBox = n
            }
            for (const { name: t, value: n } of Array.from(e.attributes)) {
              if (Cd.presentationalAttributeNames.includes(t)) {
                this.element.setAttribute(t, n)
              }
            }
            while (this.element.firstChild) {
              this.element.removeChild(this.element.firstChild)
            }
            while (e.childNodes.length > 0) {
              this.element.appendChild(e.childNodes[0])
            }
          }
        }
        _colorFillPaths() {
          if (this.fillColor) {
            this.element.querySelectorAll('.ck-icon__fill').forEach((t) => {
              t.style.fill = this.fillColor
            })
          }
        }
      }
      Cd.presentationalAttributeNames = [
        'alignment-baseline',
        'baseline-shift',
        'clip-path',
        'clip-rule',
        'color',
        'color-interpolation',
        'color-interpolation-filters',
        'color-rendering',
        'cursor',
        'direction',
        'display',
        'dominant-baseline',
        'fill',
        'fill-opacity',
        'fill-rule',
        'filter',
        'flood-color',
        'flood-opacity',
        'font-family',
        'font-size',
        'font-size-adjust',
        'font-stretch',
        'font-style',
        'font-variant',
        'font-weight',
        'image-rendering',
        'letter-spacing',
        'lighting-color',
        'marker-end',
        'marker-mid',
        'marker-start',
        'mask',
        'opacity',
        'overflow',
        'paint-order',
        'pointer-events',
        'shape-rendering',
        'stop-color',
        'stop-opacity',
        'stroke',
        'stroke-dasharray',
        'stroke-dashoffset',
        'stroke-linecap',
        'stroke-linejoin',
        'stroke-miterlimit',
        'stroke-opacity',
        'stroke-width',
        'text-anchor',
        'text-decoration',
        'text-overflow',
        'text-rendering',
        'transform',
        'unicode-bidi',
        'vector-effect',
        'visibility',
        'white-space',
        'word-spacing',
        'writing-mode',
      ]
      var vd = n(4971)
      var yd = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      yd.insert = 'head'
      yd.singleton = true
      var xd = Rl()(vd.Z, yd)
      const Ed = vd.Z.locals || {}
      class Dd extends Hl {
        constructor(t) {
          super(t)
          this._focusDelayed = null
          const e = this.bindTemplate
          const n = I()
          this.set('ariaChecked', undefined)
          this.set('ariaLabel', undefined)
          this.set('ariaLabelledBy', `ck-editor__aria-label_${n}`)
          this.set('class', undefined)
          this.set('labelStyle', undefined)
          this.set('icon', undefined)
          this.set('isEnabled', true)
          this.set('isOn', false)
          this.set('isVisible', true)
          this.set('isToggleable', false)
          this.set('keystroke', undefined)
          this.set('label', undefined)
          this.set('role', undefined)
          this.set('tabindex', -1)
          this.set('tooltip', false)
          this.set('tooltipPosition', 's')
          this.set('type', 'button')
          this.set('withText', false)
          this.set('withKeystroke', false)
          this.children = this.createCollection()
          this.labelView = this._createLabelView()
          this.iconView = new Cd()
          this.iconView.extendTemplate({ attributes: { class: 'ck-button__icon' } })
          this.keystrokeView = this._createKeystrokeView()
          this.bind('_tooltipString').to(
            this,
            'tooltip',
            this,
            'label',
            this,
            'keystroke',
            this._getTooltipString.bind(this),
          )
          const o = {
            tag: 'button',
            attributes: {
              class: [
                'ck',
                'ck-button',
                e.to('class'),
                e.if('isEnabled', 'ck-disabled', (t) => !t),
                e.if('isVisible', 'ck-hidden', (t) => !t),
                e.to('isOn', (t) => (t ? 'ck-on' : 'ck-off')),
                e.if('withText', 'ck-button_with-text'),
                e.if('withKeystroke', 'ck-button_with-keystroke'),
              ],
              role: e.to('role'),
              type: e.to('type', (t) => (t ? t : 'button')),
              tabindex: e.to('tabindex'),
              'aria-label': e.to('ariaLabel'),
              'aria-labelledby': e.to('ariaLabelledBy'),
              'aria-disabled': e.if('isEnabled', true, (t) => !t),
              'aria-checked': e.to('isOn'),
              'aria-pressed': e.to('isOn', (t) => (this.isToggleable ? String(!!t) : false)),
              'data-cke-tooltip-text': e.to('_tooltipString'),
              'data-cke-tooltip-position': e.to('tooltipPosition'),
            },
            children: this.children,
            on: {
              click: e.to((t) => {
                if (this.isEnabled) {
                  this.fire('execute')
                } else {
                  t.preventDefault()
                }
              }),
            },
          }
          if (l.isSafari) {
            if (!this._focusDelayed) {
              this._focusDelayed = yl(() => this.focus(), 0)
            }
            o.on.mousedown = e.to(() => {
              this._focusDelayed()
            })
            o.on.mouseup = e.to(() => {
              this._focusDelayed.cancel()
            })
          }
          this.setTemplate(o)
        }
        render() {
          super.render()
          if (this.icon) {
            this.iconView.bind('content').to(this, 'icon')
            this.children.add(this.iconView)
          }
          this.children.add(this.labelView)
          if (this.withKeystroke && this.keystroke) {
            this.children.add(this.keystrokeView)
          }
        }
        focus() {
          this.element.focus()
        }
        destroy() {
          if (this._focusDelayed) {
            this._focusDelayed.cancel()
          }
          super.destroy()
        }
        _createLabelView() {
          const t = new Hl()
          const e = this.bindTemplate
          t.setTemplate({
            tag: 'span',
            attributes: { class: ['ck', 'ck-button__label'], style: e.to('labelStyle'), id: this.ariaLabelledBy },
            children: [{ text: e.to('label') }],
          })
          return t
        }
        _createKeystrokeView() {
          const t = new Hl()
          t.setTemplate({
            tag: 'span',
            attributes: { class: ['ck', 'ck-button__keystroke'] },
            children: [{ text: this.bindTemplate.to('keystroke', (t) => Xc(t)) }],
          })
          return t
        }
        _getTooltipString(t, e, n) {
          if (t) {
            if (typeof t == 'string') {
              return t
            } else {
              if (n) {
                n = Xc(n)
              }
              if (t instanceof Function) {
                return t(e, n)
              } else {
                return `${e}${n ? ` (${n})` : ''}`
              }
            }
          }
          return ''
        }
      }
      var Td = n(7258)
      var Id = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      Id.insert = 'head'
      Id.singleton = true
      var Sd = Rl()(Td.Z, Id)
      const Md = Td.Z.locals || {}
      class Bd extends Dd {
        constructor(t) {
          super(t)
          this.isToggleable = true
          this.toggleSwitchView = this._createToggleView()
          this.extendTemplate({ attributes: { class: 'ck-switchbutton' } })
        }
        render() {
          super.render()
          this.children.add(this.toggleSwitchView)
        }
        _createToggleView() {
          const t = new Hl()
          t.setTemplate({
            tag: 'span',
            attributes: { class: ['ck', 'ck-button__toggle'] },
            children: [{ tag: 'span', attributes: { class: ['ck', 'ck-button__toggle__inner'] } }],
          })
          return t
        }
      }
      class Nd extends (null && ButtonView) {
        constructor(t) {
          super(t)
          const e = this.bindTemplate
          this.set('color', undefined)
          this.set('hasBorder', false)
          this.icon = checkIcon
          this.extendTemplate({
            attributes: {
              style: { backgroundColor: e.to('color') },
              class: ['ck', 'ck-color-grid__tile', e.if('hasBorder', 'ck-color-selector__color-tile_bordered')],
            },
          })
        }
        render() {
          super.render()
          this.iconView.fillColor = 'hsl(0, 0%, 100%)'
        }
      }
      var Pd = n(4923)
      var Ld = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      Ld.insert = 'head'
      Ld.singleton = true
      var zd = Rl()(Pd.Z, Ld)
      const Rd = Pd.Z.locals || {}
      class Od extends (null && View) {
        constructor(t, e) {
          super(t)
          const n = e && e.colorDefinitions ? e.colorDefinitions : []
          this.columns = e && e.columns ? e.columns : 5
          const o = { gridTemplateColumns: `repeat( ${this.columns}, 1fr)` }
          this.set('selectedColor', undefined)
          this.items = this.createCollection()
          this.focusTracker = new FocusTracker()
          this.keystrokes = new KeystrokeHandler()
          this.items.on('add', (t, e) => {
            e.isOn = e.color === this.selectedColor
          })
          n.forEach((t) => {
            const e = new ColorTileView()
            e.set({ color: t.color, label: t.label, tooltip: true, hasBorder: t.options.hasBorder })
            e.on('execute', () => {
              this.fire('execute', { value: t.color, hasBorder: t.options.hasBorder, label: t.label })
            })
            this.items.add(e)
          })
          this.setTemplate({
            tag: 'div',
            children: this.items,
            attributes: { class: ['ck', 'ck-color-grid'], style: o },
          })
          this.on('change:selectedColor', (t, e, n) => {
            for (const t of this.items) {
              t.isOn = t.color === n
            }
          })
        }
        focus() {
          if (this.items.length) {
            this.items.first.focus()
          }
        }
        focusLast() {
          if (this.items.length) {
            this.items.last.focus()
          }
        }
        render() {
          super.render()
          for (const t of this.items) {
            this.focusTracker.add(t.element)
          }
          this.items.on('add', (t, e) => {
            this.focusTracker.add(e.element)
          })
          this.items.on('remove', (t, e) => {
            this.focusTracker.remove(e.element)
          })
          this.keystrokes.listenTo(this.element)
          addKeyboardHandlingForGrid({
            keystrokeHandler: this.keystrokes,
            focusTracker: this.focusTracker,
            gridItems: this.items,
            numberOfColumns: this.columns,
            uiLanguageDirection: this.locale && this.locale.uiLanguageDirection,
          })
        }
        destroy() {
          super.destroy()
          this.focusTracker.destroy()
          this.keystrokes.destroy()
        }
      }
      var Vd = n(8874)
      const Fd = null && Hd
      var jd = { red: 0, orange: 60, yellow: 120, green: 180, blue: 240, purple: 300 }
      function Hd(t) {
        var e,
          n = [],
          o = 1,
          i
        if (typeof t === 'string') {
          if (names[t]) {
            n = names[t].slice()
            i = 'rgb'
          } else if (t === 'transparent') {
            o = 0
            i = 'rgb'
            n = [0, 0, 0]
          } else if (/^#[A-Fa-f0-9]+$/.test(t)) {
            var r = t.slice(1)
            var s = r.length
            var a = s <= 4
            o = 1
            if (a) {
              n = [parseInt(r[0] + r[0], 16), parseInt(r[1] + r[1], 16), parseInt(r[2] + r[2], 16)]
              if (s === 4) {
                o = parseInt(r[3] + r[3], 16) / 255
              }
            } else {
              n = [parseInt(r[0] + r[1], 16), parseInt(r[2] + r[3], 16), parseInt(r[4] + r[5], 16)]
              if (s === 8) {
                o = parseInt(r[6] + r[7], 16) / 255
              }
            }
            if (!n[0]) n[0] = 0
            if (!n[1]) n[1] = 0
            if (!n[2]) n[2] = 0
            i = 'rgb'
          } else if ((e = /^((?:rgb|hs[lvb]|hwb|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms)a?)\s*\(([^\)]*)\)/.exec(t))) {
            var c = e[1]
            var l = c === 'rgb'
            var r = c.replace(/a$/, '')
            i = r
            var s = r === 'cmyk' ? 4 : r === 'gray' ? 1 : 3
            n = e[2]
              .trim()
              .split(/\s*[,\/]\s*|\s+/)
              .map(function (t, e) {
                if (/%$/.test(t)) {
                  if (e === s) return parseFloat(t) / 100
                  if (r === 'rgb') return (parseFloat(t) * 255) / 100
                  return parseFloat(t)
                } else if (r[e] === 'h') {
                  if (/deg$/.test(t)) {
                    return parseFloat(t)
                  } else if (jd[t] !== undefined) {
                    return jd[t]
                  }
                }
                return parseFloat(t)
              })
            if (c === r) n.push(1)
            o = l ? 1 : n[s] === undefined ? 1 : n[s]
            n = n.slice(0, s)
          } else if (t.length > 10 && /[0-9](?:\s|\/)/.test(t)) {
            n = t.match(/([0-9]+)/g).map(function (t) {
              return parseFloat(t)
            })
            i = t
              .match(/([a-z])/gi)
              .join('')
              .toLowerCase()
          }
        } else if (!isNaN(t)) {
          i = 'rgb'
          n = [t >>> 16, (t & 65280) >>> 8, t & 255]
        } else if (Array.isArray(t) || t.length) {
          n = [t[0], t[1], t[2]]
          i = 'rgb'
          o = t.length === 4 ? t[3] : 1
        } else if (t instanceof Object) {
          if (t.r != null || t.red != null || t.R != null) {
            i = 'rgb'
            n = [t.r || t.red || t.R || 0, t.g || t.green || t.G || 0, t.b || t.blue || t.B || 0]
          } else {
            i = 'hsl'
            n = [
              t.h || t.hue || t.H || 0,
              t.s || t.saturation || t.S || 0,
              t.l || t.lightness || t.L || t.b || t.brightness,
            ]
          }
          o = t.a || t.alpha || t.opacity || 1
          if (t.opacity != null) o /= 100
        }
        return { space: i, values: n, alpha: o }
      }
      var Ud = n(2085)
      function Wd(t, e) {
        if (!t) {
          return ''
        }
        const n = $d(t)
        if (!n) {
          return ''
        }
        if (n.space === e) {
          return t
        }
        if (!Kd(n)) {
          return ''
        }
        const o = convert[n.space]
        const i = o[e]
        if (!i) {
          return ''
        }
        const r = i(n.space === 'hex' ? n.hexValue : n.values)
        return qd(r, e)
      }
      function Gd(t) {
        if (!t) {
          return ''
        }
        const e = $d(t)
        if (!e) {
          return '#000'
        }
        if (e.space === 'hex') {
          return e.hexValue
        }
        return Wd(t, 'hex')
      }
      function qd(t, e) {
        switch (e) {
          case 'hex':
            return `#${t}`
          case 'rgb':
            return `rgb( ${t[0]}, ${t[1]}, ${t[2]} )`
          case 'hsl':
            return `hsl( ${t[0]}, ${t[1]}%, ${t[2]}% )`
          case 'hwb':
            return `hwb( ${t[0]}, ${t[1]}, ${t[2]} )`
          case 'lab':
            return `lab( ${t[0]}% ${t[1]} ${t[2]} )`
          case 'lch':
            return `lch( ${t[0]}% ${t[1]} ${t[2]} )`
          default:
            return ''
        }
      }
      function $d(t) {
        if (t.startsWith('#')) {
          const e = parse(t)
          return { space: 'hex', values: e.values, hexValue: t, alpha: e.alpha }
        }
        const e = parse(t)
        if (!e.space) {
          return null
        }
        return e
      }
      function Kd(t) {
        return Object.keys(convert).includes(t.space)
      }
      var Yd = n(3525)
      var Zd = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      Zd.insert = 'head'
      Zd.singleton = true
      var Qd = Rl()(Yd.Z, Zd)
      const Jd = Yd.Z.locals || {}
      class Xd extends Hl {
        constructor(t) {
          super(t)
          this.set('text', undefined)
          this.set('for', undefined)
          this.id = `ck-editor__label_${I()}`
          const e = this.bindTemplate
          this.setTemplate({
            tag: 'label',
            attributes: { class: ['ck', 'ck-label'], id: this.id, for: e.to('for') },
            children: [{ text: e.to('text') }],
          })
        }
      }
      var tu = n(2933)
      var eu = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      eu.insert = 'head'
      eu.singleton = true
      var nu = Rl()(tu.Z, eu)
      const ou = tu.Z.locals || {}
      class iu extends Hl {
        constructor(t, e) {
          super(t)
          const n = `ck-labeled-field-view-${I()}`
          const o = `ck-labeled-field-view-status-${I()}`
          this.fieldView = e(this, n, o)
          this.set('label', undefined)
          this.set('isEnabled', true)
          this.set('isEmpty', true)
          this.set('isFocused', false)
          this.set('errorText', null)
          this.set('infoText', null)
          this.set('class', undefined)
          this.set('placeholder', undefined)
          this.labelView = this._createLabelView(n)
          this.statusView = this._createStatusView(o)
          this.fieldWrapperChildren = this.createCollection([this.fieldView, this.labelView])
          this.bind('_statusText').to(this, 'errorText', this, 'infoText', (t, e) => t || e)
          const i = this.bindTemplate
          this.setTemplate({
            tag: 'div',
            attributes: {
              class: [
                'ck',
                'ck-labeled-field-view',
                i.to('class'),
                i.if('isEnabled', 'ck-disabled', (t) => !t),
                i.if('isEmpty', 'ck-labeled-field-view_empty'),
                i.if('isFocused', 'ck-labeled-field-view_focused'),
                i.if('placeholder', 'ck-labeled-field-view_placeholder'),
                i.if('errorText', 'ck-error'),
              ],
            },
            children: [
              {
                tag: 'div',
                attributes: { class: ['ck', 'ck-labeled-field-view__input-wrapper'] },
                children: this.fieldWrapperChildren,
              },
              this.statusView,
            ],
          })
        }
        _createLabelView(t) {
          const e = new Xd(this.locale)
          e.for = t
          e.bind('text').to(this, 'label')
          return e
        }
        _createStatusView(t) {
          const e = new Hl(this.locale)
          const n = this.bindTemplate
          e.setTemplate({
            tag: 'div',
            attributes: {
              class: [
                'ck',
                'ck-labeled-field-view__status',
                n.if('errorText', 'ck-labeled-field-view__status_error'),
                n.if('_statusText', 'ck-hidden', (t) => !t),
              ],
              id: t,
              role: n.if('errorText', 'alert'),
            },
            children: [{ text: n.to('_statusText') }],
          })
          return e
        }
        focus() {
          this.fieldView.focus()
        }
      }
      var ru = n(2470)
      var su = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      su.insert = 'head'
      su.singleton = true
      var au = Rl()(ru.Z, su)
      const cu = ru.Z.locals || {}
      class lu extends Hl {
        constructor(t) {
          super(t)
          this.set('value', undefined)
          this.set('id', undefined)
          this.set('placeholder', undefined)
          this.set('isReadOnly', false)
          this.set('hasError', false)
          this.set('ariaDescribedById', undefined)
          this.focusTracker = new kl()
          this.bind('isFocused').to(this.focusTracker)
          this.set('isEmpty', true)
          this.set('inputMode', 'text')
          const e = this.bindTemplate
          this.setTemplate({
            tag: 'input',
            attributes: {
              class: [
                'ck',
                'ck-input',
                e.if('isFocused', 'ck-input_focused'),
                e.if('isEmpty', 'ck-input-text_empty'),
                e.if('hasError', 'ck-error'),
              ],
              id: e.to('id'),
              placeholder: e.to('placeholder'),
              readonly: e.to('isReadOnly'),
              inputmode: e.to('inputMode'),
              'aria-invalid': e.if('hasError', true),
              'aria-describedby': e.to('ariaDescribedById'),
            },
            on: {
              input: e.to((...t) => {
                this.fire('input', ...t)
                this._updateIsEmpty()
              }),
              change: e.to(this._updateIsEmpty.bind(this)),
            },
          })
        }
        render() {
          super.render()
          this.focusTracker.add(this.element)
          this._setDomElementValue(this.value)
          this._updateIsEmpty()
          this.on('change:value', (t, e, n) => {
            this._setDomElementValue(n)
            this._updateIsEmpty()
          })
        }
        destroy() {
          super.destroy()
          this.focusTracker.destroy()
        }
        select() {
          this.element.select()
        }
        focus() {
          this.element.focus()
        }
        _updateIsEmpty() {
          this.isEmpty = du(this.element)
        }
        _setDomElementValue(t) {
          this.element.value = !t && t !== 0 ? '' : t
        }
      }
      function du(t) {
        return !t.value
      }
      class uu extends lu {
        constructor(t) {
          super(t)
          this.extendTemplate({ attributes: { type: 'text', class: ['ck-input-text'] } })
        }
      }
      class hu extends (null && InputView) {
        constructor(t, { min: e, max: n, step: o } = {}) {
          super(t)
          const i = this.bindTemplate
          this.set('min', e)
          this.set('max', n)
          this.set('step', o)
          this.extendTemplate({
            attributes: {
              type: 'number',
              class: ['ck-input-number'],
              min: i.to('min'),
              max: i.to('max'),
              step: i.to('step'),
            },
          })
        }
      }
      class gu extends Hl {
        constructor(t) {
          super(t)
          const e = this.bindTemplate
          this.set('isVisible', false)
          this.set('position', 'se')
          this.children = this.createCollection()
          this.setTemplate({
            tag: 'div',
            attributes: {
              class: [
                'ck',
                'ck-reset',
                'ck-dropdown__panel',
                e.to('position', (t) => `ck-dropdown__panel_${t}`),
                e.if('isVisible', 'ck-dropdown__panel-visible'),
              ],
              tabindex: '-1',
            },
            children: this.children,
            on: {
              selectstart: e.to((t) => {
                if (t.target.tagName.toLocaleLowerCase() === 'input') {
                  return
                }
                t.preventDefault()
              }),
            },
          })
        }
        focus() {
          if (this.children.length) {
            const t = this.children.first
            if (typeof t.focus === 'function') {
              t.focus()
            } else {
              L('ui-dropdown-panel-focus-child-missing-focus', { childView: this.children.first, dropdownPanel: this })
            }
          }
        }
        focusLast() {
          if (this.children.length) {
            const t = this.children.last
            if (typeof t.focusLast === 'function') {
              t.focusLast()
            } else {
              t.focus()
            }
          }
        }
      }
      var fu = n(5062)
      var mu = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      mu.insert = 'head'
      mu.singleton = true
      var pu = Rl()(fu.Z, mu)
      const bu = fu.Z.locals || {}
      class ku extends Hl {
        constructor(t, e, n) {
          super(t)
          const o = this.bindTemplate
          this.buttonView = e
          this.panelView = n
          this.set('isOpen', false)
          this.set('isEnabled', true)
          this.set('class', undefined)
          this.set('id', undefined)
          this.set('panelPosition', 'auto')
          this.keystrokes = new wl()
          this.focusTracker = new kl()
          this.setTemplate({
            tag: 'div',
            attributes: {
              class: ['ck', 'ck-dropdown', o.to('class'), o.if('isEnabled', 'ck-disabled', (t) => !t)],
              id: o.to('id'),
              'aria-describedby': o.to('ariaDescribedById'),
            },
            children: [e, n],
          })
          e.extendTemplate({
            attributes: { class: ['ck-dropdown__button'], 'data-cke-tooltip-disabled': o.to('isOpen') },
          })
        }
        render() {
          super.render()
          this.focusTracker.add(this.buttonView.element)
          this.focusTracker.add(this.panelView.element)
          this.listenTo(this.buttonView, 'open', () => {
            this.isOpen = !this.isOpen
          })
          this.panelView.bind('isVisible').to(this, 'isOpen')
          this.on('change:isOpen', (t, e, n) => {
            if (!n) {
              return
            }
            if (this.panelPosition === 'auto') {
              this.panelView.position = ku._getOptimalPosition({
                element: this.panelView.element,
                target: this.buttonView.element,
                fitInViewport: true,
                positions: this._panelPositions,
              }).name
            } else {
              this.panelView.position = this.panelPosition
            }
          })
          this.keystrokes.listenTo(this.element)
          const t = (t, e) => {
            if (this.isOpen) {
              this.isOpen = false
              e()
            }
          }
          this.keystrokes.set('arrowdown', (t, e) => {
            if (this.buttonView.isEnabled && !this.isOpen) {
              this.isOpen = true
              e()
            }
          })
          this.keystrokes.set('arrowright', (t, e) => {
            if (this.isOpen) {
              e()
            }
          })
          this.keystrokes.set('arrowleft', t)
          this.keystrokes.set('esc', t)
        }
        focus() {
          this.buttonView.focus()
        }
        get _panelPositions() {
          const {
            south: t,
            north: e,
            southEast: n,
            southWest: o,
            northEast: i,
            northWest: r,
            southMiddleEast: s,
            southMiddleWest: a,
            northMiddleEast: c,
            northMiddleWest: l,
          } = ku.defaultPanelPositions
          if (this.locale.uiLanguageDirection !== 'rtl') {
            return [n, o, s, a, t, i, r, c, l, e]
          } else {
            return [o, n, a, s, t, r, i, l, c, e]
          }
        }
      }
      ku.defaultPanelPositions = {
        south: (t, e) => ({ top: t.bottom, left: t.left - (e.width - t.width) / 2, name: 's' }),
        southEast: (t) => ({ top: t.bottom, left: t.left, name: 'se' }),
        southWest: (t, e) => ({ top: t.bottom, left: t.left - e.width + t.width, name: 'sw' }),
        southMiddleEast: (t, e) => ({ top: t.bottom, left: t.left - (e.width - t.width) / 4, name: 'sme' }),
        southMiddleWest: (t, e) => ({ top: t.bottom, left: t.left - ((e.width - t.width) * 3) / 4, name: 'smw' }),
        north: (t, e) => ({ top: t.top - e.height, left: t.left - (e.width - t.width) / 2, name: 'n' }),
        northEast: (t, e) => ({ top: t.top - e.height, left: t.left, name: 'ne' }),
        northWest: (t, e) => ({ top: t.top - e.height, left: t.left - e.width + t.width, name: 'nw' }),
        northMiddleEast: (t, e) => ({ top: t.top - e.height, left: t.left - (e.width - t.width) / 4, name: 'nme' }),
        northMiddleWest: (t, e) => ({
          top: t.top - e.height,
          left: t.left - ((e.width - t.width) * 3) / 4,
          name: 'nmw',
        }),
      }
      ku._getOptimalPosition = Tc
      const wu =
        '<svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><path d="M.941 4.523a.75.75 0 1 1 1.06-1.06l3.006 3.005 3.005-3.005a.75.75 0 1 1 1.06 1.06l-3.549 3.55a.75.75 0 0 1-1.168-.136L.941 4.523z"/></svg>'
      class Au extends Dd {
        constructor(t) {
          super(t)
          this.arrowView = this._createArrowView()
          this.extendTemplate({
            attributes: { 'aria-haspopup': true, 'aria-expanded': this.bindTemplate.to('isOn', (t) => String(t)) },
          })
          this.delegate('execute').to(this, 'open')
        }
        render() {
          super.render()
          this.children.add(this.arrowView)
        }
        _createArrowView() {
          const t = new Cd()
          t.content = wu
          t.extendTemplate({ attributes: { class: 'ck-dropdown__arrow' } })
          return t
        }
      }
      class _u {
        constructor(t) {
          this.focusables = t.focusables
          this.focusTracker = t.focusTracker
          this.keystrokeHandler = t.keystrokeHandler
          this.actions = t.actions
          if (t.actions && t.keystrokeHandler) {
            for (const e in t.actions) {
              let n = t.actions[e]
              if (typeof n == 'string') {
                n = [n]
              }
              for (const o of n) {
                t.keystrokeHandler.set(o, (t, n) => {
                  this[e]()
                  n()
                })
              }
            }
          }
        }
        get first() {
          return this.focusables.find(Cu) || null
        }
        get last() {
          return this.focusables.filter(Cu).slice(-1)[0] || null
        }
        get next() {
          return this._getFocusableItem(1)
        }
        get previous() {
          return this._getFocusableItem(-1)
        }
        get current() {
          let t = null
          if (this.focusTracker.focusedElement === null) {
            return null
          }
          this.focusables.find((e, n) => {
            const o = e.element === this.focusTracker.focusedElement
            if (o) {
              t = n
            }
            return o
          })
          return t
        }
        focusFirst() {
          this._focus(this.first)
        }
        focusLast() {
          this._focus(this.last)
        }
        focusNext() {
          this._focus(this.next)
        }
        focusPrevious() {
          this._focus(this.previous)
        }
        _focus(t) {
          if (t) {
            t.focus()
          }
        }
        _getFocusableItem(t) {
          const e = this.current
          const n = this.focusables.length
          if (!n) {
            return null
          }
          if (e === null) {
            return this[t === 1 ? 'first' : 'last']
          }
          let o = (e + n + t) % n
          do {
            const e = this.focusables.get(o)
            if (Cu(e)) {
              return e
            }
            o = (o + n + t) % n
          } while (o !== e)
          return null
        }
      }
      function Cu(t) {
        return !!(t.focus && Ec(t.element))
      }
      class vu extends Hl {
        constructor(t) {
          super(t)
          this.setTemplate({ tag: 'span', attributes: { class: ['ck', 'ck-toolbar__separator'] } })
        }
      }
      class yu extends Hl {
        constructor(t) {
          super(t)
          this.setTemplate({ tag: 'span', attributes: { class: ['ck', 'ck-toolbar__line-break'] } })
        }
      }
      function xu(t) {
        return t.bindTemplate.to((e) => {
          if (e.target === t.element) {
            e.preventDefault()
          }
        })
      }
      function Eu(t) {
        if (Array.isArray(t)) {
          return { items: t, removeItems: [] }
        }
        if (!t) {
          return { items: [], removeItems: [] }
        }
        return Object.assign({ items: [], removeItems: [] }, t)
      }
      class Du extends ft() {
        constructor(t) {
          super()
          this._disableStack = new Set()
          this.editor = t
          this.set('isEnabled', true)
        }
        forceDisabled(t) {
          this._disableStack.add(t)
          if (this._disableStack.size == 1) {
            this.on('set:isEnabled', Tu, { priority: 'highest' })
            this.isEnabled = false
          }
        }
        clearForceDisabled(t) {
          this._disableStack.delete(t)
          if (this._disableStack.size == 0) {
            this.off('set:isEnabled', Tu)
            this.isEnabled = true
          }
        }
        destroy() {
          this.stopListening()
        }
        static get isContextPlugin() {
          return false
        }
      }
      function Tu(t) {
        t.return = false
        t.stop()
      }
      class Iu extends ft() {
        constructor(t) {
          super()
          this.editor = t
          this.set('value', undefined)
          this.set('isEnabled', false)
          this._affectsData = true
          this._isEnabledBasedOnSelection = true
          this._disableStack = new Set()
          this.decorate('execute')
          this.listenTo(this.editor.model.document, 'change', () => {
            this.refresh()
          })
          this.listenTo(t, 'change:isReadOnly', () => {
            this.refresh()
          })
          this.on(
            'set:isEnabled',
            (e) => {
              if (!this.affectsData) {
                return
              }
              const n = t.model.document.selection
              const o = n.getFirstPosition().root.rootName == '$graveyard'
              const i = !o && t.model.canEditAt(n)
              if (t.isReadOnly || (this._isEnabledBasedOnSelection && !i)) {
                e.return = false
                e.stop()
              }
            },
            { priority: 'highest' },
          )
          this.on(
            'execute',
            (t) => {
              if (!this.isEnabled) {
                t.stop()
              }
            },
            { priority: 'high' },
          )
        }
        get affectsData() {
          return this._affectsData
        }
        set affectsData(t) {
          this._affectsData = t
        }
        refresh() {
          this.isEnabled = true
        }
        forceDisabled(t) {
          this._disableStack.add(t)
          if (this._disableStack.size == 1) {
            this.on('set:isEnabled', Su, { priority: 'highest' })
            this.isEnabled = false
          }
        }
        clearForceDisabled(t) {
          this._disableStack.delete(t)
          if (this._disableStack.size == 0) {
            this.off('set:isEnabled', Su)
            this.refresh()
          }
        }
        execute(...t) {
          return undefined
        }
        destroy() {
          this.stopListening()
        }
      }
      function Su(t) {
        t.return = false
        t.stop()
      }
      class Mu extends Iu {
        constructor() {
          super(...arguments)
          this._childCommandsDefinitions = []
        }
        refresh() {}
        execute(...t) {
          const e = this._getFirstEnabledCommand()
          return !!e && e.execute(t)
        }
        registerChildCommand(t, e = {}) {
          B(this._childCommandsDefinitions, { command: t, priority: e.priority || 'normal' })
          t.on('change:isEnabled', () => this._checkEnabled())
          this._checkEnabled()
        }
        _checkEnabled() {
          this.isEnabled = !!this._getFirstEnabledCommand()
        }
        _getFirstEnabledCommand() {
          const t = this._childCommandsDefinitions.find(({ command: t }) => t.isEnabled)
          return t && t.command
        }
      }
      class Bu extends K() {
        constructor(t, e = [], n = []) {
          super()
          this._plugins = new Map()
          this._context = t
          this._availablePlugins = new Map()
          for (const t of e) {
            if (t.pluginName) {
              this._availablePlugins.set(t.pluginName, t)
            }
          }
          this._contextPlugins = new Map()
          for (const [t, e] of n) {
            this._contextPlugins.set(t, e)
            this._contextPlugins.set(e, t)
            if (t.pluginName) {
              this._availablePlugins.set(t.pluginName, t)
            }
          }
        }
        *[Symbol.iterator]() {
          for (const t of this._plugins) {
            if (typeof t[0] == 'function') {
              yield t
            }
          }
        }
        get(t) {
          const e = this._plugins.get(t)
          if (!e) {
            let e = t
            if (typeof t == 'function') {
              e = t.pluginName || t.name
            }
            throw new P('plugincollection-plugin-not-loaded', this._context, { plugin: e })
          }
          return e
        }
        has(t) {
          return this._plugins.has(t)
        }
        init(t, e = [], n = []) {
          const o = this
          const i = this._context
          h(t)
          f(t)
          const r = t.filter((t) => !d(t, e))
          const s = [...g(r)]
          A(s, n)
          const a = k(s)
          return w(a, 'init')
            .then(() => w(a, 'afterInit'))
            .then(() => a)
          function c(t) {
            return typeof t === 'function'
          }
          function l(t) {
            return c(t) && !!t.isContextPlugin
          }
          function d(t, e) {
            return e.some((e) => {
              if (e === t) {
                return true
              }
              if (u(t) === e) {
                return true
              }
              if (u(e) === t) {
                return true
              }
              return false
            })
          }
          function u(t) {
            return c(t) ? t.pluginName || t.name : t
          }
          function h(t, e = new Set()) {
            t.forEach((t) => {
              if (!c(t)) {
                return
              }
              if (e.has(t)) {
                return
              }
              e.add(t)
              if (t.pluginName && !o._availablePlugins.has(t.pluginName)) {
                o._availablePlugins.set(t.pluginName, t)
              }
              if (t.requires) {
                h(t.requires, e)
              }
            })
          }
          function g(t, e = new Set()) {
            return t
              .map((t) => (c(t) ? t : o._availablePlugins.get(t)))
              .reduce((t, n) => {
                if (e.has(n)) {
                  return t
                }
                e.add(n)
                if (n.requires) {
                  f(n.requires, n)
                  g(n.requires, e).forEach((e) => t.add(e))
                }
                return t.add(n)
              }, new Set())
          }
          function f(t, e = null) {
            t.map((t) => (c(t) ? t : o._availablePlugins.get(t) || t)).forEach((t) => {
              m(t, e)
              p(t, e)
              b(t, e)
            })
          }
          function m(t, e) {
            if (c(t)) {
              return
            }
            if (e) {
              throw new P('plugincollection-soft-required', i, { missingPlugin: t, requiredBy: u(e) })
            }
            throw new P('plugincollection-plugin-not-found', i, { plugin: t })
          }
          function p(t, e) {
            if (!l(e)) {
              return
            }
            if (l(t)) {
              return
            }
            throw new P('plugincollection-context-required', i, { plugin: u(t), requiredBy: u(e) })
          }
          function b(t, n) {
            if (!n) {
              return
            }
            if (!d(t, e)) {
              return
            }
            throw new P('plugincollection-required', i, { plugin: u(t), requiredBy: u(n) })
          }
          function k(t) {
            return t.map((t) => {
              let e = o._contextPlugins.get(t)
              e = e || new t(i)
              o._add(t, e)
              return e
            })
          }
          function w(t, e) {
            return t.reduce((t, n) => {
              if (!n[e]) {
                return t
              }
              if (o._contextPlugins.has(n)) {
                return t
              }
              return t.then(n[e].bind(n))
            }, Promise.resolve())
          }
          function A(t, e) {
            for (const n of e) {
              if (typeof n != 'function') {
                throw new P('plugincollection-replace-plugin-invalid-type', null, { pluginItem: n })
              }
              const e = n.pluginName
              if (!e) {
                throw new P('plugincollection-replace-plugin-missing-name', null, { pluginItem: n })
              }
              if (n.requires && n.requires.length) {
                throw new P('plugincollection-plugin-for-replacing-cannot-have-dependencies', null, { pluginName: e })
              }
              const i = o._availablePlugins.get(e)
              if (!i) {
                throw new P('plugincollection-plugin-for-replacing-not-exist', null, { pluginName: e })
              }
              const r = t.indexOf(i)
              if (r === -1) {
                if (o._contextPlugins.has(i)) {
                  return
                }
                throw new P('plugincollection-plugin-for-replacing-not-loaded', null, { pluginName: e })
              }
              if (i.requires && i.requires.length) {
                throw new P('plugincollection-replaced-plugin-cannot-have-dependencies', null, { pluginName: e })
              }
              t.splice(r, 1, n)
              o._availablePlugins.set(e, n)
            }
          }
        }
        destroy() {
          const t = []
          for (const [, e] of this) {
            if (typeof e.destroy == 'function' && !this._contextPlugins.has(e)) {
              t.push(e.destroy())
            }
          }
          return Promise.all(t)
        }
        _add(t, e) {
          this._plugins.set(t, e)
          const n = t.pluginName
          if (!n) {
            return
          }
          if (this._plugins.has(n)) {
            throw new P('plugincollection-plugin-name-conflict', null, {
              pluginName: n,
              plugin1: this._plugins.get(n).constructor,
              plugin2: t,
            })
          }
          this._plugins.set(n, e)
        }
      }
      class Nu {
        constructor(t) {
          this._contextOwner = null
          this.config = new qa(t, this.constructor.defaultConfig)
          const e = this.constructor.builtinPlugins
          this.config.define('plugins', e)
          this.plugins = new Bu(this, e)
          const n = this.config.get('language') || {}
          this.locale = new fl({
            uiLanguage: typeof n === 'string' ? n : n.ui,
            contentLanguage: this.config.get('language.content'),
          })
          this.t = this.locale.t
          this.editors = new pl()
        }
        initPlugins() {
          const t = this.config.get('plugins') || []
          const e = this.config.get('substitutePlugins') || []
          for (const n of t.concat(e)) {
            if (typeof n != 'function') {
              throw new P('context-initplugins-constructor-only', null, { Plugin: n })
            }
            if (n.isContextPlugin !== true) {
              throw new P('context-initplugins-invalid-plugin', null, { Plugin: n })
            }
          }
          return this.plugins.init(t, [], e)
        }
        destroy() {
          return Promise.all(Array.from(this.editors, (t) => t.destroy())).then(() => this.plugins.destroy())
        }
        _addEditor(t, e) {
          if (this._contextOwner) {
            throw new P('context-addeditor-private-context')
          }
          this.editors.add(t)
          if (e) {
            this._contextOwner = t
          }
        }
        _removeEditor(t) {
          if (this.editors.has(t)) {
            this.editors.remove(t)
          }
          if (this._contextOwner === t) {
            return this.destroy()
          }
          return Promise.resolve()
        }
        _getEditorConfig() {
          const t = {}
          for (const e of this.config.names()) {
            if (!['plugins', 'removePlugins', 'extraPlugins'].includes(e)) {
              t[e] = this.config.get(e)
            }
          }
          return t
        }
        static create(t) {
          return new Promise((e) => {
            const n = new this(t)
            e(n.initPlugins().then(() => n))
          })
        }
      }
      class Pu extends ft() {
        constructor(t) {
          super()
          this.context = t
        }
        destroy() {
          this.stopListening()
        }
        static get isContextPlugin() {
          return true
        }
      }
      var Lu = n(7372)
      var zu = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      zu.insert = 'head'
      zu.singleton = true
      var Ru = Rl()(Lu.Z, zu)
      const Ou = Lu.Z.locals || {}
      const Vu = new WeakMap()
      function Fu({ view: t, element: e, isDirectHost: n = true, keepOnFocus: o = false }) {
        const i = t.document
        if (!Vu.has(i)) {
          Vu.set(i, new Map())
          i.registerPostFixer((t) => Gu(i, t))
          i.on(
            'change:isComposing',
            () => {
              t.change((t) => Gu(i, t))
            },
            { priority: 'high' },
          )
        }
        if (e.is('editableElement')) {
          e.on('change:placeholder', (t, e, n) => {
            r(n)
          })
        }
        if (e.placeholder) {
          r(e.placeholder)
        }
        function r(r) {
          Vu.get(i).set(e, { text: r, isDirectHost: n, keepOnFocus: o, hostElement: n ? e : null })
          t.change((t) => Gu(i, t))
        }
      }
      function ju(t, e) {
        const n = e.document
        if (!Vu.has(n)) {
          return
        }
        t.change((t) => {
          const o = Vu.get(n)
          const i = o.get(e)
          t.removeAttribute('data-placeholder', i.hostElement)
          Uu(t, i.hostElement)
          o.delete(e)
        })
      }
      function Hu(t, e) {
        if (!e.hasClass('ck-placeholder')) {
          t.addClass('ck-placeholder', e)
          return true
        }
        return false
      }
      function Uu(t, e) {
        if (e.hasClass('ck-placeholder')) {
          t.removeClass('ck-placeholder', e)
          return true
        }
        return false
      }
      function Wu(t, e) {
        if (!t.isAttached()) {
          return false
        }
        const n = Array.from(t.getChildren()).some((t) => !t.is('uiElement'))
        if (n) {
          return false
        }
        const o = t.document
        const i = o.selection
        const r = i.anchor
        if (o.isComposing && r && r.parent === t) {
          return false
        }
        if (e) {
          return true
        }
        if (!o.isFocused) {
          return true
        }
        return !!r && r.parent !== t
      }
      function Gu(t, e) {
        const n = Vu.get(t)
        const o = []
        let i = false
        for (const [t, r] of n) {
          if (r.isDirectHost) {
            o.push(t)
            if (qu(e, t, r)) {
              i = true
            }
          }
        }
        for (const [t, r] of n) {
          if (r.isDirectHost) {
            continue
          }
          const n = $u(t)
          if (!n) {
            continue
          }
          if (o.includes(n)) {
            continue
          }
          r.hostElement = n
          if (qu(e, t, r)) {
            i = true
          }
        }
        return i
      }
      function qu(t, e, n) {
        const { text: o, isDirectHost: i, hostElement: r } = n
        let s = false
        if (r.getAttribute('data-placeholder') !== o) {
          t.setAttribute('data-placeholder', o, r)
          s = true
        }
        const a = i || e.childCount == 1
        if (a && Wu(r, n.keepOnFocus)) {
          if (Hu(t, r)) {
            s = true
          }
        } else if (Uu(t, r)) {
          s = true
        }
        return s
      }
      function $u(t) {
        if (t.childCount) {
          const e = t.getChild(0)
          if (e.is('element') && !e.is('uiElement') && !e.is('attributeElement')) {
            return e
          }
        }
        return null
      }
      class Ku {
        is() {
          throw new Error('is() method is abstract')
        }
      }
      var Yu = 4
      function Zu(t) {
        return Va(t, Yu)
      }
      const Qu = Zu
      class Ju extends K(Ku) {
        constructor(t) {
          super()
          this.document = t
          this.parent = null
        }
        get index() {
          let t
          if (!this.parent) {
            return null
          }
          if ((t = this.parent.getChildIndex(this)) == -1) {
            throw new P('view-node-not-found-in-parent', this)
          }
          return t
        }
        get nextSibling() {
          const t = this.index
          return (t !== null && this.parent.getChild(t + 1)) || null
        }
        get previousSibling() {
          const t = this.index
          return (t !== null && this.parent.getChild(t - 1)) || null
        }
        get root() {
          let t = this
          while (t.parent) {
            t = t.parent
          }
          return t
        }
        isAttached() {
          return this.root.is('rootElement')
        }
        getPath() {
          const t = []
          let e = this
          while (e.parent) {
            t.unshift(e.index)
            e = e.parent
          }
          return t
        }
        getAncestors(t = {}) {
          const e = []
          let n = t.includeSelf ? this : this.parent
          while (n) {
            e[t.parentFirst ? 'push' : 'unshift'](n)
            n = n.parent
          }
          return e
        }
        getCommonAncestor(t, e = {}) {
          const n = this.getAncestors(e)
          const o = t.getAncestors(e)
          let i = 0
          while (n[i] == o[i] && n[i]) {
            i++
          }
          return i === 0 ? null : n[i - 1]
        }
        isBefore(t) {
          if (this == t) {
            return false
          }
          if (this.root !== t.root) {
            return false
          }
          const e = this.getPath()
          const n = t.getPath()
          const o = Dt(e, n)
          switch (o) {
            case 'prefix':
              return true
            case 'extension':
              return false
            default:
              return e[o] < n[o]
          }
        }
        isAfter(t) {
          if (this == t) {
            return false
          }
          if (this.root !== t.root) {
            return false
          }
          return !this.isBefore(t)
        }
        _remove() {
          this.parent._removeChildren(this.index)
        }
        _fireChange(t, e) {
          this.fire(`change:${t}`, e)
          if (this.parent) {
            this.parent._fireChange(t, e)
          }
        }
        toJSON() {
          const t = Qu(this)
          delete t.parent
          return t
        }
      }
      Ju.prototype.is = function (t) {
        return t === 'node' || t === 'view:node'
      }
      class Xu extends Ju {
        constructor(t, e) {
          super(t)
          this._textData = e
        }
        get data() {
          return this._textData
        }
        get _data() {
          return this.data
        }
        set _data(t) {
          this._fireChange('text', this)
          this._textData = t
        }
        isSimilar(t) {
          if (!(t instanceof Xu)) {
            return false
          }
          return this === t || this.data === t.data
        }
        _clone() {
          return new Xu(this.document, this.data)
        }
      }
      Xu.prototype.is = function (t) {
        return (
          t === '$text' || t === 'view:$text' || t === 'text' || t === 'view:text' || t === 'node' || t === 'view:node'
        )
      }
      class th extends Ku {
        constructor(t, e, n) {
          super()
          this.textNode = t
          if (e < 0 || e > t.data.length) {
            throw new P('view-textproxy-wrong-offsetintext', this)
          }
          if (n < 0 || e + n > t.data.length) {
            throw new P('view-textproxy-wrong-length', this)
          }
          this.data = t.data.substring(e, e + n)
          this.offsetInText = e
        }
        get offsetSize() {
          return this.data.length
        }
        get isPartial() {
          return this.data.length !== this.textNode.data.length
        }
        get parent() {
          return this.textNode.parent
        }
        get root() {
          return this.textNode.root
        }
        get document() {
          return this.textNode.document
        }
        getAncestors(t = {}) {
          const e = []
          let n = t.includeSelf ? this.textNode : this.parent
          while (n !== null) {
            e[t.parentFirst ? 'push' : 'unshift'](n)
            n = n.parent
          }
          return e
        }
      }
      th.prototype.is = function (t) {
        return t === '$textProxy' || t === 'view:$textProxy' || t === 'textProxy' || t === 'view:textProxy'
      }
      class eh {
        constructor(...t) {
          this._patterns = []
          this.add(...t)
        }
        add(...t) {
          for (let e of t) {
            if (typeof e == 'string' || e instanceof RegExp) {
              e = { name: e }
            }
            this._patterns.push(e)
          }
        }
        match(...t) {
          for (const e of t) {
            for (const t of this._patterns) {
              const n = nh(e, t)
              if (n) {
                return { element: e, pattern: t, match: n }
              }
            }
          }
          return null
        }
        matchAll(...t) {
          const e = []
          for (const n of t) {
            for (const t of this._patterns) {
              const o = nh(n, t)
              if (o) {
                e.push({ element: n, pattern: t, match: o })
              }
            }
          }
          return e.length > 0 ? e : null
        }
        getElementName() {
          if (this._patterns.length !== 1) {
            return null
          }
          const t = this._patterns[0]
          const e = t.name
          return typeof t != 'function' && e && !(e instanceof RegExp) ? e : null
        }
      }
      function nh(t, e) {
        if (typeof e == 'function') {
          return e(t)
        }
        const n = {}
        if (e.name) {
          n.name = oh(e.name, t.name)
          if (!n.name) {
            return null
          }
        }
        if (e.attributes) {
          n.attributes = ch(e.attributes, t)
          if (!n.attributes) {
            return null
          }
        }
        if (e.classes) {
          n.classes = lh(e.classes, t)
          if (!n.classes) {
            return null
          }
        }
        if (e.styles) {
          n.styles = dh(e.styles, t)
          if (!n.styles) {
            return null
          }
        }
        return n
      }
      function oh(t, e) {
        if (t instanceof RegExp) {
          return !!e.match(t)
        }
        return t === e
      }
      function ih(t, e, n) {
        const o = rh(t)
        const i = Array.from(e)
        const r = []
        o.forEach(([t, e]) => {
          i.forEach((o) => {
            if (sh(t, o) && ah(e, o, n)) {
              r.push(o)
            }
          })
        })
        if (!o.length || r.length < o.length) {
          return undefined
        }
        return r
      }
      function rh(t) {
        if (Array.isArray(t)) {
          return t.map((t) => {
            if (pe(t)) {
              if (t.key === undefined || t.value === undefined) {
                L('matcher-pattern-missing-key-or-value', t)
              }
              return [t.key, t.value]
            }
            return [t, true]
          })
        }
        if (pe(t)) {
          return Object.entries(t)
        }
        return [[t, true]]
      }
      function sh(t, e) {
        return t === true || t === e || (t instanceof RegExp && e.match(t))
      }
      function ah(t, e, n) {
        if (t === true) {
          return true
        }
        const o = n(e)
        return t === o || (t instanceof RegExp && !!String(o).match(t))
      }
      function ch(t, e) {
        const n = new Set(e.getAttributeKeys())
        if (pe(t)) {
          if (t.style !== undefined) {
            L('matcher-pattern-deprecated-attributes-style-key', t)
          }
          if (t.class !== undefined) {
            L('matcher-pattern-deprecated-attributes-class-key', t)
          }
        } else {
          n.delete('style')
          n.delete('class')
        }
        return ih(t, n, (t) => e.getAttribute(t))
      }
      function lh(t, e) {
        return ih(t, e.getClassNames(), () => {})
      }
      function dh(t, e) {
        return ih(t, e.getStyleNames(true), (t) => e.getStyle(t))
      }
      var uh = '[object Symbol]'
      function hh(t) {
        return typeof t == 'symbol' || (te(t) && Zt(t) == uh)
      }
      const gh = hh
      var fh = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
        mh = /^\w*$/
      function ph(t, e) {
        if (Jt(t)) {
          return false
        }
        var n = typeof t
        if (n == 'number' || n == 'symbol' || n == 'boolean' || t == null || gh(t)) {
          return true
        }
        return mh.test(t) || !fh.test(t) || (e != null && t in Object(e))
      }
      const bh = ph
      var kh = 'Expected a function'
      function wh(t, e) {
        if (typeof t != 'function' || (e != null && typeof e != 'function')) {
          throw new TypeError(kh)
        }
        var n = function () {
          var o = arguments,
            i = e ? e.apply(this, o) : o[0],
            r = n.cache
          if (r.has(i)) {
            return r.get(i)
          }
          var s = t.apply(this, o)
          n.cache = r.set(i, s) || r
          return s
        }
        n.cache = new (wh.Cache || eo)()
        return n
      }
      wh.Cache = eo
      const Ah = wh
      var _h = 500
      function Ch(t) {
        var e = Ah(t, function (t) {
          if (n.size === _h) {
            n.clear()
          }
          return t
        })
        var n = e.cache
        return e
      }
      const vh = Ch
      var yh = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g
      var xh = /\\(\\)?/g
      var Eh = vh(function (t) {
        var e = []
        if (t.charCodeAt(0) === 46) {
          e.push('')
        }
        t.replace(yh, function (t, n, o, i) {
          e.push(o ? i.replace(xh, '$1') : n || t)
        })
        return e
      })
      const Dh = Eh
      function Th(t, e) {
        var n = -1,
          o = t == null ? 0 : t.length,
          i = Array(o)
        while (++n < o) {
          i[n] = e(t[n], n, t)
        }
        return i
      }
      const Ih = Th
      var Sh = 1 / 0
      var Mh = Lt ? Lt.prototype : undefined,
        Bh = Mh ? Mh.toString : undefined
      function Nh(t) {
        if (typeof t == 'string') {
          return t
        }
        if (Jt(t)) {
          return Ih(t, Nh) + ''
        }
        if (gh(t)) {
          return Bh ? Bh.call(t) : ''
        }
        var e = t + ''
        return e == '0' && 1 / t == -Sh ? '-0' : e
      }
      const Ph = Nh
      function Lh(t) {
        return t == null ? '' : Ph(t)
      }
      const zh = Lh
      function Rh(t, e) {
        if (Jt(t)) {
          return t
        }
        return bh(t, e) ? [t] : Dh(zh(t))
      }
      const Oh = Rh
      function Vh(t) {
        var e = t == null ? 0 : t.length
        return e ? t[e - 1] : undefined
      }
      const Fh = Vh
      var jh = 1 / 0
      function Hh(t) {
        if (typeof t == 'string' || gh(t)) {
          return t
        }
        var e = t + ''
        return e == '0' && 1 / t == -jh ? '-0' : e
      }
      const Uh = Hh
      function Wh(t, e) {
        e = Oh(e, t)
        var n = 0,
          o = e.length
        while (t != null && n < o) {
          t = t[Uh(e[n++])]
        }
        return n && n == o ? t : undefined
      }
      const Gh = Wh
      function qh(t, e, n) {
        var o = -1,
          i = t.length
        if (e < 0) {
          e = -e > i ? 0 : i + e
        }
        n = n > i ? i : n
        if (n < 0) {
          n += i
        }
        i = e > n ? 0 : (n - e) >>> 0
        e >>>= 0
        var r = Array(i)
        while (++o < i) {
          r[o] = t[o + e]
        }
        return r
      }
      const $h = qh
      function Kh(t, e) {
        return e.length < 2 ? t : Gh(t, $h(e, 0, -1))
      }
      const Yh = Kh
      function Zh(t, e) {
        e = Oh(e, t)
        t = Yh(t, e)
        return t == null || delete t[Uh(Fh(e))]
      }
      const Qh = Zh
      function Jh(t, e) {
        return t == null ? true : Qh(t, e)
      }
      const Xh = Jh
      function tg(t, e, n) {
        var o = t == null ? undefined : Gh(t, e)
        return o === undefined ? n : o
      }
      const eg = tg
      function ng(t, e, n) {
        if ((n !== undefined && !Ae(t[e], n)) || (n === undefined && !(e in t))) {
          go(t, e, n)
        }
      }
      const og = ng
      function ig(t) {
        return function (e, n, o) {
          var i = -1,
            r = Object(e),
            s = o(e),
            a = s.length
          while (a--) {
            var c = s[t ? a : ++i]
            if (n(r[c], c, r) === false) {
              break
            }
          }
          return e
        }
      }
      const rg = ig
      var sg = rg()
      const ag = sg
      function cg(t) {
        return te(t) && Wi(t)
      }
      const lg = cg
      function dg(t, e) {
        if (e === 'constructor' && typeof t[e] === 'function') {
          return
        }
        if (e == '__proto__') {
          return
        }
        return t[e]
      }
      const ug = dg
      function hg(t) {
        return wo(t, nr(t))
      }
      const gg = hg
      function fg(t, e, n, o, i, r, s) {
        var a = ug(t, n),
          c = ug(e, n),
          l = s.get(c)
        if (l) {
          og(t, n, l)
          return
        }
        var d = r ? r(a, c, n + '', t, e, s) : undefined
        var u = d === undefined
        if (u) {
          var h = Jt(c),
            g = !h && Oo(c),
            f = !h && !g && Ii(c)
          d = c
          if (h || g || f) {
            if (Jt(a)) {
              d = a
            } else if (lg(a)) {
              d = gr(a)
            } else if (g) {
              u = false
              d = ur(c, true)
            } else if (f) {
              u = false
              d = vs(c, true)
            } else {
              d = []
            }
          } else if (pe(c) || Io(c)) {
            d = a
            if (Io(a)) {
              d = gg(a)
            } else if (!at(a) || Ke(a)) {
              d = Ys(c)
            }
          } else {
            u = false
          }
        }
        if (u) {
          s.set(c, d)
          i(d, c, o, r, s)
          s['delete'](c)
        }
        og(t, n, d)
      }
      const mg = fg
      function pg(t, e, n, o, i) {
        if (t === e) {
          return
        }
        ag(
          e,
          function (r, s) {
            i || (i = new so())
            if (at(r)) {
              mg(t, e, s, n, pg, o, i)
            } else {
              var a = o ? o(ug(t, s), r, s + '', t, e, i) : undefined
              if (a === undefined) {
                a = r
              }
              og(t, s, a)
            }
          },
          nr,
        )
      }
      const bg = pg
      function kg(t) {
        return t
      }
      const wg = kg
      function Ag(t, e, n) {
        switch (n.length) {
          case 0:
            return t.call(e)
          case 1:
            return t.call(e, n[0])
          case 2:
            return t.call(e, n[0], n[1])
          case 3:
            return t.call(e, n[0], n[1], n[2])
        }
        return t.apply(e, n)
      }
      const _g = Ag
      var Cg = Math.max
      function vg(t, e, n) {
        e = Cg(e === undefined ? t.length - 1 : e, 0)
        return function () {
          var o = arguments,
            i = -1,
            r = Cg(o.length - e, 0),
            s = Array(r)
          while (++i < r) {
            s[i] = o[e + i]
          }
          i = -1
          var a = Array(e + 1)
          while (++i < e) {
            a[i] = o[i]
          }
          a[e] = n(s)
          return _g(t, this, a)
        }
      }
      const yg = vg
      function xg(t) {
        return function () {
          return t
        }
      }
      const Eg = xg
      var Dg = !uo
        ? wg
        : function (t, e) {
            return uo(t, 'toString', { configurable: true, enumerable: false, value: Eg(e), writable: true })
          }
      const Tg = Dg
      var Ig = 800,
        Sg = 16
      var Mg = Date.now
      function Bg(t) {
        var e = 0,
          n = 0
        return function () {
          var o = Mg(),
            i = Sg - (o - n)
          n = o
          if (i > 0) {
            if (++e >= Ig) {
              return arguments[0]
            }
          } else {
            e = 0
          }
          return t.apply(undefined, arguments)
        }
      }
      const Ng = Bg
      var Pg = Ng(Tg)
      const Lg = Pg
      function zg(t, e) {
        return Lg(yg(t, e, wg), t + '')
      }
      const Rg = zg
      function Og(t, e, n) {
        if (!at(n)) {
          return false
        }
        var o = typeof e
        if (o == 'number' ? Wi(n) && Ho(e, n.length) : o == 'string' && e in n) {
          return Ae(n[e], t)
        }
        return false
      }
      const Vg = Og
      function Fg(t) {
        return Rg(function (e, n) {
          var o = -1,
            i = n.length,
            r = i > 1 ? n[i - 1] : undefined,
            s = i > 2 ? n[2] : undefined
          r = t.length > 3 && typeof r == 'function' ? (i--, r) : undefined
          if (s && Vg(n[0], n[1], s)) {
            r = i < 3 ? undefined : r
            i = 1
          }
          e = Object(e)
          while (++o < i) {
            var a = n[o]
            if (a) {
              t(e, a, o, r)
            }
          }
          return e
        })
      }
      const jg = Fg
      var Hg = jg(function (t, e, n) {
        bg(t, e, n)
      })
      const Ug = Hg
      function Wg(t, e, n, o) {
        if (!at(t)) {
          return t
        }
        e = Oh(e, t)
        var i = -1,
          r = e.length,
          s = r - 1,
          a = t
        while (a != null && ++i < r) {
          var c = Uh(e[i]),
            l = n
          if (c === '__proto__' || c === 'constructor' || c === 'prototype') {
            return t
          }
          if (i != s) {
            var d = a[c]
            l = o ? o(d, c, a) : undefined
            if (l === undefined) {
              l = at(d) ? d : Ho(e[i + 1]) ? [] : {}
            }
          }
          bo(a, c, l)
          a = a[c]
        }
        return t
      }
      const Gg = Wg
      function qg(t, e, n) {
        return t == null ? t : Gg(t, e, n)
      }
      const $g = qg
      class Kg {
        constructor(t) {
          this._styles = {}
          this._styleProcessor = t
        }
        get isEmpty() {
          const t = Object.entries(this._styles)
          const e = Array.from(t)
          return !e.length
        }
        get size() {
          if (this.isEmpty) {
            return 0
          }
          return this.getStyleNames().length
        }
        setTo(t) {
          this.clear()
          const e = Array.from(Zg(t).entries())
          for (const [t, n] of e) {
            this._styleProcessor.toNormalizedForm(t, n, this._styles)
          }
        }
        has(t) {
          if (this.isEmpty) {
            return false
          }
          const e = this._styleProcessor.getReducedForm(t, this._styles)
          const n = e.find(([e]) => e === t)
          return Array.isArray(n)
        }
        set(t, e) {
          if (at(t)) {
            for (const [e, n] of Object.entries(t)) {
              this._styleProcessor.toNormalizedForm(e, n, this._styles)
            }
          } else {
            this._styleProcessor.toNormalizedForm(t, e, this._styles)
          }
        }
        remove(t) {
          const e = Qg(t)
          Xh(this._styles, e)
          delete this._styles[t]
          this._cleanEmptyObjectsOnPath(e)
        }
        getNormalized(t) {
          return this._styleProcessor.getNormalized(t, this._styles)
        }
        toString() {
          if (this.isEmpty) {
            return ''
          }
          return (
            this._getStylesEntries()
              .map((t) => t.join(':'))
              .sort()
              .join(';') + ';'
          )
        }
        getAsString(t) {
          if (this.isEmpty) {
            return
          }
          if (this._styles[t] && !at(this._styles[t])) {
            return this._styles[t]
          }
          const e = this._styleProcessor.getReducedForm(t, this._styles)
          const n = e.find(([e]) => e === t)
          if (Array.isArray(n)) {
            return n[1]
          }
        }
        getStyleNames(t = false) {
          if (this.isEmpty) {
            return []
          }
          if (t) {
            return this._styleProcessor.getStyleNames(this._styles)
          }
          const e = this._getStylesEntries()
          return e.map(([t]) => t)
        }
        clear() {
          this._styles = {}
        }
        _getStylesEntries() {
          const t = []
          const e = Object.keys(this._styles)
          for (const n of e) {
            t.push(...this._styleProcessor.getReducedForm(n, this._styles))
          }
          return t
        }
        _cleanEmptyObjectsOnPath(t) {
          const e = t.split('.')
          const n = e.length > 1
          if (!n) {
            return
          }
          const o = e.splice(0, e.length - 1).join('.')
          const i = eg(this._styles, o)
          if (!i) {
            return
          }
          const r = !Array.from(Object.keys(i)).length
          if (r) {
            this.remove(o)
          }
        }
      }
      class Yg {
        constructor() {
          this._normalizers = new Map()
          this._extractors = new Map()
          this._reducers = new Map()
          this._consumables = new Map()
        }
        toNormalizedForm(t, e, n) {
          if (at(e)) {
            Jg(n, Qg(t), e)
            return
          }
          if (this._normalizers.has(t)) {
            const o = this._normalizers.get(t)
            const { path: i, value: r } = o(e)
            Jg(n, i, r)
          } else {
            Jg(n, t, e)
          }
        }
        getNormalized(t, e) {
          if (!t) {
            return Ug({}, e)
          }
          if (e[t] !== undefined) {
            return e[t]
          }
          if (this._extractors.has(t)) {
            const n = this._extractors.get(t)
            if (typeof n === 'string') {
              return eg(e, n)
            }
            const o = n(t, e)
            if (o) {
              return o
            }
          }
          return eg(e, Qg(t))
        }
        getReducedForm(t, e) {
          const n = this.getNormalized(t, e)
          if (n === undefined) {
            return []
          }
          if (this._reducers.has(t)) {
            const e = this._reducers.get(t)
            return e(n)
          }
          return [[t, n]]
        }
        getStyleNames(t) {
          const e = Array.from(this._consumables.keys()).filter((e) => {
            const n = this.getNormalized(e, t)
            if (n && typeof n == 'object') {
              return Object.keys(n).length
            }
            return n
          })
          const n = new Set([...e, ...Object.keys(t)])
          return Array.from(n.values())
        }
        getRelatedStyles(t) {
          return this._consumables.get(t) || []
        }
        setNormalizer(t, e) {
          this._normalizers.set(t, e)
        }
        setExtractor(t, e) {
          this._extractors.set(t, e)
        }
        setReducer(t, e) {
          this._reducers.set(t, e)
        }
        setStyleRelation(t, e) {
          this._mapStyleNames(t, e)
          for (const n of e) {
            this._mapStyleNames(n, [t])
          }
        }
        _mapStyleNames(t, e) {
          if (!this._consumables.has(t)) {
            this._consumables.set(t, [])
          }
          this._consumables.get(t).push(...e)
        }
      }
      function Zg(t) {
        let e = null
        let n = 0
        let o = 0
        let i = null
        const r = new Map()
        if (t === '') {
          return r
        }
        if (t.charAt(t.length - 1) != ';') {
          t = t + ';'
        }
        for (let s = 0; s < t.length; s++) {
          const a = t.charAt(s)
          if (e === null) {
            switch (a) {
              case ':':
                if (!i) {
                  i = t.substr(n, s - n)
                  o = s + 1
                }
                break
              case '"':
              case "'":
                e = a
                break
              case ';': {
                const e = t.substr(o, s - o)
                if (i) {
                  r.set(i.trim(), e.trim())
                }
                i = null
                n = s + 1
                break
              }
            }
          } else if (a === e) {
            e = null
          }
        }
        return r
      }
      function Qg(t) {
        return t.replace('-', '.')
      }
      function Jg(t, e, n) {
        let o = n
        if (at(n)) {
          o = Ug({}, eg(t, e), n)
        }
        $g(t, e, o)
      }
      class Xg extends Ju {
        constructor(t, e, n, o) {
          super(t)
          this._unsafeAttributesToRender = []
          this._customProperties = new Map()
          this.name = e
          this._attrs = tf(n)
          this._children = []
          if (o) {
            this._insertChild(0, o)
          }
          this._classes = new Set()
          if (this._attrs.has('class')) {
            const t = this._attrs.get('class')
            ef(this._classes, t)
            this._attrs.delete('class')
          }
          this._styles = new Kg(this.document.stylesProcessor)
          if (this._attrs.has('style')) {
            this._styles.setTo(this._attrs.get('style'))
            this._attrs.delete('style')
          }
        }
        get childCount() {
          return this._children.length
        }
        get isEmpty() {
          return this._children.length === 0
        }
        getChild(t) {
          return this._children[t]
        }
        getChildIndex(t) {
          return this._children.indexOf(t)
        }
        getChildren() {
          return this._children[Symbol.iterator]()
        }
        *getAttributeKeys() {
          if (this._classes.size > 0) {
            yield 'class'
          }
          if (!this._styles.isEmpty) {
            yield 'style'
          }
          yield* this._attrs.keys()
        }
        *getAttributes() {
          yield* this._attrs.entries()
          if (this._classes.size > 0) {
            yield ['class', this.getAttribute('class')]
          }
          if (!this._styles.isEmpty) {
            yield ['style', this.getAttribute('style')]
          }
        }
        getAttribute(t) {
          if (t == 'class') {
            if (this._classes.size > 0) {
              return [...this._classes].join(' ')
            }
            return undefined
          }
          if (t == 'style') {
            const t = this._styles.toString()
            return t == '' ? undefined : t
          }
          return this._attrs.get(t)
        }
        hasAttribute(t) {
          if (t == 'class') {
            return this._classes.size > 0
          }
          if (t == 'style') {
            return !this._styles.isEmpty
          }
          return this._attrs.has(t)
        }
        isSimilar(t) {
          if (!(t instanceof Xg)) {
            return false
          }
          if (this === t) {
            return true
          }
          if (this.name != t.name) {
            return false
          }
          if (
            this._attrs.size !== t._attrs.size ||
            this._classes.size !== t._classes.size ||
            this._styles.size !== t._styles.size
          ) {
            return false
          }
          for (const [e, n] of this._attrs) {
            if (!t._attrs.has(e) || t._attrs.get(e) !== n) {
              return false
            }
          }
          for (const e of this._classes) {
            if (!t._classes.has(e)) {
              return false
            }
          }
          for (const e of this._styles.getStyleNames()) {
            if (!t._styles.has(e) || t._styles.getAsString(e) !== this._styles.getAsString(e)) {
              return false
            }
          }
          return true
        }
        hasClass(...t) {
          for (const e of t) {
            if (!this._classes.has(e)) {
              return false
            }
          }
          return true
        }
        getClassNames() {
          return this._classes.keys()
        }
        getStyle(t) {
          return this._styles.getAsString(t)
        }
        getNormalizedStyle(t) {
          return this._styles.getNormalized(t)
        }
        getStyleNames(t) {
          return this._styles.getStyleNames(t)
        }
        hasStyle(...t) {
          for (const e of t) {
            if (!this._styles.has(e)) {
              return false
            }
          }
          return true
        }
        findAncestor(...t) {
          const e = new eh(...t)
          let n = this.parent
          while (n && !n.is('documentFragment')) {
            if (e.match(n)) {
              return n
            }
            n = n.parent
          }
          return null
        }
        getCustomProperty(t) {
          return this._customProperties.get(t)
        }
        *getCustomProperties() {
          yield* this._customProperties.entries()
        }
        getIdentity() {
          const t = Array.from(this._classes).sort().join(',')
          const e = this._styles.toString()
          const n = Array.from(this._attrs)
            .map((t) => `${t[0]}="${t[1]}"`)
            .sort()
            .join(' ')
          return this.name + (t == '' ? '' : ` class="${t}"`) + (!e ? '' : ` style="${e}"`) + (n == '' ? '' : ` ${n}`)
        }
        shouldRenderUnsafeAttribute(t) {
          return this._unsafeAttributesToRender.includes(t)
        }
        _clone(t = false) {
          const e = []
          if (t) {
            for (const n of this.getChildren()) {
              e.push(n._clone(t))
            }
          }
          const n = new this.constructor(this.document, this.name, this._attrs, e)
          n._classes = new Set(this._classes)
          n._styles.set(this._styles.getNormalized())
          n._customProperties = new Map(this._customProperties)
          n.getFillerOffset = this.getFillerOffset
          n._unsafeAttributesToRender = this._unsafeAttributesToRender
          return n
        }
        _appendChild(t) {
          return this._insertChild(this.childCount, t)
        }
        _insertChild(t, e) {
          this._fireChange('children', this)
          let n = 0
          const o = nf(this.document, e)
          for (const e of o) {
            if (e.parent !== null) {
              e._remove()
            }
            e.parent = this
            e.document = this.document
            this._children.splice(t, 0, e)
            t++
            n++
          }
          return n
        }
        _removeChildren(t, e = 1) {
          this._fireChange('children', this)
          for (let n = t; n < t + e; n++) {
            this._children[n].parent = null
          }
          return this._children.splice(t, e)
        }
        _setAttribute(t, e) {
          const n = String(e)
          this._fireChange('attributes', this)
          if (t == 'class') {
            ef(this._classes, n)
          } else if (t == 'style') {
            this._styles.setTo(n)
          } else {
            this._attrs.set(t, n)
          }
        }
        _removeAttribute(t) {
          this._fireChange('attributes', this)
          if (t == 'class') {
            if (this._classes.size > 0) {
              this._classes.clear()
              return true
            }
            return false
          }
          if (t == 'style') {
            if (!this._styles.isEmpty) {
              this._styles.clear()
              return true
            }
            return false
          }
          return this._attrs.delete(t)
        }
        _addClass(t) {
          this._fireChange('attributes', this)
          for (const e of sl(t)) {
            this._classes.add(e)
          }
        }
        _removeClass(t) {
          this._fireChange('attributes', this)
          for (const e of sl(t)) {
            this._classes.delete(e)
          }
        }
        _setStyle(t, e) {
          this._fireChange('attributes', this)
          if (typeof t != 'string') {
            this._styles.set(t)
          } else {
            this._styles.set(t, e)
          }
        }
        _removeStyle(t) {
          this._fireChange('attributes', this)
          for (const e of sl(t)) {
            this._styles.remove(e)
          }
        }
        _setCustomProperty(t, e) {
          this._customProperties.set(t, e)
        }
        _removeCustomProperty(t) {
          return this._customProperties.delete(t)
        }
      }
      Xg.prototype.is = function (t, e) {
        if (!e) {
          return t === 'element' || t === 'view:element' || t === 'node' || t === 'view:node'
        } else {
          return e === this.name && (t === 'element' || t === 'view:element')
        }
      }
      function tf(t) {
        const e = _l(t)
        for (const [t, n] of e) {
          if (n === null) {
            e.delete(t)
          } else if (typeof n != 'string') {
            e.set(t, String(n))
          }
        }
        return e
      }
      function ef(t, e) {
        const n = e.split(/\s+/)
        t.clear()
        n.forEach((e) => t.add(e))
      }
      function nf(t, e) {
        if (typeof e == 'string') {
          return [new Xu(t, e)]
        }
        if (!Tt(e)) {
          e = [e]
        }
        return Array.from(e).map((e) => {
          if (typeof e == 'string') {
            return new Xu(t, e)
          }
          if (e instanceof th) {
            return new Xu(t, e.data)
          }
          return e
        })
      }
      class of extends Xg {
        constructor(t, e, n, o) {
          super(t, e, n, o)
          this.getFillerOffset = rf
        }
      }
      of.prototype.is = function (t, e) {
        if (!e) {
          return (
            t === 'containerElement' ||
            t === 'view:containerElement' ||
            t === 'element' ||
            t === 'view:element' ||
            t === 'node' ||
            t === 'view:node'
          )
        } else {
          return (
            e === this.name &&
            (t === 'containerElement' || t === 'view:containerElement' || t === 'element' || t === 'view:element')
          )
        }
      }
      function rf() {
        const t = [...this.getChildren()]
        const e = t[this.childCount - 1]
        if (e && e.is('element', 'br')) {
          return this.childCount
        }
        for (const e of t) {
          if (!e.is('uiElement')) {
            return null
          }
        }
        return this.childCount
      }
      class sf extends ft(of) {
        constructor(t, e, n, o) {
          super(t, e, n, o)
          this.set('isReadOnly', false)
          this.set('isFocused', false)
          this.set('placeholder', undefined)
          this.bind('isReadOnly').to(t)
          this.bind('isFocused').to(t, 'isFocused', (e) => e && t.selection.editableElement == this)
          this.listenTo(t.selection, 'change', () => {
            this.isFocused = t.isFocused && t.selection.editableElement == this
          })
        }
        destroy() {
          this.stopListening()
        }
      }
      sf.prototype.is = function (t, e) {
        if (!e) {
          return (
            t === 'editableElement' ||
            t === 'view:editableElement' ||
            t === 'containerElement' ||
            t === 'view:containerElement' ||
            t === 'element' ||
            t === 'view:element' ||
            t === 'node' ||
            t === 'view:node'
          )
        } else {
          return (
            e === this.name &&
            (t === 'editableElement' ||
              t === 'view:editableElement' ||
              t === 'containerElement' ||
              t === 'view:containerElement' ||
              t === 'element' ||
              t === 'view:element')
          )
        }
      }
      const af = Symbol('rootName')
      class cf extends sf {
        constructor(t, e) {
          super(t, e)
          this.rootName = 'main'
        }
        get rootName() {
          return this.getCustomProperty(af)
        }
        set rootName(t) {
          this._setCustomProperty(af, t)
        }
        set _name(t) {
          this.name = t
        }
      }
      cf.prototype.is = function (t, e) {
        if (!e) {
          return (
            t === 'rootElement' ||
            t === 'view:rootElement' ||
            t === 'editableElement' ||
            t === 'view:editableElement' ||
            t === 'containerElement' ||
            t === 'view:containerElement' ||
            t === 'element' ||
            t === 'view:element' ||
            t === 'node' ||
            t === 'view:node'
          )
        } else {
          return (
            e === this.name &&
            (t === 'rootElement' ||
              t === 'view:rootElement' ||
              t === 'editableElement' ||
              t === 'view:editableElement' ||
              t === 'containerElement' ||
              t === 'view:containerElement' ||
              t === 'element' ||
              t === 'view:element')
          )
        }
      }
      class lf {
        constructor(t = {}) {
          if (!t.boundaries && !t.startPosition) {
            throw new P('view-tree-walker-no-start-position', null)
          }
          if (t.direction && t.direction != 'forward' && t.direction != 'backward') {
            throw new P('view-tree-walker-unknown-direction', t.startPosition, { direction: t.direction })
          }
          this.boundaries = t.boundaries || null
          if (t.startPosition) {
            this._position = df._createAt(t.startPosition)
          } else {
            this._position = df._createAt(t.boundaries[t.direction == 'backward' ? 'end' : 'start'])
          }
          this.direction = t.direction || 'forward'
          this.singleCharacters = !!t.singleCharacters
          this.shallow = !!t.shallow
          this.ignoreElementEnd = !!t.ignoreElementEnd
          this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null
          this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null
        }
        [Symbol.iterator]() {
          return this
        }
        get position() {
          return this._position
        }
        skip(t) {
          let e
          let n
          do {
            n = this.position
            e = this.next()
          } while (!e.done && t(e.value))
          if (!e.done) {
            this._position = n
          }
        }
        next() {
          if (this.direction == 'forward') {
            return this._next()
          } else {
            return this._previous()
          }
        }
        _next() {
          let t = this.position.clone()
          const e = this.position
          const n = t.parent
          if (n.parent === null && t.offset === n.childCount) {
            return { done: true, value: undefined }
          }
          if (n === this._boundaryEndParent && t.offset == this.boundaries.end.offset) {
            return { done: true, value: undefined }
          }
          let o
          if (n instanceof Xu) {
            if (t.isAtEnd) {
              this._position = df._createAfter(n)
              return this._next()
            }
            o = n.data[t.offset]
          } else {
            o = n.getChild(t.offset)
          }
          if (o instanceof Xg) {
            if (!this.shallow) {
              t = new df(o, 0)
            } else {
              if (this.boundaries && this.boundaries.end.isBefore(t)) {
                return { done: true, value: undefined }
              }
              t.offset++
            }
            this._position = t
            return this._formatReturnValue('elementStart', o, e, t, 1)
          }
          if (o instanceof Xu) {
            if (this.singleCharacters) {
              t = new df(o, 0)
              this._position = t
              return this._next()
            }
            let n = o.data.length
            let i
            if (o == this._boundaryEndParent) {
              n = this.boundaries.end.offset
              i = new th(o, 0, n)
              t = df._createAfter(i)
            } else {
              i = new th(o, 0, o.data.length)
              t.offset++
            }
            this._position = t
            return this._formatReturnValue('text', i, e, t, n)
          }
          if (typeof o == 'string') {
            let o
            if (this.singleCharacters) {
              o = 1
            } else {
              const e = n === this._boundaryEndParent ? this.boundaries.end.offset : n.data.length
              o = e - t.offset
            }
            const i = new th(n, t.offset, o)
            t.offset += o
            this._position = t
            return this._formatReturnValue('text', i, e, t, o)
          }
          t = df._createAfter(n)
          this._position = t
          if (this.ignoreElementEnd) {
            return this._next()
          }
          return this._formatReturnValue('elementEnd', n, e, t)
        }
        _previous() {
          let t = this.position.clone()
          const e = this.position
          const n = t.parent
          if (n.parent === null && t.offset === 0) {
            return { done: true, value: undefined }
          }
          if (n == this._boundaryStartParent && t.offset == this.boundaries.start.offset) {
            return { done: true, value: undefined }
          }
          let o
          if (n instanceof Xu) {
            if (t.isAtStart) {
              this._position = df._createBefore(n)
              return this._previous()
            }
            o = n.data[t.offset - 1]
          } else {
            o = n.getChild(t.offset - 1)
          }
          if (o instanceof Xg) {
            if (this.shallow) {
              t.offset--
              this._position = t
              return this._formatReturnValue('elementStart', o, e, t, 1)
            }
            t = new df(o, o.childCount)
            this._position = t
            if (this.ignoreElementEnd) {
              return this._previous()
            }
            return this._formatReturnValue('elementEnd', o, e, t)
          }
          if (o instanceof Xu) {
            if (this.singleCharacters) {
              t = new df(o, o.data.length)
              this._position = t
              return this._previous()
            }
            let n = o.data.length
            let i
            if (o == this._boundaryStartParent) {
              const e = this.boundaries.start.offset
              i = new th(o, e, o.data.length - e)
              n = i.data.length
              t = df._createBefore(i)
            } else {
              i = new th(o, 0, o.data.length)
              t.offset--
            }
            this._position = t
            return this._formatReturnValue('text', i, e, t, n)
          }
          if (typeof o == 'string') {
            let o
            if (!this.singleCharacters) {
              const e = n === this._boundaryStartParent ? this.boundaries.start.offset : 0
              o = t.offset - e
            } else {
              o = 1
            }
            t.offset -= o
            const i = new th(n, t.offset, o)
            this._position = t
            return this._formatReturnValue('text', i, e, t, o)
          }
          t = df._createBefore(n)
          this._position = t
          return this._formatReturnValue('elementStart', n, e, t, 1)
        }
        _formatReturnValue(t, e, n, o, i) {
          if (e instanceof th) {
            if (e.offsetInText + e.data.length == e.textNode.data.length) {
              if (this.direction == 'forward' && !(this.boundaries && this.boundaries.end.isEqual(this.position))) {
                o = df._createAfter(e.textNode)
                this._position = o
              } else {
                n = df._createAfter(e.textNode)
              }
            }
            if (e.offsetInText === 0) {
              if (this.direction == 'backward' && !(this.boundaries && this.boundaries.start.isEqual(this.position))) {
                o = df._createBefore(e.textNode)
                this._position = o
              } else {
                n = df._createBefore(e.textNode)
              }
            }
          }
          return { done: false, value: { type: t, item: e, previousPosition: n, nextPosition: o, length: i } }
        }
      }
      class df extends Ku {
        constructor(t, e) {
          super()
          this.parent = t
          this.offset = e
        }
        get nodeAfter() {
          if (this.parent.is('$text')) {
            return null
          }
          return this.parent.getChild(this.offset) || null
        }
        get nodeBefore() {
          if (this.parent.is('$text')) {
            return null
          }
          return this.parent.getChild(this.offset - 1) || null
        }
        get isAtStart() {
          return this.offset === 0
        }
        get isAtEnd() {
          const t = this.parent.is('$text') ? this.parent.data.length : this.parent.childCount
          return this.offset === t
        }
        get root() {
          return this.parent.root
        }
        get editableElement() {
          let t = this.parent
          while (!(t instanceof sf)) {
            if (t.parent) {
              t = t.parent
            } else {
              return null
            }
          }
          return t
        }
        getShiftedBy(t) {
          const e = df._createAt(this)
          const n = e.offset + t
          e.offset = n < 0 ? 0 : n
          return e
        }
        getLastMatchingPosition(t, e = {}) {
          e.startPosition = this
          const n = new lf(e)
          n.skip(t)
          return n.position
        }
        getAncestors() {
          if (this.parent.is('documentFragment')) {
            return [this.parent]
          } else {
            return this.parent.getAncestors({ includeSelf: true })
          }
        }
        getCommonAncestor(t) {
          const e = this.getAncestors()
          const n = t.getAncestors()
          let o = 0
          while (e[o] == n[o] && e[o]) {
            o++
          }
          return o === 0 ? null : e[o - 1]
        }
        isEqual(t) {
          return this.parent == t.parent && this.offset == t.offset
        }
        isBefore(t) {
          return this.compareWith(t) == 'before'
        }
        isAfter(t) {
          return this.compareWith(t) == 'after'
        }
        compareWith(t) {
          if (this.root !== t.root) {
            return 'different'
          }
          if (this.isEqual(t)) {
            return 'same'
          }
          const e = this.parent.is('node') ? this.parent.getPath() : []
          const n = t.parent.is('node') ? t.parent.getPath() : []
          e.push(this.offset)
          n.push(t.offset)
          const o = Dt(e, n)
          switch (o) {
            case 'prefix':
              return 'before'
            case 'extension':
              return 'after'
            default:
              return e[o] < n[o] ? 'before' : 'after'
          }
        }
        getWalker(t = {}) {
          t.startPosition = this
          return new lf(t)
        }
        clone() {
          return new df(this.parent, this.offset)
        }
        static _createAt(t, e) {
          if (t instanceof df) {
            return new this(t.parent, t.offset)
          } else {
            const n = t
            if (e == 'end') {
              e = n.is('$text') ? n.data.length : n.childCount
            } else if (e == 'before') {
              return this._createBefore(n)
            } else if (e == 'after') {
              return this._createAfter(n)
            } else if (e !== 0 && !e) {
              throw new P('view-createpositionat-offset-required', n)
            }
            return new df(n, e)
          }
        }
        static _createAfter(t) {
          if (t.is('$textProxy')) {
            return new df(t.textNode, t.offsetInText + t.data.length)
          }
          if (!t.parent) {
            throw new P('view-position-after-root', t, { root: t })
          }
          return new df(t.parent, t.index + 1)
        }
        static _createBefore(t) {
          if (t.is('$textProxy')) {
            return new df(t.textNode, t.offsetInText)
          }
          if (!t.parent) {
            throw new P('view-position-before-root', t, { root: t })
          }
          return new df(t.parent, t.index)
        }
      }
      df.prototype.is = function (t) {
        return t === 'position' || t === 'view:position'
      }
      class uf extends Ku {
        constructor(t, e = null) {
          super()
          this.start = t.clone()
          this.end = e ? e.clone() : t.clone()
        }
        *[Symbol.iterator]() {
          yield* new lf({ boundaries: this, ignoreElementEnd: true })
        }
        get isCollapsed() {
          return this.start.isEqual(this.end)
        }
        get isFlat() {
          return this.start.parent === this.end.parent
        }
        get root() {
          return this.start.root
        }
        getEnlarged() {
          let t = this.start.getLastMatchingPosition(hf, { direction: 'backward' })
          let e = this.end.getLastMatchingPosition(hf)
          if (t.parent.is('$text') && t.isAtStart) {
            t = df._createBefore(t.parent)
          }
          if (e.parent.is('$text') && e.isAtEnd) {
            e = df._createAfter(e.parent)
          }
          return new uf(t, e)
        }
        getTrimmed() {
          let t = this.start.getLastMatchingPosition(hf)
          if (t.isAfter(this.end) || t.isEqual(this.end)) {
            return new uf(t, t)
          }
          let e = this.end.getLastMatchingPosition(hf, { direction: 'backward' })
          const n = t.nodeAfter
          const o = e.nodeBefore
          if (n && n.is('$text')) {
            t = new df(n, 0)
          }
          if (o && o.is('$text')) {
            e = new df(o, o.data.length)
          }
          return new uf(t, e)
        }
        isEqual(t) {
          return this == t || (this.start.isEqual(t.start) && this.end.isEqual(t.end))
        }
        containsPosition(t) {
          return t.isAfter(this.start) && t.isBefore(this.end)
        }
        containsRange(t, e = false) {
          if (t.isCollapsed) {
            e = false
          }
          const n = this.containsPosition(t.start) || (e && this.start.isEqual(t.start))
          const o = this.containsPosition(t.end) || (e && this.end.isEqual(t.end))
          return n && o
        }
        getDifference(t) {
          const e = []
          if (this.isIntersecting(t)) {
            if (this.containsPosition(t.start)) {
              e.push(new uf(this.start, t.start))
            }
            if (this.containsPosition(t.end)) {
              e.push(new uf(t.end, this.end))
            }
          } else {
            e.push(this.clone())
          }
          return e
        }
        getIntersection(t) {
          if (this.isIntersecting(t)) {
            let e = this.start
            let n = this.end
            if (this.containsPosition(t.start)) {
              e = t.start
            }
            if (this.containsPosition(t.end)) {
              n = t.end
            }
            return new uf(e, n)
          }
          return null
        }
        getWalker(t = {}) {
          t.boundaries = this
          return new lf(t)
        }
        getCommonAncestor() {
          return this.start.getCommonAncestor(this.end)
        }
        getContainedElement() {
          if (this.isCollapsed) {
            return null
          }
          let t = this.start.nodeAfter
          let e = this.end.nodeBefore
          if (this.start.parent.is('$text') && this.start.isAtEnd && this.start.parent.nextSibling) {
            t = this.start.parent.nextSibling
          }
          if (this.end.parent.is('$text') && this.end.isAtStart && this.end.parent.previousSibling) {
            e = this.end.parent.previousSibling
          }
          if (t && t.is('element') && t === e) {
            return t
          }
          return null
        }
        clone() {
          return new uf(this.start, this.end)
        }
        *getItems(t = {}) {
          t.boundaries = this
          t.ignoreElementEnd = true
          const e = new lf(t)
          for (const t of e) {
            yield t.item
          }
        }
        *getPositions(t = {}) {
          t.boundaries = this
          const e = new lf(t)
          yield e.position
          for (const t of e) {
            yield t.nextPosition
          }
        }
        isIntersecting(t) {
          return this.start.isBefore(t.end) && this.end.isAfter(t.start)
        }
        static _createFromParentsAndOffsets(t, e, n, o) {
          return new this(new df(t, e), new df(n, o))
        }
        static _createFromPositionAndShift(t, e) {
          const n = t
          const o = t.getShiftedBy(e)
          return e > 0 ? new this(n, o) : new this(o, n)
        }
        static _createIn(t) {
          return this._createFromParentsAndOffsets(t, 0, t, t.childCount)
        }
        static _createOn(t) {
          const e = t.is('$textProxy') ? t.offsetSize : 1
          return this._createFromPositionAndShift(df._createBefore(t), e)
        }
      }
      uf.prototype.is = function (t) {
        return t === 'range' || t === 'view:range'
      }
      function hf(t) {
        if (t.item.is('attributeElement') || t.item.is('uiElement')) {
          return true
        }
        return false
      }
      class gf extends K(Ku) {
        constructor(...t) {
          super()
          this._ranges = []
          this._lastRangeBackward = false
          this._isFake = false
          this._fakeSelectionLabel = ''
          if (t.length) {
            this.setTo(...t)
          }
        }
        get isFake() {
          return this._isFake
        }
        get fakeSelectionLabel() {
          return this._fakeSelectionLabel
        }
        get anchor() {
          if (!this._ranges.length) {
            return null
          }
          const t = this._ranges[this._ranges.length - 1]
          const e = this._lastRangeBackward ? t.end : t.start
          return e.clone()
        }
        get focus() {
          if (!this._ranges.length) {
            return null
          }
          const t = this._ranges[this._ranges.length - 1]
          const e = this._lastRangeBackward ? t.start : t.end
          return e.clone()
        }
        get isCollapsed() {
          return this.rangeCount === 1 && this._ranges[0].isCollapsed
        }
        get rangeCount() {
          return this._ranges.length
        }
        get isBackward() {
          return !this.isCollapsed && this._lastRangeBackward
        }
        get editableElement() {
          if (this.anchor) {
            return this.anchor.editableElement
          }
          return null
        }
        *getRanges() {
          for (const t of this._ranges) {
            yield t.clone()
          }
        }
        getFirstRange() {
          let t = null
          for (const e of this._ranges) {
            if (!t || e.start.isBefore(t.start)) {
              t = e
            }
          }
          return t ? t.clone() : null
        }
        getLastRange() {
          let t = null
          for (const e of this._ranges) {
            if (!t || e.end.isAfter(t.end)) {
              t = e
            }
          }
          return t ? t.clone() : null
        }
        getFirstPosition() {
          const t = this.getFirstRange()
          return t ? t.start.clone() : null
        }
        getLastPosition() {
          const t = this.getLastRange()
          return t ? t.end.clone() : null
        }
        isEqual(t) {
          if (this.isFake != t.isFake) {
            return false
          }
          if (this.isFake && this.fakeSelectionLabel != t.fakeSelectionLabel) {
            return false
          }
          if (this.rangeCount != t.rangeCount) {
            return false
          } else if (this.rangeCount === 0) {
            return true
          }
          if (!this.anchor.isEqual(t.anchor) || !this.focus.isEqual(t.focus)) {
            return false
          }
          for (const e of this._ranges) {
            let n = false
            for (const o of t._ranges) {
              if (e.isEqual(o)) {
                n = true
                break
              }
            }
            if (!n) {
              return false
            }
          }
          return true
        }
        isSimilar(t) {
          if (this.isBackward != t.isBackward) {
            return false
          }
          const e = Et(this.getRanges())
          const n = Et(t.getRanges())
          if (e != n) {
            return false
          }
          if (e == 0) {
            return true
          }
          for (let e of this.getRanges()) {
            e = e.getTrimmed()
            let n = false
            for (let o of t.getRanges()) {
              o = o.getTrimmed()
              if (e.start.isEqual(o.start) && e.end.isEqual(o.end)) {
                n = true
                break
              }
            }
            if (!n) {
              return false
            }
          }
          return true
        }
        getSelectedElement() {
          if (this.rangeCount !== 1) {
            return null
          }
          return this.getFirstRange().getContainedElement()
        }
        setTo(...t) {
          let [e, n, o] = t
          if (typeof n == 'object') {
            o = n
            n = undefined
          }
          if (e === null) {
            this._setRanges([])
            this._setFakeOptions(o)
          } else if (e instanceof gf || e instanceof ff) {
            this._setRanges(e.getRanges(), e.isBackward)
            this._setFakeOptions({ fake: e.isFake, label: e.fakeSelectionLabel })
          } else if (e instanceof uf) {
            this._setRanges([e], o && o.backward)
            this._setFakeOptions(o)
          } else if (e instanceof df) {
            this._setRanges([new uf(e)])
            this._setFakeOptions(o)
          } else if (e instanceof Ju) {
            const t = !!o && !!o.backward
            let i
            if (n === undefined) {
              throw new P('view-selection-setto-required-second-parameter', this)
            } else if (n == 'in') {
              i = uf._createIn(e)
            } else if (n == 'on') {
              i = uf._createOn(e)
            } else {
              i = new uf(df._createAt(e, n))
            }
            this._setRanges([i], t)
            this._setFakeOptions(o)
          } else if (Tt(e)) {
            this._setRanges(e, o && o.backward)
            this._setFakeOptions(o)
          } else {
            throw new P('view-selection-setto-not-selectable', this)
          }
          this.fire('change')
        }
        setFocus(t, e) {
          if (this.anchor === null) {
            throw new P('view-selection-setfocus-no-ranges', this)
          }
          const n = df._createAt(t, e)
          if (n.compareWith(this.focus) == 'same') {
            return
          }
          const o = this.anchor
          this._ranges.pop()
          if (n.compareWith(o) == 'before') {
            this._addRange(new uf(n, o), true)
          } else {
            this._addRange(new uf(o, n))
          }
          this.fire('change')
        }
        _setRanges(t, e = false) {
          t = Array.from(t)
          this._ranges = []
          for (const e of t) {
            this._addRange(e)
          }
          this._lastRangeBackward = !!e
        }
        _setFakeOptions(t = {}) {
          this._isFake = !!t.fake
          this._fakeSelectionLabel = t.fake ? t.label || '' : ''
        }
        _addRange(t, e = false) {
          if (!(t instanceof uf)) {
            throw new P('view-selection-add-range-not-range', this)
          }
          this._pushRange(t)
          this._lastRangeBackward = !!e
        }
        _pushRange(t) {
          for (const e of this._ranges) {
            if (t.isIntersecting(e)) {
              throw new P('view-selection-range-intersects', this, { addedRange: t, intersectingRange: e })
            }
          }
          this._ranges.push(new uf(t.start, t.end))
        }
      }
      gf.prototype.is = function (t) {
        return t === 'selection' || t === 'view:selection'
      }
      class ff extends K(Ku) {
        constructor(...t) {
          super()
          this._selection = new gf()
          this._selection.delegate('change').to(this)
          if (t.length) {
            this._selection.setTo(...t)
          }
        }
        get isFake() {
          return this._selection.isFake
        }
        get fakeSelectionLabel() {
          return this._selection.fakeSelectionLabel
        }
        get anchor() {
          return this._selection.anchor
        }
        get focus() {
          return this._selection.focus
        }
        get isCollapsed() {
          return this._selection.isCollapsed
        }
        get rangeCount() {
          return this._selection.rangeCount
        }
        get isBackward() {
          return this._selection.isBackward
        }
        get editableElement() {
          return this._selection.editableElement
        }
        get _ranges() {
          return this._selection._ranges
        }
        *getRanges() {
          yield* this._selection.getRanges()
        }
        getFirstRange() {
          return this._selection.getFirstRange()
        }
        getLastRange() {
          return this._selection.getLastRange()
        }
        getFirstPosition() {
          return this._selection.getFirstPosition()
        }
        getLastPosition() {
          return this._selection.getLastPosition()
        }
        getSelectedElement() {
          return this._selection.getSelectedElement()
        }
        isEqual(t) {
          return this._selection.isEqual(t)
        }
        isSimilar(t) {
          return this._selection.isSimilar(t)
        }
        _setTo(...t) {
          this._selection.setTo(...t)
        }
        _setFocus(t, e) {
          this._selection.setFocus(t, e)
        }
      }
      ff.prototype.is = function (t) {
        return t === 'selection' || t == 'documentSelection' || t == 'view:selection' || t == 'view:documentSelection'
      }
      class mf extends D {
        constructor(t, e, n) {
          super(t, e)
          this.startRange = n
          this._eventPhase = 'none'
          this._currentTarget = null
        }
        get eventPhase() {
          return this._eventPhase
        }
        get currentTarget() {
          return this._currentTarget
        }
      }
      const pf = Symbol('bubbling contexts')
      function bf(t) {
        class e extends t {
          fire(t, ...e) {
            try {
              const n = t instanceof D ? t : new D(this, t)
              const o = _f(this)
              if (!o.size) {
                return
              }
              kf(n, 'capturing', this)
              if (wf(o, '$capture', n, ...e)) {
                return n.return
              }
              const i = n.startRange || this.selection.getFirstRange()
              const r = i ? i.getContainedElement() : null
              const s = r ? Boolean(Af(o, r)) : false
              let a = r || Cf(i)
              kf(n, 'atTarget', a)
              if (!s) {
                if (wf(o, '$text', n, ...e)) {
                  return n.return
                }
                kf(n, 'bubbling', a)
              }
              while (a) {
                if (a.is('rootElement')) {
                  if (wf(o, '$root', n, ...e)) {
                    return n.return
                  }
                } else if (a.is('element')) {
                  if (wf(o, a.name, n, ...e)) {
                    return n.return
                  }
                }
                if (wf(o, a, n, ...e)) {
                  return n.return
                }
                a = a.parent
                kf(n, 'bubbling', a)
              }
              kf(n, 'bubbling', this)
              wf(o, '$document', n, ...e)
              return n.return
            } catch (t) {
              P.rethrowUnexpectedError(t, this)
            }
          }
          _addEventListener(t, e, n) {
            const o = sl(n.context || '$document')
            const i = _f(this)
            for (const r of o) {
              let o = i.get(r)
              if (!o) {
                o = new (K())()
                i.set(r, o)
              }
              this.listenTo(o, t, e, n)
            }
          }
          _removeEventListener(t, e) {
            const n = _f(this)
            for (const o of n.values()) {
              this.stopListening(o, t, e)
            }
          }
        }
        return e
      }
      {
        const t = bf(Object)
        ;['fire', '_addEventListener', '_removeEventListener'].forEach((e) => {
          bf[e] = t.prototype[e]
        })
      }
      function kf(t, e, n) {
        if (t instanceof mf) {
          t._eventPhase = e
          t._currentTarget = n
        }
      }
      function wf(t, e, n, ...o) {
        const i = typeof e == 'string' ? t.get(e) : Af(t, e)
        if (!i) {
          return false
        }
        i.fire(n, ...o)
        return n.stop.called
      }
      function Af(t, e) {
        for (const [n, o] of t) {
          if (typeof n == 'function' && n(e)) {
            return o
          }
        }
        return null
      }
      function _f(t) {
        if (!t[pf]) {
          t[pf] = new Map()
        }
        return t[pf]
      }
      function Cf(t) {
        if (!t) {
          return null
        }
        const e = t.start.parent
        const n = t.end.parent
        const o = e.getPath()
        const i = n.getPath()
        return o.length > i.length ? e : n
      }
      class vf extends bf(ft()) {
        constructor(t) {
          super()
          this._postFixers = new Set()
          this.selection = new ff()
          this.roots = new pl({ idProperty: 'rootName' })
          this.stylesProcessor = t
          this.set('isReadOnly', false)
          this.set('isFocused', false)
          this.set('isSelecting', false)
          this.set('isComposing', false)
        }
        getRoot(t = 'main') {
          return this.roots.get(t)
        }
        registerPostFixer(t) {
          this._postFixers.add(t)
        }
        destroy() {
          this.roots.map((t) => t.destroy())
          this.stopListening()
        }
        _callPostFixers(t) {
          let e = false
          do {
            for (const n of this._postFixers) {
              e = n(t)
              if (e) {
                break
              }
            }
          } while (e)
        }
      }
      const yf = 10
      class xf extends Xg {
        constructor(t, e, n, o) {
          super(t, e, n, o)
          this._priority = yf
          this._id = null
          this._clonesGroup = null
          this.getFillerOffset = Ef
        }
        get priority() {
          return this._priority
        }
        get id() {
          return this._id
        }
        getElementsWithSameId() {
          if (this.id === null) {
            throw new P('attribute-element-get-elements-with-same-id-no-id', this)
          }
          return new Set(this._clonesGroup)
        }
        isSimilar(t) {
          if (this.id !== null || t.id !== null) {
            return this.id === t.id
          }
          return super.isSimilar(t) && this.priority == t.priority
        }
        _clone(t = false) {
          const e = super._clone(t)
          e._priority = this._priority
          e._id = this._id
          return e
        }
      }
      xf.DEFAULT_PRIORITY = yf
      xf.prototype.is = function (t, e) {
        if (!e) {
          return (
            t === 'attributeElement' ||
            t === 'view:attributeElement' ||
            t === 'element' ||
            t === 'view:element' ||
            t === 'node' ||
            t === 'view:node'
          )
        } else {
          return (
            e === this.name &&
            (t === 'attributeElement' || t === 'view:attributeElement' || t === 'element' || t === 'view:element')
          )
        }
      }
      function Ef() {
        if (Df(this)) {
          return null
        }
        let t = this.parent
        while (t && t.is('attributeElement')) {
          if (Df(t) > 1) {
            return null
          }
          t = t.parent
        }
        if (!t || Df(t) > 1) {
          return null
        }
        return this.childCount
      }
      function Df(t) {
        return Array.from(t.getChildren()).filter((t) => !t.is('uiElement')).length
      }
      class Tf extends Xg {
        constructor(t, e, n, o) {
          super(t, e, n, o)
          this.getFillerOffset = If
        }
        _insertChild(t, e) {
          if (e && (e instanceof Ju || Array.from(e).length > 0)) {
            throw new P('view-emptyelement-cannot-add', [this, e])
          }
          return 0
        }
      }
      Tf.prototype.is = function (t, e) {
        if (!e) {
          return (
            t === 'emptyElement' ||
            t === 'view:emptyElement' ||
            t === 'element' ||
            t === 'view:element' ||
            t === 'node' ||
            t === 'view:node'
          )
        } else {
          return (
            e === this.name &&
            (t === 'emptyElement' || t === 'view:emptyElement' || t === 'element' || t === 'view:element')
          )
        }
      }
      function If() {
        return null
      }
      class Sf extends Xg {
        constructor(t, e, n, o) {
          super(t, e, n, o)
          this.getFillerOffset = Bf
        }
        _insertChild(t, e) {
          if (e && (e instanceof Ju || Array.from(e).length > 0)) {
            throw new P('view-uielement-cannot-add', [this, e])
          }
          return 0
        }
        render(t, e) {
          return this.toDomElement(t)
        }
        toDomElement(t) {
          const e = t.createElement(this.name)
          for (const t of this.getAttributeKeys()) {
            e.setAttribute(t, this.getAttribute(t))
          }
          return e
        }
      }
      Sf.prototype.is = function (t, e) {
        if (!e) {
          return (
            t === 'uiElement' ||
            t === 'view:uiElement' ||
            t === 'element' ||
            t === 'view:element' ||
            t === 'node' ||
            t === 'view:node'
          )
        } else {
          return (
            e === this.name && (t === 'uiElement' || t === 'view:uiElement' || t === 'element' || t === 'view:element')
          )
        }
      }
      function Mf(t) {
        t.document.on('arrowKey', (e, n) => Nf(e, n, t.domConverter), { priority: 'low' })
      }
      function Bf() {
        return null
      }
      function Nf(t, e, n) {
        if (e.keyCode == Yc.arrowright) {
          const t = e.domTarget.ownerDocument.defaultView.getSelection()
          const o = t.rangeCount == 1 && t.getRangeAt(0).collapsed
          if (o || e.shiftKey) {
            const e = t.focusNode
            const i = t.focusOffset
            const r = n.domPositionToView(e, i)
            if (r === null) {
              return
            }
            let s = false
            const a = r.getLastMatchingPosition((t) => {
              if (t.item.is('uiElement')) {
                s = true
              }
              if (t.item.is('uiElement') || t.item.is('attributeElement')) {
                return true
              }
              return false
            })
            if (s) {
              const e = n.viewPositionToDom(a)
              if (o) {
                t.collapse(e.parent, e.offset)
              } else {
                t.extend(e.parent, e.offset)
              }
            }
          }
        }
      }
      class Pf extends Xg {
        constructor(t, e, n, o) {
          super(t, e, n, o)
          this.getFillerOffset = Lf
        }
        _insertChild(t, e) {
          if (e && (e instanceof Ju || Array.from(e).length > 0)) {
            throw new P('view-rawelement-cannot-add', [this, e])
          }
          return 0
        }
        render(t, e) {}
      }
      Pf.prototype.is = function (t, e) {
        if (!e) {
          return (
            t === 'rawElement' ||
            t === 'view:rawElement' ||
            t === this.name ||
            t === 'view:' + this.name ||
            t === 'element' ||
            t === 'view:element' ||
            t === 'node' ||
            t === 'view:node'
          )
        } else {
          return (
            e === this.name &&
            (t === 'rawElement' || t === 'view:rawElement' || t === 'element' || t === 'view:element')
          )
        }
      }
      function Lf() {
        return null
      }
      class zf extends K(Ku) {
        constructor(t, e) {
          super()
          this._children = []
          this._customProperties = new Map()
          this.document = t
          if (e) {
            this._insertChild(0, e)
          }
        }
        [Symbol.iterator]() {
          return this._children[Symbol.iterator]()
        }
        get childCount() {
          return this._children.length
        }
        get isEmpty() {
          return this.childCount === 0
        }
        get root() {
          return this
        }
        get parent() {
          return null
        }
        get name() {
          return undefined
        }
        getCustomProperty(t) {
          return this._customProperties.get(t)
        }
        *getCustomProperties() {
          yield* this._customProperties.entries()
        }
        _appendChild(t) {
          return this._insertChild(this.childCount, t)
        }
        getChild(t) {
          return this._children[t]
        }
        getChildIndex(t) {
          return this._children.indexOf(t)
        }
        getChildren() {
          return this._children[Symbol.iterator]()
        }
        _insertChild(t, e) {
          this._fireChange('children', this)
          let n = 0
          const o = Rf(this.document, e)
          for (const e of o) {
            if (e.parent !== null) {
              e._remove()
            }
            e.parent = this
            this._children.splice(t, 0, e)
            t++
            n++
          }
          return n
        }
        _removeChildren(t, e = 1) {
          this._fireChange('children', this)
          for (let n = t; n < t + e; n++) {
            this._children[n].parent = null
          }
          return this._children.splice(t, e)
        }
        _fireChange(t, e) {
          this.fire('change:' + t, e)
        }
        _setCustomProperty(t, e) {
          this._customProperties.set(t, e)
        }
        _removeCustomProperty(t) {
          return this._customProperties.delete(t)
        }
      }
      zf.prototype.is = function (t) {
        return t === 'documentFragment' || t === 'view:documentFragment'
      }
      function Rf(t, e) {
        if (typeof e == 'string') {
          return [new Xu(t, e)]
        }
        if (!Tt(e)) {
          e = [e]
        }
        return Array.from(e).map((e) => {
          if (typeof e == 'string') {
            return new Xu(t, e)
          }
          if (e instanceof th) {
            return new Xu(t, e.data)
          }
          return e
        })
      }
      class Of {
        constructor(t) {
          this._cloneGroups = new Map()
          this._slotFactory = null
          this.document = t
        }
        setSelection(...t) {
          this.document.selection._setTo(...t)
        }
        setSelectionFocus(t, e) {
          this.document.selection._setFocus(t, e)
        }
        createDocumentFragment(t) {
          return new zf(this.document, t)
        }
        createText(t) {
          return new Xu(this.document, t)
        }
        createAttributeElement(t, e, n = {}) {
          const o = new xf(this.document, t, e)
          if (typeof n.priority === 'number') {
            o._priority = n.priority
          }
          if (n.id) {
            o._id = n.id
          }
          if (n.renderUnsafeAttributes) {
            o._unsafeAttributesToRender.push(...n.renderUnsafeAttributes)
          }
          return o
        }
        createContainerElement(t, e, n = {}, o = {}) {
          let i = null
          if (pe(n)) {
            o = n
          } else {
            i = n
          }
          const r = new of(this.document, t, e, i)
          if (o.renderUnsafeAttributes) {
            r._unsafeAttributesToRender.push(...o.renderUnsafeAttributes)
          }
          return r
        }
        createEditableElement(t, e, n = {}) {
          const o = new sf(this.document, t, e)
          if (n.renderUnsafeAttributes) {
            o._unsafeAttributesToRender.push(...n.renderUnsafeAttributes)
          }
          return o
        }
        createEmptyElement(t, e, n = {}) {
          const o = new Tf(this.document, t, e)
          if (n.renderUnsafeAttributes) {
            o._unsafeAttributesToRender.push(...n.renderUnsafeAttributes)
          }
          return o
        }
        createUIElement(t, e, n) {
          const o = new Sf(this.document, t, e)
          if (n) {
            o.render = n
          }
          return o
        }
        createRawElement(t, e, n, o = {}) {
          const i = new Pf(this.document, t, e)
          if (n) {
            i.render = n
          }
          if (o.renderUnsafeAttributes) {
            i._unsafeAttributesToRender.push(...o.renderUnsafeAttributes)
          }
          return i
        }
        setAttribute(t, e, n) {
          n._setAttribute(t, e)
        }
        removeAttribute(t, e) {
          e._removeAttribute(t)
        }
        addClass(t, e) {
          e._addClass(t)
        }
        removeClass(t, e) {
          e._removeClass(t)
        }
        setStyle(t, e, n) {
          if (pe(t) && n === undefined) {
            e._setStyle(t)
          } else {
            n._setStyle(t, e)
          }
        }
        removeStyle(t, e) {
          e._removeStyle(t)
        }
        setCustomProperty(t, e, n) {
          n._setCustomProperty(t, e)
        }
        removeCustomProperty(t, e) {
          return e._removeCustomProperty(t)
        }
        breakAttributes(t) {
          if (t instanceof df) {
            return this._breakAttributes(t)
          } else {
            return this._breakAttributesRange(t)
          }
        }
        breakContainer(t) {
          const e = t.parent
          if (!e.is('containerElement')) {
            throw new P('view-writer-break-non-container-element', this.document)
          }
          if (!e.parent) {
            throw new P('view-writer-break-root', this.document)
          }
          if (t.isAtStart) {
            return df._createBefore(e)
          } else if (!t.isAtEnd) {
            const n = e._clone(false)
            this.insert(df._createAfter(e), n)
            const o = new uf(t, df._createAt(e, 'end'))
            const i = new df(n, 0)
            this.move(o, i)
          }
          return df._createAfter(e)
        }
        mergeAttributes(t) {
          const e = t.offset
          const n = t.parent
          if (n.is('$text')) {
            return t
          }
          if (n.is('attributeElement') && n.childCount === 0) {
            const t = n.parent
            const e = n.index
            n._remove()
            this._removeFromClonedElementsGroup(n)
            return this.mergeAttributes(new df(t, e))
          }
          const o = n.getChild(e - 1)
          const i = n.getChild(e)
          if (!o || !i) {
            return t
          }
          if (o.is('$text') && i.is('$text')) {
            return Wf(o, i)
          } else if (o.is('attributeElement') && i.is('attributeElement') && o.isSimilar(i)) {
            const t = o.childCount
            o._appendChild(i.getChildren())
            i._remove()
            this._removeFromClonedElementsGroup(i)
            return this.mergeAttributes(new df(o, t))
          }
          return t
        }
        mergeContainers(t) {
          const e = t.nodeBefore
          const n = t.nodeAfter
          if (!e || !n || !e.is('containerElement') || !n.is('containerElement')) {
            throw new P('view-writer-merge-containers-invalid-position', this.document)
          }
          const o = e.getChild(e.childCount - 1)
          const i = o instanceof Xu ? df._createAt(o, 'end') : df._createAt(e, 'end')
          this.move(uf._createIn(n), df._createAt(e, 'end'))
          this.remove(uf._createOn(n))
          return i
        }
        insert(t, e) {
          e = Tt(e) ? [...e] : [e]
          qf(e, this.document)
          const n = e.reduce((t, e) => {
            const n = t[t.length - 1]
            const o = !e.is('uiElement')
            if (!n || n.breakAttributes != o) {
              t.push({ breakAttributes: o, nodes: [e] })
            } else {
              n.nodes.push(e)
            }
            return t
          }, [])
          let o = null
          let i = t
          for (const { nodes: t, breakAttributes: e } of n) {
            const n = this._insertNodes(i, t, e)
            if (!o) {
              o = n.start
            }
            i = n.end
          }
          if (!o) {
            return new uf(t)
          }
          return new uf(o, i)
        }
        remove(t) {
          const e = t instanceof uf ? t : uf._createOn(t)
          Kf(e, this.document)
          if (e.isCollapsed) {
            return new zf(this.document)
          }
          const { start: n, end: o } = this._breakAttributesRange(e, true)
          const i = n.parent
          const r = o.offset - n.offset
          const s = i._removeChildren(n.offset, r)
          for (const t of s) {
            this._removeFromClonedElementsGroup(t)
          }
          const a = this.mergeAttributes(n)
          e.start = a
          e.end = a.clone()
          return new zf(this.document, s)
        }
        clear(t, e) {
          Kf(t, this.document)
          const n = t.getWalker({ direction: 'backward', ignoreElementEnd: true })
          for (const o of n) {
            const n = o.item
            let i
            if (n.is('element') && e.isSimilar(n)) {
              i = uf._createOn(n)
            } else if (!o.nextPosition.isAfter(t.start) && n.is('$textProxy')) {
              const t = n.getAncestors().find((t) => t.is('element') && e.isSimilar(t))
              if (t) {
                i = uf._createIn(t)
              }
            }
            if (i) {
              if (i.end.isAfter(t.end)) {
                i.end = t.end
              }
              if (i.start.isBefore(t.start)) {
                i.start = t.start
              }
              this.remove(i)
            }
          }
        }
        move(t, e) {
          let n
          if (e.isAfter(t.end)) {
            e = this._breakAttributes(e, true)
            const o = e.parent
            const i = o.childCount
            t = this._breakAttributesRange(t, true)
            n = this.remove(t)
            e.offset += o.childCount - i
          } else {
            n = this.remove(t)
          }
          return this.insert(e, n)
        }
        wrap(t, e) {
          if (!(e instanceof xf)) {
            throw new P('view-writer-wrap-invalid-attribute', this.document)
          }
          Kf(t, this.document)
          if (!t.isCollapsed) {
            return this._wrapRange(t, e)
          } else {
            let n = t.start
            if (n.parent.is('element') && !Vf(n.parent)) {
              n = n.getLastMatchingPosition((t) => t.item.is('uiElement'))
            }
            n = this._wrapPosition(n, e)
            const o = this.document.selection
            if (o.isCollapsed && o.getFirstPosition().isEqual(t.start)) {
              this.setSelection(n)
            }
            return new uf(n)
          }
        }
        unwrap(t, e) {
          if (!(e instanceof xf)) {
            throw new P('view-writer-unwrap-invalid-attribute', this.document)
          }
          Kf(t, this.document)
          if (t.isCollapsed) {
            return t
          }
          const { start: n, end: o } = this._breakAttributesRange(t, true)
          const i = n.parent
          const r = this._unwrapChildren(i, n.offset, o.offset, e)
          const s = this.mergeAttributes(r.start)
          if (!s.isEqual(r.start)) {
            r.end.offset--
          }
          const a = this.mergeAttributes(r.end)
          return new uf(s, a)
        }
        rename(t, e) {
          const n = new of(this.document, t, e.getAttributes())
          this.insert(df._createAfter(e), n)
          this.move(uf._createIn(e), df._createAt(n, 0))
          this.remove(uf._createOn(e))
          return n
        }
        clearClonedElementsGroup(t) {
          this._cloneGroups.delete(t)
        }
        createPositionAt(t, e) {
          return df._createAt(t, e)
        }
        createPositionAfter(t) {
          return df._createAfter(t)
        }
        createPositionBefore(t) {
          return df._createBefore(t)
        }
        createRange(t, e) {
          return new uf(t, e)
        }
        createRangeOn(t) {
          return uf._createOn(t)
        }
        createRangeIn(t) {
          return uf._createIn(t)
        }
        createSelection(...t) {
          return new gf(...t)
        }
        createSlot(t = 'children') {
          if (!this._slotFactory) {
            throw new P('view-writer-invalid-create-slot-context', this.document)
          }
          return this._slotFactory(this, t)
        }
        _registerSlotFactory(t) {
          this._slotFactory = t
        }
        _clearSlotFactory() {
          this._slotFactory = null
        }
        _insertNodes(t, e, n) {
          let o
          if (n) {
            o = Ff(t)
          } else {
            o = t.parent.is('$text') ? t.parent.parent : t.parent
          }
          if (!o) {
            throw new P('view-writer-invalid-position-container', this.document)
          }
          let i
          if (n) {
            i = this._breakAttributes(t, true)
          } else {
            i = t.parent.is('$text') ? Uf(t) : t
          }
          const r = o._insertChild(i.offset, e)
          for (const t of e) {
            this._addToClonedElementsGroup(t)
          }
          const s = i.getShiftedBy(r)
          const a = this.mergeAttributes(i)
          if (!a.isEqual(i)) {
            s.offset--
          }
          const c = this.mergeAttributes(s)
          return new uf(a, c)
        }
        _wrapChildren(t, e, n, o) {
          let i = e
          const r = []
          while (i < n) {
            const e = t.getChild(i)
            const n = e.is('$text')
            const s = e.is('attributeElement')
            if (s && this._wrapAttributeElement(o, e)) {
              r.push(new df(t, i))
            } else if (n || !s || jf(o, e)) {
              const n = o._clone()
              e._remove()
              n._appendChild(e)
              t._insertChild(i, n)
              this._addToClonedElementsGroup(n)
              r.push(new df(t, i))
            } else {
              this._wrapChildren(e, 0, e.childCount, o)
            }
            i++
          }
          let s = 0
          for (const t of r) {
            t.offset -= s
            if (t.offset == e) {
              continue
            }
            const o = this.mergeAttributes(t)
            if (!o.isEqual(t)) {
              s++
              n--
            }
          }
          return uf._createFromParentsAndOffsets(t, e, t, n)
        }
        _unwrapChildren(t, e, n, o) {
          let i = e
          const r = []
          while (i < n) {
            const e = t.getChild(i)
            if (!e.is('attributeElement')) {
              i++
              continue
            }
            if (e.isSimilar(o)) {
              const o = e.getChildren()
              const s = e.childCount
              e._remove()
              t._insertChild(i, o)
              this._removeFromClonedElementsGroup(e)
              r.push(new df(t, i), new df(t, i + s))
              i += s
              n += s - 1
              continue
            }
            if (this._unwrapAttributeElement(o, e)) {
              r.push(new df(t, i), new df(t, i + 1))
              i++
              continue
            }
            this._unwrapChildren(e, 0, e.childCount, o)
            i++
          }
          let s = 0
          for (const t of r) {
            t.offset -= s
            if (t.offset == e || t.offset == n) {
              continue
            }
            const o = this.mergeAttributes(t)
            if (!o.isEqual(t)) {
              s++
              n--
            }
          }
          return uf._createFromParentsAndOffsets(t, e, t, n)
        }
        _wrapRange(t, e) {
          const { start: n, end: o } = this._breakAttributesRange(t, true)
          const i = n.parent
          const r = this._wrapChildren(i, n.offset, o.offset, e)
          const s = this.mergeAttributes(r.start)
          if (!s.isEqual(r.start)) {
            r.end.offset--
          }
          const a = this.mergeAttributes(r.end)
          return new uf(s, a)
        }
        _wrapPosition(t, e) {
          if (e.isSimilar(t.parent)) {
            return Hf(t.clone())
          }
          if (t.parent.is('$text')) {
            t = Uf(t)
          }
          const n = this.createAttributeElement('_wrapPosition-fake-element')
          n._priority = Number.POSITIVE_INFINITY
          n.isSimilar = () => false
          t.parent._insertChild(t.offset, n)
          const o = new uf(t, t.getShiftedBy(1))
          this.wrap(o, e)
          const i = new df(n.parent, n.index)
          n._remove()
          const r = i.nodeBefore
          const s = i.nodeAfter
          if (r instanceof Xu && s instanceof Xu) {
            return Wf(r, s)
          }
          return Hf(i)
        }
        _wrapAttributeElement(t, e) {
          if (!Yf(t, e)) {
            return false
          }
          if (t.name !== e.name || t.priority !== e.priority) {
            return false
          }
          for (const n of t.getAttributeKeys()) {
            if (n === 'class' || n === 'style') {
              continue
            }
            if (e.hasAttribute(n) && e.getAttribute(n) !== t.getAttribute(n)) {
              return false
            }
          }
          for (const n of t.getStyleNames()) {
            if (e.hasStyle(n) && e.getStyle(n) !== t.getStyle(n)) {
              return false
            }
          }
          for (const n of t.getAttributeKeys()) {
            if (n === 'class' || n === 'style') {
              continue
            }
            if (!e.hasAttribute(n)) {
              this.setAttribute(n, t.getAttribute(n), e)
            }
          }
          for (const n of t.getStyleNames()) {
            if (!e.hasStyle(n)) {
              this.setStyle(n, t.getStyle(n), e)
            }
          }
          for (const n of t.getClassNames()) {
            if (!e.hasClass(n)) {
              this.addClass(n, e)
            }
          }
          return true
        }
        _unwrapAttributeElement(t, e) {
          if (!Yf(t, e)) {
            return false
          }
          if (t.name !== e.name || t.priority !== e.priority) {
            return false
          }
          for (const n of t.getAttributeKeys()) {
            if (n === 'class' || n === 'style') {
              continue
            }
            if (!e.hasAttribute(n) || e.getAttribute(n) !== t.getAttribute(n)) {
              return false
            }
          }
          if (!e.hasClass(...t.getClassNames())) {
            return false
          }
          for (const n of t.getStyleNames()) {
            if (!e.hasStyle(n) || e.getStyle(n) !== t.getStyle(n)) {
              return false
            }
          }
          for (const n of t.getAttributeKeys()) {
            if (n === 'class' || n === 'style') {
              continue
            }
            this.removeAttribute(n, e)
          }
          this.removeClass(Array.from(t.getClassNames()), e)
          this.removeStyle(Array.from(t.getStyleNames()), e)
          return true
        }
        _breakAttributesRange(t, e = false) {
          const n = t.start
          const o = t.end
          Kf(t, this.document)
          if (t.isCollapsed) {
            const n = this._breakAttributes(t.start, e)
            return new uf(n, n)
          }
          const i = this._breakAttributes(o, e)
          const r = i.parent.childCount
          const s = this._breakAttributes(n, e)
          i.offset += i.parent.childCount - r
          return new uf(s, i)
        }
        _breakAttributes(t, e = false) {
          const n = t.offset
          const o = t.parent
          if (t.parent.is('emptyElement')) {
            throw new P('view-writer-cannot-break-empty-element', this.document)
          }
          if (t.parent.is('uiElement')) {
            throw new P('view-writer-cannot-break-ui-element', this.document)
          }
          if (t.parent.is('rawElement')) {
            throw new P('view-writer-cannot-break-raw-element', this.document)
          }
          if (!e && o.is('$text') && $f(o.parent)) {
            return t.clone()
          }
          if ($f(o)) {
            return t.clone()
          }
          if (o.is('$text')) {
            return this._breakAttributes(Uf(t), e)
          }
          const i = o.childCount
          if (n == i) {
            const t = new df(o.parent, o.index + 1)
            return this._breakAttributes(t, e)
          } else {
            if (n === 0) {
              const t = new df(o.parent, o.index)
              return this._breakAttributes(t, e)
            } else {
              const t = o.index + 1
              const i = o._clone()
              o.parent._insertChild(t, i)
              this._addToClonedElementsGroup(i)
              const r = o.childCount - n
              const s = o._removeChildren(n, r)
              i._appendChild(s)
              const a = new df(o.parent, t)
              return this._breakAttributes(a, e)
            }
          }
        }
        _addToClonedElementsGroup(t) {
          if (!t.root.is('rootElement')) {
            return
          }
          if (t.is('element')) {
            for (const e of t.getChildren()) {
              this._addToClonedElementsGroup(e)
            }
          }
          const e = t.id
          if (!e) {
            return
          }
          let n = this._cloneGroups.get(e)
          if (!n) {
            n = new Set()
            this._cloneGroups.set(e, n)
          }
          n.add(t)
          t._clonesGroup = n
        }
        _removeFromClonedElementsGroup(t) {
          if (t.is('element')) {
            for (const e of t.getChildren()) {
              this._removeFromClonedElementsGroup(e)
            }
          }
          const e = t.id
          if (!e) {
            return
          }
          const n = this._cloneGroups.get(e)
          if (!n) {
            return
          }
          n.delete(t)
        }
      }
      function Vf(t) {
        return Array.from(t.getChildren()).some((t) => !t.is('uiElement'))
      }
      function Ff(t) {
        let e = t.parent
        while (!$f(e)) {
          if (!e) {
            return undefined
          }
          e = e.parent
        }
        return e
      }
      function jf(t, e) {
        if (t.priority < e.priority) {
          return true
        } else if (t.priority > e.priority) {
          return false
        }
        return t.getIdentity() < e.getIdentity()
      }
      function Hf(t) {
        const e = t.nodeBefore
        if (e && e.is('$text')) {
          return new df(e, e.data.length)
        }
        const n = t.nodeAfter
        if (n && n.is('$text')) {
          return new df(n, 0)
        }
        return t
      }
      function Uf(t) {
        if (t.offset == t.parent.data.length) {
          return new df(t.parent.parent, t.parent.index + 1)
        }
        if (t.offset === 0) {
          return new df(t.parent.parent, t.parent.index)
        }
        const e = t.parent.data.slice(t.offset)
        t.parent._data = t.parent.data.slice(0, t.offset)
        t.parent.parent._insertChild(t.parent.index + 1, new Xu(t.root.document, e))
        return new df(t.parent.parent, t.parent.index + 1)
      }
      function Wf(t, e) {
        const n = t.data.length
        t._data += e.data
        e._remove()
        return new df(t, n)
      }
      const Gf = [Xu, xf, of, Tf, Pf, Sf]
      function qf(t, e) {
        for (const n of t) {
          if (!Gf.some((t) => n instanceof t)) {
            throw new P('view-writer-insert-invalid-node-type', e)
          }
          if (!n.is('$text')) {
            qf(n.getChildren(), e)
          }
        }
      }
      function $f(t) {
        return t && (t.is('containerElement') || t.is('documentFragment'))
      }
      function Kf(t, e) {
        const n = Ff(t.start)
        const o = Ff(t.end)
        if (!n || !o || n !== o) {
          throw new P('view-writer-invalid-range-container', e)
        }
      }
      function Yf(t, e) {
        return t.id === null && e.id === null
      }
      const Zf = (t) => t.createTextNode(' ')
      const Qf = (t) => {
        const e = t.createElement('span')
        e.dataset.ckeFiller = 'true'
        e.innerText = ' '
        return e
      }
      const Jf = (t) => {
        const e = t.createElement('br')
        e.dataset.ckeFiller = 'true'
        return e
      }
      const Xf = 7
      const tm = '⁠'.repeat(Xf)
      function em(t) {
        if (typeof t == 'string') {
          return t.substr(0, Xf) === tm
        }
        return cc(t) && t.data.substr(0, Xf) === tm
      }
      function nm(t) {
        return t.data.length == Xf && em(t)
      }
      function om(t) {
        const e = typeof t == 'string' ? t : t.data
        if (em(t)) {
          return e.slice(Xf)
        }
        return e
      }
      function im(t) {
        t.document.on('arrowKey', rm, { priority: 'low' })
      }
      function rm(t, e) {
        if (e.keyCode == Yc.arrowleft) {
          const t = e.domTarget.ownerDocument.defaultView.getSelection()
          if (t.rangeCount == 1 && t.getRangeAt(0).collapsed) {
            const e = t.getRangeAt(0).startContainer
            const n = t.getRangeAt(0).startOffset
            if (em(e) && n <= Xf) {
              t.collapse(e, 0)
            }
          }
        }
      }
      var sm = n(5037)
      var am = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      am.insert = 'head'
      am.singleton = true
      var cm = Rl()(sm.Z, am)
      const lm = sm.Z.locals || {}
      class dm extends ft() {
        constructor(t, e) {
          super()
          this.domDocuments = new Set()
          this.markedAttributes = new Set()
          this.markedChildren = new Set()
          this.markedTexts = new Set()
          this._inlineFiller = null
          this._fakeSelectionContainer = null
          this.domConverter = t
          this.selection = e
          this.set('isFocused', false)
          this.set('isSelecting', false)
          if (l.isBlink && !l.isAndroid) {
            this.on('change:isSelecting', () => {
              if (!this.isSelecting) {
                this.render()
              }
            })
          }
          this.set('isComposing', false)
          this.on('change:isComposing', () => {
            if (!this.isComposing) {
              this.render()
            }
          })
        }
        markToSync(t, e) {
          if (t === 'text') {
            if (this.domConverter.mapViewToDom(e.parent)) {
              this.markedTexts.add(e)
            }
          } else {
            if (!this.domConverter.mapViewToDom(e)) {
              return
            }
            if (t === 'attributes') {
              this.markedAttributes.add(e)
            } else if (t === 'children') {
              this.markedChildren.add(e)
            } else {
              const e = t
              throw new P('view-renderer-unknown-type', this)
            }
          }
        }
        render() {
          if (this.isComposing && !l.isAndroid) {
            return
          }
          let t = null
          const e = l.isBlink && !l.isAndroid ? !this.isSelecting : true
          for (const t of this.markedChildren) {
            this._updateChildrenMappings(t)
          }
          if (e) {
            if (this._inlineFiller && !this._isSelectionInInlineFiller()) {
              this._removeInlineFiller()
            }
            if (this._inlineFiller) {
              t = this._getInlineFillerPosition()
            } else if (this._needsInlineFillerAtSelection()) {
              t = this.selection.getFirstPosition()
              this.markedChildren.add(t.parent)
            }
          } else if (this._inlineFiller && this._inlineFiller.parentNode) {
            t = this.domConverter.domPositionToView(this._inlineFiller)
            if (t && t.parent.is('$text')) {
              t = df._createBefore(t.parent)
            }
          }
          for (const t of this.markedAttributes) {
            this._updateAttrs(t)
          }
          for (const e of this.markedChildren) {
            this._updateChildren(e, { inlineFillerPosition: t })
          }
          for (const e of this.markedTexts) {
            if (!this.markedChildren.has(e.parent) && this.domConverter.mapViewToDom(e.parent)) {
              this._updateText(e, { inlineFillerPosition: t })
            }
          }
          if (e) {
            if (t) {
              const e = this.domConverter.viewPositionToDom(t)
              const n = e.parent.ownerDocument
              if (!em(e.parent)) {
                this._inlineFiller = hm(n, e.parent, e.offset)
              } else {
                this._inlineFiller = e.parent
              }
            } else {
              this._inlineFiller = null
            }
          }
          this._updateFocus()
          this._updateSelection()
          this.markedTexts.clear()
          this.markedAttributes.clear()
          this.markedChildren.clear()
        }
        _updateChildrenMappings(t) {
          const e = this.domConverter.mapViewToDom(t)
          if (!e) {
            return
          }
          const n = Array.from(this.domConverter.mapViewToDom(t).childNodes)
          const o = Array.from(this.domConverter.viewChildrenToDom(t, { withChildren: false }))
          const i = this._diffNodeLists(n, o)
          const r = this._findUpdateActions(i, n, o, gm)
          if (r.indexOf('update') !== -1) {
            const e = { equal: 0, insert: 0, delete: 0 }
            for (const i of r) {
              if (i === 'update') {
                const i = e.equal + e.insert
                const r = e.equal + e.delete
                const s = t.getChild(i)
                if (s && !(s.is('uiElement') || s.is('rawElement'))) {
                  this._updateElementMappings(s, n[r])
                }
                Pc(o[i])
                e.equal++
              } else {
                e[i]++
              }
            }
          }
        }
        _updateElementMappings(t, e) {
          this.domConverter.unbindDomElement(e)
          this.domConverter.bindElements(e, t)
          this.markedChildren.add(t)
          this.markedAttributes.add(t)
        }
        _getInlineFillerPosition() {
          const t = this.selection.getFirstPosition()
          if (t.parent.is('$text')) {
            return df._createBefore(t.parent)
          } else {
            return t
          }
        }
        _isSelectionInInlineFiller() {
          if (this.selection.rangeCount != 1 || !this.selection.isCollapsed) {
            return false
          }
          const t = this.selection.getFirstPosition()
          const e = this.domConverter.viewPositionToDom(t)
          if (e && cc(e.parent) && em(e.parent)) {
            return true
          }
          return false
        }
        _removeInlineFiller() {
          const t = this._inlineFiller
          if (!em(t)) {
            throw new P('view-renderer-filler-was-lost', this)
          }
          if (nm(t)) {
            t.remove()
          } else {
            t.data = t.data.substr(Xf)
          }
          this._inlineFiller = null
        }
        _needsInlineFillerAtSelection() {
          if (this.selection.rangeCount != 1 || !this.selection.isCollapsed) {
            return false
          }
          const t = this.selection.getFirstPosition()
          const e = t.parent
          const n = t.offset
          if (!this.domConverter.mapViewToDom(e.root)) {
            return false
          }
          if (!e.is('element')) {
            return false
          }
          if (!um(e)) {
            return false
          }
          if (n === e.getFillerOffset()) {
            return false
          }
          const o = t.nodeBefore
          const i = t.nodeAfter
          if (o instanceof Xu || i instanceof Xu) {
            return false
          }
          if (l.isAndroid && (o || i)) {
            return false
          }
          return true
        }
        _updateText(t, e) {
          const n = this.domConverter.findCorrespondingDomText(t)
          const o = this.domConverter.viewToDom(t)
          let i = o.data
          const r = e.inlineFillerPosition
          if (r && r.parent == t.parent && r.offset == t.index) {
            i = tm + i
          }
          wm(n, i)
        }
        _updateAttrs(t) {
          const e = this.domConverter.mapViewToDom(t)
          if (!e) {
            return
          }
          const n = Array.from(e.attributes).map((t) => t.name)
          const o = t.getAttributeKeys()
          for (const n of o) {
            this.domConverter.setDomElementAttribute(e, n, t.getAttribute(n), t)
          }
          for (const o of n) {
            if (!t.hasAttribute(o)) {
              this.domConverter.removeDomElementAttribute(e, o)
            }
          }
        }
        _updateChildren(t, e) {
          const n = this.domConverter.mapViewToDom(t)
          if (!n) {
            return
          }
          if (l.isAndroid) {
            let t = null
            for (const e of Array.from(n.childNodes)) {
              if (t && cc(t) && cc(e)) {
                n.normalize()
                break
              }
              t = e
            }
          }
          const o = e.inlineFillerPosition
          const i = n.childNodes
          const r = Array.from(this.domConverter.viewChildrenToDom(t, { bind: true }))
          if (o && o.parent === t) {
            hm(n.ownerDocument, r, o.offset)
          }
          const s = this._diffNodeLists(i, r)
          const a = this._findUpdateActions(s, i, r, fm)
          let c = 0
          const d = new Set()
          for (const t of a) {
            if (t === 'delete') {
              d.add(i[c])
              Pc(i[c])
            } else if (t === 'equal' || t === 'update') {
              c++
            }
          }
          c = 0
          for (const t of a) {
            if (t === 'insert') {
              vc(n, c, r[c])
              c++
            } else if (t === 'update') {
              wm(i[c], r[c].data)
              c++
            } else if (t === 'equal') {
              this._markDescendantTextToSync(this.domConverter.domToView(r[c]))
              c++
            }
          }
          for (const t of d) {
            if (!t.parentNode) {
              this.domConverter.unbindDomElement(t)
            }
          }
        }
        _diffNodeLists(t, e) {
          t = bm(t, this._fakeSelectionContainer)
          return y(t, e, mm.bind(null, this.domConverter))
        }
        _findUpdateActions(t, e, n, o) {
          if (t.indexOf('insert') === -1 || t.indexOf('delete') === -1) {
            return t
          }
          let i = []
          let r = []
          let s = []
          const a = { equal: 0, insert: 0, delete: 0 }
          for (const c of t) {
            if (c === 'insert') {
              s.push(n[a.equal + a.insert])
            } else if (c === 'delete') {
              r.push(e[a.equal + a.delete])
            } else {
              i = i.concat(y(r, s, o).map((t) => (t === 'equal' ? 'update' : t)))
              i.push('equal')
              r = []
              s = []
            }
            a[c]++
          }
          return i.concat(y(r, s, o).map((t) => (t === 'equal' ? 'update' : t)))
        }
        _markDescendantTextToSync(t) {
          if (!t) {
            return
          }
          if (t.is('$text')) {
            this.markedTexts.add(t)
          } else if (t.is('element')) {
            for (const e of t.getChildren()) {
              this._markDescendantTextToSync(e)
            }
          }
        }
        _updateSelection() {
          if (l.isBlink && !l.isAndroid && this.isSelecting && !this.markedChildren.size) {
            return
          }
          if (this.selection.rangeCount === 0) {
            this._removeDomSelection()
            this._removeFakeSelection()
            return
          }
          const t = this.domConverter.mapViewToDom(this.selection.editableElement)
          if (!this.isFocused || !t) {
            return
          }
          if (this.selection.isFake) {
            this._updateFakeSelection(t)
          } else if (this._fakeSelectionContainer && this._fakeSelectionContainer.isConnected) {
            this._removeFakeSelection()
            this._updateDomSelection(t)
          } else if (!(this.isComposing && l.isAndroid)) {
            this._updateDomSelection(t)
          }
        }
        _updateFakeSelection(t) {
          const e = t.ownerDocument
          if (!this._fakeSelectionContainer) {
            this._fakeSelectionContainer = km(e)
          }
          const n = this._fakeSelectionContainer
          this.domConverter.bindFakeSelection(n, this.selection)
          if (!this._fakeSelectionNeedsUpdate(t)) {
            return
          }
          if (!n.parentElement || n.parentElement != t) {
            t.appendChild(n)
          }
          n.textContent = this.selection.fakeSelectionLabel || ' '
          const o = e.getSelection()
          const i = e.createRange()
          o.removeAllRanges()
          i.selectNodeContents(n)
          o.addRange(i)
        }
        _updateDomSelection(t) {
          const e = t.ownerDocument.defaultView.getSelection()
          if (!this._domSelectionNeedsUpdate(e)) {
            return
          }
          const n = this.domConverter.viewPositionToDom(this.selection.anchor)
          const o = this.domConverter.viewPositionToDom(this.selection.focus)
          e.setBaseAndExtent(n.parent, n.offset, o.parent, o.offset)
          if (l.isGecko) {
            pm(o, e)
          }
        }
        _domSelectionNeedsUpdate(t) {
          if (!this.domConverter.isDomSelectionCorrect(t)) {
            return true
          }
          const e = t && this.domConverter.domSelectionToView(t)
          if (e && this.selection.isEqual(e)) {
            return false
          }
          if (!this.selection.isCollapsed && this.selection.isSimilar(e)) {
            return false
          }
          return true
        }
        _fakeSelectionNeedsUpdate(t) {
          const e = this._fakeSelectionContainer
          const n = t.ownerDocument.getSelection()
          if (!e || e.parentElement !== t) {
            return true
          }
          if (n.anchorNode !== e && !e.contains(n.anchorNode)) {
            return true
          }
          return e.textContent !== this.selection.fakeSelectionLabel
        }
        _removeDomSelection() {
          for (const t of this.domDocuments) {
            const e = t.getSelection()
            if (e.rangeCount) {
              const n = t.activeElement
              const o = this.domConverter.mapDomToView(n)
              if (n && o) {
                e.removeAllRanges()
              }
            }
          }
        }
        _removeFakeSelection() {
          const t = this._fakeSelectionContainer
          if (t) {
            t.remove()
          }
        }
        _updateFocus() {
          if (this.isFocused) {
            const t = this.selection.editableElement
            if (t) {
              this.domConverter.focus(t)
            }
          }
        }
      }
      function um(t) {
        if (t.getAttribute('contenteditable') == 'false') {
          return false
        }
        const e = t.findAncestor((t) => t.hasAttribute('contenteditable'))
        return !e || e.getAttribute('contenteditable') == 'true'
      }
      function hm(t, e, n) {
        const o = e instanceof Array ? e : e.childNodes
        const i = o[n]
        if (cc(i)) {
          i.data = tm + i.data
          return i
        } else {
          const i = t.createTextNode(tm)
          if (Array.isArray(e)) {
            o.splice(n, 0, i)
          } else {
            vc(e, n, i)
          }
          return i
        }
      }
      function gm(t, e) {
        return (
          Ya(t) && Ya(e) && !cc(t) && !cc(e) && !yc(t) && !yc(e) && t.tagName.toLowerCase() === e.tagName.toLowerCase()
        )
      }
      function fm(t, e) {
        return Ya(t) && Ya(e) && cc(t) && cc(e)
      }
      function mm(t, e, n) {
        if (e === n) {
          return true
        } else if (cc(e) && cc(n)) {
          return e.data === n.data
        } else if (t.isBlockFiller(e) && t.isBlockFiller(n)) {
          return true
        }
        return false
      }
      function pm(t, e) {
        const n = t.parent
        if (n.nodeType != Node.ELEMENT_NODE || t.offset != n.childNodes.length - 1) {
          return
        }
        const o = n.childNodes[t.offset]
        if (o && o.tagName == 'BR') {
          e.addRange(e.getRangeAt(0))
        }
      }
      function bm(t, e) {
        const n = Array.from(t)
        if (n.length == 0 || !e) {
          return n
        }
        const o = n[n.length - 1]
        if (o == e) {
          n.pop()
        }
        return n
      }
      function km(t) {
        const e = t.createElement('div')
        e.className = 'ck-fake-selection-container'
        Object.assign(e.style, { position: 'fixed', top: 0, left: '-9999px', width: '42px' })
        e.textContent = ' '
        return e
      }
      function wm(t, e) {
        const n = t.data
        if (n == e) {
          return
        }
        const o = k(n, e)
        for (const e of o) {
          if (e.type === 'insert') {
            t.insertData(e.index, e.values.join(''))
          } else {
            t.deleteData(e.index, e.howMany)
          }
        }
      }
      const Am = Jf(oc.document)
      const _m = Zf(oc.document)
      const Cm = Qf(oc.document)
      const vm = 'data-ck-unsafe-attribute-'
      const ym = 'data-ck-unsafe-element'
      class xm {
        constructor(t, { blockFillerMode: e, renderingMode: n = 'editing' } = {}) {
          this._domToViewMapping = new WeakMap()
          this._viewToDomMapping = new WeakMap()
          this._fakeSelectionMapping = new WeakMap()
          this._rawContentElementMatcher = new eh()
          this._inlineObjectElementMatcher = new eh()
          this.document = t
          this.renderingMode = n
          this.blockFillerMode = e || (n === 'editing' ? 'br' : 'nbsp')
          this.preElements = ['pre']
          this.blockElements = [
            'address',
            'article',
            'aside',
            'blockquote',
            'caption',
            'center',
            'dd',
            'details',
            'dir',
            'div',
            'dl',
            'dt',
            'fieldset',
            'figcaption',
            'figure',
            'footer',
            'form',
            'h1',
            'h2',
            'h3',
            'h4',
            'h5',
            'h6',
            'header',
            'hgroup',
            'legend',
            'li',
            'main',
            'menu',
            'nav',
            'ol',
            'p',
            'pre',
            'section',
            'summary',
            'table',
            'tbody',
            'td',
            'tfoot',
            'th',
            'thead',
            'tr',
            'ul',
          ]
          this.inlineObjectElements = [
            'object',
            'iframe',
            'input',
            'button',
            'textarea',
            'select',
            'option',
            'video',
            'embed',
            'audio',
            'img',
            'canvas',
          ]
          this.unsafeElements = ['script', 'style']
          this._domDocument =
            this.renderingMode === 'editing' ? oc.document : oc.document.implementation.createHTMLDocument('')
        }
        bindFakeSelection(t, e) {
          this._fakeSelectionMapping.set(t, new gf(e))
        }
        fakeSelectionToView(t) {
          return this._fakeSelectionMapping.get(t)
        }
        bindElements(t, e) {
          this._domToViewMapping.set(t, e)
          this._viewToDomMapping.set(e, t)
        }
        unbindDomElement(t) {
          const e = this._domToViewMapping.get(t)
          if (e) {
            this._domToViewMapping.delete(t)
            this._viewToDomMapping.delete(e)
            for (const e of Array.from(t.children)) {
              this.unbindDomElement(e)
            }
          }
        }
        bindDocumentFragments(t, e) {
          this._domToViewMapping.set(t, e)
          this._viewToDomMapping.set(e, t)
        }
        shouldRenderAttribute(t, e, n) {
          if (this.renderingMode === 'data') {
            return true
          }
          t = t.toLowerCase()
          if (t.startsWith('on')) {
            return false
          }
          if (t === 'srcdoc' && e.match(/\bon\S+\s*=|javascript:|<\s*\/*script/i)) {
            return false
          }
          if (n === 'img' && (t === 'src' || t === 'srcset')) {
            return true
          }
          if (n === 'source' && t === 'srcset') {
            return true
          }
          if (e.match(/^\s*(javascript:|data:(image\/svg|text\/x?html))/i)) {
            return false
          }
          return true
        }
        setContentOf(t, e) {
          if (this.renderingMode === 'data') {
            t.innerHTML = e
            return
          }
          const n = new DOMParser().parseFromString(e, 'text/html')
          const o = n.createDocumentFragment()
          const i = n.body.childNodes
          while (i.length > 0) {
            o.appendChild(i[0])
          }
          const r = n.createTreeWalker(o, NodeFilter.SHOW_ELEMENT)
          const s = []
          let a
          while ((a = r.nextNode())) {
            s.push(a)
          }
          for (const t of s) {
            for (const e of t.getAttributeNames()) {
              this.setDomElementAttribute(t, e, t.getAttribute(e))
            }
            const e = t.tagName.toLowerCase()
            if (this._shouldRenameElement(e)) {
              Sm(e)
              t.replaceWith(this._createReplacementDomElement(e, t))
            }
          }
          while (t.firstChild) {
            t.firstChild.remove()
          }
          t.append(o)
        }
        viewToDom(t, e = {}) {
          if (t.is('$text')) {
            const e = this._processDataFromViewText(t)
            return this._domDocument.createTextNode(e)
          } else {
            if (this.mapViewToDom(t)) {
              return this.mapViewToDom(t)
            }
            let n
            if (t.is('documentFragment')) {
              n = this._domDocument.createDocumentFragment()
              if (e.bind) {
                this.bindDocumentFragments(n, t)
              }
            } else if (t.is('uiElement')) {
              if (t.name === '$comment') {
                n = this._domDocument.createComment(t.getCustomProperty('$rawContent'))
              } else {
                n = t.render(this._domDocument, this)
              }
              if (e.bind) {
                this.bindElements(n, t)
              }
              return n
            } else {
              if (this._shouldRenameElement(t.name)) {
                Sm(t.name)
                n = this._createReplacementDomElement(t.name)
              } else if (t.hasAttribute('xmlns')) {
                n = this._domDocument.createElementNS(t.getAttribute('xmlns'), t.name)
              } else {
                n = this._domDocument.createElement(t.name)
              }
              if (t.is('rawElement')) {
                t.render(n, this)
              }
              if (e.bind) {
                this.bindElements(n, t)
              }
              for (const e of t.getAttributeKeys()) {
                this.setDomElementAttribute(n, e, t.getAttribute(e), t)
              }
            }
            if (e.withChildren !== false) {
              for (const o of this.viewChildrenToDom(t, e)) {
                n.appendChild(o)
              }
            }
            return n
          }
        }
        setDomElementAttribute(t, e, n, o) {
          const i = this.shouldRenderAttribute(e, n, t.tagName.toLowerCase()) || (o && o.shouldRenderUnsafeAttribute(e))
          if (!i) {
            L('domconverter-unsafe-attribute-detected', { domElement: t, key: e, value: n })
          }
          if (!xc(e)) {
            L('domconverter-invalid-attribute-detected', { domElement: t, key: e, value: n })
            return
          }
          if (t.hasAttribute(e) && !i) {
            t.removeAttribute(e)
          } else if (t.hasAttribute(vm + e) && i) {
            t.removeAttribute(vm + e)
          }
          t.setAttribute(i ? e : vm + e, n)
        }
        removeDomElementAttribute(t, e) {
          if (e == ym) {
            return
          }
          t.removeAttribute(e)
          t.removeAttribute(vm + e)
        }
        *viewChildrenToDom(t, e = {}) {
          const n = t.getFillerOffset && t.getFillerOffset()
          let o = 0
          for (const i of t.getChildren()) {
            if (n === o) {
              yield this._getBlockFiller()
            }
            const t =
              i.is('element') && !!i.getCustomProperty('dataPipeline:transparentRendering') && !bl(i.getAttributes())
            if (t && this.renderingMode == 'data') {
              yield* this.viewChildrenToDom(i, e)
            } else {
              if (t) {
                L('domconverter-transparent-rendering-unsupported-in-editing-pipeline', { viewElement: i })
              }
              yield this.viewToDom(i, e)
            }
            o++
          }
          if (n === o) {
            yield this._getBlockFiller()
          }
        }
        viewRangeToDom(t) {
          const e = this.viewPositionToDom(t.start)
          const n = this.viewPositionToDom(t.end)
          const o = this._domDocument.createRange()
          o.setStart(e.parent, e.offset)
          o.setEnd(n.parent, n.offset)
          return o
        }
        viewPositionToDom(t) {
          const e = t.parent
          if (e.is('$text')) {
            const n = this.findCorrespondingDomText(e)
            if (!n) {
              return null
            }
            let o = t.offset
            if (em(n)) {
              o += Xf
            }
            return { parent: n, offset: o }
          } else {
            let n, o, i
            if (t.offset === 0) {
              n = this.mapViewToDom(e)
              if (!n) {
                return null
              }
              i = n.childNodes[0]
            } else {
              const e = t.nodeBefore
              o = e.is('$text') ? this.findCorrespondingDomText(e) : this.mapViewToDom(e)
              if (!o) {
                return null
              }
              n = o.parentNode
              i = o.nextSibling
            }
            if (cc(i) && em(i)) {
              return { parent: i, offset: Xf }
            }
            const r = o ? Cc(o) + 1 : 0
            return { parent: n, offset: r }
          }
        }
        domToView(t, e = {}) {
          const n = []
          const o = this._domToView(t, e, n)
          const i = o.next().value
          if (!i) {
            return null
          }
          o.next()
          this._processDomInlineNodes(null, n, e)
          if (i.is('$text') && i.data.length == 0) {
            return null
          }
          return i
        }
        *domChildrenToView(t, e = {}, n = []) {
          for (let o = 0; o < t.childNodes.length; o++) {
            const i = t.childNodes[o]
            const r = this._domToView(i, e, n)
            const s = r.next().value
            if (s !== null) {
              if (this._isBlockViewElement(s)) {
                this._processDomInlineNodes(t, n, e)
              }
              yield s
              r.next()
            }
          }
          this._processDomInlineNodes(t, n, e)
        }
        domSelectionToView(t) {
          if (t.rangeCount === 1) {
            let e = t.getRangeAt(0).startContainer
            if (cc(e)) {
              e = e.parentNode
            }
            const n = this.fakeSelectionToView(e)
            if (n) {
              return n
            }
          }
          const e = this.isDomSelectionBackward(t)
          const n = []
          for (let e = 0; e < t.rangeCount; e++) {
            const o = t.getRangeAt(e)
            const i = this.domRangeToView(o)
            if (i) {
              n.push(i)
            }
          }
          return new gf(n, { backward: e })
        }
        domRangeToView(t) {
          const e = this.domPositionToView(t.startContainer, t.startOffset)
          const n = this.domPositionToView(t.endContainer, t.endOffset)
          if (e && n) {
            return new uf(e, n)
          }
          return null
        }
        domPositionToView(t, e = 0) {
          if (this.isBlockFiller(t)) {
            return this.domPositionToView(t.parentNode, Cc(t))
          }
          const n = this.mapDomToView(t)
          if (n && (n.is('uiElement') || n.is('rawElement'))) {
            return df._createBefore(n)
          }
          if (cc(t)) {
            if (nm(t)) {
              return this.domPositionToView(t.parentNode, Cc(t))
            }
            const n = this.findCorrespondingViewText(t)
            let o = e
            if (!n) {
              return null
            }
            if (em(t)) {
              o -= Xf
              o = o < 0 ? 0 : o
            }
            return new df(n, o)
          } else {
            if (e === 0) {
              const e = this.mapDomToView(t)
              if (e) {
                return new df(e, 0)
              }
            } else {
              const n = t.childNodes[e - 1]
              if ((cc(n) && nm(n)) || (n && this.isBlockFiller(n))) {
                return this.domPositionToView(n.parentNode, Cc(n))
              }
              const o = cc(n) ? this.findCorrespondingViewText(n) : this.mapDomToView(n)
              if (o && o.parent) {
                return new df(o.parent, o.index + 1)
              }
            }
            return null
          }
        }
        mapDomToView(t) {
          const e = this.getHostViewElement(t)
          return e || this._domToViewMapping.get(t)
        }
        findCorrespondingViewText(t) {
          if (nm(t)) {
            return null
          }
          const e = this.getHostViewElement(t)
          if (e) {
            return e
          }
          const n = t.previousSibling
          if (n) {
            if (!this.isElement(n)) {
              return null
            }
            const t = this.mapDomToView(n)
            if (t) {
              const e = t.nextSibling
              if (e instanceof Xu) {
                return e
              } else {
                return null
              }
            }
          } else {
            const e = this.mapDomToView(t.parentNode)
            if (e) {
              const t = e.getChild(0)
              if (t instanceof Xu) {
                return t
              } else {
                return null
              }
            }
          }
          return null
        }
        mapViewToDom(t) {
          return this._viewToDomMapping.get(t)
        }
        findCorrespondingDomText(t) {
          const e = t.previousSibling
          if (e && this.mapViewToDom(e)) {
            return this.mapViewToDom(e).nextSibling
          }
          if (!e && t.parent && this.mapViewToDom(t.parent)) {
            return this.mapViewToDom(t.parent).childNodes[0]
          }
          return null
        }
        focus(t) {
          const e = this.mapViewToDom(t)
          if (e && e.ownerDocument.activeElement !== e) {
            const { scrollX: t, scrollY: n } = oc.window
            const o = []
            Dm(e, (t) => {
              const { scrollLeft: e, scrollTop: n } = t
              o.push([e, n])
            })
            e.focus()
            Dm(e, (t) => {
              const [e, n] = o.shift()
              t.scrollLeft = e
              t.scrollTop = n
            })
            oc.window.scrollTo(t, n)
          }
        }
        _clearDomSelection() {
          const t = this.mapViewToDom(this.document.selection.editableElement)
          if (!t) {
            return
          }
          const e = t.ownerDocument.defaultView.getSelection()
          const n = this.domSelectionToView(e)
          const o = n && n.rangeCount > 0
          if (o) {
            e.removeAllRanges()
          }
        }
        isElement(t) {
          return t && t.nodeType == Node.ELEMENT_NODE
        }
        isDocumentFragment(t) {
          return t && t.nodeType == Node.DOCUMENT_FRAGMENT_NODE
        }
        isBlockFiller(t) {
          if (this.blockFillerMode == 'br') {
            return t.isEqualNode(Am)
          }
          if (t.tagName === 'BR' && Im(t, this.blockElements) && t.parentNode.childNodes.length === 1) {
            return true
          }
          return t.isEqualNode(Cm) || Tm(t, this.blockElements)
        }
        isDomSelectionBackward(t) {
          if (t.isCollapsed) {
            return false
          }
          const e = this._domDocument.createRange()
          try {
            e.setStart(t.anchorNode, t.anchorOffset)
            e.setEnd(t.focusNode, t.focusOffset)
          } catch (t) {
            return false
          }
          const n = e.collapsed
          e.detach()
          return n
        }
        getHostViewElement(t) {
          const e = rc(t)
          e.pop()
          while (e.length) {
            const t = e.pop()
            const n = this._domToViewMapping.get(t)
            if (n && (n.is('uiElement') || n.is('rawElement'))) {
              return n
            }
          }
          return null
        }
        isDomSelectionCorrect(t) {
          return (
            this._isDomSelectionPositionCorrect(t.anchorNode, t.anchorOffset) &&
            this._isDomSelectionPositionCorrect(t.focusNode, t.focusOffset)
          )
        }
        registerRawContentMatcher(t) {
          this._rawContentElementMatcher.add(t)
        }
        registerInlineObjectMatcher(t) {
          this._inlineObjectElementMatcher.add(t)
        }
        _getBlockFiller() {
          switch (this.blockFillerMode) {
            case 'nbsp':
              return Zf(this._domDocument)
            case 'markedNbsp':
              return Qf(this._domDocument)
            case 'br':
              return Jf(this._domDocument)
          }
        }
        _isDomSelectionPositionCorrect(t, e) {
          if (cc(t) && em(t) && e < Xf) {
            return false
          }
          if (this.isElement(t) && em(t.childNodes[e])) {
            return false
          }
          const n = this.mapDomToView(t)
          if (n && (n.is('uiElement') || n.is('rawElement'))) {
            return false
          }
          return true
        }
        *_domToView(t, e, n) {
          if (this.isBlockFiller(t)) {
            return null
          }
          const o = this.getHostViewElement(t)
          if (o) {
            return o
          }
          if (yc(t) && e.skipComments) {
            return null
          }
          if (cc(t)) {
            if (nm(t)) {
              return null
            } else {
              const e = t.data
              if (e === '') {
                return null
              }
              const o = new Xu(this.document, e)
              n.push(o)
              return o
            }
          } else {
            let o = this.mapDomToView(t)
            if (o) {
              if (this._isInlineObjectElement(o)) {
                n.push(o)
              }
              return o
            }
            if (this.isDocumentFragment(t)) {
              o = new zf(this.document)
              if (e.bind) {
                this.bindDocumentFragments(t, o)
              }
            } else {
              o = this._createViewElement(t, e)
              if (e.bind) {
                this.bindElements(t, o)
              }
              const i = t.attributes
              if (i) {
                for (let t = i.length, e = 0; e < t; e++) {
                  o._setAttribute(i[e].name, i[e].value)
                }
              }
              if (this._isViewElementWithRawContent(o, e)) {
                o._setCustomProperty('$rawContent', t.innerHTML)
                if (!this._isBlockViewElement(o)) {
                  n.push(o)
                }
                return o
              }
              if (yc(t)) {
                o._setCustomProperty('$rawContent', t.data)
                return o
              }
            }
            yield o
            const i = []
            if (e.withChildren !== false) {
              for (const n of this.domChildrenToView(t, e, i)) {
                o._appendChild(n)
              }
            }
            if (this._isInlineObjectElement(o)) {
              n.push(o)
            } else {
              for (const t of i) {
                n.push(t)
              }
            }
          }
        }
        _processDomInlineNodes(t, e, n) {
          if (!e.length) {
            return
          }
          if (t && !this.isDocumentFragment(t) && !this._isBlockDomElement(t)) {
            return
          }
          let o = false
          for (let t = 0; t < e.length; t++) {
            const i = e[t]
            if (!i.is('$text')) {
              o = false
              continue
            }
            let r
            let s = false
            if (Em(i, this.preElements)) {
              r = om(i.data)
            } else {
              r = i.data.replace(/[ \n\t\r]{1,}/g, ' ')
              s = /[^\S\u00A0]/.test(r.charAt(r.length - 1))
              const a = t > 0 ? e[t - 1] : null
              const c = t + 1 < e.length ? e[t + 1] : null
              const l = !a || (a.is('element') && a.name == 'br') || o
              const d = c ? false : !em(i.data)
              if (n.withChildren !== false) {
                if (l) {
                  r = r.replace(/^ /, '')
                }
                if (d) {
                  r = r.replace(/ $/, '')
                }
              }
              r = om(r)
              r = r.replace(/ \u00A0/g, '  ')
              const u = c && c.is('element') && c.name != 'br'
              const h = c && c.is('$text') && c.data.charAt(0) == ' '
              if (/[ \u00A0]\u00A0$/.test(r) || !c || u || h) {
                r = r.replace(/\u00A0$/, ' ')
              }
              if (l || (a && a.is('element') && a.name != 'br')) {
                r = r.replace(/^\u00A0/, ' ')
              }
            }
            if (r.length == 0 && i.parent) {
              i._remove()
              e.splice(t, 1)
              t--
            } else {
              i._data = r
              o = s
            }
          }
          e.length = 0
        }
        _processDataFromViewText(t) {
          let e = t.data
          if (t.getAncestors().some((t) => this.preElements.includes(t.name))) {
            return e
          }
          if (e.charAt(0) == ' ') {
            const n = this._getTouchingInlineViewNode(t, false)
            const o = n && n.is('$textProxy') && this._nodeEndsWithSpace(n)
            if (o || !n) {
              e = ' ' + e.substr(1)
            }
          }
          if (e.charAt(e.length - 1) == ' ') {
            const n = this._getTouchingInlineViewNode(t, true)
            const o = n && n.is('$textProxy') && n.data.charAt(0) == ' '
            if (e.charAt(e.length - 2) == ' ' || !n || o) {
              e = e.substr(0, e.length - 1) + ' '
            }
          }
          return e.replace(/ {2}/g, '  ')
        }
        _nodeEndsWithSpace(t) {
          if (t.getAncestors().some((t) => this.preElements.includes(t.name))) {
            return false
          }
          const e = this._processDataFromViewText(t)
          return e.charAt(e.length - 1) == ' '
        }
        _getTouchingInlineViewNode(t, e) {
          const n = new lf({
            startPosition: e ? df._createAfter(t) : df._createBefore(t),
            direction: e ? 'forward' : 'backward',
          })
          for (const t of n) {
            if (t.item.is('element', 'br')) {
              return null
            } else if (this._isInlineObjectElement(t.item)) {
              return t.item
            } else if (t.item.is('containerElement')) {
              return null
            } else if (t.item.is('$textProxy')) {
              return t.item
            }
          }
          return null
        }
        _isBlockDomElement(t) {
          return this.isElement(t) && this.blockElements.includes(t.tagName.toLowerCase())
        }
        _isBlockViewElement(t) {
          return t.is('element') && this.blockElements.includes(t.name)
        }
        _isInlineObjectElement(t) {
          if (!t.is('element')) {
            return false
          }
          return (
            t.name == 'br' || this.inlineObjectElements.includes(t.name) || !!this._inlineObjectElementMatcher.match(t)
          )
        }
        _createViewElement(t, e) {
          if (yc(t)) {
            return new Sf(this.document, '$comment')
          }
          const n = e.keepOriginalCase ? t.tagName : t.tagName.toLowerCase()
          return new Xg(this.document, n)
        }
        _isViewElementWithRawContent(t, e) {
          return e.withChildren !== false && t.is('element') && !!this._rawContentElementMatcher.match(t)
        }
        _shouldRenameElement(t) {
          const e = t.toLowerCase()
          return this.renderingMode === 'editing' && this.unsafeElements.includes(e)
        }
        _createReplacementDomElement(t, e) {
          const n = this._domDocument.createElement('span')
          n.setAttribute(ym, t)
          if (e) {
            while (e.firstChild) {
              n.appendChild(e.firstChild)
            }
            for (const t of e.getAttributeNames()) {
              n.setAttribute(t, e.getAttribute(t))
            }
          }
          return n
        }
      }
      function Em(t, e) {
        return t.getAncestors().some((t) => t.is('element') && e.includes(t.name))
      }
      function Dm(t, e) {
        let n = t
        while (n) {
          e(n)
          n = n.parentElement
        }
      }
      function Tm(t, e) {
        const n = t.isEqualNode(_m)
        return n && Im(t, e) && t.parentNode.childNodes.length === 1
      }
      function Im(t, e) {
        const n = t.parentNode
        return !!n && !!n.tagName && e.includes(n.tagName.toLowerCase())
      }
      function Sm(t) {
        if (t === 'script') {
          L('domconverter-unsafe-script-element-detected')
        }
        if (t === 'style') {
          L('domconverter-unsafe-style-element-detected')
        }
      }
      class Mm extends Ja() {
        constructor(t) {
          super()
          this._isEnabled = false
          this.view = t
          this.document = t.document
        }
        get isEnabled() {
          return this._isEnabled
        }
        enable() {
          this._isEnabled = true
        }
        disable() {
          this._isEnabled = false
        }
        destroy() {
          this.disable()
          this.stopListening()
        }
        checkShouldIgnoreEventFromTarget(t) {
          if (t && t.nodeType === 3) {
            t = t.parentNode
          }
          if (!t || t.nodeType !== 1) {
            return false
          }
          return t.matches('[data-cke-ignore-events], [data-cke-ignore-events] *')
        }
      }
      var Bm = jg(function (t, e) {
        wo(e, nr(e), t)
      })
      const Nm = Bm
      class Pm {
        constructor(t, e, n) {
          this.view = t
          this.document = t.document
          this.domEvent = e
          this.domTarget = e.target
          Nm(this, n)
        }
        get target() {
          return this.view.domConverter.mapDomToView(this.domTarget)
        }
        preventDefault() {
          this.domEvent.preventDefault()
        }
        stopPropagation() {
          this.domEvent.stopPropagation()
        }
      }
      class Lm extends Mm {
        constructor() {
          super(...arguments)
          this.useCapture = false
        }
        observe(t) {
          const e = typeof this.domEventType == 'string' ? [this.domEventType] : this.domEventType
          e.forEach((e) => {
            this.listenTo(
              t,
              e,
              (t, e) => {
                if (this.isEnabled && !this.checkShouldIgnoreEventFromTarget(e.target)) {
                  this.onDomEvent(e)
                }
              },
              { useCapture: this.useCapture },
            )
          })
        }
        stopObserving(t) {
          this.stopListening(t)
        }
        fire(t, e, n) {
          if (this.isEnabled) {
            this.document.fire(t, new Pm(this.view, e, n))
          }
        }
      }
      class zm extends Lm {
        constructor() {
          super(...arguments)
          this.domEventType = ['keydown', 'keyup']
        }
        onDomEvent(t) {
          const e = {
            keyCode: t.keyCode,
            altKey: t.altKey,
            ctrlKey: t.ctrlKey,
            shiftKey: t.shiftKey,
            metaKey: t.metaKey,
            get keystroke() {
              return Qc(this)
            },
          }
          this.fire(t.type, t, e)
        }
      }
      var Rm = function () {
        return Nt.Date.now()
      }
      const Om = Rm
      var Vm = /\s/
      function Fm(t) {
        var e = t.length
        while (e-- && Vm.test(t.charAt(e))) {}
        return e
      }
      const jm = Fm
      var Hm = /^\s+/
      function Um(t) {
        return t ? t.slice(0, jm(t) + 1).replace(Hm, '') : t
      }
      const Wm = Um
      var Gm = 0 / 0
      var qm = /^[-+]0x[0-9a-f]+$/i
      var $m = /^0b[01]+$/i
      var Km = /^0o[0-7]+$/i
      var Ym = parseInt
      function Zm(t) {
        if (typeof t == 'number') {
          return t
        }
        if (gh(t)) {
          return Gm
        }
        if (at(t)) {
          var e = typeof t.valueOf == 'function' ? t.valueOf() : t
          t = at(e) ? e + '' : e
        }
        if (typeof t != 'string') {
          return t === 0 ? t : +t
        }
        t = Wm(t)
        var n = $m.test(t)
        return n || Km.test(t) ? Ym(t.slice(2), n ? 2 : 8) : qm.test(t) ? Gm : +t
      }
      const Qm = Zm
      var Jm = 'Expected a function'
      var Xm = Math.max,
        tp = Math.min
      function ep(t, e, n) {
        var o,
          i,
          r,
          s,
          a,
          c,
          l = 0,
          d = false,
          u = false,
          h = true
        if (typeof t != 'function') {
          throw new TypeError(Jm)
        }
        e = Qm(e) || 0
        if (at(n)) {
          d = !!n.leading
          u = 'maxWait' in n
          r = u ? Xm(Qm(n.maxWait) || 0, e) : r
          h = 'trailing' in n ? !!n.trailing : h
        }
        function g(e) {
          var n = o,
            r = i
          o = i = undefined
          l = e
          s = t.apply(r, n)
          return s
        }
        function f(t) {
          l = t
          a = setTimeout(b, e)
          return d ? g(t) : s
        }
        function m(t) {
          var n = t - c,
            o = t - l,
            i = e - n
          return u ? tp(i, r - o) : i
        }
        function p(t) {
          var n = t - c,
            o = t - l
          return c === undefined || n >= e || n < 0 || (u && o >= r)
        }
        function b() {
          var t = Om()
          if (p(t)) {
            return k(t)
          }
          a = setTimeout(b, m(t))
        }
        function k(t) {
          a = undefined
          if (h && o) {
            return g(t)
          }
          o = i = undefined
          return s
        }
        function w() {
          if (a !== undefined) {
            clearTimeout(a)
          }
          l = 0
          o = c = i = a = undefined
        }
        function A() {
          return a === undefined ? s : k(Om())
        }
        function _() {
          var t = Om(),
            n = p(t)
          o = arguments
          i = this
          c = t
          if (n) {
            if (a === undefined) {
              return f(c)
            }
            if (u) {
              clearTimeout(a)
              a = setTimeout(b, e)
              return g(c)
            }
          }
          if (a === undefined) {
            a = setTimeout(b, e)
          }
          return s
        }
        _.cancel = w
        _.flush = A
        return _
      }
      const np = ep
      class op extends Mm {
        constructor(t) {
          super(t)
          this._fireSelectionChangeDoneDebounced = np((t) => {
            this.document.fire('selectionChangeDone', t)
          }, 200)
        }
        observe() {
          const t = this.document
          t.on(
            'arrowKey',
            (e, n) => {
              const o = t.selection
              if (o.isFake && this.isEnabled) {
                n.preventDefault()
              }
            },
            { context: '$capture' },
          )
          t.on(
            'arrowKey',
            (e, n) => {
              const o = t.selection
              if (o.isFake && this.isEnabled) {
                this._handleSelectionMove(n.keyCode)
              }
            },
            { priority: 'lowest' },
          )
        }
        stopObserving() {}
        destroy() {
          super.destroy()
          this._fireSelectionChangeDoneDebounced.cancel()
        }
        _handleSelectionMove(t) {
          const e = this.document.selection
          const n = new gf(e.getRanges(), { backward: e.isBackward, fake: false })
          if (t == Yc.arrowleft || t == Yc.arrowup) {
            n.setTo(n.getFirstPosition())
          }
          if (t == Yc.arrowright || t == Yc.arrowdown) {
            n.setTo(n.getLastPosition())
          }
          const o = { oldSelection: e, newSelection: n, domSelection: null }
          this.document.fire('selectionChange', o)
          this._fireSelectionChangeDoneDebounced(o)
        }
      }
      var ip = '__lodash_hash_undefined__'
      function rp(t) {
        this.__data__.set(t, ip)
        return this
      }
      const sp = rp
      function ap(t) {
        return this.__data__.has(t)
      }
      const cp = ap
      function lp(t) {
        var e = -1,
          n = t == null ? 0 : t.length
        this.__data__ = new eo()
        while (++e < n) {
          this.add(t[e])
        }
      }
      lp.prototype.add = lp.prototype.push = sp
      lp.prototype.has = cp
      const dp = lp
      function up(t, e) {
        var n = -1,
          o = t == null ? 0 : t.length
        while (++n < o) {
          if (e(t[n], n, t)) {
            return true
          }
        }
        return false
      }
      const hp = up
      function gp(t, e) {
        return t.has(e)
      }
      const fp = gp
      var mp = 1,
        pp = 2
      function bp(t, e, n, o, i, r) {
        var s = n & mp,
          a = t.length,
          c = e.length
        if (a != c && !(s && c > a)) {
          return false
        }
        var l = r.get(t)
        var d = r.get(e)
        if (l && d) {
          return l == e && d == t
        }
        var u = -1,
          h = true,
          g = n & pp ? new dp() : undefined
        r.set(t, e)
        r.set(e, t)
        while (++u < a) {
          var f = t[u],
            m = e[u]
          if (o) {
            var p = s ? o(m, f, u, e, t, r) : o(f, m, u, t, e, r)
          }
          if (p !== undefined) {
            if (p) {
              continue
            }
            h = false
            break
          }
          if (g) {
            if (
              !hp(e, function (t, e) {
                if (!fp(g, e) && (f === t || i(f, t, n, o, r))) {
                  return g.push(e)
                }
              })
            ) {
              h = false
              break
            }
          } else if (!(f === m || i(f, m, n, o, r))) {
            h = false
            break
          }
        }
        r['delete'](t)
        r['delete'](e)
        return h
      }
      const kp = bp
      function wp(t) {
        var e = -1,
          n = Array(t.size)
        t.forEach(function (t, o) {
          n[++e] = [o, t]
        })
        return n
      }
      const Ap = wp
      function _p(t) {
        var e = -1,
          n = Array(t.size)
        t.forEach(function (t) {
          n[++e] = t
        })
        return n
      }
      const Cp = _p
      var vp = 1,
        yp = 2
      var xp = '[object Boolean]',
        Ep = '[object Date]',
        Dp = '[object Error]',
        Tp = '[object Map]',
        Ip = '[object Number]',
        Sp = '[object RegExp]',
        Mp = '[object Set]',
        Bp = '[object String]',
        Np = '[object Symbol]'
      var Pp = '[object ArrayBuffer]',
        Lp = '[object DataView]'
      var zp = Lt ? Lt.prototype : undefined,
        Rp = zp ? zp.valueOf : undefined
      function Op(t, e, n, o, i, r, s) {
        switch (n) {
          case Lp:
            if (t.byteLength != e.byteLength || t.byteOffset != e.byteOffset) {
              return false
            }
            t = t.buffer
            e = e.buffer
          case Pp:
            if (t.byteLength != e.byteLength || !r(new ds(t), new ds(e))) {
              return false
            }
            return true
          case xp:
          case Ep:
          case Ip:
            return Ae(+t, +e)
          case Dp:
            return t.name == e.name && t.message == e.message
          case Sp:
          case Bp:
            return t == e + ''
          case Tp:
            var a = Ap
          case Mp:
            var c = o & vp
            a || (a = Cp)
            if (t.size != e.size && !c) {
              return false
            }
            var l = s.get(t)
            if (l) {
              return l == e
            }
            o |= yp
            s.set(t, e)
            var d = kp(a(t), a(e), o, i, r, s)
            s['delete'](t)
            return d
          case Np:
            if (Rp) {
              return Rp.call(t) == Rp.call(e)
            }
        }
        return false
      }
      const Vp = Op
      var Fp = 1
      var jp = Object.prototype
      var Hp = jp.hasOwnProperty
      function Up(t, e, n, o, i, r) {
        var s = n & Fp,
          a = Lr(t),
          c = a.length,
          l = Lr(e),
          d = l.length
        if (c != d && !s) {
          return false
        }
        var u = c
        while (u--) {
          var h = a[u]
          if (!(s ? h in e : Hp.call(e, h))) {
            return false
          }
        }
        var g = r.get(t)
        var f = r.get(e)
        if (g && f) {
          return g == e && f == t
        }
        var m = true
        r.set(t, e)
        r.set(e, t)
        var p = s
        while (++u < c) {
          h = a[u]
          var b = t[h],
            k = e[h]
          if (o) {
            var w = s ? o(k, b, h, e, t, r) : o(b, k, h, t, e, r)
          }
          if (!(w === undefined ? b === k || i(b, k, n, o, r) : w)) {
            m = false
            break
          }
          p || (p = h == 'constructor')
        }
        if (m && !p) {
          var A = t.constructor,
            _ = e.constructor
          if (
            A != _ &&
            'constructor' in t &&
            'constructor' in e &&
            !(typeof A == 'function' && A instanceof A && typeof _ == 'function' && _ instanceof _)
          ) {
            m = false
          }
        }
        r['delete'](t)
        r['delete'](e)
        return m
      }
      const Wp = Up
      var Gp = 1
      var qp = '[object Arguments]',
        $p = '[object Array]',
        Kp = '[object Object]'
      var Yp = Object.prototype
      var Zp = Yp.hasOwnProperty
      function Qp(t, e, n, o, i, r) {
        var s = Jt(t),
          a = Jt(e),
          c = s ? $p : is(t),
          l = a ? $p : is(e)
        c = c == qp ? Kp : c
        l = l == qp ? Kp : l
        var d = c == Kp,
          u = l == Kp,
          h = c == l
        if (h && Oo(t)) {
          if (!Oo(e)) {
            return false
          }
          s = true
          d = false
        }
        if (h && !d) {
          r || (r = new so())
          return s || Ii(t) ? kp(t, e, n, o, i, r) : Vp(t, e, c, n, o, i, r)
        }
        if (!(n & Gp)) {
          var g = d && Zp.call(t, '__wrapped__'),
            f = u && Zp.call(e, '__wrapped__')
          if (g || f) {
            var m = g ? t.value() : t,
              p = f ? e.value() : e
            r || (r = new so())
            return i(m, p, n, o, r)
          }
        }
        if (!h) {
          return false
        }
        r || (r = new so())
        return Wp(t, e, n, o, i, r)
      }
      const Jp = Qp
      function Xp(t, e, n, o, i) {
        if (t === e) {
          return true
        }
        if (t == null || e == null || (!te(t) && !te(e))) {
          return t !== t && e !== e
        }
        return Jp(t, e, n, o, Xp, i)
      }
      const tb = Xp
      function eb(t, e, n) {
        n = typeof n == 'function' ? n : undefined
        var o = n ? n(t, e) : undefined
        return o === undefined ? tb(t, e, undefined, n) : !!o
      }
      const nb = eb
      class ob extends Mm {
        constructor(t) {
          super(t)
          this._config = { childList: true, characterData: true, subtree: true }
          this.domConverter = t.domConverter
          this.renderer = t._renderer
          this._domElements = new Set()
          this._mutationObserver = new window.MutationObserver(this._onMutations.bind(this))
        }
        flush() {
          this._onMutations(this._mutationObserver.takeRecords())
        }
        observe(t) {
          this._domElements.add(t)
          if (this.isEnabled) {
            this._mutationObserver.observe(t, this._config)
          }
        }
        stopObserving(t) {
          this._domElements.delete(t)
          if (this.isEnabled) {
            this._mutationObserver.disconnect()
            for (const t of this._domElements) {
              this._mutationObserver.observe(t, this._config)
            }
          }
        }
        enable() {
          super.enable()
          for (const t of this._domElements) {
            this._mutationObserver.observe(t, this._config)
          }
        }
        disable() {
          super.disable()
          this._mutationObserver.disconnect()
        }
        destroy() {
          super.destroy()
          this._mutationObserver.disconnect()
        }
        _onMutations(t) {
          if (t.length === 0) {
            return
          }
          const e = this.domConverter
          const n = new Set()
          const o = new Set()
          for (const n of t) {
            const t = e.mapDomToView(n.target)
            if (!t) {
              continue
            }
            if (t.is('uiElement') || t.is('rawElement')) {
              continue
            }
            if (n.type === 'childList' && !this._isBogusBrMutation(n)) {
              o.add(t)
            }
          }
          for (const i of t) {
            const t = e.mapDomToView(i.target)
            if (t && (t.is('uiElement') || t.is('rawElement'))) {
              continue
            }
            if (i.type === 'characterData') {
              const t = e.findCorrespondingViewText(i.target)
              if (t && !o.has(t.parent)) {
                n.add(t)
              } else if (!t && em(i.target)) {
                o.add(e.mapDomToView(i.target.parentNode))
              }
            }
          }
          let i = false
          for (const t of n) {
            i = true
            this.renderer.markToSync('text', t)
          }
          for (const t of o) {
            const n = e.mapViewToDom(t)
            const o = Array.from(t.getChildren())
            const r = Array.from(e.domChildrenToView(n, { withChildren: false }))
            if (!nb(o, r, ib)) {
              i = true
              this.renderer.markToSync('children', t)
            }
          }
          if (i) {
            this.view.forceRender()
          }
        }
        _isBogusBrMutation(t) {
          let e = null
          if (t.nextSibling === null && t.removedNodes.length === 0 && t.addedNodes.length == 1) {
            e = this.domConverter.domToView(t.addedNodes[0], { withChildren: false })
          }
          return e && e.is('element', 'br')
        }
      }
      function ib(t, e) {
        if (Array.isArray(t)) {
          return
        }
        if (t === e) {
          return true
        } else if (t.is('$text') && e.is('$text')) {
          return t.data === e.data
        }
        return false
      }
      class rb extends Lm {
        constructor(t) {
          super(t)
          this._isFocusChanging = false
          this.domEventType = ['focus', 'blur']
          this.useCapture = true
          const e = this.document
          e.on('focus', () => {
            this._isFocusChanging = true
            this._renderTimeoutId = setTimeout(() => {
              this.flush()
              t.change(() => {})
            }, 50)
          })
          e.on('blur', (n, o) => {
            const i = e.selection.editableElement
            if (i === null || i === o.target) {
              e.isFocused = false
              this._isFocusChanging = false
              t.change(() => {})
            }
          })
        }
        flush() {
          if (this._isFocusChanging) {
            this._isFocusChanging = false
            this.document.isFocused = true
          }
        }
        onDomEvent(t) {
          this.fire(t.type, t)
        }
        destroy() {
          if (this._renderTimeoutId) {
            clearTimeout(this._renderTimeoutId)
          }
          super.destroy()
        }
      }
      class sb extends Mm {
        constructor(t) {
          super(t)
          this.mutationObserver = t.getObserver(ob)
          this.focusObserver = t.getObserver(rb)
          this.selection = this.document.selection
          this.domConverter = t.domConverter
          this._documents = new WeakSet()
          this._fireSelectionChangeDoneDebounced = np((t) => {
            this.document.fire('selectionChangeDone', t)
          }, 200)
          this._clearInfiniteLoopInterval = setInterval(() => this._clearInfiniteLoop(), 1e3)
          this._documentIsSelectingInactivityTimeoutDebounced = np(() => (this.document.isSelecting = false), 5e3)
          this._loopbackCounter = 0
        }
        observe(t) {
          const e = t.ownerDocument
          const n = () => {
            this.document.isSelecting = true
            this._documentIsSelectingInactivityTimeoutDebounced()
          }
          const o = () => {
            if (!this.document.isSelecting) {
              return
            }
            this._handleSelectionChange(null, e)
            this.document.isSelecting = false
            this._documentIsSelectingInactivityTimeoutDebounced.cancel()
          }
          this.listenTo(t, 'selectstart', n, { priority: 'highest' })
          this.listenTo(t, 'keydown', o, { priority: 'highest', useCapture: true })
          this.listenTo(t, 'keyup', o, { priority: 'highest', useCapture: true })
          if (this._documents.has(e)) {
            return
          }
          this.listenTo(e, 'mouseup', o, { priority: 'highest', useCapture: true })
          this.listenTo(e, 'selectionchange', (t, n) => {
            if (this.document.isComposing && !l.isAndroid) {
              return
            }
            this._handleSelectionChange(n, e)
            this._documentIsSelectingInactivityTimeoutDebounced()
          })
          this._documents.add(e)
        }
        stopObserving(t) {
          this.stopListening(t)
        }
        destroy() {
          super.destroy()
          clearInterval(this._clearInfiniteLoopInterval)
          this._fireSelectionChangeDoneDebounced.cancel()
          this._documentIsSelectingInactivityTimeoutDebounced.cancel()
        }
        _reportInfiniteLoop() {}
        _handleSelectionChange(t, e) {
          if (!this.isEnabled) {
            return
          }
          const n = e.defaultView.getSelection()
          if (this.checkShouldIgnoreEventFromTarget(n.anchorNode)) {
            return
          }
          this.mutationObserver.flush()
          const o = this.domConverter.domSelectionToView(n)
          if (o.rangeCount == 0) {
            this.view.hasDomSelection = false
            return
          }
          this.view.hasDomSelection = true
          this.focusObserver.flush()
          if (this.selection.isEqual(o) && this.domConverter.isDomSelectionCorrect(n)) {
            return
          }
          if (++this._loopbackCounter > 60) {
            this._reportInfiniteLoop()
            return
          }
          if (this.selection.isSimilar(o)) {
            this.view.forceRender()
          } else {
            const t = { oldSelection: this.selection, newSelection: o, domSelection: n }
            this.document.fire('selectionChange', t)
            this._fireSelectionChangeDoneDebounced(t)
          }
        }
        _clearInfiniteLoop() {
          this._loopbackCounter = 0
        }
      }
      class ab extends Lm {
        constructor(t) {
          super(t)
          this.domEventType = ['compositionstart', 'compositionupdate', 'compositionend']
          const e = this.document
          e.on(
            'compositionstart',
            () => {
              e.isComposing = true
            },
            { priority: 'low' },
          )
          e.on(
            'compositionend',
            () => {
              e.isComposing = false
            },
            { priority: 'low' },
          )
        }
        onDomEvent(t) {
          this.fire(t.type, t, { data: t.data })
        }
      }
      class cb {
        constructor(t, e = {}) {
          this._files = e.cacheFiles ? lb(t) : null
          this._native = t
        }
        get files() {
          if (!this._files) {
            this._files = lb(this._native)
          }
          return this._files
        }
        get types() {
          return this._native.types
        }
        getData(t) {
          return this._native.getData(t)
        }
        setData(t, e) {
          this._native.setData(t, e)
        }
        set effectAllowed(t) {
          this._native.effectAllowed = t
        }
        get effectAllowed() {
          return this._native.effectAllowed
        }
        set dropEffect(t) {
          this._native.dropEffect = t
        }
        get dropEffect() {
          return this._native.dropEffect
        }
        setDragImage(t, e, n) {
          this._native.setDragImage(t, e, n)
        }
        get isCanceled() {
          return this._native.dropEffect == 'none' || !!this._native.mozUserCancelled
        }
      }
      function lb(t) {
        const e = Array.from(t.files || [])
        const n = Array.from(t.items || [])
        if (e.length) {
          return e
        }
        return n.filter((t) => t.kind === 'file').map((t) => t.getAsFile())
      }
      class db extends Lm {
        constructor() {
          super(...arguments)
          this.domEventType = 'beforeinput'
        }
        onDomEvent(t) {
          const e = t.getTargetRanges()
          const n = this.view
          const o = n.document
          let i = null
          let r = null
          let s = []
          if (t.dataTransfer) {
            i = new cb(t.dataTransfer)
          }
          if (t.data !== null) {
            r = t.data
          } else if (i) {
            r = i.getData('text/plain')
          }
          if (o.selection.isFake) {
            s = Array.from(o.selection.getRanges())
          } else if (e.length) {
            s = e
              .map((t) => {
                const e = n.domConverter.domPositionToView(t.startContainer, t.startOffset)
                const o = n.domConverter.domPositionToView(t.endContainer, t.endOffset)
                if (e) {
                  return n.createRange(e, o)
                } else if (o) {
                  return n.createRange(o)
                }
              })
              .filter((t) => !!t)
          } else if (l.isAndroid) {
            const e = t.target.ownerDocument.defaultView.getSelection()
            s = Array.from(n.domConverter.domSelectionToView(e).getRanges())
          }
          if (l.isAndroid && t.inputType == 'insertCompositionText' && r && r.endsWith('\n')) {
            this.fire(t.type, t, { inputType: 'insertParagraph', targetRanges: [n.createRange(s[0].end)] })
            return
          }
          if (t.inputType == 'insertText' && r && r.includes('\n')) {
            const e = r.split(/\n{1,2}/g)
            let n = s
            for (let r = 0; r < e.length; r++) {
              const s = e[r]
              if (s != '') {
                this.fire(t.type, t, {
                  data: s,
                  dataTransfer: i,
                  targetRanges: n,
                  inputType: t.inputType,
                  isComposing: t.isComposing,
                })
                n = [o.selection.getFirstRange()]
              }
              if (r + 1 < e.length) {
                this.fire(t.type, t, { inputType: 'insertParagraph', targetRanges: n })
                n = [o.selection.getFirstRange()]
              }
            }
            return
          }
          this.fire(t.type, t, {
            data: r,
            dataTransfer: i,
            targetRanges: s,
            inputType: t.inputType,
            isComposing: t.isComposing,
          })
        }
      }
      class ub extends Mm {
        constructor(t) {
          super(t)
          this.document.on('keydown', (t, e) => {
            if (this.isEnabled && tl(e.keyCode)) {
              const n = new mf(this.document, 'arrowKey', this.document.selection.getFirstRange())
              this.document.fire(n, e)
              if (n.stop.called) {
                t.stop()
              }
            }
          })
        }
        observe() {}
        stopObserving() {}
      }
      class hb extends Mm {
        constructor(t) {
          super(t)
          const e = this.document
          e.on('keydown', (t, n) => {
            if (!this.isEnabled || n.keyCode != Yc.tab || n.ctrlKey) {
              return
            }
            const o = new mf(e, 'tab', e.selection.getFirstRange())
            e.fire(o, n)
            if (o.stop.called) {
              t.stop()
            }
          })
        }
        observe() {}
        stopObserving() {}
      }
      var gb = 1,
        fb = 4
      function mb(t) {
        return Va(t, gb | fb)
      }
      const pb = mb
      class bb extends ft() {
        constructor(t) {
          super()
          this.domRoots = new Map()
          this._initialDomRootAttributes = new WeakMap()
          this._observers = new Map()
          this._ongoingChange = false
          this._postFixersInProgress = false
          this._renderingDisabled = false
          this._hasChangedSinceTheLastRendering = false
          this.document = new vf(t)
          this.domConverter = new xm(this.document)
          this.set('isRenderingInProgress', false)
          this.set('hasDomSelection', false)
          this._renderer = new dm(this.domConverter, this.document.selection)
          this._renderer
            .bind('isFocused', 'isSelecting', 'isComposing')
            .to(this.document, 'isFocused', 'isSelecting', 'isComposing')
          this._writer = new Of(this.document)
          this.addObserver(ob)
          this.addObserver(rb)
          this.addObserver(sb)
          this.addObserver(zm)
          this.addObserver(op)
          this.addObserver(ab)
          this.addObserver(ub)
          this.addObserver(db)
          this.addObserver(hb)
          im(this)
          Mf(this)
          this.on('render', () => {
            this._render()
            this.document.fire('layoutChanged')
            this._hasChangedSinceTheLastRendering = false
          })
          this.listenTo(this.document.selection, 'change', () => {
            this._hasChangedSinceTheLastRendering = true
          })
          this.listenTo(this.document, 'change:isFocused', () => {
            this._hasChangedSinceTheLastRendering = true
          })
          if (l.isiOS) {
            this.listenTo(this.document, 'blur', (t, e) => {
              const n = this.domConverter.mapDomToView(e.domEvent.relatedTarget)
              if (!n) {
                this.domConverter._clearDomSelection()
              }
            })
          }
        }
        attachDomRoot(t, e = 'main') {
          const n = this.document.getRoot(e)
          n._name = t.tagName.toLowerCase()
          const o = {}
          for (const { name: e, value: i } of Array.from(t.attributes)) {
            o[e] = i
            if (e === 'class') {
              this._writer.addClass(i.split(' '), n)
            } else {
              this._writer.setAttribute(e, i, n)
            }
          }
          this._initialDomRootAttributes.set(t, o)
          const i = () => {
            this._writer.setAttribute('contenteditable', (!n.isReadOnly).toString(), n)
            if (n.isReadOnly) {
              this._writer.addClass('ck-read-only', n)
            } else {
              this._writer.removeClass('ck-read-only', n)
            }
          }
          i()
          this.domRoots.set(e, t)
          this.domConverter.bindElements(t, n)
          this._renderer.markToSync('children', n)
          this._renderer.markToSync('attributes', n)
          this._renderer.domDocuments.add(t.ownerDocument)
          n.on('change:children', (t, e) => this._renderer.markToSync('children', e))
          n.on('change:attributes', (t, e) => this._renderer.markToSync('attributes', e))
          n.on('change:text', (t, e) => this._renderer.markToSync('text', e))
          n.on('change:isReadOnly', () => this.change(i))
          n.on('change', () => {
            this._hasChangedSinceTheLastRendering = true
          })
          for (const n of this._observers.values()) {
            n.observe(t, e)
          }
        }
        detachDomRoot(t) {
          const e = this.domRoots.get(t)
          Array.from(e.attributes).forEach(({ name: t }) => e.removeAttribute(t))
          const n = this._initialDomRootAttributes.get(e)
          for (const t in n) {
            e.setAttribute(t, n[t])
          }
          this.domRoots.delete(t)
          this.domConverter.unbindDomElement(e)
          for (const t of this._observers.values()) {
            t.stopObserving(e)
          }
        }
        getDomRoot(t = 'main') {
          return this.domRoots.get(t)
        }
        addObserver(t) {
          let e = this._observers.get(t)
          if (e) {
            return e
          }
          e = new t(this)
          this._observers.set(t, e)
          for (const [t, n] of this.domRoots) {
            e.observe(n, t)
          }
          e.enable()
          return e
        }
        getObserver(t) {
          return this._observers.get(t)
        }
        disableObservers() {
          for (const t of this._observers.values()) {
            t.disable()
          }
        }
        enableObservers() {
          for (const t of this._observers.values()) {
            t.enable()
          }
        }
        scrollToTheSelection({ alignToTop: t, forceScroll: e, viewportOffset: n = 20, ancestorOffset: o = 20 } = {}) {
          const i = this.document.selection.getFirstRange()
          if (!i) {
            return
          }
          const r = pb({ alignToTop: t, forceScroll: e, viewportOffset: n, ancestorOffset: o })
          if (typeof n === 'number') {
            n = { top: n, bottom: n, left: n, right: n }
          }
          const s = {
            target: this.domConverter.viewRangeToDom(i),
            viewportOffset: n,
            ancestorOffset: o,
            alignToTop: t,
            forceScroll: e,
          }
          this.fire('scrollToTheSelection', s, r)
          Lc(s)
        }
        focus() {
          if (!this.document.isFocused) {
            const t = this.document.selection.editableElement
            if (t) {
              this.domConverter.focus(t)
              this.forceRender()
            } else {
            }
          }
        }
        change(t) {
          if (this.isRenderingInProgress || this._postFixersInProgress) {
            throw new P('cannot-change-view-tree', this)
          }
          try {
            if (this._ongoingChange) {
              return t(this._writer)
            }
            this._ongoingChange = true
            const e = t(this._writer)
            this._ongoingChange = false
            if (!this._renderingDisabled && this._hasChangedSinceTheLastRendering) {
              this._postFixersInProgress = true
              this.document._callPostFixers(this._writer)
              this._postFixersInProgress = false
              this.fire('render')
            }
            return e
          } catch (t) {
            P.rethrowUnexpectedError(t, this)
          }
        }
        forceRender() {
          this._hasChangedSinceTheLastRendering = true
          this.getObserver(rb).flush()
          this.change(() => {})
        }
        destroy() {
          for (const t of this._observers.values()) {
            t.destroy()
          }
          this.document.destroy()
          this.stopListening()
        }
        createPositionAt(t, e) {
          return df._createAt(t, e)
        }
        createPositionAfter(t) {
          return df._createAfter(t)
        }
        createPositionBefore(t) {
          return df._createBefore(t)
        }
        createRange(t, e) {
          return new uf(t, e)
        }
        createRangeOn(t) {
          return uf._createOn(t)
        }
        createRangeIn(t) {
          return uf._createIn(t)
        }
        createSelection(...t) {
          return new gf(...t)
        }
        _disableRendering(t) {
          this._renderingDisabled = t
          if (t == false) {
            this.change(() => {})
          }
        }
        _render() {
          this.isRenderingInProgress = true
          this.disableObservers()
          this._renderer.render()
          this.enableObservers()
          this.isRenderingInProgress = false
        }
      }
      class kb {
        is() {
          throw new Error('is() method is abstract')
        }
      }
      class wb extends kb {
        constructor(t) {
          super()
          this.parent = null
          this._attrs = _l(t)
        }
        get document() {
          return null
        }
        get index() {
          let t
          if (!this.parent) {
            return null
          }
          if ((t = this.parent.getChildIndex(this)) === null) {
            throw new P('model-node-not-found-in-parent', this)
          }
          return t
        }
        get startOffset() {
          let t
          if (!this.parent) {
            return null
          }
          if ((t = this.parent.getChildStartOffset(this)) === null) {
            throw new P('model-node-not-found-in-parent', this)
          }
          return t
        }
        get offsetSize() {
          return 1
        }
        get endOffset() {
          if (!this.parent) {
            return null
          }
          return this.startOffset + this.offsetSize
        }
        get nextSibling() {
          const t = this.index
          return (t !== null && this.parent.getChild(t + 1)) || null
        }
        get previousSibling() {
          const t = this.index
          return (t !== null && this.parent.getChild(t - 1)) || null
        }
        get root() {
          let t = this
          while (t.parent) {
            t = t.parent
          }
          return t
        }
        isAttached() {
          return this.parent === null ? false : this.root.isAttached()
        }
        getPath() {
          const t = []
          let e = this
          while (e.parent) {
            t.unshift(e.startOffset)
            e = e.parent
          }
          return t
        }
        getAncestors(t = {}) {
          const e = []
          let n = t.includeSelf ? this : this.parent
          while (n) {
            e[t.parentFirst ? 'push' : 'unshift'](n)
            n = n.parent
          }
          return e
        }
        getCommonAncestor(t, e = {}) {
          const n = this.getAncestors(e)
          const o = t.getAncestors(e)
          let i = 0
          while (n[i] == o[i] && n[i]) {
            i++
          }
          return i === 0 ? null : n[i - 1]
        }
        isBefore(t) {
          if (this == t) {
            return false
          }
          if (this.root !== t.root) {
            return false
          }
          const e = this.getPath()
          const n = t.getPath()
          const o = Dt(e, n)
          switch (o) {
            case 'prefix':
              return true
            case 'extension':
              return false
            default:
              return e[o] < n[o]
          }
        }
        isAfter(t) {
          if (this == t) {
            return false
          }
          if (this.root !== t.root) {
            return false
          }
          return !this.isBefore(t)
        }
        hasAttribute(t) {
          return this._attrs.has(t)
        }
        getAttribute(t) {
          return this._attrs.get(t)
        }
        getAttributes() {
          return this._attrs.entries()
        }
        getAttributeKeys() {
          return this._attrs.keys()
        }
        toJSON() {
          const t = {}
          if (this._attrs.size) {
            t.attributes = Array.from(this._attrs).reduce((t, e) => {
              t[e[0]] = e[1]
              return t
            }, {})
          }
          return t
        }
        _clone(t) {
          return new this.constructor(this._attrs)
        }
        _remove() {
          this.parent._removeChildren(this.index)
        }
        _setAttribute(t, e) {
          this._attrs.set(t, e)
        }
        _setAttributesTo(t) {
          this._attrs = _l(t)
        }
        _removeAttribute(t) {
          return this._attrs.delete(t)
        }
        _clearAttributes() {
          this._attrs.clear()
        }
      }
      wb.prototype.is = function (t) {
        return t === 'node' || t === 'model:node'
      }
      class Ab {
        constructor(t) {
          this._nodes = []
          if (t) {
            this._insertNodes(0, t)
          }
        }
        [Symbol.iterator]() {
          return this._nodes[Symbol.iterator]()
        }
        get length() {
          return this._nodes.length
        }
        get maxOffset() {
          return this._nodes.reduce((t, e) => t + e.offsetSize, 0)
        }
        getNode(t) {
          return this._nodes[t] || null
        }
        getNodeIndex(t) {
          const e = this._nodes.indexOf(t)
          return e == -1 ? null : e
        }
        getNodeStartOffset(t) {
          const e = this.getNodeIndex(t)
          return e === null ? null : this._nodes.slice(0, e).reduce((t, e) => t + e.offsetSize, 0)
        }
        indexToOffset(t) {
          if (t == this._nodes.length) {
            return this.maxOffset
          }
          const e = this._nodes[t]
          if (!e) {
            throw new P('model-nodelist-index-out-of-bounds', this)
          }
          return this.getNodeStartOffset(e)
        }
        offsetToIndex(t) {
          let e = 0
          for (const n of this._nodes) {
            if (t >= e && t < e + n.offsetSize) {
              return this.getNodeIndex(n)
            }
            e += n.offsetSize
          }
          if (e != t) {
            throw new P('model-nodelist-offset-out-of-bounds', this, { offset: t, nodeList: this })
          }
          return this.length
        }
        _insertNodes(t, e) {
          for (const t of e) {
            if (!(t instanceof wb)) {
              throw new P('model-nodelist-insertnodes-not-node', this)
            }
          }
          this._nodes = vl(this._nodes, Array.from(e), t, 0)
        }
        _removeNodes(t, e = 1) {
          return this._nodes.splice(t, e)
        }
        toJSON() {
          return this._nodes.map((t) => t.toJSON())
        }
      }
      class _b extends wb {
        constructor(t, e) {
          super(e)
          this._data = t || ''
        }
        get offsetSize() {
          return this.data.length
        }
        get data() {
          return this._data
        }
        toJSON() {
          const t = super.toJSON()
          t.data = this.data
          return t
        }
        _clone() {
          return new _b(this.data, this.getAttributes())
        }
        static fromJSON(t) {
          return new _b(t.data, t.attributes)
        }
      }
      _b.prototype.is = function (t) {
        return (
          t === '$text' ||
          t === 'model:$text' ||
          t === 'text' ||
          t === 'model:text' ||
          t === 'node' ||
          t === 'model:node'
        )
      }
      class Cb extends kb {
        constructor(t, e, n) {
          super()
          this.textNode = t
          if (e < 0 || e > t.offsetSize) {
            throw new P('model-textproxy-wrong-offsetintext', this)
          }
          if (n < 0 || e + n > t.offsetSize) {
            throw new P('model-textproxy-wrong-length', this)
          }
          this.data = t.data.substring(e, e + n)
          this.offsetInText = e
        }
        get startOffset() {
          return this.textNode.startOffset !== null ? this.textNode.startOffset + this.offsetInText : null
        }
        get offsetSize() {
          return this.data.length
        }
        get endOffset() {
          return this.startOffset !== null ? this.startOffset + this.offsetSize : null
        }
        get isPartial() {
          return this.offsetSize !== this.textNode.offsetSize
        }
        get parent() {
          return this.textNode.parent
        }
        get root() {
          return this.textNode.root
        }
        getPath() {
          const t = this.textNode.getPath()
          if (t.length > 0) {
            t[t.length - 1] += this.offsetInText
          }
          return t
        }
        getAncestors(t = {}) {
          const e = []
          let n = t.includeSelf ? this : this.parent
          while (n) {
            e[t.parentFirst ? 'push' : 'unshift'](n)
            n = n.parent
          }
          return e
        }
        hasAttribute(t) {
          return this.textNode.hasAttribute(t)
        }
        getAttribute(t) {
          return this.textNode.getAttribute(t)
        }
        getAttributes() {
          return this.textNode.getAttributes()
        }
        getAttributeKeys() {
          return this.textNode.getAttributeKeys()
        }
      }
      Cb.prototype.is = function (t) {
        return t === '$textProxy' || t === 'model:$textProxy' || t === 'textProxy' || t === 'model:textProxy'
      }
      class vb extends wb {
        constructor(t, e, n) {
          super(e)
          this._children = new Ab()
          this.name = t
          if (n) {
            this._insertChild(0, n)
          }
        }
        get childCount() {
          return this._children.length
        }
        get maxOffset() {
          return this._children.maxOffset
        }
        get isEmpty() {
          return this.childCount === 0
        }
        getChild(t) {
          return this._children.getNode(t)
        }
        getChildren() {
          return this._children[Symbol.iterator]()
        }
        getChildIndex(t) {
          return this._children.getNodeIndex(t)
        }
        getChildStartOffset(t) {
          return this._children.getNodeStartOffset(t)
        }
        offsetToIndex(t) {
          return this._children.offsetToIndex(t)
        }
        getNodeByPath(t) {
          let e = this
          for (const n of t) {
            e = e.getChild(e.offsetToIndex(n))
          }
          return e
        }
        findAncestor(t, e = {}) {
          let n = e.includeSelf ? this : this.parent
          while (n) {
            if (n.name === t) {
              return n
            }
            n = n.parent
          }
          return null
        }
        toJSON() {
          const t = super.toJSON()
          t.name = this.name
          if (this._children.length > 0) {
            t.children = []
            for (const e of this._children) {
              t.children.push(e.toJSON())
            }
          }
          return t
        }
        _clone(t = false) {
          const e = t ? Array.from(this._children).map((t) => t._clone(true)) : undefined
          return new vb(this.name, this.getAttributes(), e)
        }
        _appendChild(t) {
          this._insertChild(this.childCount, t)
        }
        _insertChild(t, e) {
          const n = yb(e)
          for (const t of n) {
            if (t.parent !== null) {
              t._remove()
            }
            t.parent = this
          }
          this._children._insertNodes(t, n)
        }
        _removeChildren(t, e = 1) {
          const n = this._children._removeNodes(t, e)
          for (const t of n) {
            t.parent = null
          }
          return n
        }
        static fromJSON(t) {
          let e
          if (t.children) {
            e = []
            for (const n of t.children) {
              if (n.name) {
                e.push(vb.fromJSON(n))
              } else {
                e.push(_b.fromJSON(n))
              }
            }
          }
          return new vb(t.name, t.attributes, e)
        }
      }
      vb.prototype.is = function (t, e) {
        if (!e) {
          return t === 'element' || t === 'model:element' || t === 'node' || t === 'model:node'
        }
        return e === this.name && (t === 'element' || t === 'model:element')
      }
      function yb(t) {
        if (typeof t == 'string') {
          return [new _b(t)]
        }
        if (!Tt(t)) {
          t = [t]
        }
        return Array.from(t).map((t) => {
          if (typeof t == 'string') {
            return new _b(t)
          }
          if (t instanceof Cb) {
            return new _b(t.data, t.getAttributes())
          }
          return t
        })
      }
      class xb {
        constructor(t) {
          if (!t || (!t.boundaries && !t.startPosition)) {
            throw new P('model-tree-walker-no-start-position', null)
          }
          const e = t.direction || 'forward'
          if (e != 'forward' && e != 'backward') {
            throw new P('model-tree-walker-unknown-direction', t, { direction: e })
          }
          this.direction = e
          this.boundaries = t.boundaries || null
          if (t.startPosition) {
            this._position = t.startPosition.clone()
          } else {
            this._position = Db._createAt(this.boundaries[this.direction == 'backward' ? 'end' : 'start'])
          }
          this.position.stickiness = 'toNone'
          this.singleCharacters = !!t.singleCharacters
          this.shallow = !!t.shallow
          this.ignoreElementEnd = !!t.ignoreElementEnd
          this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null
          this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null
          this._visitedParent = this.position.parent
        }
        [Symbol.iterator]() {
          return this
        }
        get position() {
          return this._position
        }
        skip(t) {
          let e, n, o, i
          do {
            o = this.position
            i = this._visitedParent
            ;({ done: e, value: n } = this.next())
          } while (!e && t(n))
          if (!e) {
            this._position = o
            this._visitedParent = i
          }
        }
        next() {
          if (this.direction == 'forward') {
            return this._next()
          } else {
            return this._previous()
          }
        }
        _next() {
          const t = this.position
          const e = this.position.clone()
          const n = this._visitedParent
          if (n.parent === null && e.offset === n.maxOffset) {
            return { done: true, value: undefined }
          }
          if (n === this._boundaryEndParent && e.offset == this.boundaries.end.offset) {
            return { done: true, value: undefined }
          }
          const o = Tb(e, n)
          const i = o || Ib(e, n, o)
          if (i instanceof vb) {
            if (!this.shallow) {
              e.path.push(0)
              this._visitedParent = i
            } else {
              if (this.boundaries && this.boundaries.end.isBefore(e)) {
                return { done: true, value: undefined }
              }
              e.offset++
            }
            this._position = e
            return Eb('elementStart', i, t, e, 1)
          }
          if (i instanceof _b) {
            let o
            if (this.singleCharacters) {
              o = 1
            } else {
              let t = i.endOffset
              if (this._boundaryEndParent == n && this.boundaries.end.offset < t) {
                t = this.boundaries.end.offset
              }
              o = t - e.offset
            }
            const r = e.offset - i.startOffset
            const s = new Cb(i, r, o)
            e.offset += o
            this._position = e
            return Eb('text', s, t, e, o)
          }
          e.path.pop()
          e.offset++
          this._position = e
          this._visitedParent = n.parent
          if (this.ignoreElementEnd) {
            return this._next()
          }
          return Eb('elementEnd', n, t, e)
        }
        _previous() {
          const t = this.position
          const e = this.position.clone()
          const n = this._visitedParent
          if (n.parent === null && e.offset === 0) {
            return { done: true, value: undefined }
          }
          if (n == this._boundaryStartParent && e.offset == this.boundaries.start.offset) {
            return { done: true, value: undefined }
          }
          const o = e.parent
          const i = Tb(e, o)
          const r = i || Sb(e, o, i)
          if (r instanceof vb) {
            e.offset--
            if (this.shallow) {
              this._position = e
              return Eb('elementStart', r, t, e, 1)
            }
            e.path.push(r.maxOffset)
            this._position = e
            this._visitedParent = r
            if (this.ignoreElementEnd) {
              return this._previous()
            }
            return Eb('elementEnd', r, t, e)
          }
          if (r instanceof _b) {
            let o
            if (this.singleCharacters) {
              o = 1
            } else {
              let t = r.startOffset
              if (this._boundaryStartParent == n && this.boundaries.start.offset > t) {
                t = this.boundaries.start.offset
              }
              o = e.offset - t
            }
            const i = e.offset - r.startOffset
            const s = new Cb(r, i - o, o)
            e.offset -= o
            this._position = e
            return Eb('text', s, t, e, o)
          }
          e.path.pop()
          this._position = e
          this._visitedParent = n.parent
          return Eb('elementStart', n, t, e, 1)
        }
      }
      function Eb(t, e, n, o, i) {
        return { done: false, value: { type: t, item: e, previousPosition: n, nextPosition: o, length: i } }
      }
      class Db extends kb {
        constructor(t, e, n = 'toNone') {
          super()
          if (!t.is('element') && !t.is('documentFragment')) {
            throw new P('model-position-root-invalid', t)
          }
          if (!(e instanceof Array) || e.length === 0) {
            throw new P('model-position-path-incorrect-format', t, { path: e })
          }
          if (t.is('rootElement')) {
            e = e.slice()
          } else {
            e = [...t.getPath(), ...e]
            t = t.root
          }
          this.root = t
          this.path = e
          this.stickiness = n
        }
        get offset() {
          return this.path[this.path.length - 1]
        }
        set offset(t) {
          this.path[this.path.length - 1] = t
        }
        get parent() {
          let t = this.root
          for (let e = 0; e < this.path.length - 1; e++) {
            t = t.getChild(t.offsetToIndex(this.path[e]))
            if (!t) {
              throw new P('model-position-path-incorrect', this, { position: this })
            }
          }
          if (t.is('$text')) {
            throw new P('model-position-path-incorrect', this, { position: this })
          }
          return t
        }
        get index() {
          return this.parent.offsetToIndex(this.offset)
        }
        get textNode() {
          return Tb(this, this.parent)
        }
        get nodeAfter() {
          const t = this.parent
          return Ib(this, t, Tb(this, t))
        }
        get nodeBefore() {
          const t = this.parent
          return Sb(this, t, Tb(this, t))
        }
        get isAtStart() {
          return this.offset === 0
        }
        get isAtEnd() {
          return this.offset == this.parent.maxOffset
        }
        compareWith(t) {
          if (this.root != t.root) {
            return 'different'
          }
          const e = Dt(this.path, t.path)
          switch (e) {
            case 'same':
              return 'same'
            case 'prefix':
              return 'before'
            case 'extension':
              return 'after'
            default:
              return this.path[e] < t.path[e] ? 'before' : 'after'
          }
        }
        getLastMatchingPosition(t, e = {}) {
          e.startPosition = this
          const n = new xb(e)
          n.skip(t)
          return n.position
        }
        getParentPath() {
          return this.path.slice(0, -1)
        }
        getAncestors() {
          const t = this.parent
          if (t.is('documentFragment')) {
            return [t]
          } else {
            return t.getAncestors({ includeSelf: true })
          }
        }
        findAncestor(t) {
          const e = this.parent
          if (e.is('element')) {
            return e.findAncestor(t, { includeSelf: true })
          }
          return null
        }
        getCommonPath(t) {
          if (this.root != t.root) {
            return []
          }
          const e = Dt(this.path, t.path)
          const n = typeof e == 'string' ? Math.min(this.path.length, t.path.length) : e
          return this.path.slice(0, n)
        }
        getCommonAncestor(t) {
          const e = this.getAncestors()
          const n = t.getAncestors()
          let o = 0
          while (e[o] == n[o] && e[o]) {
            o++
          }
          return o === 0 ? null : e[o - 1]
        }
        getShiftedBy(t) {
          const e = this.clone()
          const n = e.offset + t
          e.offset = n < 0 ? 0 : n
          return e
        }
        isAfter(t) {
          return this.compareWith(t) == 'after'
        }
        isBefore(t) {
          return this.compareWith(t) == 'before'
        }
        isEqual(t) {
          return this.compareWith(t) == 'same'
        }
        isTouching(t) {
          if (this.root !== t.root) {
            return false
          }
          const e = Math.min(this.path.length, t.path.length)
          for (let n = 0; n < e; n++) {
            const e = this.path[n] - t.path[n]
            if (e < -1 || e > 1) {
              return false
            } else if (e === 1) {
              return Mb(t, this, n)
            } else if (e === -1) {
              return Mb(this, t, n)
            }
          }
          if (this.path.length === t.path.length) {
            return true
          } else if (this.path.length > t.path.length) {
            return Bb(this.path, e)
          } else {
            return Bb(t.path, e)
          }
        }
        hasSameParentAs(t) {
          if (this.root !== t.root) {
            return false
          }
          const e = this.getParentPath()
          const n = t.getParentPath()
          return Dt(e, n) == 'same'
        }
        getTransformedByOperation(t) {
          let e
          switch (t.type) {
            case 'insert':
              e = this._getTransformedByInsertOperation(t)
              break
            case 'move':
            case 'remove':
            case 'reinsert':
              e = this._getTransformedByMoveOperation(t)
              break
            case 'split':
              e = this._getTransformedBySplitOperation(t)
              break
            case 'merge':
              e = this._getTransformedByMergeOperation(t)
              break
            default:
              e = Db._createAt(this)
              break
          }
          return e
        }
        _getTransformedByInsertOperation(t) {
          return this._getTransformedByInsertion(t.position, t.howMany)
        }
        _getTransformedByMoveOperation(t) {
          return this._getTransformedByMove(t.sourcePosition, t.targetPosition, t.howMany)
        }
        _getTransformedBySplitOperation(t) {
          const e = t.movedRange
          const n = e.containsPosition(this) || (e.start.isEqual(this) && this.stickiness == 'toNext')
          if (n) {
            return this._getCombined(t.splitPosition, t.moveTargetPosition)
          } else {
            if (t.graveyardPosition) {
              return this._getTransformedByMove(t.graveyardPosition, t.insertionPosition, 1)
            } else {
              return this._getTransformedByInsertion(t.insertionPosition, 1)
            }
          }
        }
        _getTransformedByMergeOperation(t) {
          const e = t.movedRange
          const n = e.containsPosition(this) || e.start.isEqual(this)
          let o
          if (n) {
            o = this._getCombined(t.sourcePosition, t.targetPosition)
            if (t.sourcePosition.isBefore(t.targetPosition)) {
              o = o._getTransformedByDeletion(t.deletionPosition, 1)
            }
          } else if (this.isEqual(t.deletionPosition)) {
            o = Db._createAt(t.deletionPosition)
          } else {
            o = this._getTransformedByMove(t.deletionPosition, t.graveyardPosition, 1)
          }
          return o
        }
        _getTransformedByDeletion(t, e) {
          const n = Db._createAt(this)
          if (this.root != t.root) {
            return n
          }
          if (Dt(t.getParentPath(), this.getParentPath()) == 'same') {
            if (t.offset < this.offset) {
              if (t.offset + e > this.offset) {
                return null
              } else {
                n.offset -= e
              }
            }
          } else if (Dt(t.getParentPath(), this.getParentPath()) == 'prefix') {
            const o = t.path.length - 1
            if (t.offset <= this.path[o]) {
              if (t.offset + e > this.path[o]) {
                return null
              } else {
                n.path[o] -= e
              }
            }
          }
          return n
        }
        _getTransformedByInsertion(t, e) {
          const n = Db._createAt(this)
          if (this.root != t.root) {
            return n
          }
          if (Dt(t.getParentPath(), this.getParentPath()) == 'same') {
            if (t.offset < this.offset || (t.offset == this.offset && this.stickiness != 'toPrevious')) {
              n.offset += e
            }
          } else if (Dt(t.getParentPath(), this.getParentPath()) == 'prefix') {
            const o = t.path.length - 1
            if (t.offset <= this.path[o]) {
              n.path[o] += e
            }
          }
          return n
        }
        _getTransformedByMove(t, e, n) {
          e = e._getTransformedByDeletion(t, n)
          if (t.isEqual(e)) {
            return Db._createAt(this)
          }
          const o = this._getTransformedByDeletion(t, n)
          const i =
            o === null ||
            (t.isEqual(this) && this.stickiness == 'toNext') ||
            (t.getShiftedBy(n).isEqual(this) && this.stickiness == 'toPrevious')
          if (i) {
            return this._getCombined(t, e)
          } else {
            return o._getTransformedByInsertion(e, n)
          }
        }
        _getCombined(t, e) {
          const n = t.path.length - 1
          const o = Db._createAt(e)
          o.stickiness = this.stickiness
          o.offset = o.offset + this.path[n] - t.offset
          o.path = [...o.path, ...this.path.slice(n + 1)]
          return o
        }
        toJSON() {
          return { root: this.root.toJSON(), path: Array.from(this.path), stickiness: this.stickiness }
        }
        clone() {
          return new this.constructor(this.root, this.path, this.stickiness)
        }
        static _createAt(t, e, n = 'toNone') {
          if (t instanceof Db) {
            return new Db(t.root, t.path, t.stickiness)
          } else {
            const o = t
            if (e == 'end') {
              e = o.maxOffset
            } else if (e == 'before') {
              return this._createBefore(o, n)
            } else if (e == 'after') {
              return this._createAfter(o, n)
            } else if (e !== 0 && !e) {
              throw new P('model-createpositionat-offset-required', [this, t])
            }
            if (!o.is('element') && !o.is('documentFragment')) {
              throw new P('model-position-parent-incorrect', [this, t])
            }
            const i = o.getPath()
            i.push(e)
            return new this(o.root, i, n)
          }
        }
        static _createAfter(t, e) {
          if (!t.parent) {
            throw new P('model-position-after-root', [this, t], { root: t })
          }
          return this._createAt(t.parent, t.endOffset, e)
        }
        static _createBefore(t, e) {
          if (!t.parent) {
            throw new P('model-position-before-root', t, { root: t })
          }
          return this._createAt(t.parent, t.startOffset, e)
        }
        static fromJSON(t, e) {
          if (t.root === '$graveyard') {
            const n = new Db(e.graveyard, t.path)
            n.stickiness = t.stickiness
            return n
          }
          if (!e.getRoot(t.root)) {
            throw new P('model-position-fromjson-no-root', e, { rootName: t.root })
          }
          return new Db(e.getRoot(t.root), t.path, t.stickiness)
        }
      }
      Db.prototype.is = function (t) {
        return t === 'position' || t === 'model:position'
      }
      function Tb(t, e) {
        const n = e.getChild(e.offsetToIndex(t.offset))
        if (n && n.is('$text') && n.startOffset < t.offset) {
          return n
        }
        return null
      }
      function Ib(t, e, n) {
        if (n !== null) {
          return null
        }
        return e.getChild(e.offsetToIndex(t.offset))
      }
      function Sb(t, e, n) {
        if (n !== null) {
          return null
        }
        return e.getChild(e.offsetToIndex(t.offset) - 1)
      }
      function Mb(t, e, n) {
        if (n + 1 === t.path.length) {
          return false
        }
        if (!Bb(e.path, n + 1)) {
          return false
        }
        if (!Nb(t, n + 1)) {
          return false
        }
        return true
      }
      function Bb(t, e) {
        while (e < t.length) {
          if (t[e] !== 0) {
            return false
          }
          e++
        }
        return true
      }
      function Nb(t, e) {
        let n = t.parent
        let o = t.path.length - 1
        let i = 0
        while (o >= e) {
          if (t.path[o] + i !== n.maxOffset) {
            return false
          }
          i = 1
          o--
          n = n.parent
        }
        return true
      }
      class Pb extends kb {
        constructor(t, e) {
          super()
          this.start = Db._createAt(t)
          this.end = e ? Db._createAt(e) : Db._createAt(t)
          this.start.stickiness = this.isCollapsed ? 'toNone' : 'toNext'
          this.end.stickiness = this.isCollapsed ? 'toNone' : 'toPrevious'
        }
        *[Symbol.iterator]() {
          yield* new xb({ boundaries: this, ignoreElementEnd: true })
        }
        get isCollapsed() {
          return this.start.isEqual(this.end)
        }
        get isFlat() {
          const t = this.start.getParentPath()
          const e = this.end.getParentPath()
          return Dt(t, e) == 'same'
        }
        get root() {
          return this.start.root
        }
        containsPosition(t) {
          return t.isAfter(this.start) && t.isBefore(this.end)
        }
        containsRange(t, e = false) {
          if (t.isCollapsed) {
            e = false
          }
          const n = this.containsPosition(t.start) || (e && this.start.isEqual(t.start))
          const o = this.containsPosition(t.end) || (e && this.end.isEqual(t.end))
          return n && o
        }
        containsItem(t) {
          const e = Db._createBefore(t)
          return this.containsPosition(e) || this.start.isEqual(e)
        }
        isEqual(t) {
          return this.start.isEqual(t.start) && this.end.isEqual(t.end)
        }
        isIntersecting(t) {
          return this.start.isBefore(t.end) && this.end.isAfter(t.start)
        }
        getDifference(t) {
          const e = []
          if (this.isIntersecting(t)) {
            if (this.containsPosition(t.start)) {
              e.push(new Pb(this.start, t.start))
            }
            if (this.containsPosition(t.end)) {
              e.push(new Pb(t.end, this.end))
            }
          } else {
            e.push(new Pb(this.start, this.end))
          }
          return e
        }
        getIntersection(t) {
          if (this.isIntersecting(t)) {
            let e = this.start
            let n = this.end
            if (this.containsPosition(t.start)) {
              e = t.start
            }
            if (this.containsPosition(t.end)) {
              n = t.end
            }
            return new Pb(e, n)
          }
          return null
        }
        getJoined(t, e = false) {
          let n = this.isIntersecting(t)
          if (!n) {
            if (this.start.isBefore(t.start)) {
              n = e ? this.end.isTouching(t.start) : this.end.isEqual(t.start)
            } else {
              n = e ? t.end.isTouching(this.start) : t.end.isEqual(this.start)
            }
          }
          if (!n) {
            return null
          }
          let o = this.start
          let i = this.end
          if (t.start.isBefore(o)) {
            o = t.start
          }
          if (t.end.isAfter(i)) {
            i = t.end
          }
          return new Pb(o, i)
        }
        getMinimalFlatRanges() {
          const t = []
          const e = this.start.getCommonPath(this.end).length
          const n = Db._createAt(this.start)
          let o = n.parent
          while (n.path.length > e + 1) {
            const e = o.maxOffset - n.offset
            if (e !== 0) {
              t.push(new Pb(n, n.getShiftedBy(e)))
            }
            n.path = n.path.slice(0, -1)
            n.offset++
            o = o.parent
          }
          while (n.path.length <= this.end.path.length) {
            const e = this.end.path[n.path.length - 1]
            const o = e - n.offset
            if (o !== 0) {
              t.push(new Pb(n, n.getShiftedBy(o)))
            }
            n.offset = e
            n.path.push(0)
          }
          return t
        }
        getWalker(t = {}) {
          t.boundaries = this
          return new xb(t)
        }
        *getItems(t = {}) {
          t.boundaries = this
          t.ignoreElementEnd = true
          const e = new xb(t)
          for (const t of e) {
            yield t.item
          }
        }
        *getPositions(t = {}) {
          t.boundaries = this
          const e = new xb(t)
          yield e.position
          for (const t of e) {
            yield t.nextPosition
          }
        }
        getTransformedByOperation(t) {
          switch (t.type) {
            case 'insert':
              return this._getTransformedByInsertOperation(t)
            case 'move':
            case 'remove':
            case 'reinsert':
              return this._getTransformedByMoveOperation(t)
            case 'split':
              return [this._getTransformedBySplitOperation(t)]
            case 'merge':
              return [this._getTransformedByMergeOperation(t)]
          }
          return [new Pb(this.start, this.end)]
        }
        getTransformedByOperations(t) {
          const e = [new Pb(this.start, this.end)]
          for (const n of t) {
            for (let t = 0; t < e.length; t++) {
              const o = e[t].getTransformedByOperation(n)
              e.splice(t, 1, ...o)
              t += o.length - 1
            }
          }
          for (let t = 0; t < e.length; t++) {
            const n = e[t]
            for (let o = t + 1; o < e.length; o++) {
              const t = e[o]
              if (n.containsRange(t) || t.containsRange(n) || n.isEqual(t)) {
                e.splice(o, 1)
              }
            }
          }
          return e
        }
        getCommonAncestor() {
          return this.start.getCommonAncestor(this.end)
        }
        getContainedElement() {
          if (this.isCollapsed) {
            return null
          }
          const t = this.start.nodeAfter
          const e = this.end.nodeBefore
          if (t && t.is('element') && t === e) {
            return t
          }
          return null
        }
        toJSON() {
          return { start: this.start.toJSON(), end: this.end.toJSON() }
        }
        clone() {
          return new this.constructor(this.start, this.end)
        }
        _getTransformedByInsertOperation(t, e = false) {
          return this._getTransformedByInsertion(t.position, t.howMany, e)
        }
        _getTransformedByMoveOperation(t, e = false) {
          const n = t.sourcePosition
          const o = t.howMany
          const i = t.targetPosition
          return this._getTransformedByMove(n, i, o, e)
        }
        _getTransformedBySplitOperation(t) {
          const e = this.start._getTransformedBySplitOperation(t)
          let n = this.end._getTransformedBySplitOperation(t)
          if (this.end.isEqual(t.insertionPosition)) {
            n = this.end.getShiftedBy(1)
          }
          if (e.root != n.root) {
            n = this.end.getShiftedBy(-1)
          }
          return new Pb(e, n)
        }
        _getTransformedByMergeOperation(t) {
          if (this.start.isEqual(t.targetPosition) && this.end.isEqual(t.deletionPosition)) {
            return new Pb(this.start)
          }
          let e = this.start._getTransformedByMergeOperation(t)
          let n = this.end._getTransformedByMergeOperation(t)
          if (e.root != n.root) {
            n = this.end.getShiftedBy(-1)
          }
          if (e.isAfter(n)) {
            if (t.sourcePosition.isBefore(t.targetPosition)) {
              e = Db._createAt(n)
              e.offset = 0
            } else {
              if (!t.deletionPosition.isEqual(e)) {
                n = t.deletionPosition
              }
              e = t.targetPosition
            }
            return new Pb(e, n)
          }
          return new Pb(e, n)
        }
        _getTransformedByInsertion(t, e, n = false) {
          if (n && this.containsPosition(t)) {
            return [new Pb(this.start, t), new Pb(t.getShiftedBy(e), this.end._getTransformedByInsertion(t, e))]
          } else {
            const n = new Pb(this.start, this.end)
            n.start = n.start._getTransformedByInsertion(t, e)
            n.end = n.end._getTransformedByInsertion(t, e)
            return [n]
          }
        }
        _getTransformedByMove(t, e, n, o = false) {
          if (this.isCollapsed) {
            const o = this.start._getTransformedByMove(t, e, n)
            return [new Pb(o)]
          }
          const i = Pb._createFromPositionAndShift(t, n)
          const r = e._getTransformedByDeletion(t, n)
          if (this.containsPosition(e) && !o) {
            if (i.containsPosition(this.start) || i.containsPosition(this.end)) {
              const o = this.start._getTransformedByMove(t, e, n)
              const i = this.end._getTransformedByMove(t, e, n)
              return [new Pb(o, i)]
            }
          }
          let s
          const a = this.getDifference(i)
          let c = null
          const l = this.getIntersection(i)
          if (a.length == 1) {
            c = new Pb(a[0].start._getTransformedByDeletion(t, n), a[0].end._getTransformedByDeletion(t, n))
          } else if (a.length == 2) {
            c = new Pb(this.start, this.end._getTransformedByDeletion(t, n))
          }
          if (c) {
            s = c._getTransformedByInsertion(r, n, l !== null || o)
          } else {
            s = []
          }
          if (l) {
            const t = new Pb(l.start._getCombined(i.start, r), l.end._getCombined(i.start, r))
            if (s.length == 2) {
              s.splice(1, 0, t)
            } else {
              s.push(t)
            }
          }
          return s
        }
        _getTransformedByDeletion(t, e) {
          let n = this.start._getTransformedByDeletion(t, e)
          let o = this.end._getTransformedByDeletion(t, e)
          if (n == null && o == null) {
            return null
          }
          if (n == null) {
            n = t
          }
          if (o == null) {
            o = t
          }
          return new Pb(n, o)
        }
        static _createFromPositionAndShift(t, e) {
          const n = t
          const o = t.getShiftedBy(e)
          return e > 0 ? new this(n, o) : new this(o, n)
        }
        static _createIn(t) {
          return new this(Db._createAt(t, 0), Db._createAt(t, t.maxOffset))
        }
        static _createOn(t) {
          return this._createFromPositionAndShift(Db._createBefore(t), t.offsetSize)
        }
        static _createFromRanges(t) {
          if (t.length === 0) {
            throw new P('range-create-from-ranges-empty-array', null)
          } else if (t.length == 1) {
            return t[0].clone()
          }
          const e = t[0]
          t.sort((t, e) => (t.start.isAfter(e.start) ? 1 : -1))
          const n = t.indexOf(e)
          const o = new this(e.start, e.end)
          if (n > 0) {
            for (let e = n - 1; true; e++) {
              if (t[e].end.isEqual(o.start)) {
                o.start = Db._createAt(t[e].start)
              } else {
                break
              }
            }
          }
          for (let e = n + 1; e < t.length; e++) {
            if (t[e].start.isEqual(o.end)) {
              o.end = Db._createAt(t[e].end)
            } else {
              break
            }
          }
          return o
        }
        static fromJSON(t, e) {
          return new this(Db.fromJSON(t.start, e), Db.fromJSON(t.end, e))
        }
      }
      Pb.prototype.is = function (t) {
        return t === 'range' || t === 'model:range'
      }
      class Lb extends K() {
        constructor() {
          super()
          this._modelToViewMapping = new WeakMap()
          this._viewToModelMapping = new WeakMap()
          this._viewToModelLengthCallbacks = new Map()
          this._markerNameToElements = new Map()
          this._elementToMarkerNames = new Map()
          this._deferredBindingRemovals = new Map()
          this._unboundMarkerNames = new Set()
          this.on(
            'modelToViewPosition',
            (t, e) => {
              if (e.viewPosition) {
                return
              }
              const n = this._modelToViewMapping.get(e.modelPosition.parent)
              if (!n) {
                throw new P('mapping-model-position-view-parent-not-found', this, { modelPosition: e.modelPosition })
              }
              e.viewPosition = this.findPositionIn(n, e.modelPosition.offset)
            },
            { priority: 'low' },
          )
          this.on(
            'viewToModelPosition',
            (t, e) => {
              if (e.modelPosition) {
                return
              }
              const n = this.findMappedViewAncestor(e.viewPosition)
              const o = this._viewToModelMapping.get(n)
              const i = this._toModelOffset(e.viewPosition.parent, e.viewPosition.offset, n)
              e.modelPosition = Db._createAt(o, i)
            },
            { priority: 'low' },
          )
        }
        bindElements(t, e) {
          this._modelToViewMapping.set(t, e)
          this._viewToModelMapping.set(e, t)
        }
        unbindViewElement(t, e = {}) {
          const n = this.toModelElement(t)
          if (this._elementToMarkerNames.has(t)) {
            for (const e of this._elementToMarkerNames.get(t)) {
              this._unboundMarkerNames.add(e)
            }
          }
          if (e.defer) {
            this._deferredBindingRemovals.set(t, t.root)
          } else {
            this._viewToModelMapping.delete(t)
            if (this._modelToViewMapping.get(n) == t) {
              this._modelToViewMapping.delete(n)
            }
          }
        }
        unbindModelElement(t) {
          const e = this.toViewElement(t)
          this._modelToViewMapping.delete(t)
          if (this._viewToModelMapping.get(e) == t) {
            this._viewToModelMapping.delete(e)
          }
        }
        bindElementToMarker(t, e) {
          const n = this._markerNameToElements.get(e) || new Set()
          n.add(t)
          const o = this._elementToMarkerNames.get(t) || new Set()
          o.add(e)
          this._markerNameToElements.set(e, n)
          this._elementToMarkerNames.set(t, o)
        }
        unbindElementFromMarkerName(t, e) {
          const n = this._markerNameToElements.get(e)
          if (n) {
            n.delete(t)
            if (n.size == 0) {
              this._markerNameToElements.delete(e)
            }
          }
          const o = this._elementToMarkerNames.get(t)
          if (o) {
            o.delete(e)
            if (o.size == 0) {
              this._elementToMarkerNames.delete(t)
            }
          }
        }
        flushUnboundMarkerNames() {
          const t = Array.from(this._unboundMarkerNames)
          this._unboundMarkerNames.clear()
          return t
        }
        flushDeferredBindings() {
          for (const [t, e] of this._deferredBindingRemovals) {
            if (t.root == e) {
              this.unbindViewElement(t)
            }
          }
          this._deferredBindingRemovals = new Map()
        }
        clearBindings() {
          this._modelToViewMapping = new WeakMap()
          this._viewToModelMapping = new WeakMap()
          this._markerNameToElements = new Map()
          this._elementToMarkerNames = new Map()
          this._unboundMarkerNames = new Set()
          this._deferredBindingRemovals = new Map()
        }
        toModelElement(t) {
          return this._viewToModelMapping.get(t)
        }
        toViewElement(t) {
          return this._modelToViewMapping.get(t)
        }
        toModelRange(t) {
          return new Pb(this.toModelPosition(t.start), this.toModelPosition(t.end))
        }
        toViewRange(t) {
          return new uf(this.toViewPosition(t.start), this.toViewPosition(t.end))
        }
        toModelPosition(t) {
          const e = { viewPosition: t, mapper: this }
          this.fire('viewToModelPosition', e)
          return e.modelPosition
        }
        toViewPosition(t, e = {}) {
          const n = { modelPosition: t, mapper: this, isPhantom: e.isPhantom }
          this.fire('modelToViewPosition', n)
          return n.viewPosition
        }
        markerNameToElements(t) {
          const e = this._markerNameToElements.get(t)
          if (!e) {
            return null
          }
          const n = new Set()
          for (const t of e) {
            if (t.is('attributeElement')) {
              for (const e of t.getElementsWithSameId()) {
                n.add(e)
              }
            } else {
              n.add(t)
            }
          }
          return n
        }
        registerViewToModelLength(t, e) {
          this._viewToModelLengthCallbacks.set(t, e)
        }
        findMappedViewAncestor(t) {
          let e = t.parent
          while (!this._viewToModelMapping.has(e)) {
            e = e.parent
          }
          return e
        }
        _toModelOffset(t, e, n) {
          if (n != t) {
            const o = this._toModelOffset(t.parent, t.index, n)
            const i = this._toModelOffset(t, e, t)
            return o + i
          }
          if (t.is('$text')) {
            return e
          }
          let o = 0
          for (let n = 0; n < e; n++) {
            o += this.getModelLength(t.getChild(n))
          }
          return o
        }
        getModelLength(t) {
          if (this._viewToModelLengthCallbacks.get(t.name)) {
            const e = this._viewToModelLengthCallbacks.get(t.name)
            return e(t)
          } else if (this._viewToModelMapping.has(t)) {
            return 1
          } else if (t.is('$text')) {
            return t.data.length
          } else if (t.is('uiElement')) {
            return 0
          } else {
            let e = 0
            for (const n of t.getChildren()) {
              e += this.getModelLength(n)
            }
            return e
          }
        }
        findPositionIn(t, e) {
          let n
          let o = 0
          let i = 0
          let r = 0
          if (t.is('$text')) {
            return new df(t, e)
          }
          while (i < e) {
            n = t.getChild(r)
            o = this.getModelLength(n)
            i += o
            r++
          }
          if (i == e) {
            return this._moveViewPositionToTextNode(new df(t, r))
          } else {
            return this.findPositionIn(n, e - (i - o))
          }
        }
        _moveViewPositionToTextNode(t) {
          const e = t.nodeBefore
          const n = t.nodeAfter
          if (e instanceof Xu) {
            return new df(e, e.data.length)
          } else if (n instanceof Xu) {
            return new df(n, 0)
          }
          return t
        }
      }
      class zb {
        constructor() {
          this._consumable = new Map()
          this._textProxyRegistry = new Map()
        }
        add(t, e) {
          e = Rb(e)
          if (t instanceof Cb) {
            t = this._getSymbolForTextProxy(t)
          }
          if (!this._consumable.has(t)) {
            this._consumable.set(t, new Map())
          }
          this._consumable.get(t).set(e, true)
        }
        consume(t, e) {
          e = Rb(e)
          if (t instanceof Cb) {
            t = this._getSymbolForTextProxy(t)
          }
          if (this.test(t, e)) {
            this._consumable.get(t).set(e, false)
            return true
          } else {
            return false
          }
        }
        test(t, e) {
          e = Rb(e)
          if (t instanceof Cb) {
            t = this._getSymbolForTextProxy(t)
          }
          const n = this._consumable.get(t)
          if (n === undefined) {
            return null
          }
          const o = n.get(e)
          if (o === undefined) {
            return null
          }
          return o
        }
        revert(t, e) {
          e = Rb(e)
          if (t instanceof Cb) {
            t = this._getSymbolForTextProxy(t)
          }
          const n = this.test(t, e)
          if (n === false) {
            this._consumable.get(t).set(e, true)
            return true
          } else if (n === true) {
            return false
          }
          return null
        }
        verifyAllConsumed(t) {
          const e = []
          for (const [n, o] of this._consumable) {
            for (const [i, r] of o) {
              const o = i.split(':')[0]
              if (r && t == o) {
                e.push({ event: i, item: n.name || n.description })
              }
            }
          }
          if (e.length) {
            throw new P('conversion-model-consumable-not-consumed', null, { items: e })
          }
        }
        _getSymbolForTextProxy(t) {
          let e = null
          const n = this._textProxyRegistry.get(t.startOffset)
          if (n) {
            const o = n.get(t.endOffset)
            if (o) {
              e = o.get(t.parent)
            }
          }
          if (!e) {
            e = this._addSymbolForTextProxy(t)
          }
          return e
        }
        _addSymbolForTextProxy(t) {
          const e = t.startOffset
          const n = t.endOffset
          const o = t.parent
          const i = Symbol('$textProxy:' + t.data)
          let r
          let s
          r = this._textProxyRegistry.get(e)
          if (!r) {
            r = new Map()
            this._textProxyRegistry.set(e, r)
          }
          s = r.get(n)
          if (!s) {
            s = new Map()
            r.set(n, s)
          }
          s.set(o, i)
          return i
        }
      }
      function Rb(t) {
        const e = t.split(':')
        if (e[0] == 'insert') {
          return e[0]
        }
        if (e[0] == 'addMarker' || e[0] == 'removeMarker') {
          return t
        }
        return e.length > 1 ? e[0] + ':' + e[1] : e[0]
      }
      class Ob extends K() {
        constructor(t) {
          super()
          this._conversionApi = { dispatcher: this, ...t }
          this._firedEventsMap = new WeakMap()
        }
        convertChanges(t, e, n) {
          const o = this._createConversionApi(n, t.getRefreshedItems())
          for (const e of t.getMarkersToRemove()) {
            this._convertMarkerRemove(e.name, e.range, o)
          }
          const i = this._reduceChanges(t.getChanges())
          for (const t of i) {
            if (t.type === 'insert') {
              this._convertInsert(Pb._createFromPositionAndShift(t.position, t.length), o)
            } else if (t.type === 'reinsert') {
              this._convertReinsert(Pb._createFromPositionAndShift(t.position, t.length), o)
            } else if (t.type === 'remove') {
              this._convertRemove(t.position, t.length, t.name, o)
            } else {
              this._convertAttribute(t.range, t.attributeKey, t.attributeOldValue, t.attributeNewValue, o)
            }
          }
          for (const t of o.mapper.flushUnboundMarkerNames()) {
            const n = e.get(t).getRange()
            this._convertMarkerRemove(t, n, o)
            this._convertMarkerAdd(t, n, o)
          }
          for (const e of t.getMarkersToAdd()) {
            this._convertMarkerAdd(e.name, e.range, o)
          }
          o.mapper.flushDeferredBindings()
          o.consumable.verifyAllConsumed('insert')
        }
        convert(t, e, n, o = {}) {
          const i = this._createConversionApi(n, undefined, o)
          this._convertInsert(t, i)
          for (const [t, n] of e) {
            this._convertMarkerAdd(t, n, i)
          }
          i.consumable.verifyAllConsumed('insert')
        }
        convertSelection(t, e, n) {
          const o = this._createConversionApi(n)
          this.fire('cleanSelection', { selection: t }, o)
          const i = t.getFirstPosition().root
          if (!o.mapper.toViewElement(i)) {
            return
          }
          const r = Array.from(e.getMarkersAtPosition(t.getFirstPosition()))
          this._addConsumablesForSelection(o.consumable, t, r)
          this.fire('selection', { selection: t }, o)
          if (!t.isCollapsed) {
            return
          }
          for (const e of r) {
            if (o.consumable.test(t, 'addMarker:' + e.name)) {
              const n = e.getRange()
              if (!Vb(t.getFirstPosition(), e, o.mapper)) {
                continue
              }
              const i = { item: t, markerName: e.name, markerRange: n }
              this.fire(`addMarker:${e.name}`, i, o)
            }
          }
          for (const e of t.getAttributeKeys()) {
            if (o.consumable.test(t, 'attribute:' + e)) {
              const n = {
                item: t,
                range: t.getFirstRange(),
                attributeKey: e,
                attributeOldValue: null,
                attributeNewValue: t.getAttribute(e),
              }
              this.fire(`attribute:${e}:$text`, n, o)
            }
          }
        }
        _convertInsert(t, e, n = {}) {
          if (!n.doNotAddConsumables) {
            this._addConsumablesForInsert(e.consumable, Array.from(t))
          }
          for (const n of Array.from(t.getWalker({ shallow: true })).map(jb)) {
            this._testAndFire('insert', n, e)
          }
        }
        _convertRemove(t, e, n, o) {
          this.fire(`remove:${n}`, { position: t, length: e }, o)
        }
        _convertAttribute(t, e, n, o, i) {
          this._addConsumablesForRange(i.consumable, t, `attribute:${e}`)
          for (const r of t) {
            const t = {
              item: r.item,
              range: Pb._createFromPositionAndShift(r.previousPosition, r.length),
              attributeKey: e,
              attributeOldValue: n,
              attributeNewValue: o,
            }
            this._testAndFire(`attribute:${e}`, t, i)
          }
        }
        _convertReinsert(t, e) {
          const n = Array.from(t.getWalker({ shallow: true }))
          this._addConsumablesForInsert(e.consumable, n)
          for (const t of n.map(jb)) {
            this._testAndFire('insert', { ...t, reconversion: true }, e)
          }
        }
        _convertMarkerAdd(t, e, n) {
          if (e.root.rootName == '$graveyard') {
            return
          }
          const o = `addMarker:${t}`
          n.consumable.add(e, o)
          this.fire(o, { markerName: t, markerRange: e }, n)
          if (!n.consumable.consume(e, o)) {
            return
          }
          this._addConsumablesForRange(n.consumable, e, o)
          for (const i of e.getItems()) {
            if (!n.consumable.test(i, o)) {
              continue
            }
            const r = { item: i, range: Pb._createOn(i), markerName: t, markerRange: e }
            this.fire(o, r, n)
          }
        }
        _convertMarkerRemove(t, e, n) {
          if (e.root.rootName == '$graveyard') {
            return
          }
          this.fire(`removeMarker:${t}`, { markerName: t, markerRange: e }, n)
        }
        _reduceChanges(t) {
          const e = { changes: t }
          this.fire('reduceChanges', e)
          return e.changes
        }
        _addConsumablesForInsert(t, e) {
          for (const n of e) {
            const e = n.item
            if (t.test(e, 'insert') === null) {
              t.add(e, 'insert')
              for (const n of e.getAttributeKeys()) {
                t.add(e, 'attribute:' + n)
              }
            }
          }
          return t
        }
        _addConsumablesForRange(t, e, n) {
          for (const o of e.getItems()) {
            t.add(o, n)
          }
          return t
        }
        _addConsumablesForSelection(t, e, n) {
          t.add(e, 'selection')
          for (const o of n) {
            t.add(e, 'addMarker:' + o.name)
          }
          for (const n of e.getAttributeKeys()) {
            t.add(e, 'attribute:' + n)
          }
          return t
        }
        _testAndFire(t, e, n) {
          const o = Fb(t, e)
          const i = e.item.is('$textProxy') ? n.consumable._getSymbolForTextProxy(e.item) : e.item
          const r = this._firedEventsMap.get(n)
          const s = r.get(i)
          if (!s) {
            r.set(i, new Set([o]))
          } else if (!s.has(o)) {
            s.add(o)
          } else {
            return
          }
          this.fire(o, e, n)
        }
        _testAndFireAddAttributes(t, e) {
          const n = { item: t, range: Pb._createOn(t) }
          for (const t of n.item.getAttributeKeys()) {
            n.attributeKey = t
            n.attributeOldValue = null
            n.attributeNewValue = n.item.getAttribute(t)
            this._testAndFire(`attribute:${t}`, n, e)
          }
        }
        _createConversionApi(t, e = new Set(), n = {}) {
          const o = {
            ...this._conversionApi,
            consumable: new zb(),
            writer: t,
            options: n,
            convertItem: (t) => this._convertInsert(Pb._createOn(t), o),
            convertChildren: (t) => this._convertInsert(Pb._createIn(t), o, { doNotAddConsumables: true }),
            convertAttributes: (t) => this._testAndFireAddAttributes(t, o),
            canReuseView: (t) => !e.has(o.mapper.toModelElement(t)),
          }
          this._firedEventsMap.set(o, new Map())
          return o
        }
      }
      function Vb(t, e, n) {
        const o = e.getRange()
        const i = Array.from(t.getAncestors())
        i.shift()
        i.reverse()
        const r = i.some((t) => {
          if (o.containsItem(t)) {
            const e = n.toViewElement(t)
            return !!e.getCustomProperty('addHighlight')
          }
        })
        return !r
      }
      function Fb(t, e) {
        const n = e.item.is('element') ? e.item.name : '$text'
        return `${t}:${n}`
      }
      function jb(t) {
        const e = t.item
        const n = Pb._createFromPositionAndShift(t.previousPosition, t.length)
        return { item: e, range: n }
      }
      class Hb extends K(kb) {
        constructor(...t) {
          super()
          this._lastRangeBackward = false
          this._attrs = new Map()
          this._ranges = []
          if (t.length) {
            this.setTo(...t)
          }
        }
        get anchor() {
          if (this._ranges.length > 0) {
            const t = this._ranges[this._ranges.length - 1]
            return this._lastRangeBackward ? t.end : t.start
          }
          return null
        }
        get focus() {
          if (this._ranges.length > 0) {
            const t = this._ranges[this._ranges.length - 1]
            return this._lastRangeBackward ? t.start : t.end
          }
          return null
        }
        get isCollapsed() {
          const t = this._ranges.length
          if (t === 1) {
            return this._ranges[0].isCollapsed
          } else {
            return false
          }
        }
        get rangeCount() {
          return this._ranges.length
        }
        get isBackward() {
          return !this.isCollapsed && this._lastRangeBackward
        }
        isEqual(t) {
          if (this.rangeCount != t.rangeCount) {
            return false
          } else if (this.rangeCount === 0) {
            return true
          }
          if (!this.anchor.isEqual(t.anchor) || !this.focus.isEqual(t.focus)) {
            return false
          }
          for (const e of this._ranges) {
            let n = false
            for (const o of t._ranges) {
              if (e.isEqual(o)) {
                n = true
                break
              }
            }
            if (!n) {
              return false
            }
          }
          return true
        }
        *getRanges() {
          for (const t of this._ranges) {
            yield new Pb(t.start, t.end)
          }
        }
        getFirstRange() {
          let t = null
          for (const e of this._ranges) {
            if (!t || e.start.isBefore(t.start)) {
              t = e
            }
          }
          return t ? new Pb(t.start, t.end) : null
        }
        getLastRange() {
          let t = null
          for (const e of this._ranges) {
            if (!t || e.end.isAfter(t.end)) {
              t = e
            }
          }
          return t ? new Pb(t.start, t.end) : null
        }
        getFirstPosition() {
          const t = this.getFirstRange()
          return t ? t.start.clone() : null
        }
        getLastPosition() {
          const t = this.getLastRange()
          return t ? t.end.clone() : null
        }
        setTo(...t) {
          let [e, n, o] = t
          if (typeof n == 'object') {
            o = n
            n = undefined
          }
          if (e === null) {
            this._setRanges([])
          } else if (e instanceof Hb) {
            this._setRanges(e.getRanges(), e.isBackward)
          } else if (e && typeof e.getRanges == 'function') {
            this._setRanges(e.getRanges(), e.isBackward)
          } else if (e instanceof Pb) {
            this._setRanges([e], !!o && !!o.backward)
          } else if (e instanceof Db) {
            this._setRanges([new Pb(e)])
          } else if (e instanceof wb) {
            const t = !!o && !!o.backward
            let i
            if (n == 'in') {
              i = Pb._createIn(e)
            } else if (n == 'on') {
              i = Pb._createOn(e)
            } else if (n !== undefined) {
              i = new Pb(Db._createAt(e, n))
            } else {
              throw new P('model-selection-setto-required-second-parameter', [this, e])
            }
            this._setRanges([i], t)
          } else if (Tt(e)) {
            this._setRanges(e, o && !!o.backward)
          } else {
            throw new P('model-selection-setto-not-selectable', [this, e])
          }
        }
        _setRanges(t, e = false) {
          const n = Array.from(t)
          const o = n.some((e) => {
            if (!(e instanceof Pb)) {
              throw new P('model-selection-set-ranges-not-range', [this, t])
            }
            return this._ranges.every((t) => !t.isEqual(e))
          })
          if (n.length === this._ranges.length && !o) {
            return
          }
          this._replaceAllRanges(n)
          this._lastRangeBackward = !!e
          this.fire('change:range', { directChange: true })
        }
        setFocus(t, e) {
          if (this.anchor === null) {
            throw new P('model-selection-setfocus-no-ranges', [this, t])
          }
          const n = Db._createAt(t, e)
          if (n.compareWith(this.focus) == 'same') {
            return
          }
          const o = this.anchor
          if (this._ranges.length) {
            this._popRange()
          }
          if (n.compareWith(o) == 'before') {
            this._pushRange(new Pb(n, o))
            this._lastRangeBackward = true
          } else {
            this._pushRange(new Pb(o, n))
            this._lastRangeBackward = false
          }
          this.fire('change:range', { directChange: true })
        }
        getAttribute(t) {
          return this._attrs.get(t)
        }
        getAttributes() {
          return this._attrs.entries()
        }
        getAttributeKeys() {
          return this._attrs.keys()
        }
        hasAttribute(t) {
          return this._attrs.has(t)
        }
        removeAttribute(t) {
          if (this.hasAttribute(t)) {
            this._attrs.delete(t)
            this.fire('change:attribute', { attributeKeys: [t], directChange: true })
          }
        }
        setAttribute(t, e) {
          if (this.getAttribute(t) !== e) {
            this._attrs.set(t, e)
            this.fire('change:attribute', { attributeKeys: [t], directChange: true })
          }
        }
        getSelectedElement() {
          if (this.rangeCount !== 1) {
            return null
          }
          return this.getFirstRange().getContainedElement()
        }
        *getSelectedBlocks() {
          const t = new WeakSet()
          for (const e of this.getRanges()) {
            const n = Gb(e.start, t)
            if ($b(n, e)) {
              yield n
            }
            for (const n of e.getWalker()) {
              const o = n.item
              if (n.type == 'elementEnd' && Wb(o, t, e)) {
                yield o
              }
            }
            const o = Gb(e.end, t)
            if (Kb(o, e)) {
              yield o
            }
          }
        }
        containsEntireContent(t = this.anchor.root) {
          const e = Db._createAt(t, 0)
          const n = Db._createAt(t, 'end')
          return e.isTouching(this.getFirstPosition()) && n.isTouching(this.getLastPosition())
        }
        _pushRange(t) {
          this._checkRange(t)
          this._ranges.push(new Pb(t.start, t.end))
        }
        _checkRange(t) {
          for (let e = 0; e < this._ranges.length; e++) {
            if (t.isIntersecting(this._ranges[e])) {
              throw new P('model-selection-range-intersects', [this, t], {
                addedRange: t,
                intersectingRange: this._ranges[e],
              })
            }
          }
        }
        _replaceAllRanges(t) {
          this._removeAllRanges()
          for (const e of t) {
            this._pushRange(e)
          }
        }
        _removeAllRanges() {
          while (this._ranges.length > 0) {
            this._popRange()
          }
        }
        _popRange() {
          this._ranges.pop()
        }
      }
      Hb.prototype.is = function (t) {
        return t === 'selection' || t === 'model:selection'
      }
      function Ub(t, e) {
        if (e.has(t)) {
          return false
        }
        e.add(t)
        return t.root.document.model.schema.isBlock(t) && !!t.parent
      }
      function Wb(t, e, n) {
        return Ub(t, e) && qb(t, n)
      }
      function Gb(t, e) {
        const n = t.parent
        const o = n.root.document.model.schema
        const i = t.parent.getAncestors({ parentFirst: true, includeSelf: true })
        let r = false
        const s = i.find((t) => {
          if (r) {
            return false
          }
          r = o.isLimit(t)
          return !r && Ub(t, e)
        })
        i.forEach((t) => e.add(t))
        return s
      }
      function qb(t, e) {
        const n = Yb(t)
        if (!n) {
          return true
        }
        const o = e.containsRange(Pb._createOn(n), true)
        return !o
      }
      function $b(t, e) {
        if (!t) {
          return false
        }
        if (e.isCollapsed || t.isEmpty) {
          return true
        }
        if (e.start.isTouching(Db._createAt(t, t.maxOffset))) {
          return false
        }
        return qb(t, e)
      }
      function Kb(t, e) {
        if (!t) {
          return false
        }
        if (e.isCollapsed || t.isEmpty) {
          return true
        }
        if (e.end.isTouching(Db._createAt(t, 0))) {
          return false
        }
        return qb(t, e)
      }
      function Yb(t) {
        const e = t.root.document.model.schema
        let n = t.parent
        while (n) {
          if (e.isBlock(n)) {
            return n
          }
          n = n.parent
        }
      }
      class Zb extends K(Pb) {
        constructor(t, e) {
          super(t, e)
          Qb.call(this)
        }
        detach() {
          this.stopListening()
        }
        toRange() {
          return new Pb(this.start, this.end)
        }
        static fromRange(t) {
          return new Zb(t.start, t.end)
        }
      }
      Zb.prototype.is = function (t) {
        return t === 'liveRange' || t === 'model:liveRange' || t == 'range' || t === 'model:range'
      }
      function Qb() {
        this.listenTo(
          this.root.document.model,
          'applyOperation',
          (t, e) => {
            const n = e[0]
            if (!n.isDocumentOperation) {
              return
            }
            Jb.call(this, n)
          },
          { priority: 'low' },
        )
      }
      function Jb(t) {
        const e = this.getTransformedByOperation(t)
        const n = Pb._createFromRanges(e)
        const o = !n.isEqual(this)
        const i = Xb(this, t)
        let r = null
        if (o) {
          if (n.root.rootName == '$graveyard') {
            if (t.type == 'remove') {
              r = t.sourcePosition
            } else {
              r = t.deletionPosition
            }
          }
          const e = this.toRange()
          this.start = n.start
          this.end = n.end
          this.fire('change:range', e, { deletionPosition: r })
        } else if (i) {
          this.fire('change:content', this.toRange(), { deletionPosition: r })
        }
      }
      function Xb(t, e) {
        switch (e.type) {
          case 'insert':
            return t.containsPosition(e.position)
          case 'move':
          case 'remove':
          case 'reinsert':
          case 'merge':
            return (
              t.containsPosition(e.sourcePosition) ||
              t.start.isEqual(e.sourcePosition) ||
              t.containsPosition(e.targetPosition)
            )
          case 'split':
            return t.containsPosition(e.splitPosition) || t.containsPosition(e.insertionPosition)
        }
        return false
      }
      const tk = 'selection:'
      class ek extends K(kb) {
        constructor(t) {
          super()
          this._selection = new nk(t)
          this._selection.delegate('change:range').to(this)
          this._selection.delegate('change:attribute').to(this)
          this._selection.delegate('change:marker').to(this)
        }
        get isCollapsed() {
          return this._selection.isCollapsed
        }
        get anchor() {
          return this._selection.anchor
        }
        get focus() {
          return this._selection.focus
        }
        get rangeCount() {
          return this._selection.rangeCount
        }
        get hasOwnRange() {
          return this._selection.hasOwnRange
        }
        get isBackward() {
          return this._selection.isBackward
        }
        get isGravityOverridden() {
          return this._selection.isGravityOverridden
        }
        get markers() {
          return this._selection.markers
        }
        get _ranges() {
          return this._selection._ranges
        }
        getRanges() {
          return this._selection.getRanges()
        }
        getFirstPosition() {
          return this._selection.getFirstPosition()
        }
        getLastPosition() {
          return this._selection.getLastPosition()
        }
        getFirstRange() {
          return this._selection.getFirstRange()
        }
        getLastRange() {
          return this._selection.getLastRange()
        }
        getSelectedBlocks() {
          return this._selection.getSelectedBlocks()
        }
        getSelectedElement() {
          return this._selection.getSelectedElement()
        }
        containsEntireContent(t) {
          return this._selection.containsEntireContent(t)
        }
        destroy() {
          this._selection.destroy()
        }
        getAttributeKeys() {
          return this._selection.getAttributeKeys()
        }
        getAttributes() {
          return this._selection.getAttributes()
        }
        getAttribute(t) {
          return this._selection.getAttribute(t)
        }
        hasAttribute(t) {
          return this._selection.hasAttribute(t)
        }
        refresh() {
          this._selection.updateMarkers()
          this._selection._updateAttributes(false)
        }
        observeMarkers(t) {
          this._selection.observeMarkers(t)
        }
        _setFocus(t, e) {
          this._selection.setFocus(t, e)
        }
        _setTo(...t) {
          this._selection.setTo(...t)
        }
        _setAttribute(t, e) {
          this._selection.setAttribute(t, e)
        }
        _removeAttribute(t) {
          this._selection.removeAttribute(t)
        }
        _getStoredAttributes() {
          return this._selection.getStoredAttributes()
        }
        _overrideGravity() {
          return this._selection.overrideGravity()
        }
        _restoreGravity(t) {
          this._selection.restoreGravity(t)
        }
        static _getStoreAttributeKey(t) {
          return tk + t
        }
        static _isStoreAttributeKey(t) {
          return t.startsWith(tk)
        }
      }
      ek.prototype.is = function (t) {
        return t === 'selection' || t == 'model:selection' || t == 'documentSelection' || t == 'model:documentSelection'
      }
      class nk extends Hb {
        constructor(t) {
          super()
          this.markers = new pl({ idProperty: 'name' })
          this._attributePriority = new Map()
          this._selectionRestorePosition = null
          this._hasChangedRange = false
          this._overriddenGravityRegister = new Set()
          this._observedMarkers = new Set()
          this._model = t.model
          this._document = t
          this.listenTo(
            this._model,
            'applyOperation',
            (t, e) => {
              const n = e[0]
              if (!n.isDocumentOperation || n.type == 'marker' || n.type == 'rename' || n.type == 'noop') {
                return
              }
              if (this._ranges.length == 0 && this._selectionRestorePosition) {
                this._fixGraveyardSelection(this._selectionRestorePosition)
              }
              this._selectionRestorePosition = null
              if (this._hasChangedRange) {
                this._hasChangedRange = false
                this.fire('change:range', { directChange: false })
              }
            },
            { priority: 'lowest' },
          )
          this.on('change:range', () => {
            this._validateSelectionRanges(this.getRanges())
          })
          this.listenTo(this._model.markers, 'update', (t, e, n, o) => {
            this._updateMarker(e, o)
          })
          this.listenTo(this._document, 'change', (t, e) => {
            ik(this._model, e)
          })
        }
        get isCollapsed() {
          const t = this._ranges.length
          return t === 0 ? this._document._getDefaultRange().isCollapsed : super.isCollapsed
        }
        get anchor() {
          return super.anchor || this._document._getDefaultRange().start
        }
        get focus() {
          return super.focus || this._document._getDefaultRange().end
        }
        get rangeCount() {
          return this._ranges.length ? this._ranges.length : 1
        }
        get hasOwnRange() {
          return this._ranges.length > 0
        }
        get isGravityOverridden() {
          return !!this._overriddenGravityRegister.size
        }
        destroy() {
          for (let t = 0; t < this._ranges.length; t++) {
            this._ranges[t].detach()
          }
          this.stopListening()
        }
        *getRanges() {
          if (this._ranges.length) {
            yield* super.getRanges()
          } else {
            yield this._document._getDefaultRange()
          }
        }
        getFirstRange() {
          return super.getFirstRange() || this._document._getDefaultRange()
        }
        getLastRange() {
          return super.getLastRange() || this._document._getDefaultRange()
        }
        setTo(...t) {
          super.setTo(...t)
          this._updateAttributes(true)
          this.updateMarkers()
        }
        setFocus(t, e) {
          super.setFocus(t, e)
          this._updateAttributes(true)
          this.updateMarkers()
        }
        setAttribute(t, e) {
          if (this._setAttribute(t, e)) {
            const e = [t]
            this.fire('change:attribute', { attributeKeys: e, directChange: true })
          }
        }
        removeAttribute(t) {
          if (this._removeAttribute(t)) {
            const e = [t]
            this.fire('change:attribute', { attributeKeys: e, directChange: true })
          }
        }
        overrideGravity() {
          const t = I()
          this._overriddenGravityRegister.add(t)
          if (this._overriddenGravityRegister.size === 1) {
            this._updateAttributes(true)
          }
          return t
        }
        restoreGravity(t) {
          if (!this._overriddenGravityRegister.has(t)) {
            throw new P('document-selection-gravity-wrong-restore', this, { uid: t })
          }
          this._overriddenGravityRegister.delete(t)
          if (!this.isGravityOverridden) {
            this._updateAttributes(true)
          }
        }
        observeMarkers(t) {
          this._observedMarkers.add(t)
          this.updateMarkers()
        }
        _replaceAllRanges(t) {
          this._validateSelectionRanges(t)
          super._replaceAllRanges(t)
        }
        _popRange() {
          this._ranges.pop().detach()
        }
        _pushRange(t) {
          const e = this._prepareRange(t)
          if (e) {
            this._ranges.push(e)
          }
        }
        _validateSelectionRanges(t) {
          for (const e of t) {
            if (!this._document._validateSelectionRange(e)) {
              throw new P('document-selection-wrong-position', this, { range: e })
            }
          }
        }
        _prepareRange(t) {
          this._checkRange(t)
          if (t.root == this._document.graveyard) {
            return
          }
          const e = Zb.fromRange(t)
          e.on('change:range', (t, n, o) => {
            this._hasChangedRange = true
            if (e.root == this._document.graveyard) {
              this._selectionRestorePosition = o.deletionPosition
              const t = this._ranges.indexOf(e)
              this._ranges.splice(t, 1)
              e.detach()
            }
          })
          return e
        }
        updateMarkers() {
          if (!this._observedMarkers.size) {
            return
          }
          const t = []
          let e = false
          for (const e of this._model.markers) {
            const n = e.name.split(':', 1)[0]
            if (!this._observedMarkers.has(n)) {
              continue
            }
            const o = e.getRange()
            for (const n of this.getRanges()) {
              if (o.containsRange(n, !n.isCollapsed)) {
                t.push(e)
              }
            }
          }
          const n = Array.from(this.markers)
          for (const n of t) {
            if (!this.markers.has(n)) {
              this.markers.add(n)
              e = true
            }
          }
          for (const n of Array.from(this.markers)) {
            if (!t.includes(n)) {
              this.markers.remove(n)
              e = true
            }
          }
          if (e) {
            this.fire('change:marker', { oldMarkers: n, directChange: false })
          }
        }
        _updateMarker(t, e) {
          const n = t.name.split(':', 1)[0]
          if (!this._observedMarkers.has(n)) {
            return
          }
          let o = false
          const i = Array.from(this.markers)
          const r = this.markers.has(t)
          if (!e) {
            if (r) {
              this.markers.remove(t)
              o = true
            }
          } else {
            let n = false
            for (const t of this.getRanges()) {
              if (e.containsRange(t, !t.isCollapsed)) {
                n = true
                break
              }
            }
            if (n && !r) {
              this.markers.add(t)
              o = true
            } else if (!n && r) {
              this.markers.remove(t)
              o = true
            }
          }
          if (o) {
            this.fire('change:marker', { oldMarkers: i, directChange: false })
          }
        }
        _updateAttributes(t) {
          const e = _l(this._getSurroundingAttributes())
          const n = _l(this.getAttributes())
          if (t) {
            this._attributePriority = new Map()
            this._attrs = new Map()
          } else {
            for (const [t, e] of this._attributePriority) {
              if (e == 'low') {
                this._attrs.delete(t)
                this._attributePriority.delete(t)
              }
            }
          }
          this._setAttributesTo(e)
          const o = []
          for (const [t, e] of this.getAttributes()) {
            if (!n.has(t) || n.get(t) !== e) {
              o.push(t)
            }
          }
          for (const [t] of n) {
            if (!this.hasAttribute(t)) {
              o.push(t)
            }
          }
          if (o.length > 0) {
            this.fire('change:attribute', { attributeKeys: o, directChange: false })
          }
        }
        _setAttribute(t, e, n = true) {
          const o = n ? 'normal' : 'low'
          if (o == 'low' && this._attributePriority.get(t) == 'normal') {
            return false
          }
          const i = super.getAttribute(t)
          if (i === e) {
            return false
          }
          this._attrs.set(t, e)
          this._attributePriority.set(t, o)
          return true
        }
        _removeAttribute(t, e = true) {
          const n = e ? 'normal' : 'low'
          if (n == 'low' && this._attributePriority.get(t) == 'normal') {
            return false
          }
          this._attributePriority.set(t, n)
          if (!super.hasAttribute(t)) {
            return false
          }
          this._attrs.delete(t)
          return true
        }
        _setAttributesTo(t) {
          const e = new Set()
          for (const [e, n] of this.getAttributes()) {
            if (t.get(e) === n) {
              continue
            }
            this._removeAttribute(e, false)
          }
          for (const [n, o] of t) {
            const t = this._setAttribute(n, o, false)
            if (t) {
              e.add(n)
            }
          }
          return e
        }
        *getStoredAttributes() {
          const t = this.getFirstPosition().parent
          if (this.isCollapsed && t.isEmpty) {
            for (const e of t.getAttributeKeys()) {
              if (e.startsWith(tk)) {
                const n = e.substr(tk.length)
                yield [n, t.getAttribute(e)]
              }
            }
          }
        }
        _getSurroundingAttributes() {
          const t = this.getFirstPosition()
          const e = this._model.schema
          if (t.root.rootName == '$graveyard') {
            return null
          }
          let n = null
          if (!this.isCollapsed) {
            const t = this.getFirstRange()
            for (const o of t) {
              if (o.item.is('element') && e.isObject(o.item)) {
                n = ok(o.item, e)
                break
              }
              if (o.type == 'text') {
                n = o.item.getAttributes()
                break
              }
            }
          } else {
            const o = t.textNode ? t.textNode : t.nodeBefore
            const i = t.textNode ? t.textNode : t.nodeAfter
            if (!this.isGravityOverridden) {
              n = ok(o, e)
            }
            if (!n) {
              n = ok(i, e)
            }
            if (!this.isGravityOverridden && !n) {
              let t = o
              while (t && !n) {
                t = t.previousSibling
                n = ok(t, e)
              }
            }
            if (!n) {
              let t = i
              while (t && !n) {
                t = t.nextSibling
                n = ok(t, e)
              }
            }
            if (!n) {
              n = this.getStoredAttributes()
            }
          }
          return n
        }
        _fixGraveyardSelection(t) {
          const e = this._model.schema.getNearestSelectionRange(t)
          if (e) {
            this._pushRange(e)
          }
        }
      }
      function ok(t, e) {
        if (!t) {
          return null
        }
        if (t instanceof Cb || t instanceof _b) {
          return t.getAttributes()
        }
        if (!e.isInline(t)) {
          return null
        }
        if (!e.isObject(t)) {
          return []
        }
        const n = []
        for (const [o, i] of t.getAttributes()) {
          if (e.checkAttribute('$text', o) && e.getAttributeProperties(o).copyFromObject !== false) {
            n.push([o, i])
          }
        }
        return n
      }
      function ik(t, e) {
        const n = t.document.differ
        for (const o of n.getChanges()) {
          if (o.type != 'insert') {
            continue
          }
          const n = o.position.parent
          const i = o.length === n.maxOffset
          if (i) {
            t.enqueueChange(e, (t) => {
              const e = Array.from(n.getAttributeKeys()).filter((t) => t.startsWith(tk))
              for (const o of e) {
                t.removeAttribute(o, n)
              }
            })
          }
        }
      }
      class rk {
        constructor(t) {
          this._dispatchers = t
        }
        add(t) {
          for (const e of this._dispatchers) {
            t(e)
          }
          return this
        }
      }
      class sk extends rk {
        elementToElement(t) {
          return this.add(Tk(t))
        }
        elementToStructure(t) {
          return this.add(Ik(t))
        }
        attributeToElement(t) {
          return this.add(Sk(t))
        }
        attributeToAttribute(t) {
          return this.add(Mk(t))
        }
        markerToElement(t) {
          return this.add(Bk(t))
        }
        markerToHighlight(t) {
          return this.add(Pk(t))
        }
        markerToData(t) {
          return this.add(Nk(t))
        }
      }
      function ak() {
        return (t, e, n) => {
          if (!n.consumable.consume(e.item, t.name)) {
            return
          }
          const o = n.writer
          const i = n.mapper.toViewPosition(e.range.start)
          const r = o.createText(e.item.data)
          o.insert(i, r)
        }
      }
      function ck() {
        return (t, e, n) => {
          n.convertAttributes(e.item)
          if (!e.reconversion && e.item.is('element') && !e.item.isEmpty) {
            n.convertChildren(e.item)
          }
        }
      }
      function lk() {
        return (t, e, n) => {
          const o = n.mapper.toViewPosition(e.position)
          const i = e.position.getShiftedBy(e.length)
          const r = n.mapper.toViewPosition(i, { isPhantom: true })
          const s = n.writer.createRange(o, r)
          const a = n.writer.remove(s.getTrimmed())
          for (const t of n.writer.createRangeIn(a).getItems()) {
            n.mapper.unbindViewElement(t, { defer: true })
          }
        }
      }
      function dk(t, e) {
        const n = t.createAttributeElement('span', e.attributes)
        if (e.classes) {
          n._addClass(e.classes)
        }
        if (typeof e.priority === 'number') {
          n._priority = e.priority
        }
        n._id = e.id
        return n
      }
      function uk() {
        return (t, e, n) => {
          const o = e.selection
          if (o.isCollapsed) {
            return
          }
          if (!n.consumable.consume(o, 'selection')) {
            return
          }
          const i = []
          for (const t of o.getRanges()) {
            i.push(n.mapper.toViewRange(t))
          }
          n.writer.setSelection(i, { backward: o.isBackward })
        }
      }
      function hk() {
        return (t, e, n) => {
          const o = e.selection
          if (!o.isCollapsed) {
            return
          }
          if (!n.consumable.consume(o, 'selection')) {
            return
          }
          const i = n.writer
          const r = o.getFirstPosition()
          const s = n.mapper.toViewPosition(r)
          const a = i.breakAttributes(s)
          i.setSelection(a)
        }
      }
      function gk() {
        return (t, e, n) => {
          const o = n.writer
          const i = o.document.selection
          for (const t of i.getRanges()) {
            if (t.isCollapsed) {
              if (t.end.parent.isAttached()) {
                n.writer.mergeAttributes(t.start)
              }
            }
          }
          o.setSelection(null)
        }
      }
      function fk(t) {
        return (e, n, o) => {
          if (!o.consumable.test(n.item, e.name)) {
            return
          }
          const i = t(n.attributeOldValue, o, n)
          const r = t(n.attributeNewValue, o, n)
          if (!i && !r) {
            return
          }
          o.consumable.consume(n.item, e.name)
          const s = o.writer
          const a = s.document.selection
          if (n.item instanceof Hb || n.item instanceof ek) {
            s.wrap(a.getFirstRange(), r)
          } else {
            let t = o.mapper.toViewRange(n.range)
            if (n.attributeOldValue !== null && i) {
              t = s.unwrap(t, i)
            }
            if (n.attributeNewValue !== null && r) {
              s.wrap(t, r)
            }
          }
        }
      }
      function mk(t, e = Yk) {
        return (n, o, i) => {
          if (!e(o.item, i.consumable, { preflight: true })) {
            return
          }
          const r = t(o.item, i, o)
          if (!r) {
            return
          }
          e(o.item, i.consumable)
          const s = i.mapper.toViewPosition(o.range.start)
          i.mapper.bindElements(o.item, r)
          i.writer.insert(s, r)
          i.convertAttributes(o.item)
          $k(r, o.item.getChildren(), i, { reconversion: o.reconversion })
        }
      }
      function pk(t, e) {
        return (n, o, i) => {
          if (!e(o.item, i.consumable, { preflight: true })) {
            return
          }
          const r = new Map()
          i.writer._registerSlotFactory(Wk(o.item, r, i))
          const s = t(o.item, i, o)
          i.writer._clearSlotFactory()
          if (!s) {
            return
          }
          Gk(o.item, r, i)
          e(o.item, i.consumable)
          const a = i.mapper.toViewPosition(o.range.start)
          i.mapper.bindElements(o.item, s)
          i.writer.insert(a, s)
          i.convertAttributes(o.item)
          qk(s, r, i, { reconversion: o.reconversion })
        }
      }
      function bk(t) {
        return (e, n, o) => {
          n.isOpening = true
          const i = t(n, o)
          n.isOpening = false
          const r = t(n, o)
          if (!i || !r) {
            return
          }
          const s = n.markerRange
          if (s.isCollapsed && !o.consumable.consume(s, e.name)) {
            return
          }
          for (const t of s) {
            if (!o.consumable.consume(t.item, e.name)) {
              return
            }
          }
          const a = o.mapper
          const c = o.writer
          c.insert(a.toViewPosition(s.start), i)
          o.mapper.bindElementToMarker(i, n.markerName)
          if (!s.isCollapsed) {
            c.insert(a.toViewPosition(s.end), r)
            o.mapper.bindElementToMarker(r, n.markerName)
          }
          e.stop()
        }
      }
      function kk() {
        return (t, e, n) => {
          const o = n.mapper.markerNameToElements(e.markerName)
          if (!o) {
            return
          }
          for (const t of o) {
            n.mapper.unbindElementFromMarkerName(t, e.markerName)
            n.writer.clear(n.writer.createRangeOn(t), t)
          }
          n.writer.clearClonedElementsGroup(e.markerName)
          t.stop()
        }
      }
      function wk(t) {
        return (e, n, o) => {
          const i = t(n.markerName, o)
          if (!i) {
            return
          }
          const r = n.markerRange
          if (!o.consumable.consume(r, e.name)) {
            return
          }
          Ak(r, false, o, n, i)
          Ak(r, true, o, n, i)
          e.stop()
        }
      }
      function Ak(t, e, n, o, i) {
        const r = e ? t.start : t.end
        const s = r.nodeAfter && r.nodeAfter.is('element') ? r.nodeAfter : null
        const a = r.nodeBefore && r.nodeBefore.is('element') ? r.nodeBefore : null
        if (s || a) {
          let t
          let r
          if ((e && s) || (!e && !a)) {
            t = s
            r = true
          } else {
            t = a
            r = false
          }
          const c = n.mapper.toViewElement(t)
          if (c) {
            _k(c, e, r, n, o, i)
            return
          }
        }
        const c = n.mapper.toViewPosition(r)
        Ck(c, e, n, o, i)
      }
      function _k(t, e, n, o, i, r) {
        const s = `data-${r.group}-${e ? 'start' : 'end'}-${n ? 'before' : 'after'}`
        const a = t.hasAttribute(s) ? t.getAttribute(s).split(',') : []
        a.unshift(r.name)
        o.writer.setAttribute(s, a.join(','), t)
        o.mapper.bindElementToMarker(t, i.markerName)
      }
      function Ck(t, e, n, o, i) {
        const r = `${i.group}-${e ? 'start' : 'end'}`
        const s = i.name ? { name: i.name } : null
        const a = n.writer.createUIElement(r, s)
        n.writer.insert(t, a)
        n.mapper.bindElementToMarker(a, o.markerName)
      }
      function vk(t) {
        return (e, n, o) => {
          const i = t(n.markerName, o)
          if (!i) {
            return
          }
          const r = o.mapper.markerNameToElements(n.markerName)
          if (!r) {
            return
          }
          for (const t of r) {
            o.mapper.unbindElementFromMarkerName(t, n.markerName)
            if (t.is('containerElement')) {
              s(`data-${i.group}-start-before`, t)
              s(`data-${i.group}-start-after`, t)
              s(`data-${i.group}-end-before`, t)
              s(`data-${i.group}-end-after`, t)
            } else {
              o.writer.clear(o.writer.createRangeOn(t), t)
            }
          }
          o.writer.clearClonedElementsGroup(n.markerName)
          e.stop()
          function s(t, e) {
            if (e.hasAttribute(t)) {
              const n = new Set(e.getAttribute(t).split(','))
              n.delete(i.name)
              if (n.size == 0) {
                o.writer.removeAttribute(t, e)
              } else {
                o.writer.setAttribute(t, Array.from(n).join(','), e)
              }
            }
          }
        }
      }
      function yk(t) {
        return (e, n, o) => {
          if (!o.consumable.test(n.item, e.name)) {
            return
          }
          const i = t(n.attributeOldValue, o, n)
          const r = t(n.attributeNewValue, o, n)
          if (!i && !r) {
            return
          }
          o.consumable.consume(n.item, e.name)
          const s = o.mapper.toViewElement(n.item)
          const a = o.writer
          if (!s) {
            throw new P('conversion-attribute-to-attribute-on-text', o.dispatcher, n)
          }
          if (n.attributeOldValue !== null && i) {
            if (i.key == 'class') {
              const t = sl(i.value)
              for (const e of t) {
                a.removeClass(e, s)
              }
            } else if (i.key == 'style') {
              const t = Object.keys(i.value)
              for (const e of t) {
                a.removeStyle(e, s)
              }
            } else {
              a.removeAttribute(i.key, s)
            }
          }
          if (n.attributeNewValue !== null && r) {
            if (r.key == 'class') {
              const t = sl(r.value)
              for (const e of t) {
                a.addClass(e, s)
              }
            } else if (r.key == 'style') {
              const t = Object.keys(r.value)
              for (const e of t) {
                a.setStyle(e, r.value[e], s)
              }
            } else {
              a.setAttribute(r.key, r.value, s)
            }
          }
        }
      }
      function xk(t) {
        return (e, n, o) => {
          if (!n.item) {
            return
          }
          if (!(n.item instanceof Hb || n.item instanceof ek) && !n.item.is('$textProxy')) {
            return
          }
          const i = Fk(t, n, o)
          if (!i) {
            return
          }
          if (!o.consumable.consume(n.item, e.name)) {
            return
          }
          const r = o.writer
          const s = dk(r, i)
          const a = r.document.selection
          if (n.item instanceof Hb || n.item instanceof ek) {
            r.wrap(a.getFirstRange(), s)
          } else {
            const t = o.mapper.toViewRange(n.range)
            const e = r.wrap(t, s)
            for (const t of e.getItems()) {
              if (t.is('attributeElement') && t.isSimilar(s)) {
                o.mapper.bindElementToMarker(t, n.markerName)
                break
              }
            }
          }
        }
      }
      function Ek(t) {
        return (e, n, o) => {
          if (!n.item) {
            return
          }
          if (!(n.item instanceof vb)) {
            return
          }
          const i = Fk(t, n, o)
          if (!i) {
            return
          }
          if (!o.consumable.test(n.item, e.name)) {
            return
          }
          const r = o.mapper.toViewElement(n.item)
          if (r && r.getCustomProperty('addHighlight')) {
            o.consumable.consume(n.item, e.name)
            for (const t of Pb._createIn(n.item)) {
              o.consumable.consume(t.item, e.name)
            }
            const t = r.getCustomProperty('addHighlight')
            t(r, i, o.writer)
            o.mapper.bindElementToMarker(r, n.markerName)
          }
        }
      }
      function Dk(t) {
        return (e, n, o) => {
          if (n.markerRange.isCollapsed) {
            return
          }
          const i = Fk(t, n, o)
          if (!i) {
            return
          }
          const r = dk(o.writer, i)
          const s = o.mapper.markerNameToElements(n.markerName)
          if (!s) {
            return
          }
          for (const t of s) {
            o.mapper.unbindElementFromMarkerName(t, n.markerName)
            if (t.is('attributeElement')) {
              o.writer.unwrap(o.writer.createRangeOn(t), r)
            } else {
              const e = t.getCustomProperty('removeHighlight')
              e(t, i.id, o.writer)
            }
          }
          o.writer.clearClonedElementsGroup(n.markerName)
          e.stop()
        }
      }
      function Tk(t) {
        const e = Lk(t.model)
        const n = zk(t.view, 'container')
        if (e.attributes.length) {
          e.children = true
        }
        return (o) => {
          o.on(`insert:${e.name}`, mk(n, Uk(e)), { priority: t.converterPriority || 'normal' })
          if (e.children || e.attributes.length) {
            o.on('reduceChanges', Hk(e), { priority: 'low' })
          }
        }
      }
      function Ik(t) {
        const e = Lk(t.model)
        const n = zk(t.view, 'container')
        e.children = true
        return (o) => {
          if (o._conversionApi.schema.checkChild(e.name, '$text')) {
            throw new P('conversion-element-to-structure-disallowed-text', o, { elementName: e.name })
          }
          o.on(`insert:${e.name}`, pk(n, Uk(e)), { priority: t.converterPriority || 'normal' })
          o.on('reduceChanges', Hk(e), { priority: 'low' })
        }
      }
      function Sk(t) {
        t = pb(t)
        let e = t.model
        if (typeof e == 'string') {
          e = { key: e }
        }
        let n = `attribute:${e.key}`
        if (e.name) {
          n += ':' + e.name
        }
        if (e.values) {
          for (const n of e.values) {
            t.view[n] = zk(t.view[n], 'attribute')
          }
        } else {
          t.view = zk(t.view, 'attribute')
        }
        const o = Ok(t)
        return (e) => {
          e.on(n, fk(o), { priority: t.converterPriority || 'normal' })
        }
      }
      function Mk(t) {
        t = pb(t)
        let e = t.model
        if (typeof e == 'string') {
          e = { key: e }
        }
        let n = `attribute:${e.key}`
        if (e.name) {
          n += ':' + e.name
        }
        if (e.values) {
          for (const n of e.values) {
            t.view[n] = Vk(t.view[n])
          }
        } else {
          t.view = Vk(t.view)
        }
        const o = Ok(t)
        return (e) => {
          e.on(n, yk(o), { priority: t.converterPriority || 'normal' })
        }
      }
      function Bk(t) {
        const e = zk(t.view, 'ui')
        return (n) => {
          n.on(`addMarker:${t.model}`, bk(e), { priority: t.converterPriority || 'normal' })
          n.on(`removeMarker:${t.model}`, kk(), { priority: t.converterPriority || 'normal' })
        }
      }
      function Nk(t) {
        t = pb(t)
        const e = t.model
        let n = t.view
        if (!n) {
          n = (n) => ({ group: e, name: n.substr(t.model.length + 1) })
        }
        return (o) => {
          o.on(`addMarker:${e}`, wk(n), { priority: t.converterPriority || 'normal' })
          o.on(`removeMarker:${e}`, vk(n), { priority: t.converterPriority || 'normal' })
        }
      }
      function Pk(t) {
        return (e) => {
          e.on(`addMarker:${t.model}`, xk(t.view), { priority: t.converterPriority || 'normal' })
          e.on(`addMarker:${t.model}`, Ek(t.view), { priority: t.converterPriority || 'normal' })
          e.on(`removeMarker:${t.model}`, Dk(t.view), { priority: t.converterPriority || 'normal' })
        }
      }
      function Lk(t) {
        if (typeof t == 'string') {
          t = { name: t }
        }
        if (!t.attributes) {
          t.attributes = []
        } else if (!Array.isArray(t.attributes)) {
          t.attributes = [t.attributes]
        }
        t.children = !!t.children
        return t
      }
      function zk(t, e) {
        if (typeof t == 'function') {
          return t
        }
        return (n, o) => Rk(t, o, e)
      }
      function Rk(t, e, n) {
        if (typeof t == 'string') {
          t = { name: t }
        }
        let o
        const i = e.writer
        const r = Object.assign({}, t.attributes)
        if (n == 'container') {
          o = i.createContainerElement(t.name, r)
        } else if (n == 'attribute') {
          const e = { priority: t.priority || xf.DEFAULT_PRIORITY }
          o = i.createAttributeElement(t.name, r, e)
        } else {
          o = i.createUIElement(t.name, r)
        }
        if (t.styles) {
          const e = Object.keys(t.styles)
          for (const n of e) {
            i.setStyle(n, t.styles[n], o)
          }
        }
        if (t.classes) {
          const e = t.classes
          if (typeof e == 'string') {
            i.addClass(e, o)
          } else {
            for (const t of e) {
              i.addClass(t, o)
            }
          }
        }
        return o
      }
      function Ok(t) {
        if (t.model.values) {
          return (e, n, o) => {
            const i = t.view[e]
            if (i) {
              return i(e, n, o)
            }
            return null
          }
        } else {
          return t.view
        }
      }
      function Vk(t) {
        if (typeof t == 'string') {
          return (e) => ({ key: t, value: e })
        } else if (typeof t == 'object') {
          if (t.value) {
            return () => t
          } else {
            return (e) => ({ key: t.key, value: e })
          }
        } else {
          return t
        }
      }
      function Fk(t, e, n) {
        const o = typeof t == 'function' ? t(e, n) : t
        if (!o) {
          return null
        }
        if (!o.priority) {
          o.priority = 10
        }
        if (!o.id) {
          o.id = e.markerName
        }
        return o
      }
      function jk(t) {
        return (e, n) => {
          if (!e.is('element', t.name)) {
            return false
          }
          if (n.type == 'attribute') {
            if (t.attributes.includes(n.attributeKey)) {
              return true
            }
          } else {
            if (t.children) {
              return true
            }
          }
          return false
        }
      }
      function Hk(t) {
        const e = jk(t)
        return (t, n) => {
          const o = []
          if (!n.reconvertedElements) {
            n.reconvertedElements = new Set()
          }
          for (const t of n.changes) {
            const i = t.type == 'attribute' ? t.range.start.nodeAfter : t.position.parent
            if (!i || !e(i, t)) {
              o.push(t)
              continue
            }
            if (!n.reconvertedElements.has(i)) {
              n.reconvertedElements.add(i)
              const t = Db._createBefore(i)
              let e = o.length
              for (let n = o.length - 1; n >= 0; n--) {
                const i = o[n]
                const r = i.type == 'attribute' ? i.range.start : i.position
                const s = r.compareWith(t)
                if (s == 'before' || (i.type == 'remove' && s == 'same')) {
                  break
                }
                e = n
              }
              o.splice(
                e,
                0,
                { type: 'remove', name: i.name, position: t, length: 1 },
                { type: 'reinsert', name: i.name, position: t, length: 1 },
              )
            }
          }
          n.changes = o
        }
      }
      function Uk(t) {
        return (e, n, o = {}) => {
          const i = ['insert']
          for (const n of t.attributes) {
            if (e.hasAttribute(n)) {
              i.push(`attribute:${n}`)
            }
          }
          if (!i.every((t) => n.test(e, t))) {
            return false
          }
          if (!o.preflight) {
            i.forEach((t) => n.consume(e, t))
          }
          return true
        }
      }
      function Wk(t, e, n) {
        return (o, i) => {
          const r = o.createContainerElement('$slot')
          let s = null
          if (i === 'children') {
            s = Array.from(t.getChildren())
          } else if (typeof i == 'function') {
            s = Array.from(t.getChildren()).filter((t) => i(t))
          } else {
            throw new P('conversion-slot-mode-unknown', n.dispatcher, { modeOrFilter: i })
          }
          e.set(r, s)
          return r
        }
      }
      function Gk(t, e, n) {
        const o = Array.from(e.values()).flat()
        const i = new Set(o)
        if (i.size != o.length) {
          throw new P('conversion-slot-filter-overlap', n.dispatcher, { element: t })
        }
        if (i.size != t.childCount) {
          throw new P('conversion-slot-filter-incomplete', n.dispatcher, { element: t })
        }
      }
      function qk(t, e, n, o) {
        n.mapper.on('modelToViewPosition', s, { priority: 'highest' })
        let i = null
        let r = null
        for ([i, r] of e) {
          $k(t, r, n, o)
          n.writer.move(n.writer.createRangeIn(i), n.writer.createPositionBefore(i))
          n.writer.remove(i)
        }
        n.mapper.off('modelToViewPosition', s)
        function s(t, e) {
          const n = e.modelPosition.nodeAfter
          const o = r.indexOf(n)
          if (o < 0) {
            return
          }
          e.viewPosition = e.mapper.findPositionIn(i, o)
        }
      }
      function $k(t, e, n, o) {
        for (const i of e) {
          if (!Kk(t.root, i, n, o)) {
            n.convertItem(i)
          }
        }
      }
      function Kk(t, e, n, o) {
        const { writer: i, mapper: r } = n
        if (!o.reconversion) {
          return false
        }
        const s = r.toViewElement(e)
        if (!s || s.root == t) {
          return false
        }
        if (!n.canReuseView(s)) {
          return false
        }
        i.move(i.createRangeOn(s), r.toViewPosition(Db._createBefore(e)))
        return true
      }
      function Yk(t, e, { preflight: n } = {}) {
        if (n) {
          return e.test(t, 'insert')
        } else {
          return e.consume(t, 'insert')
        }
      }
      function Zk(t) {
        const { schema: e, document: n } = t.model
        for (const o of n.getRoots()) {
          if (o.isEmpty && !e.checkChild(o, '$text')) {
            if (e.checkChild(o, 'paragraph')) {
              t.insertElement('paragraph', o)
              return true
            }
          }
        }
        return false
      }
      function Qk(t, e, n) {
        const o = n.createContext(t)
        if (!n.checkChild(o, 'paragraph')) {
          return false
        }
        if (!n.checkChild(o.push('paragraph'), e)) {
          return false
        }
        return true
      }
      function Jk(t, e) {
        const n = e.createElement('paragraph')
        e.insert(n, t)
        return e.createPositionAt(n, 0)
      }
      class Xk extends rk {
        elementToElement(t) {
          return this.add(ow(t))
        }
        elementToAttribute(t) {
          return this.add(iw(t))
        }
        attributeToAttribute(t) {
          return this.add(rw(t))
        }
        elementToMarker(t) {
          return this.add(sw(t))
        }
        dataToMarker(t) {
          return this.add(aw(t))
        }
      }
      function tw() {
        return (t, e, n) => {
          if (!e.modelRange && n.consumable.consume(e.viewItem, { name: true })) {
            const { modelRange: t, modelCursor: o } = n.convertChildren(e.viewItem, e.modelCursor)
            e.modelRange = t
            e.modelCursor = o
          }
        }
      }
      function ew() {
        return (t, e, { schema: n, consumable: o, writer: i }) => {
          let r = e.modelCursor
          if (!o.test(e.viewItem)) {
            return
          }
          if (!n.checkChild(r, '$text')) {
            if (!Qk(r, '$text', n)) {
              return
            }
            if (e.viewItem.data.trim().length == 0) {
              return
            }
            const t = r.nodeBefore
            r = Jk(r, i)
            if (t && t.is('element', '$marker')) {
              i.move(i.createRangeOn(t), r)
              r = i.createPositionAfter(t)
            }
          }
          o.consume(e.viewItem)
          const s = i.createText(e.viewItem.data)
          i.insert(s, r)
          e.modelRange = i.createRange(r, r.getShiftedBy(s.offsetSize))
          e.modelCursor = e.modelRange.end
        }
      }
      function nw(t, e) {
        return (n, o) => {
          const i = o.newSelection
          const r = []
          for (const t of i.getRanges()) {
            r.push(e.toModelRange(t))
          }
          const s = t.createSelection(r, { backward: i.isBackward })
          if (!s.isEqual(t.document.selection)) {
            t.change((t) => {
              t.setSelection(s)
            })
          }
        }
      }
      function ow(t) {
        t = pb(t)
        const e = dw(t)
        const n = lw(t.view)
        const o = n ? `element:${n}` : 'element'
        return (n) => {
          n.on(o, e, { priority: t.converterPriority || 'normal' })
        }
      }
      function iw(t) {
        t = pb(t)
        gw(t)
        const e = fw(t, false)
        const n = lw(t.view)
        const o = n ? `element:${n}` : 'element'
        return (n) => {
          n.on(o, e, { priority: t.converterPriority || 'low' })
        }
      }
      function rw(t) {
        t = pb(t)
        let e = null
        if (typeof t.view == 'string' || t.view.key) {
          e = hw(t)
        }
        gw(t, e)
        const n = fw(t, true)
        return (e) => {
          e.on('element', n, { priority: t.converterPriority || 'low' })
        }
      }
      function sw(t) {
        const e = bw(t.model)
        return ow({ ...t, model: e })
      }
      function aw(t) {
        t = pb(t)
        if (!t.model) {
          t.model = (e) => (e ? t.view + ':' + e : t.view)
        }
        const e = { view: t.view, model: t.model }
        const n = dw(kw(e, 'start'))
        const o = dw(kw(e, 'end'))
        return (i) => {
          i.on(`element:${t.view}-start`, n, { priority: t.converterPriority || 'normal' })
          i.on(`element:${t.view}-end`, o, { priority: t.converterPriority || 'normal' })
          const r = M.low
          const s = M.highest
          const a = M.get(t.converterPriority) / s
          i.on('element', cw(e), { priority: r + a })
        }
      }
      function cw(t) {
        return (e, n, o) => {
          const i = `data-${t.view}`
          if (
            !o.consumable.test(n.viewItem, { attributes: i + '-end-after' }) &&
            !o.consumable.test(n.viewItem, { attributes: i + '-start-after' }) &&
            !o.consumable.test(n.viewItem, { attributes: i + '-end-before' }) &&
            !o.consumable.test(n.viewItem, { attributes: i + '-start-before' })
          ) {
            return
          }
          if (!n.modelRange) {
            Object.assign(n, o.convertChildren(n.viewItem, n.modelCursor))
          }
          if (o.consumable.consume(n.viewItem, { attributes: i + '-end-after' })) {
            r(n.modelRange.end, n.viewItem.getAttribute(i + '-end-after').split(','))
          }
          if (o.consumable.consume(n.viewItem, { attributes: i + '-start-after' })) {
            r(n.modelRange.end, n.viewItem.getAttribute(i + '-start-after').split(','))
          }
          if (o.consumable.consume(n.viewItem, { attributes: i + '-end-before' })) {
            r(n.modelRange.start, n.viewItem.getAttribute(i + '-end-before').split(','))
          }
          if (o.consumable.consume(n.viewItem, { attributes: i + '-start-before' })) {
            r(n.modelRange.start, n.viewItem.getAttribute(i + '-start-before').split(','))
          }
          function r(e, i) {
            for (const r of i) {
              const i = t.model(r, o)
              const s = o.writer.createElement('$marker', { 'data-name': i })
              o.writer.insert(s, e)
              if (n.modelCursor.isEqual(e)) {
                n.modelCursor = n.modelCursor.getShiftedBy(1)
              } else {
                n.modelCursor = n.modelCursor._getTransformedByInsertion(e, 1)
              }
              n.modelRange = n.modelRange._getTransformedByInsertion(e, 1)[0]
            }
          }
        }
      }
      function lw(t) {
        if (typeof t == 'string') {
          return t
        }
        if (typeof t == 'object' && typeof t.name == 'string') {
          return t.name
        }
        return null
      }
      function dw(t) {
        const e = new eh(t.view)
        return (n, o, i) => {
          const r = e.match(o.viewItem)
          if (!r) {
            return
          }
          const s = r.match
          s.name = true
          if (!i.consumable.test(o.viewItem, s)) {
            return
          }
          const a = uw(t.model, o.viewItem, i)
          if (!a) {
            return
          }
          if (!i.safeInsert(a, o.modelCursor)) {
            return
          }
          i.consumable.consume(o.viewItem, s)
          i.convertChildren(o.viewItem, a)
          i.updateConversionResult(a, o)
        }
      }
      function uw(t, e, n) {
        if (t instanceof Function) {
          return t(e, n)
        } else {
          return n.writer.createElement(t)
        }
      }
      function hw(t) {
        if (typeof t.view == 'string') {
          t.view = { key: t.view }
        }
        const e = t.view.key
        let n
        if (e == 'class' || e == 'style') {
          const o = e == 'class' ? 'classes' : 'styles'
          n = { [o]: t.view.value }
        } else {
          const o = typeof t.view.value == 'undefined' ? /[\s\S]*/ : t.view.value
          n = { attributes: { [e]: o } }
        }
        if (t.view.name) {
          n.name = t.view.name
        }
        t.view = n
        return e
      }
      function gw(t, e = null) {
        const n = e === null ? true : (t) => t.getAttribute(e)
        const o = typeof t.model != 'object' ? t.model : t.model.key
        const i = typeof t.model != 'object' || typeof t.model.value == 'undefined' ? n : t.model.value
        t.model = { key: o, value: i }
      }
      function fw(t, e) {
        const n = new eh(t.view)
        return (o, i, r) => {
          if (!i.modelRange && e) {
            return
          }
          const s = n.match(i.viewItem)
          if (!s) {
            return
          }
          if (mw(t.view, i.viewItem)) {
            s.match.name = true
          } else {
            delete s.match.name
          }
          if (!r.consumable.test(i.viewItem, s.match)) {
            return
          }
          const a = t.model.key
          const c = typeof t.model.value == 'function' ? t.model.value(i.viewItem, r) : t.model.value
          if (c === null) {
            return
          }
          if (!i.modelRange) {
            Object.assign(i, r.convertChildren(i.viewItem, i.modelCursor))
          }
          const l = pw(i.modelRange, { key: a, value: c }, e, r)
          if (l) {
            if (r.consumable.test(i.viewItem, { name: true })) {
              s.match.name = true
            }
            r.consumable.consume(i.viewItem, s.match)
          }
        }
      }
      function mw(t, e) {
        const n = typeof t == 'function' ? t(e) : t
        if (typeof n == 'object' && !lw(n)) {
          return false
        }
        return !n.classes && !n.attributes && !n.styles
      }
      function pw(t, e, n, o) {
        let i = false
        for (const r of Array.from(t.getItems({ shallow: n }))) {
          if (!o.schema.checkAttribute(r, e.key)) {
            continue
          }
          i = true
          if (r.hasAttribute(e.key)) {
            continue
          }
          o.writer.setAttribute(e.key, e.value, r)
        }
        return i
      }
      function bw(t) {
        return (e, n) => {
          const o = typeof t == 'string' ? t : t(e, n)
          return n.writer.createElement('$marker', { 'data-name': o })
        }
      }
      function kw(t, e) {
        const n = (e, n) => {
          const o = e.getAttribute('name')
          const i = t.model(o, n)
          return n.writer.createElement('$marker', { 'data-name': i })
        }
        return { view: `${t.view}-${e}`, model: n }
      }
      function ww(t) {
        t.document.registerPostFixer((e) => Aw(e, t))
      }
      function Aw(t, e) {
        const n = e.document.selection
        const o = e.schema
        const i = []
        let r = false
        for (const t of n.getRanges()) {
          const e = _w(t, o)
          if (e && !e.isEqual(t)) {
            i.push(e)
            r = true
          } else {
            i.push(t)
          }
        }
        if (r) {
          t.setSelection(Ew(i), { backward: n.isBackward })
        }
        return false
      }
      function _w(t, e) {
        if (t.isCollapsed) {
          return Cw(t, e)
        }
        return vw(t, e)
      }
      function Cw(t, e) {
        const n = t.start
        const o = e.getNearestSelectionRange(n)
        if (!o) {
          const t = n
            .getAncestors()
            .reverse()
            .find((t) => e.isObject(t))
          if (t) {
            return Pb._createOn(t)
          }
          return null
        }
        if (!o.isCollapsed) {
          return o
        }
        const i = o.start
        if (n.isEqual(i)) {
          return null
        }
        return new Pb(i)
      }
      function vw(t, e) {
        const { start: n, end: o } = t
        const i = e.checkChild(n, '$text')
        const r = e.checkChild(o, '$text')
        const s = e.getLimitElement(n)
        const a = e.getLimitElement(o)
        if (s === a) {
          if (i && r) {
            return null
          }
          if (xw(n, o, e)) {
            const t = n.nodeAfter && e.isSelectable(n.nodeAfter)
            const i = t ? null : e.getNearestSelectionRange(n, 'forward')
            const r = o.nodeBefore && e.isSelectable(o.nodeBefore)
            const s = r ? null : e.getNearestSelectionRange(o, 'backward')
            const a = i ? i.start : n
            const c = s ? s.end : o
            return new Pb(a, c)
          }
        }
        const c = s && !s.is('rootElement')
        const l = a && !a.is('rootElement')
        if (c || l) {
          const t = n.nodeAfter && o.nodeBefore && n.nodeAfter.parent === o.nodeBefore.parent
          const i = c && (!t || !Dw(n.nodeAfter, e))
          const r = l && (!t || !Dw(o.nodeBefore, e))
          let d = n
          let u = o
          if (i) {
            d = Db._createBefore(yw(s, e))
          }
          if (r) {
            u = Db._createAfter(yw(a, e))
          }
          return new Pb(d, u)
        }
        return null
      }
      function yw(t, e) {
        let n = t
        let o = n
        while (e.isLimit(o) && o.parent) {
          n = o
          o = o.parent
        }
        return n
      }
      function xw(t, e, n) {
        const o = (t.nodeAfter && !n.isLimit(t.nodeAfter)) || n.checkChild(t, '$text')
        const i = (e.nodeBefore && !n.isLimit(e.nodeBefore)) || n.checkChild(e, '$text')
        return o || i
      }
      function Ew(t) {
        const e = [...t]
        const n = new Set()
        let o = 1
        while (o < e.length) {
          const t = e[o]
          const i = e.slice(0, o)
          for (const [r, s] of i.entries()) {
            if (n.has(r)) {
              continue
            }
            if (t.isEqual(s)) {
              n.add(r)
            } else if (t.isIntersecting(s)) {
              n.add(r)
              n.add(o)
              const i = t.getJoined(s)
              e.push(i)
            }
          }
          o++
        }
        const i = e.filter((t, e) => !n.has(e))
        return i
      }
      function Dw(t, e) {
        return t && e.isSelectable(t)
      }
      class Tw extends ft() {
        constructor(t, e) {
          super()
          this.model = t
          this.view = new bb(e)
          this.mapper = new Lb()
          this.downcastDispatcher = new Ob({ mapper: this.mapper, schema: t.schema })
          const n = this.model.document
          const o = n.selection
          const i = this.model.markers
          this.listenTo(
            this.model,
            '_beforeChanges',
            () => {
              this.view._disableRendering(true)
            },
            { priority: 'highest' },
          )
          this.listenTo(
            this.model,
            '_afterChanges',
            () => {
              this.view._disableRendering(false)
            },
            { priority: 'lowest' },
          )
          this.listenTo(
            n,
            'change',
            () => {
              this.view.change((t) => {
                this.downcastDispatcher.convertChanges(n.differ, i, t)
                this.downcastDispatcher.convertSelection(o, i, t)
              })
            },
            { priority: 'low' },
          )
          this.listenTo(this.view.document, 'selectionChange', nw(this.model, this.mapper))
          this.listenTo(this.view.document, 'beforeinput', Iw(this.mapper, this.model.schema, this.view), {
            priority: 'high',
          })
          this.downcastDispatcher.on('insert:$text', ak(), { priority: 'lowest' })
          this.downcastDispatcher.on('insert', ck(), { priority: 'lowest' })
          this.downcastDispatcher.on('remove', lk(), { priority: 'low' })
          this.downcastDispatcher.on('cleanSelection', gk())
          this.downcastDispatcher.on('selection', uk(), { priority: 'low' })
          this.downcastDispatcher.on('selection', hk(), { priority: 'low' })
          this.view.document.roots.bindTo(this.model.document.roots).using((t) => {
            if (t.rootName == '$graveyard') {
              return null
            }
            const e = new cf(this.view.document, t.name)
            e.rootName = t.rootName
            this.mapper.bindElements(t, e)
            return e
          })
        }
        destroy() {
          this.view.destroy()
          this.stopListening()
        }
        reconvertMarker(t) {
          const e = typeof t == 'string' ? t : t.name
          const n = this.model.markers.get(e)
          if (!n) {
            throw new P('editingcontroller-reconvertmarker-marker-not-exist', this, { markerName: e })
          }
          this.model.change(() => {
            this.model.markers._refresh(n)
          })
        }
        reconvertItem(t) {
          this.model.change(() => {
            this.model.document.differ._refreshItem(t)
          })
        }
      }
      function Iw(t, e, n) {
        return (o, i) => {
          if (n.document.isComposing && !l.isAndroid) {
            return
          }
          for (let n = 0; n < i.targetRanges.length; n++) {
            const o = i.targetRanges[n]
            const r = t.toModelRange(o)
            const s = _w(r, e)
            if (!s || s.isEqual(r)) {
              continue
            }
            i.targetRanges[n] = t.toViewRange(s)
          }
        }
      }
      class Sw {
        constructor() {
          this._consumables = new Map()
        }
        add(t, e) {
          let n
          if (t.is('$text') || t.is('documentFragment')) {
            this._consumables.set(t, true)
            return
          }
          if (!this._consumables.has(t)) {
            n = new Bw(t)
            this._consumables.set(t, n)
          } else {
            n = this._consumables.get(t)
          }
          n.add(e)
        }
        test(t, e) {
          const n = this._consumables.get(t)
          if (n === undefined) {
            return null
          }
          if (t.is('$text') || t.is('documentFragment')) {
            return n
          }
          return n.test(e)
        }
        consume(t, e) {
          if (this.test(t, e)) {
            if (t.is('$text') || t.is('documentFragment')) {
              this._consumables.set(t, false)
            } else {
              this._consumables.get(t).consume(e)
            }
            return true
          }
          return false
        }
        revert(t, e) {
          const n = this._consumables.get(t)
          if (n !== undefined) {
            if (t.is('$text') || t.is('documentFragment')) {
              this._consumables.set(t, true)
            } else {
              n.revert(e)
            }
          }
        }
        static consumablesFromElement(t) {
          const e = { element: t, name: true, attributes: [], classes: [], styles: [] }
          const n = t.getAttributeKeys()
          for (const t of n) {
            if (t == 'style' || t == 'class') {
              continue
            }
            e.attributes.push(t)
          }
          const o = t.getClassNames()
          for (const t of o) {
            e.classes.push(t)
          }
          const i = t.getStyleNames()
          for (const t of i) {
            e.styles.push(t)
          }
          return e
        }
        static createFrom(t, e) {
          if (!e) {
            e = new Sw()
          }
          if (t.is('$text')) {
            e.add(t)
            return e
          }
          if (t.is('element')) {
            e.add(t, Sw.consumablesFromElement(t))
          }
          if (t.is('documentFragment')) {
            e.add(t)
          }
          for (const n of t.getChildren()) {
            e = Sw.createFrom(n, e)
          }
          return e
        }
      }
      const Mw = ['attributes', 'classes', 'styles']
      class Bw {
        constructor(t) {
          this.element = t
          this._canConsumeName = null
          this._consumables = { attributes: new Map(), styles: new Map(), classes: new Map() }
        }
        add(t) {
          if (t.name) {
            this._canConsumeName = true
          }
          for (const e of Mw) {
            if (e in t) {
              this._add(e, t[e])
            }
          }
        }
        test(t) {
          if (t.name && !this._canConsumeName) {
            return this._canConsumeName
          }
          for (const e of Mw) {
            if (e in t) {
              const n = this._test(e, t[e])
              if (n !== true) {
                return n
              }
            }
          }
          return true
        }
        consume(t) {
          if (t.name) {
            this._canConsumeName = false
          }
          for (const e of Mw) {
            if (e in t) {
              this._consume(e, t[e])
            }
          }
        }
        revert(t) {
          if (t.name) {
            this._canConsumeName = true
          }
          for (const e of Mw) {
            if (e in t) {
              this._revert(e, t[e])
            }
          }
        }
        _add(t, e) {
          const n = Jt(e) ? e : [e]
          const o = this._consumables[t]
          for (const e of n) {
            if (t === 'attributes' && (e === 'class' || e === 'style')) {
              throw new P('viewconsumable-invalid-attribute', this)
            }
            o.set(e, true)
            if (t === 'styles') {
              for (const t of this.element.document.stylesProcessor.getRelatedStyles(e)) {
                o.set(t, true)
              }
            }
          }
        }
        _test(t, e) {
          const n = Jt(e) ? e : [e]
          const o = this._consumables[t]
          for (const e of n) {
            if (t === 'attributes' && (e === 'class' || e === 'style')) {
              const t = e == 'class' ? 'classes' : 'styles'
              const n = this._test(t, [...this._consumables[t].keys()])
              if (n !== true) {
                return n
              }
            } else {
              const t = o.get(e)
              if (t === undefined) {
                return null
              }
              if (!t) {
                return false
              }
            }
          }
          return true
        }
        _consume(t, e) {
          const n = Jt(e) ? e : [e]
          const o = this._consumables[t]
          for (const e of n) {
            if (t === 'attributes' && (e === 'class' || e === 'style')) {
              const t = e == 'class' ? 'classes' : 'styles'
              this._consume(t, [...this._consumables[t].keys()])
            } else {
              o.set(e, false)
              if (t == 'styles') {
                for (const t of this.element.document.stylesProcessor.getRelatedStyles(e)) {
                  o.set(t, false)
                }
              }
            }
          }
        }
        _revert(t, e) {
          const n = Jt(e) ? e : [e]
          const o = this._consumables[t]
          for (const e of n) {
            if (t === 'attributes' && (e === 'class' || e === 'style')) {
              const t = e == 'class' ? 'classes' : 'styles'
              this._revert(t, [...this._consumables[t].keys()])
            } else {
              const t = o.get(e)
              if (t === false) {
                o.set(e, true)
              }
            }
          }
        }
      }
      class Nw extends ft() {
        constructor() {
          super()
          this._sourceDefinitions = {}
          this._attributeProperties = {}
          this.decorate('checkChild')
          this.decorate('checkAttribute')
          this.on(
            'checkAttribute',
            (t, e) => {
              e[0] = new Pw(e[0])
            },
            { priority: 'highest' },
          )
          this.on(
            'checkChild',
            (t, e) => {
              e[0] = new Pw(e[0])
              e[1] = this.getDefinition(e[1])
            },
            { priority: 'highest' },
          )
        }
        register(t, e) {
          if (this._sourceDefinitions[t]) {
            throw new P('schema-cannot-register-item-twice', this, { itemName: t })
          }
          this._sourceDefinitions[t] = [Object.assign({}, e)]
          this._clearCache()
        }
        extend(t, e) {
          if (!this._sourceDefinitions[t]) {
            throw new P('schema-cannot-extend-missing-item', this, { itemName: t })
          }
          this._sourceDefinitions[t].push(Object.assign({}, e))
          this._clearCache()
        }
        getDefinitions() {
          if (!this._compiledDefinitions) {
            this._compile()
          }
          return this._compiledDefinitions
        }
        getDefinition(t) {
          let e
          if (typeof t == 'string') {
            e = t
          } else if ('is' in t && (t.is('$text') || t.is('$textProxy'))) {
            e = '$text'
          } else {
            e = t.name
          }
          return this.getDefinitions()[e]
        }
        isRegistered(t) {
          return !!this.getDefinition(t)
        }
        isBlock(t) {
          const e = this.getDefinition(t)
          return !!(e && e.isBlock)
        }
        isLimit(t) {
          const e = this.getDefinition(t)
          if (!e) {
            return false
          }
          return !!(e.isLimit || e.isObject)
        }
        isObject(t) {
          const e = this.getDefinition(t)
          if (!e) {
            return false
          }
          return !!(e.isObject || (e.isLimit && e.isSelectable && e.isContent))
        }
        isInline(t) {
          const e = this.getDefinition(t)
          return !!(e && e.isInline)
        }
        isSelectable(t) {
          const e = this.getDefinition(t)
          if (!e) {
            return false
          }
          return !!(e.isSelectable || e.isObject)
        }
        isContent(t) {
          const e = this.getDefinition(t)
          if (!e) {
            return false
          }
          return !!(e.isContent || e.isObject)
        }
        checkChild(t, e) {
          if (!e) {
            return false
          }
          return this._checkContextMatch(e, t)
        }
        checkAttribute(t, e) {
          const n = this.getDefinition(t.last)
          if (!n) {
            return false
          }
          return n.allowAttributes.includes(e)
        }
        checkMerge(t, e) {
          if (t instanceof Db) {
            const e = t.nodeBefore
            const n = t.nodeAfter
            if (!(e instanceof vb)) {
              throw new P('schema-check-merge-no-element-before', this)
            }
            if (!(n instanceof vb)) {
              throw new P('schema-check-merge-no-element-after', this)
            }
            return this.checkMerge(e, n)
          }
          for (const n of e.getChildren()) {
            if (!this.checkChild(t, n)) {
              return false
            }
          }
          return true
        }
        addChildCheck(t) {
          this.on(
            'checkChild',
            (e, [n, o]) => {
              if (!o) {
                return
              }
              const i = t(n, o)
              if (typeof i == 'boolean') {
                e.stop()
                e.return = i
              }
            },
            { priority: 'high' },
          )
        }
        addAttributeCheck(t) {
          this.on(
            'checkAttribute',
            (e, [n, o]) => {
              const i = t(n, o)
              if (typeof i == 'boolean') {
                e.stop()
                e.return = i
              }
            },
            { priority: 'high' },
          )
        }
        setAttributeProperties(t, e) {
          this._attributeProperties[t] = Object.assign(this.getAttributeProperties(t), e)
        }
        getAttributeProperties(t) {
          return this._attributeProperties[t] || {}
        }
        getLimitElement(t) {
          let e
          if (t instanceof Db) {
            e = t.parent
          } else {
            const n = t instanceof Pb ? [t] : Array.from(t.getRanges())
            e = n.reduce((t, e) => {
              const n = e.getCommonAncestor()
              if (!t) {
                return n
              }
              return t.getCommonAncestor(n, { includeSelf: true })
            }, null)
          }
          while (!this.isLimit(e)) {
            if (e.parent) {
              e = e.parent
            } else {
              break
            }
          }
          return e
        }
        checkAttributeInSelection(t, e) {
          if (t.isCollapsed) {
            const n = t.getFirstPosition()
            const o = [...n.getAncestors(), new _b('', t.getAttributes())]
            return this.checkAttribute(o, e)
          } else {
            const n = t.getRanges()
            for (const t of n) {
              for (const n of t) {
                if (this.checkAttribute(n.item, e)) {
                  return true
                }
              }
            }
          }
          return false
        }
        *getValidRanges(t, e) {
          t = Qw(t)
          for (const n of t) {
            yield* this._getValidRangesForRange(n, e)
          }
        }
        getNearestSelectionRange(t, e = 'both') {
          if (t.root.rootName == '$graveyard') {
            return null
          }
          if (this.checkChild(t, '$text')) {
            return new Pb(t)
          }
          let n, o
          const i =
            t
              .getAncestors()
              .reverse()
              .find((t) => this.isLimit(t)) || t.root
          if (e == 'both' || e == 'backward') {
            n = new xb({ boundaries: Pb._createIn(i), startPosition: t, direction: 'backward' })
          }
          if (e == 'both' || e == 'forward') {
            o = new xb({ boundaries: Pb._createIn(i), startPosition: t })
          }
          for (const t of Zw(n, o)) {
            const e = t.walker == n ? 'elementEnd' : 'elementStart'
            const o = t.value
            if (o.type == e && this.isObject(o.item)) {
              return Pb._createOn(o.item)
            }
            if (this.checkChild(o.nextPosition, '$text')) {
              return new Pb(o.nextPosition)
            }
          }
          return null
        }
        findAllowedParent(t, e) {
          let n = t.parent
          while (n) {
            if (this.checkChild(n, e)) {
              return n
            }
            if (this.isLimit(n)) {
              return null
            }
            n = n.parent
          }
          return null
        }
        setAllowedAttributes(t, e, n) {
          const o = n.model
          for (const [i, r] of Object.entries(e)) {
            if (o.schema.checkAttribute(t, i)) {
              n.setAttribute(i, r, t)
            }
          }
        }
        removeDisallowedAttributes(t, e) {
          for (const n of t) {
            if (n.is('$text')) {
              Jw(this, n, e)
            } else {
              const t = Pb._createIn(n)
              const o = t.getPositions()
              for (const t of o) {
                const n = t.nodeBefore || t.parent
                Jw(this, n, e)
              }
            }
          }
        }
        getAttributesWithProperty(t, e, n) {
          const o = {}
          for (const [i, r] of t.getAttributes()) {
            const t = this.getAttributeProperties(i)
            if (t[e] === undefined) {
              continue
            }
            if (n === undefined || n === t[e]) {
              o[i] = r
            }
          }
          return o
        }
        createContext(t) {
          return new Pw(t)
        }
        _clearCache() {
          this._compiledDefinitions = null
        }
        _compile() {
          const t = {}
          const e = this._sourceDefinitions
          const n = Object.keys(e)
          for (const o of n) {
            t[o] = Lw(e[o], o)
          }
          for (const e of n) {
            zw(t, e)
          }
          for (const e of n) {
            Rw(t, e)
          }
          for (const e of n) {
            Ow(t, e)
          }
          for (const e of n) {
            Vw(t, e)
            Fw(t, e)
          }
          for (const e of n) {
            jw(t, e)
            Hw(t, e)
            Uw(t, e)
          }
          this._compiledDefinitions = t
        }
        _checkContextMatch(t, e, n = e.length - 1) {
          const o = e.getItem(n)
          if (t.allowIn.includes(o.name)) {
            if (n == 0) {
              return true
            } else {
              const t = this.getDefinition(o)
              return this._checkContextMatch(t, e, n - 1)
            }
          } else {
            return false
          }
        }
        *_getValidRangesForRange(t, e) {
          let n = t.start
          let o = t.start
          for (const i of t.getItems({ shallow: true })) {
            if (i.is('element')) {
              yield* this._getValidRangesForRange(Pb._createIn(i), e)
            }
            if (!this.checkAttribute(i, e)) {
              if (!n.isEqual(o)) {
                yield new Pb(n, o)
              }
              n = Db._createAfter(i)
            }
            o = Db._createAfter(i)
          }
          if (!n.isEqual(o)) {
            yield new Pb(n, o)
          }
        }
      }
      class Pw {
        constructor(t) {
          if (t instanceof Pw) {
            return t
          }
          let e
          if (typeof t == 'string') {
            e = [t]
          } else if (!Array.isArray(t)) {
            e = t.getAncestors({ includeSelf: true })
          } else {
            e = t
          }
          this._items = e.map(Yw)
        }
        get length() {
          return this._items.length
        }
        get last() {
          return this._items[this._items.length - 1]
        }
        [Symbol.iterator]() {
          return this._items[Symbol.iterator]()
        }
        push(t) {
          const e = new Pw([t])
          e._items = [...this._items, ...e._items]
          return e
        }
        getItem(t) {
          return this._items[t]
        }
        *getNames() {
          yield* this._items.map((t) => t.name)
        }
        endsWith(t) {
          return Array.from(this.getNames()).join(' ').endsWith(t)
        }
        startsWith(t) {
          return Array.from(this.getNames()).join(' ').startsWith(t)
        }
      }
      function Lw(t, e) {
        const n = {
          name: e,
          allowIn: [],
          allowContentOf: [],
          allowWhere: [],
          allowAttributes: [],
          allowAttributesOf: [],
          allowChildren: [],
          inheritTypesFrom: [],
        }
        Ww(t, n)
        Gw(t, n, 'allowIn')
        Gw(t, n, 'allowContentOf')
        Gw(t, n, 'allowWhere')
        Gw(t, n, 'allowAttributes')
        Gw(t, n, 'allowAttributesOf')
        Gw(t, n, 'allowChildren')
        Gw(t, n, 'inheritTypesFrom')
        qw(t, n)
        return n
      }
      function zw(t, e) {
        const n = t[e]
        for (const o of n.allowChildren) {
          const n = t[o]
          if (!n) {
            continue
          }
          n.allowIn.push(e)
        }
        n.allowChildren.length = 0
      }
      function Rw(t, e) {
        for (const n of t[e].allowContentOf) {
          if (t[n]) {
            const o = $w(t, n)
            o.forEach((t) => {
              t.allowIn.push(e)
            })
          }
        }
        delete t[e].allowContentOf
      }
      function Ow(t, e) {
        for (const n of t[e].allowWhere) {
          const o = t[n]
          if (o) {
            const n = o.allowIn
            t[e].allowIn.push(...n)
          }
        }
        delete t[e].allowWhere
      }
      function Vw(t, e) {
        for (const n of t[e].allowAttributesOf) {
          const o = t[n]
          if (o) {
            const n = o.allowAttributes
            t[e].allowAttributes.push(...n)
          }
        }
        delete t[e].allowAttributesOf
      }
      function Fw(t, e) {
        const n = t[e]
        for (const e of n.inheritTypesFrom) {
          const o = t[e]
          if (o) {
            const t = Object.keys(o).filter((t) => t.startsWith('is'))
            for (const e of t) {
              if (!(e in n)) {
                n[e] = o[e]
              }
            }
          }
        }
        delete n.inheritTypesFrom
      }
      function jw(t, e) {
        const n = t[e]
        const o = n.allowIn.filter((e) => t[e])
        n.allowIn = Array.from(new Set(o))
      }
      function Hw(t, e) {
        const n = t[e]
        for (const o of n.allowIn) {
          const n = t[o]
          n.allowChildren.push(e)
        }
      }
      function Uw(t, e) {
        const n = t[e]
        n.allowAttributes = Array.from(new Set(n.allowAttributes))
      }
      function Ww(t, e) {
        for (const n of t) {
          const t = Object.keys(n).filter((t) => t.startsWith('is'))
          for (const o of t) {
            e[o] = !!n[o]
          }
        }
      }
      function Gw(t, e, n) {
        for (const o of t) {
          const t = o[n]
          if (typeof t == 'string') {
            e[n].push(t)
          } else if (Array.isArray(t)) {
            e[n].push(...t)
          }
        }
      }
      function qw(t, e) {
        for (const n of t) {
          const t = n.inheritAllFrom
          if (t) {
            e.allowContentOf.push(t)
            e.allowWhere.push(t)
            e.allowAttributesOf.push(t)
            e.inheritTypesFrom.push(t)
          }
        }
      }
      function $w(t, e) {
        const n = t[e]
        return Kw(t).filter((t) => t.allowIn.includes(n.name))
      }
      function Kw(t) {
        return Object.keys(t).map((e) => t[e])
      }
      function Yw(t) {
        if (typeof t == 'string' || t.is('documentFragment')) {
          return { name: typeof t == 'string' ? t : '$documentFragment', *getAttributeKeys() {}, getAttribute() {} }
        } else {
          return {
            name: t.is('element') ? t.name : '$text',
            *getAttributeKeys() {
              yield* t.getAttributeKeys()
            },
            getAttribute(e) {
              return t.getAttribute(e)
            },
          }
        }
      }
      function* Zw(t, e) {
        let n = false
        while (!n) {
          n = true
          if (t) {
            const e = t.next()
            if (!e.done) {
              n = false
              yield { walker: t, value: e.value }
            }
          }
          if (e) {
            const t = e.next()
            if (!t.done) {
              n = false
              yield { walker: e, value: t.value }
            }
          }
        }
      }
      function* Qw(t) {
        for (const e of t) {
          yield* e.getMinimalFlatRanges()
        }
      }
      function Jw(t, e, n) {
        for (const o of e.getAttributeKeys()) {
          if (!t.checkAttribute(e, o)) {
            n.removeAttribute(o, e)
          }
        }
      }
      class Xw extends K() {
        constructor(t) {
          super()
          this._splitParts = new Map()
          this._cursorParents = new Map()
          this._modelCursor = null
          this._emptyElementsToKeep = new Set()
          this.conversionApi = {
            ...t,
            consumable: null,
            writer: null,
            store: null,
            convertItem: (t, e) => this._convertItem(t, e),
            convertChildren: (t, e) => this._convertChildren(t, e),
            safeInsert: (t, e) => this._safeInsert(t, e),
            updateConversionResult: (t, e) => this._updateConversionResult(t, e),
            splitToAllowedParent: (t, e) => this._splitToAllowedParent(t, e),
            getSplitParts: (t) => this._getSplitParts(t),
            keepEmptyElement: (t) => this._keepEmptyElement(t),
          }
        }
        convert(t, e, n = ['$root']) {
          this.fire('viewCleanup', t)
          this._modelCursor = eA(n, e)
          this.conversionApi.writer = e
          this.conversionApi.consumable = Sw.createFrom(t)
          this.conversionApi.store = {}
          const { modelRange: o } = this._convertItem(t, this._modelCursor)
          const i = e.createDocumentFragment()
          if (o) {
            this._removeEmptyElements()
            for (const t of Array.from(this._modelCursor.parent.getChildren())) {
              e.append(t, i)
            }
            i.markers = tA(i, e)
          }
          this._modelCursor = null
          this._splitParts.clear()
          this._cursorParents.clear()
          this._emptyElementsToKeep.clear()
          this.conversionApi.writer = null
          this.conversionApi.store = null
          return i
        }
        _convertItem(t, e) {
          const n = { viewItem: t, modelCursor: e, modelRange: null }
          if (t.is('element')) {
            this.fire(`element:${t.name}`, n, this.conversionApi)
          } else if (t.is('$text')) {
            this.fire('text', n, this.conversionApi)
          } else {
            this.fire('documentFragment', n, this.conversionApi)
          }
          if (n.modelRange && !(n.modelRange instanceof Pb)) {
            throw new P('view-conversion-dispatcher-incorrect-result', this)
          }
          return { modelRange: n.modelRange, modelCursor: n.modelCursor }
        }
        _convertChildren(t, e) {
          let n = e.is('position') ? e : Db._createAt(e, 0)
          const o = new Pb(n)
          for (const e of Array.from(t.getChildren())) {
            const t = this._convertItem(e, n)
            if (t.modelRange instanceof Pb) {
              o.end = t.modelRange.end
              n = t.modelCursor
            }
          }
          return { modelRange: o, modelCursor: n }
        }
        _safeInsert(t, e) {
          const n = this._splitToAllowedParent(t, e)
          if (!n) {
            return false
          }
          this.conversionApi.writer.insert(t, n.position)
          return true
        }
        _updateConversionResult(t, e) {
          const n = this._getSplitParts(t)
          const o = this.conversionApi.writer
          if (!e.modelRange) {
            e.modelRange = o.createRange(o.createPositionBefore(t), o.createPositionAfter(n[n.length - 1]))
          }
          const i = this._cursorParents.get(t)
          if (i) {
            e.modelCursor = o.createPositionAt(i, 0)
          } else {
            e.modelCursor = e.modelRange.end
          }
        }
        _splitToAllowedParent(t, e) {
          const { schema: n, writer: o } = this.conversionApi
          let i = n.findAllowedParent(e, t)
          if (i) {
            if (i === e.parent) {
              return { position: e }
            }
            if (this._modelCursor.parent.getAncestors().includes(i)) {
              i = null
            }
          }
          if (!i) {
            if (!Qk(e, t, n)) {
              return null
            }
            return { position: Jk(e, o) }
          }
          const r = this.conversionApi.writer.split(e, i)
          const s = []
          for (const t of r.range.getWalker()) {
            if (t.type == 'elementEnd') {
              s.push(t.item)
            } else {
              const e = s.pop()
              const n = t.item
              this._registerSplitPair(e, n)
            }
          }
          const a = r.range.end.parent
          this._cursorParents.set(t, a)
          return { position: r.position, cursorParent: a }
        }
        _registerSplitPair(t, e) {
          if (!this._splitParts.has(t)) {
            this._splitParts.set(t, [t])
          }
          const n = this._splitParts.get(t)
          this._splitParts.set(e, n)
          n.push(e)
        }
        _getSplitParts(t) {
          let e
          if (!this._splitParts.has(t)) {
            e = [t]
          } else {
            e = this._splitParts.get(t)
          }
          return e
        }
        _keepEmptyElement(t) {
          this._emptyElementsToKeep.add(t)
        }
        _removeEmptyElements() {
          let t = false
          for (const e of this._splitParts.keys()) {
            if (e.isEmpty && !this._emptyElementsToKeep.has(e)) {
              this.conversionApi.writer.remove(e)
              this._splitParts.delete(e)
              t = true
            }
          }
          if (t) {
            this._removeEmptyElements()
          }
        }
      }
      function tA(t, e) {
        const n = new Set()
        const o = new Map()
        const i = Pb._createIn(t).getItems()
        for (const t of i) {
          if (t.is('element', '$marker')) {
            n.add(t)
          }
        }
        for (const t of n) {
          const n = t.getAttribute('data-name')
          const i = e.createPositionBefore(t)
          if (!o.has(n)) {
            o.set(n, new Pb(i.clone()))
          } else {
            o.get(n).end = i.clone()
          }
          e.remove(t)
        }
        return o
      }
      function eA(t, e) {
        let n
        for (const o of new Pw(t)) {
          const t = {}
          for (const e of o.getAttributeKeys()) {
            t[e] = o.getAttribute(e)
          }
          const i = e.createElement(o.name, t)
          if (n) {
            e.insert(i, n)
          }
          n = Db._createAt(i, 0)
        }
        return n
      }
      class nA {
        getHtml(t) {
          const e = document.implementation.createHTMLDocument('')
          const n = e.createElement('div')
          n.appendChild(t)
          return n.innerHTML
        }
      }
      class oA {
        constructor(t) {
          this.skipComments = true
          this.domParser = new DOMParser()
          this.domConverter = new xm(t, { renderingMode: 'data' })
          this.htmlWriter = new nA()
        }
        toData(t) {
          const e = this.domConverter.viewToDom(t)
          return this.htmlWriter.getHtml(e)
        }
        toView(t) {
          const e = this._toDom(t)
          return this.domConverter.domToView(e, { skipComments: this.skipComments })
        }
        registerRawContentMatcher(t) {
          this.domConverter.registerRawContentMatcher(t)
        }
        useFillerType(t) {
          this.domConverter.blockFillerMode = t == 'marked' ? 'markedNbsp' : 'nbsp'
        }
        _toDom(t) {
          if (!t.match(/<(?:html|body|head|meta)(?:\s[^>]*)?>/i)) {
            t = `<body>${t}</body>`
          }
          const e = this.domParser.parseFromString(t, 'text/html')
          const n = e.createDocumentFragment()
          const o = e.body.childNodes
          while (o.length > 0) {
            n.appendChild(o[0])
          }
          return n
        }
      }
      class iA extends K() {
        constructor(t, e) {
          super()
          this.model = t
          this.mapper = new Lb()
          this.downcastDispatcher = new Ob({ mapper: this.mapper, schema: t.schema })
          this.downcastDispatcher.on('insert:$text', ak(), { priority: 'lowest' })
          this.downcastDispatcher.on('insert', ck(), { priority: 'lowest' })
          this.upcastDispatcher = new Xw({ schema: t.schema })
          this.viewDocument = new vf(e)
          this.stylesProcessor = e
          this.htmlProcessor = new oA(this.viewDocument)
          this.processor = this.htmlProcessor
          this._viewWriter = new Of(this.viewDocument)
          this.upcastDispatcher.on('text', ew(), { priority: 'lowest' })
          this.upcastDispatcher.on('element', tw(), { priority: 'lowest' })
          this.upcastDispatcher.on('documentFragment', tw(), { priority: 'lowest' })
          ft().prototype.decorate.call(this, 'init')
          ft().prototype.decorate.call(this, 'set')
          ft().prototype.decorate.call(this, 'get')
          ft().prototype.decorate.call(this, 'toView')
          ft().prototype.decorate.call(this, 'toModel')
          this.on(
            'init',
            () => {
              this.fire('ready')
            },
            { priority: 'lowest' },
          )
          this.on(
            'ready',
            () => {
              this.model.enqueueChange({ isUndoable: false }, Zk)
            },
            { priority: 'lowest' },
          )
        }
        get(t = {}) {
          const { rootName: e = 'main', trim: n = 'empty' } = t
          if (!this._checkIfRootsExists([e])) {
            throw new P('datacontroller-get-non-existent-root', this)
          }
          const o = this.model.document.getRoot(e)
          if (!o.isAttached()) {
            L('datacontroller-get-detached-root', this)
          }
          if (n === 'empty' && !this.model.hasContent(o, { ignoreWhitespaces: true })) {
            return ''
          }
          return this.stringify(o, t)
        }
        stringify(t, e = {}) {
          const n = this.toView(t, e)
          return this.processor.toData(n)
        }
        toView(t, e = {}) {
          const n = this.viewDocument
          const o = this._viewWriter
          this.mapper.clearBindings()
          const i = Pb._createIn(t)
          const r = new zf(n)
          this.mapper.bindElements(t, r)
          const s = t.is('documentFragment') ? t.markers : rA(t)
          this.downcastDispatcher.convert(i, s, o, e)
          return r
        }
        init(t) {
          if (this.model.document.version) {
            throw new P('datacontroller-init-document-not-empty', this)
          }
          let e = {}
          if (typeof t === 'string') {
            e.main = t
          } else {
            e = t
          }
          if (!this._checkIfRootsExists(Object.keys(e))) {
            throw new P('datacontroller-init-non-existent-root', this)
          }
          this.model.enqueueChange({ isUndoable: false }, (t) => {
            for (const n of Object.keys(e)) {
              const o = this.model.document.getRoot(n)
              t.insert(this.parse(e[n], o), o, 0)
            }
          })
          return Promise.resolve()
        }
        set(t, e = {}) {
          let n = {}
          if (typeof t === 'string') {
            n.main = t
          } else {
            n = t
          }
          if (!this._checkIfRootsExists(Object.keys(n))) {
            throw new P('datacontroller-set-non-existent-root', this)
          }
          this.model.enqueueChange(e.batchType || {}, (t) => {
            t.setSelection(null)
            t.removeSelectionAttribute(this.model.document.selection.getAttributeKeys())
            for (const e of Object.keys(n)) {
              const o = this.model.document.getRoot(e)
              t.remove(t.createRangeIn(o))
              t.insert(this.parse(n[e], o), o, 0)
            }
          })
        }
        parse(t, e = '$root') {
          const n = this.processor.toView(t)
          return this.toModel(n, e)
        }
        toModel(t, e = '$root') {
          return this.model.change((n) => this.upcastDispatcher.convert(t, n, e))
        }
        addStyleProcessorRules(t) {
          t(this.stylesProcessor)
        }
        registerRawContentMatcher(t) {
          if (this.processor && this.processor !== this.htmlProcessor) {
            this.processor.registerRawContentMatcher(t)
          }
          this.htmlProcessor.registerRawContentMatcher(t)
        }
        destroy() {
          this.stopListening()
        }
        _checkIfRootsExists(t) {
          for (const e of t) {
            if (!this.model.document.getRoot(e)) {
              return false
            }
          }
          return true
        }
      }
      function rA(t) {
        const e = []
        const n = t.root.document
        if (!n) {
          return new Map()
        }
        const o = Pb._createIn(t)
        for (const t of n.model.markers) {
          const n = t.getRange()
          const i = n.isCollapsed
          const r = n.start.isEqual(o.start) || n.end.isEqual(o.end)
          if (i && r) {
            e.push([t.name, n])
          } else {
            const i = o.getIntersection(n)
            if (i) {
              e.push([t.name, i])
            }
          }
        }
        e.sort(([t, e], [n, o]) => {
          if (e.end.compareWith(o.start) !== 'after') {
            return 1
          } else if (e.start.compareWith(o.end) !== 'before') {
            return -1
          } else {
            switch (e.start.compareWith(o.start)) {
              case 'before':
                return 1
              case 'after':
                return -1
              default:
                switch (e.end.compareWith(o.end)) {
                  case 'before':
                    return 1
                  case 'after':
                    return -1
                  default:
                    return n.localeCompare(t)
                }
            }
          }
        })
        return new Map(e)
      }
      class sA {
        constructor(t, e) {
          this._helpers = new Map()
          this._downcast = sl(t)
          this._createConversionHelpers({ name: 'downcast', dispatchers: this._downcast, isDowncast: true })
          this._upcast = sl(e)
          this._createConversionHelpers({ name: 'upcast', dispatchers: this._upcast, isDowncast: false })
        }
        addAlias(t, e) {
          const n = this._downcast.includes(e)
          const o = this._upcast.includes(e)
          if (!o && !n) {
            throw new P('conversion-add-alias-dispatcher-not-registered', this)
          }
          this._createConversionHelpers({ name: t, dispatchers: [e], isDowncast: n })
        }
        for(t) {
          if (!this._helpers.has(t)) {
            throw new P('conversion-for-unknown-group', this)
          }
          return this._helpers.get(t)
        }
        elementToElement(t) {
          this.for('downcast').elementToElement(t)
          for (const { model: e, view: n } of aA(t)) {
            this.for('upcast').elementToElement({ model: e, view: n, converterPriority: t.converterPriority })
          }
        }
        attributeToElement(t) {
          this.for('downcast').attributeToElement(t)
          for (const { model: e, view: n } of aA(t)) {
            this.for('upcast').elementToAttribute({ view: n, model: e, converterPriority: t.converterPriority })
          }
        }
        attributeToAttribute(t) {
          this.for('downcast').attributeToAttribute(t)
          for (const { model: e, view: n } of aA(t)) {
            this.for('upcast').attributeToAttribute({ view: n, model: e })
          }
        }
        _createConversionHelpers({ name: t, dispatchers: e, isDowncast: n }) {
          if (this._helpers.has(t)) {
            throw new P('conversion-group-exists', this)
          }
          const o = n ? new sk(e) : new Xk(e)
          this._helpers.set(t, o)
        }
      }
      function* aA(t) {
        if (t.model.values) {
          for (const e of t.model.values) {
            const n = { key: t.model.key, value: e }
            const o = t.view[e]
            const i = t.upcastAlso ? t.upcastAlso[e] : undefined
            yield* cA(n, o, i)
          }
        } else {
          yield* cA(t.model, t.view, t.upcastAlso)
        }
      }
      function* cA(t, e, n) {
        yield { model: t, view: e }
        if (n) {
          for (const e of sl(n)) {
            yield { model: t, view: e }
          }
        }
      }
      class lA {
        constructor(t) {
          this.baseVersion = t
          this.isDocumentOperation = this.baseVersion !== null
          this.batch = null
        }
        _validate() {}
        toJSON() {
          const t = Object.assign({}, this)
          t.__className = this.constructor.className
          delete t.batch
          delete t.isDocumentOperation
          return t
        }
        static get className() {
          return 'Operation'
        }
        static fromJSON(t, e) {
          return new this(t.baseVersion)
        }
      }
      function dA(t, e) {
        const n = fA(e)
        const o = n.reduce((t, e) => t + e.offsetSize, 0)
        const i = t.parent
        pA(t)
        const r = t.index
        i._insertChild(r, n)
        mA(i, r + n.length)
        mA(i, r)
        return new Pb(t, t.getShiftedBy(o))
      }
      function uA(t) {
        if (!t.isFlat) {
          throw new P('operation-utils-remove-range-not-flat', this)
        }
        const e = t.start.parent
        pA(t.start)
        pA(t.end)
        const n = e._removeChildren(t.start.index, t.end.index - t.start.index)
        mA(e, t.start.index)
        return n
      }
      function hA(t, e) {
        if (!t.isFlat) {
          throw new P('operation-utils-move-range-not-flat', this)
        }
        const n = uA(t)
        e = e._getTransformedByDeletion(t.start, t.end.offset - t.start.offset)
        return dA(e, n)
      }
      function gA(t, e, n) {
        pA(t.start)
        pA(t.end)
        for (const o of t.getItems({ shallow: true })) {
          const t = o.is('$textProxy') ? o.textNode : o
          if (n !== null) {
            t._setAttribute(e, n)
          } else {
            t._removeAttribute(e)
          }
          mA(t.parent, t.index)
        }
        mA(t.end.parent, t.end.index)
      }
      function fA(t) {
        const e = []
        function n(t) {
          if (typeof t == 'string') {
            e.push(new _b(t))
          } else if (t instanceof Cb) {
            e.push(new _b(t.data, t.getAttributes()))
          } else if (t instanceof wb) {
            e.push(t)
          } else if (Tt(t)) {
            for (const e of t) {
              n(e)
            }
          }
        }
        n(t)
        for (let t = 1; t < e.length; t++) {
          const n = e[t]
          const o = e[t - 1]
          if (n instanceof _b && o instanceof _b && bA(n, o)) {
            e.splice(t - 1, 2, new _b(o.data + n.data, o.getAttributes()))
            t--
          }
        }
        return e
      }
      function mA(t, e) {
        const n = t.getChild(e - 1)
        const o = t.getChild(e)
        if (n && o && n.is('$text') && o.is('$text') && bA(n, o)) {
          const i = new _b(n.data + o.data, n.getAttributes())
          t._removeChildren(e - 1, 2)
          t._insertChild(e - 1, i)
        }
      }
      function pA(t) {
        const e = t.textNode
        const n = t.parent
        if (e) {
          const o = t.offset - e.startOffset
          const i = e.index
          n._removeChildren(i, 1)
          const r = new _b(e.data.substr(0, o), e.getAttributes())
          const s = new _b(e.data.substr(o), e.getAttributes())
          n._insertChild(i, [r, s])
        }
      }
      function bA(t, e) {
        const n = t.getAttributes()
        const o = e.getAttributes()
        for (const t of n) {
          if (t[1] !== e.getAttribute(t[0])) {
            return false
          }
          o.next()
        }
        return o.next().done
      }
      class kA extends lA {
        constructor(t, e, n, o) {
          super(o)
          this.sourcePosition = t.clone()
          this.sourcePosition.stickiness = 'toNext'
          this.howMany = e
          this.targetPosition = n.clone()
          this.targetPosition.stickiness = 'toNone'
        }
        get type() {
          if (this.targetPosition.root.rootName == '$graveyard') {
            return 'remove'
          } else if (this.sourcePosition.root.rootName == '$graveyard') {
            return 'reinsert'
          }
          return 'move'
        }
        get affectedSelectable() {
          return [
            Pb._createFromPositionAndShift(this.sourcePosition, this.howMany),
            Pb._createFromPositionAndShift(this.targetPosition, 0),
          ]
        }
        clone() {
          return new kA(this.sourcePosition, this.howMany, this.targetPosition, this.baseVersion)
        }
        getMovedRangeStart() {
          return this.targetPosition._getTransformedByDeletion(this.sourcePosition, this.howMany)
        }
        getReversed() {
          const t = this.sourcePosition._getTransformedByInsertion(this.targetPosition, this.howMany)
          return new kA(this.getMovedRangeStart(), this.howMany, t, this.baseVersion + 1)
        }
        _validate() {
          const t = this.sourcePosition.parent
          const e = this.targetPosition.parent
          const n = this.sourcePosition.offset
          const o = this.targetPosition.offset
          if (n + this.howMany > t.maxOffset) {
            throw new P('move-operation-nodes-do-not-exist', this)
          } else if (t === e && n < o && o < n + this.howMany) {
            throw new P('move-operation-range-into-itself', this)
          } else if (this.sourcePosition.root == this.targetPosition.root) {
            if (Dt(this.sourcePosition.getParentPath(), this.targetPosition.getParentPath()) == 'prefix') {
              const t = this.sourcePosition.path.length - 1
              if (this.targetPosition.path[t] >= n && this.targetPosition.path[t] < n + this.howMany) {
                throw new P('move-operation-node-into-itself', this)
              }
            }
          }
        }
        _execute() {
          hA(Pb._createFromPositionAndShift(this.sourcePosition, this.howMany), this.targetPosition)
        }
        toJSON() {
          const t = super.toJSON()
          t.sourcePosition = this.sourcePosition.toJSON()
          t.targetPosition = this.targetPosition.toJSON()
          return t
        }
        static get className() {
          return 'MoveOperation'
        }
        static fromJSON(t, e) {
          const n = Db.fromJSON(t.sourcePosition, e)
          const o = Db.fromJSON(t.targetPosition, e)
          return new this(n, t.howMany, o, t.baseVersion)
        }
      }
      class wA extends lA {
        constructor(t, e, n) {
          super(n)
          this.position = t.clone()
          this.position.stickiness = 'toNone'
          this.nodes = new Ab(fA(e))
          this.shouldReceiveAttributes = false
        }
        get type() {
          return 'insert'
        }
        get howMany() {
          return this.nodes.maxOffset
        }
        get affectedSelectable() {
          return this.position.clone()
        }
        clone() {
          const t = new Ab([...this.nodes].map((t) => t._clone(true)))
          const e = new wA(this.position, t, this.baseVersion)
          e.shouldReceiveAttributes = this.shouldReceiveAttributes
          return e
        }
        getReversed() {
          const t = this.position.root.document.graveyard
          const e = new Db(t, [0])
          return new kA(this.position, this.nodes.maxOffset, e, this.baseVersion + 1)
        }
        _validate() {
          const t = this.position.parent
          if (!t || t.maxOffset < this.position.offset) {
            throw new P('insert-operation-position-invalid', this)
          }
        }
        _execute() {
          const t = this.nodes
          this.nodes = new Ab([...t].map((t) => t._clone(true)))
          dA(this.position, t)
        }
        toJSON() {
          const t = super.toJSON()
          t.position = this.position.toJSON()
          t.nodes = this.nodes.toJSON()
          return t
        }
        static get className() {
          return 'InsertOperation'
        }
        static fromJSON(t, e) {
          const n = []
          for (const e of t.nodes) {
            if (e.name) {
              n.push(vb.fromJSON(e))
            } else {
              n.push(_b.fromJSON(e))
            }
          }
          const o = new wA(Db.fromJSON(t.position, e), n, t.baseVersion)
          o.shouldReceiveAttributes = t.shouldReceiveAttributes
          return o
        }
      }
      class AA extends lA {
        constructor(t, e, n, o, i) {
          super(i)
          this.splitPosition = t.clone()
          this.splitPosition.stickiness = 'toNext'
          this.howMany = e
          this.insertionPosition = n
          this.graveyardPosition = o ? o.clone() : null
          if (this.graveyardPosition) {
            this.graveyardPosition.stickiness = 'toNext'
          }
        }
        get type() {
          return 'split'
        }
        get moveTargetPosition() {
          const t = this.insertionPosition.path.slice()
          t.push(0)
          return new Db(this.insertionPosition.root, t)
        }
        get movedRange() {
          const t = this.splitPosition.getShiftedBy(Number.POSITIVE_INFINITY)
          return new Pb(this.splitPosition, t)
        }
        get affectedSelectable() {
          const t = [
            Pb._createFromPositionAndShift(this.splitPosition, 0),
            Pb._createFromPositionAndShift(this.insertionPosition, 0),
          ]
          if (this.graveyardPosition) {
            t.push(Pb._createFromPositionAndShift(this.graveyardPosition, 0))
          }
          return t
        }
        clone() {
          return new AA(
            this.splitPosition,
            this.howMany,
            this.insertionPosition,
            this.graveyardPosition,
            this.baseVersion,
          )
        }
        getReversed() {
          const t = this.splitPosition.root.document.graveyard
          const e = new Db(t, [0])
          return new _A(this.moveTargetPosition, this.howMany, this.splitPosition, e, this.baseVersion + 1)
        }
        _validate() {
          const t = this.splitPosition.parent
          const e = this.splitPosition.offset
          if (!t || t.maxOffset < e) {
            throw new P('split-operation-position-invalid', this)
          } else if (!t.parent) {
            throw new P('split-operation-split-in-root', this)
          } else if (this.howMany != t.maxOffset - this.splitPosition.offset) {
            throw new P('split-operation-how-many-invalid', this)
          } else if (this.graveyardPosition && !this.graveyardPosition.nodeAfter) {
            throw new P('split-operation-graveyard-position-invalid', this)
          }
        }
        _execute() {
          const t = this.splitPosition.parent
          if (this.graveyardPosition) {
            hA(Pb._createFromPositionAndShift(this.graveyardPosition, 1), this.insertionPosition)
          } else {
            const e = t._clone()
            dA(this.insertionPosition, e)
          }
          const e = new Pb(Db._createAt(t, this.splitPosition.offset), Db._createAt(t, t.maxOffset))
          hA(e, this.moveTargetPosition)
        }
        toJSON() {
          const t = super.toJSON()
          t.splitPosition = this.splitPosition.toJSON()
          t.insertionPosition = this.insertionPosition.toJSON()
          if (this.graveyardPosition) {
            t.graveyardPosition = this.graveyardPosition.toJSON()
          }
          return t
        }
        static get className() {
          return 'SplitOperation'
        }
        static getInsertionPosition(t) {
          const e = t.path.slice(0, -1)
          e[e.length - 1]++
          return new Db(t.root, e, 'toPrevious')
        }
        static fromJSON(t, e) {
          const n = Db.fromJSON(t.splitPosition, e)
          const o = Db.fromJSON(t.insertionPosition, e)
          const i = t.graveyardPosition ? Db.fromJSON(t.graveyardPosition, e) : null
          return new this(n, t.howMany, o, i, t.baseVersion)
        }
      }
      class _A extends lA {
        constructor(t, e, n, o, i) {
          super(i)
          this.sourcePosition = t.clone()
          this.sourcePosition.stickiness = 'toPrevious'
          this.howMany = e
          this.targetPosition = n.clone()
          this.targetPosition.stickiness = 'toNext'
          this.graveyardPosition = o.clone()
        }
        get type() {
          return 'merge'
        }
        get deletionPosition() {
          return new Db(this.sourcePosition.root, this.sourcePosition.path.slice(0, -1))
        }
        get movedRange() {
          const t = this.sourcePosition.getShiftedBy(Number.POSITIVE_INFINITY)
          return new Pb(this.sourcePosition, t)
        }
        get affectedSelectable() {
          const t = this.sourcePosition.parent
          return [
            Pb._createOn(t),
            Pb._createFromPositionAndShift(this.targetPosition, 0),
            Pb._createFromPositionAndShift(this.graveyardPosition, 0),
          ]
        }
        clone() {
          return new _A(
            this.sourcePosition,
            this.howMany,
            this.targetPosition,
            this.graveyardPosition,
            this.baseVersion,
          )
        }
        getReversed() {
          const t = this.targetPosition._getTransformedByMergeOperation(this)
          const e = this.sourcePosition.path.slice(0, -1)
          const n = new Db(this.sourcePosition.root, e)._getTransformedByMergeOperation(this)
          return new AA(t, this.howMany, n, this.graveyardPosition, this.baseVersion + 1)
        }
        _validate() {
          const t = this.sourcePosition.parent
          const e = this.targetPosition.parent
          if (!t.parent) {
            throw new P('merge-operation-source-position-invalid', this)
          } else if (!e.parent) {
            throw new P('merge-operation-target-position-invalid', this)
          } else if (this.howMany != t.maxOffset) {
            throw new P('merge-operation-how-many-invalid', this)
          }
        }
        _execute() {
          const t = this.sourcePosition.parent
          const e = Pb._createIn(t)
          hA(e, this.targetPosition)
          hA(Pb._createOn(t), this.graveyardPosition)
        }
        toJSON() {
          const t = super.toJSON()
          t.sourcePosition = t.sourcePosition.toJSON()
          t.targetPosition = t.targetPosition.toJSON()
          t.graveyardPosition = t.graveyardPosition.toJSON()
          return t
        }
        static get className() {
          return 'MergeOperation'
        }
        static fromJSON(t, e) {
          const n = Db.fromJSON(t.sourcePosition, e)
          const o = Db.fromJSON(t.targetPosition, e)
          const i = Db.fromJSON(t.graveyardPosition, e)
          return new this(n, t.howMany, o, i, t.baseVersion)
        }
      }
      class CA extends lA {
        constructor(t, e, n, o, i, r) {
          super(r)
          this.name = t
          this.oldRange = e ? e.clone() : null
          this.newRange = n ? n.clone() : null
          this.affectsData = i
          this._markers = o
        }
        get type() {
          return 'marker'
        }
        get affectedSelectable() {
          const t = []
          if (this.oldRange) {
            t.push(this.oldRange.clone())
          }
          if (this.newRange) {
            if (this.oldRange) {
              t.push(...this.newRange.getDifference(this.oldRange))
            } else {
              t.push(this.newRange.clone())
            }
          }
          return t
        }
        clone() {
          return new CA(this.name, this.oldRange, this.newRange, this._markers, this.affectsData, this.baseVersion)
        }
        getReversed() {
          return new CA(this.name, this.newRange, this.oldRange, this._markers, this.affectsData, this.baseVersion + 1)
        }
        _execute() {
          if (this.newRange) {
            this._markers._set(this.name, this.newRange, true, this.affectsData)
          } else {
            this._markers._remove(this.name)
          }
        }
        toJSON() {
          const t = super.toJSON()
          if (this.oldRange) {
            t.oldRange = this.oldRange.toJSON()
          }
          if (this.newRange) {
            t.newRange = this.newRange.toJSON()
          }
          delete t._markers
          return t
        }
        static get className() {
          return 'MarkerOperation'
        }
        static fromJSON(t, e) {
          return new CA(
            t.name,
            t.oldRange ? Pb.fromJSON(t.oldRange, e) : null,
            t.newRange ? Pb.fromJSON(t.newRange, e) : null,
            e.model.markers,
            t.affectsData,
            t.baseVersion,
          )
        }
      }
      function vA(t, e) {
        return tb(t, e)
      }
      const yA = vA
      class xA extends lA {
        constructor(t, e, n, o, i) {
          super(i)
          this.range = t.clone()
          this.key = e
          this.oldValue = n === undefined ? null : n
          this.newValue = o === undefined ? null : o
        }
        get type() {
          if (this.oldValue === null) {
            return 'addAttribute'
          } else if (this.newValue === null) {
            return 'removeAttribute'
          } else {
            return 'changeAttribute'
          }
        }
        get affectedSelectable() {
          return this.range.clone()
        }
        clone() {
          return new xA(this.range, this.key, this.oldValue, this.newValue, this.baseVersion)
        }
        getReversed() {
          return new xA(this.range, this.key, this.newValue, this.oldValue, this.baseVersion + 1)
        }
        toJSON() {
          const t = super.toJSON()
          t.range = this.range.toJSON()
          return t
        }
        _validate() {
          if (!this.range.isFlat) {
            throw new P('attribute-operation-range-not-flat', this)
          }
          for (const t of this.range.getItems({ shallow: true })) {
            if (this.oldValue !== null && !yA(t.getAttribute(this.key), this.oldValue)) {
              throw new P('attribute-operation-wrong-old-value', this, { item: t, key: this.key, value: this.oldValue })
            }
            if (this.oldValue === null && this.newValue !== null && t.hasAttribute(this.key)) {
              throw new P('attribute-operation-attribute-exists', this, { node: t, key: this.key })
            }
          }
        }
        _execute() {
          if (!yA(this.oldValue, this.newValue)) {
            gA(this.range, this.key, this.newValue)
          }
        }
        static get className() {
          return 'AttributeOperation'
        }
        static fromJSON(t, e) {
          return new xA(Pb.fromJSON(t.range, e), t.key, t.oldValue, t.newValue, t.baseVersion)
        }
      }
      class EA extends lA {
        get type() {
          return 'noop'
        }
        get affectedSelectable() {
          return null
        }
        clone() {
          return new EA(this.baseVersion)
        }
        getReversed() {
          return new EA(this.baseVersion + 1)
        }
        _execute() {}
        static get className() {
          return 'NoOperation'
        }
      }
      class DA extends lA {
        constructor(t, e, n, o) {
          super(o)
          this.position = t
          this.position.stickiness = 'toNext'
          this.oldName = e
          this.newName = n
        }
        get type() {
          return 'rename'
        }
        get affectedSelectable() {
          return this.position.nodeAfter
        }
        clone() {
          return new DA(this.position.clone(), this.oldName, this.newName, this.baseVersion)
        }
        getReversed() {
          return new DA(this.position.clone(), this.newName, this.oldName, this.baseVersion + 1)
        }
        _validate() {
          const t = this.position.nodeAfter
          if (!(t instanceof vb)) {
            throw new P('rename-operation-wrong-position', this)
          } else if (t.name !== this.oldName) {
            throw new P('rename-operation-wrong-name', this)
          }
        }
        _execute() {
          const t = this.position.nodeAfter
          t.name = this.newName
        }
        toJSON() {
          const t = super.toJSON()
          t.position = this.position.toJSON()
          return t
        }
        static get className() {
          return 'RenameOperation'
        }
        static fromJSON(t, e) {
          return new DA(Db.fromJSON(t.position, e), t.oldName, t.newName, t.baseVersion)
        }
      }
      class TA extends lA {
        constructor(t, e, n, o, i) {
          super(i)
          this.root = t
          this.key = e
          this.oldValue = n === undefined ? null : n
          this.newValue = o === undefined ? null : o
        }
        get type() {
          if (this.oldValue === null) {
            return 'addRootAttribute'
          } else if (this.newValue === null) {
            return 'removeRootAttribute'
          } else {
            return 'changeRootAttribute'
          }
        }
        get affectedSelectable() {
          return this.root
        }
        clone() {
          return new TA(this.root, this.key, this.oldValue, this.newValue, this.baseVersion)
        }
        getReversed() {
          return new TA(this.root, this.key, this.newValue, this.oldValue, this.baseVersion + 1)
        }
        _validate() {
          if (this.root != this.root.root || this.root.is('documentFragment')) {
            throw new P('rootattribute-operation-not-a-root', this, { root: this.root, key: this.key })
          }
          if (this.oldValue !== null && this.root.getAttribute(this.key) !== this.oldValue) {
            throw new P('rootattribute-operation-wrong-old-value', this, { root: this.root, key: this.key })
          }
          if (this.oldValue === null && this.newValue !== null && this.root.hasAttribute(this.key)) {
            throw new P('rootattribute-operation-attribute-exists', this, { root: this.root, key: this.key })
          }
        }
        _execute() {
          if (this.newValue !== null) {
            this.root._setAttribute(this.key, this.newValue)
          } else {
            this.root._removeAttribute(this.key)
          }
        }
        toJSON() {
          const t = super.toJSON()
          t.root = this.root.toJSON()
          return t
        }
        static get className() {
          return 'RootAttributeOperation'
        }
        static fromJSON(t, e) {
          if (!e.getRoot(t.root)) {
            throw new P('rootattribute-operation-fromjson-no-root', this, { rootName: t.root })
          }
          return new TA(e.getRoot(t.root), t.key, t.oldValue, t.newValue, t.baseVersion)
        }
      }
      class IA extends lA {
        constructor(t, e, n, o, i) {
          super(i)
          this.rootName = t
          this.elementName = e
          this.isAdd = n
          this._document = o
          if (!this._document.getRoot(this.rootName)) {
            const t = this._document.createRoot(this.elementName, this.rootName)
            t._isAttached = false
          }
        }
        get type() {
          return this.isAdd ? 'addRoot' : 'detachRoot'
        }
        get affectedSelectable() {
          return this._document.getRoot(this.rootName)
        }
        clone() {
          return new IA(this.rootName, this.elementName, this.isAdd, this._document, this.baseVersion)
        }
        getReversed() {
          return new IA(this.rootName, this.elementName, !this.isAdd, this._document, this.baseVersion + 1)
        }
        _execute() {
          this._document.getRoot(this.rootName)._isAttached = this.isAdd
        }
        toJSON() {
          const t = super.toJSON()
          delete t._document
          return t
        }
        static get className() {
          return 'RootOperation'
        }
        static fromJSON(t, e) {
          return new IA(t.rootName, t.elementName, t.isAdd, e, t.baseVersion)
        }
      }
      const SA = {}
      SA[xA.className] = xA
      SA[wA.className] = wA
      SA[CA.className] = CA
      SA[kA.className] = kA
      SA[EA.className] = EA
      SA[lA.className] = lA
      SA[DA.className] = DA
      SA[TA.className] = TA
      SA[IA.className] = IA
      SA[AA.className] = AA
      SA[_A.className] = _A
      class MA {
        static fromJSON(t, e) {
          return SA[t.__className].fromJSON(t, e)
        }
      }
      const BA = new Map()
      function NA(t, e, n) {
        let o = BA.get(t)
        if (!o) {
          o = new Map()
          BA.set(t, o)
        }
        o.set(e, n)
      }
      function PA(t, e) {
        const n = BA.get(t)
        if (n && n.has(e)) {
          return n.get(e)
        }
        return LA
      }
      function LA(t) {
        return [t]
      }
      function zA(t, e, n = {}) {
        const o = PA(t.constructor, e.constructor)
        try {
          t = t.clone()
          return o(t, e, n)
        } catch (t) {
          throw t
        }
      }
      function RA(t, e, n) {
        t = t.slice()
        e = e.slice()
        const o = new OA(n.document, n.useRelations, n.forceWeakRemove)
        o.setOriginalOperations(t)
        o.setOriginalOperations(e)
        const i = o.originalOperations
        if (t.length == 0 || e.length == 0) {
          return { operationsA: t, operationsB: e, originalOperations: i }
        }
        const r = new WeakMap()
        for (const e of t) {
          r.set(e, 0)
        }
        const s = {
          nextBaseVersionA: t[t.length - 1].baseVersion + 1,
          nextBaseVersionB: e[e.length - 1].baseVersion + 1,
          originalOperationsACount: t.length,
          originalOperationsBCount: e.length,
        }
        let a = 0
        while (a < t.length) {
          const n = t[a]
          const i = r.get(n)
          if (i == e.length) {
            a++
            continue
          }
          const s = e[i]
          const c = zA(n, s, o.getContext(n, s, true))
          const l = zA(s, n, o.getContext(s, n, false))
          o.updateRelation(n, s)
          o.setOriginalOperations(c, n)
          o.setOriginalOperations(l, s)
          for (const t of c) {
            r.set(t, i + l.length)
          }
          t.splice(a, 1, ...c)
          e.splice(i, 1, ...l)
        }
        if (n.padWithNoOps) {
          const n = t.length - s.originalOperationsACount
          const o = e.length - s.originalOperationsBCount
          FA(t, o - n)
          FA(e, n - o)
        }
        VA(t, s.nextBaseVersionB)
        VA(e, s.nextBaseVersionA)
        return { operationsA: t, operationsB: e, originalOperations: i }
      }
      class OA {
        constructor(t, e, n = false) {
          this.originalOperations = new Map()
          this._history = t.history
          this._useRelations = e
          this._forceWeakRemove = !!n
          this._relations = new Map()
        }
        setOriginalOperations(t, e = null) {
          const n = e ? this.originalOperations.get(e) : null
          for (const e of t) {
            this.originalOperations.set(e, n || e)
          }
        }
        updateRelation(t, e) {
          if (t instanceof kA) {
            if (e instanceof _A) {
              if (t.targetPosition.isEqual(e.sourcePosition) || e.movedRange.containsPosition(t.targetPosition)) {
                this._setRelation(t, e, 'insertAtSource')
              } else if (t.targetPosition.isEqual(e.deletionPosition)) {
                this._setRelation(t, e, 'insertBetween')
              } else if (t.targetPosition.isAfter(e.sourcePosition)) {
                this._setRelation(t, e, 'moveTargetAfter')
              }
            } else if (e instanceof kA) {
              if (t.targetPosition.isEqual(e.sourcePosition) || t.targetPosition.isBefore(e.sourcePosition)) {
                this._setRelation(t, e, 'insertBefore')
              } else {
                this._setRelation(t, e, 'insertAfter')
              }
            }
          } else if (t instanceof AA) {
            if (e instanceof _A) {
              if (t.splitPosition.isBefore(e.sourcePosition)) {
                this._setRelation(t, e, 'splitBefore')
              }
            } else if (e instanceof kA) {
              if (t.splitPosition.isEqual(e.sourcePosition) || t.splitPosition.isBefore(e.sourcePosition)) {
                this._setRelation(t, e, 'splitBefore')
              } else {
                const n = Pb._createFromPositionAndShift(e.sourcePosition, e.howMany)
                if (t.splitPosition.hasSameParentAs(e.sourcePosition) && n.containsPosition(t.splitPosition)) {
                  const o = n.end.offset - t.splitPosition.offset
                  const i = t.splitPosition.offset - n.start.offset
                  this._setRelation(t, e, { howMany: o, offset: i })
                }
              }
            }
          } else if (t instanceof _A) {
            if (e instanceof _A) {
              if (!t.targetPosition.isEqual(e.sourcePosition)) {
                this._setRelation(t, e, 'mergeTargetNotMoved')
              }
              if (t.sourcePosition.isEqual(e.targetPosition)) {
                this._setRelation(t, e, 'mergeSourceNotMoved')
              }
              if (t.sourcePosition.isEqual(e.sourcePosition)) {
                this._setRelation(t, e, 'mergeSameElement')
              }
            } else if (e instanceof AA) {
              if (t.sourcePosition.isEqual(e.splitPosition)) {
                this._setRelation(t, e, 'splitAtSource')
              }
            }
          } else if (t instanceof CA) {
            const n = t.newRange
            if (!n) {
              return
            }
            if (e instanceof kA) {
              const o = Pb._createFromPositionAndShift(e.sourcePosition, e.howMany)
              const i = o.containsPosition(n.start) || o.start.isEqual(n.start)
              const r = o.containsPosition(n.end) || o.end.isEqual(n.end)
              if ((i || r) && !o.containsRange(n)) {
                this._setRelation(t, e, {
                  side: i ? 'left' : 'right',
                  path: i ? n.start.path.slice() : n.end.path.slice(),
                })
              }
            } else if (e instanceof _A) {
              const o = n.start.isEqual(e.targetPosition)
              const i = n.start.isEqual(e.deletionPosition)
              const r = n.end.isEqual(e.deletionPosition)
              const s = n.end.isEqual(e.sourcePosition)
              if (o || i || r || s) {
                this._setRelation(t, e, {
                  wasInLeftElement: o,
                  wasStartBeforeMergedElement: i,
                  wasEndBeforeMergedElement: r,
                  wasInRightElement: s,
                })
              }
            }
          }
        }
        getContext(t, e, n) {
          return {
            aIsStrong: n,
            aWasUndone: this._wasUndone(t),
            bWasUndone: this._wasUndone(e),
            abRelation: this._useRelations ? this._getRelation(t, e) : null,
            baRelation: this._useRelations ? this._getRelation(e, t) : null,
            forceWeakRemove: this._forceWeakRemove,
          }
        }
        _wasUndone(t) {
          const e = this.originalOperations.get(t)
          return e.wasUndone || this._history.isUndoneOperation(e)
        }
        _getRelation(t, e) {
          const n = this.originalOperations.get(e)
          const o = this._history.getUndoneOperation(n)
          if (!o) {
            return null
          }
          const i = this.originalOperations.get(t)
          const r = this._relations.get(i)
          if (r) {
            return r.get(o) || null
          }
          return null
        }
        _setRelation(t, e, n) {
          const o = this.originalOperations.get(t)
          const i = this.originalOperations.get(e)
          let r = this._relations.get(o)
          if (!r) {
            r = new Map()
            this._relations.set(o, r)
          }
          r.set(i, n)
        }
      }
      function VA(t, e) {
        for (const n of t) {
          n.baseVersion = e++
        }
      }
      function FA(t, e) {
        for (let n = 0; n < e; n++) {
          t.push(new EA(0))
        }
      }
      NA(xA, xA, (t, e, n) => {
        if (t.key === e.key && t.range.start.hasSameParentAs(e.range.start)) {
          const o = t.range.getDifference(e.range).map((e) => new xA(e, t.key, t.oldValue, t.newValue, 0))
          const i = t.range.getIntersection(e.range)
          if (i) {
            if (n.aIsStrong) {
              o.push(new xA(i, e.key, e.newValue, t.newValue, 0))
            }
          }
          if (o.length == 0) {
            return [new EA(0)]
          }
          return o
        } else {
          return [t]
        }
      })
      NA(xA, wA, (t, e) => {
        if (t.range.start.hasSameParentAs(e.position) && t.range.containsPosition(e.position)) {
          const n = t.range._getTransformedByInsertion(e.position, e.howMany, !e.shouldReceiveAttributes)
          const o = n.map((e) => new xA(e, t.key, t.oldValue, t.newValue, t.baseVersion))
          if (e.shouldReceiveAttributes) {
            const n = jA(e, t.key, t.oldValue)
            if (n) {
              o.unshift(n)
            }
          }
          return o
        }
        t.range = t.range._getTransformedByInsertion(e.position, e.howMany, false)[0]
        return [t]
      })
      function jA(t, e, n) {
        const o = t.nodes
        const i = o.getNode(0).getAttribute(e)
        if (i == n) {
          return null
        }
        const r = new Pb(t.position, t.position.getShiftedBy(t.howMany))
        return new xA(r, e, i, n, 0)
      }
      NA(xA, _A, (t, e) => {
        const n = []
        if (t.range.start.hasSameParentAs(e.deletionPosition)) {
          if (t.range.containsPosition(e.deletionPosition) || t.range.start.isEqual(e.deletionPosition)) {
            n.push(Pb._createFromPositionAndShift(e.graveyardPosition, 1))
          }
        }
        const o = t.range._getTransformedByMergeOperation(e)
        if (!o.isCollapsed) {
          n.push(o)
        }
        return n.map((e) => new xA(e, t.key, t.oldValue, t.newValue, t.baseVersion))
      })
      NA(xA, kA, (t, e) => {
        const n = HA(t.range, e)
        return n.map((e) => new xA(e, t.key, t.oldValue, t.newValue, t.baseVersion))
      })
      function HA(t, e) {
        const n = Pb._createFromPositionAndShift(e.sourcePosition, e.howMany)
        let o = null
        let i = []
        if (n.containsRange(t, true)) {
          o = t
        } else if (t.start.hasSameParentAs(n.start)) {
          i = t.getDifference(n)
          o = t.getIntersection(n)
        } else {
          i = [t]
        }
        const r = []
        for (let t of i) {
          t = t._getTransformedByDeletion(e.sourcePosition, e.howMany)
          const n = e.getMovedRangeStart()
          const o = t.start.hasSameParentAs(n)
          const i = t._getTransformedByInsertion(n, e.howMany, o)
          r.push(...i)
        }
        if (o) {
          r.push(o._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany, false)[0])
        }
        return r
      }
      NA(xA, AA, (t, e) => {
        if (t.range.end.isEqual(e.insertionPosition)) {
          if (!e.graveyardPosition) {
            t.range.end.offset++
          }
          return [t]
        }
        if (t.range.start.hasSameParentAs(e.splitPosition) && t.range.containsPosition(e.splitPosition)) {
          const n = t.clone()
          n.range = new Pb(
            e.moveTargetPosition.clone(),
            t.range.end._getCombined(e.splitPosition, e.moveTargetPosition),
          )
          t.range.end = e.splitPosition.clone()
          t.range.end.stickiness = 'toPrevious'
          return [t, n]
        }
        t.range = t.range._getTransformedBySplitOperation(e)
        return [t]
      })
      NA(wA, xA, (t, e) => {
        const n = [t]
        if (
          t.shouldReceiveAttributes &&
          t.position.hasSameParentAs(e.range.start) &&
          e.range.containsPosition(t.position)
        ) {
          const o = jA(t, e.key, e.newValue)
          if (o) {
            n.push(o)
          }
        }
        return n
      })
      NA(wA, wA, (t, e, n) => {
        if (t.position.isEqual(e.position) && n.aIsStrong) {
          return [t]
        }
        t.position = t.position._getTransformedByInsertOperation(e)
        return [t]
      })
      NA(wA, kA, (t, e) => {
        t.position = t.position._getTransformedByMoveOperation(e)
        return [t]
      })
      NA(wA, AA, (t, e) => {
        t.position = t.position._getTransformedBySplitOperation(e)
        return [t]
      })
      NA(wA, _A, (t, e) => {
        t.position = t.position._getTransformedByMergeOperation(e)
        return [t]
      })
      NA(CA, wA, (t, e) => {
        if (t.oldRange) {
          t.oldRange = t.oldRange._getTransformedByInsertOperation(e)[0]
        }
        if (t.newRange) {
          t.newRange = t.newRange._getTransformedByInsertOperation(e)[0]
        }
        return [t]
      })
      NA(CA, CA, (t, e, n) => {
        if (t.name == e.name) {
          if (n.aIsStrong) {
            t.oldRange = e.newRange ? e.newRange.clone() : null
          } else {
            return [new EA(0)]
          }
        }
        return [t]
      })
      NA(CA, _A, (t, e) => {
        if (t.oldRange) {
          t.oldRange = t.oldRange._getTransformedByMergeOperation(e)
        }
        if (t.newRange) {
          t.newRange = t.newRange._getTransformedByMergeOperation(e)
        }
        return [t]
      })
      NA(CA, kA, (t, e, n) => {
        if (t.oldRange) {
          t.oldRange = Pb._createFromRanges(t.oldRange._getTransformedByMoveOperation(e))
        }
        if (t.newRange) {
          if (n.abRelation) {
            const o = Pb._createFromRanges(t.newRange._getTransformedByMoveOperation(e))
            if (n.abRelation.side == 'left' && e.targetPosition.isEqual(t.newRange.start)) {
              t.newRange.end = o.end
              t.newRange.start.path = n.abRelation.path
              return [t]
            } else if (n.abRelation.side == 'right' && e.targetPosition.isEqual(t.newRange.end)) {
              t.newRange.start = o.start
              t.newRange.end.path = n.abRelation.path
              return [t]
            }
          }
          t.newRange = Pb._createFromRanges(t.newRange._getTransformedByMoveOperation(e))
        }
        return [t]
      })
      NA(CA, AA, (t, e, n) => {
        if (t.oldRange) {
          t.oldRange = t.oldRange._getTransformedBySplitOperation(e)
        }
        if (t.newRange) {
          if (n.abRelation) {
            const o = t.newRange._getTransformedBySplitOperation(e)
            if (t.newRange.start.isEqual(e.splitPosition) && n.abRelation.wasStartBeforeMergedElement) {
              t.newRange.start = Db._createAt(e.insertionPosition)
            } else if (t.newRange.start.isEqual(e.splitPosition) && !n.abRelation.wasInLeftElement) {
              t.newRange.start = Db._createAt(e.moveTargetPosition)
            }
            if (t.newRange.end.isEqual(e.splitPosition) && n.abRelation.wasInRightElement) {
              t.newRange.end = Db._createAt(e.moveTargetPosition)
            } else if (t.newRange.end.isEqual(e.splitPosition) && n.abRelation.wasEndBeforeMergedElement) {
              t.newRange.end = Db._createAt(e.insertionPosition)
            } else {
              t.newRange.end = o.end
            }
            return [t]
          }
          t.newRange = t.newRange._getTransformedBySplitOperation(e)
        }
        return [t]
      })
      NA(_A, wA, (t, e) => {
        if (t.sourcePosition.hasSameParentAs(e.position)) {
          t.howMany += e.howMany
        }
        t.sourcePosition = t.sourcePosition._getTransformedByInsertOperation(e)
        t.targetPosition = t.targetPosition._getTransformedByInsertOperation(e)
        return [t]
      })
      NA(_A, _A, (t, e, n) => {
        if (t.sourcePosition.isEqual(e.sourcePosition) && t.targetPosition.isEqual(e.targetPosition)) {
          if (!n.bWasUndone) {
            return [new EA(0)]
          } else {
            const n = e.graveyardPosition.path.slice()
            n.push(0)
            t.sourcePosition = new Db(e.graveyardPosition.root, n)
            t.howMany = 0
            return [t]
          }
        }
        if (
          t.sourcePosition.isEqual(e.sourcePosition) &&
          !t.targetPosition.isEqual(e.targetPosition) &&
          !n.bWasUndone &&
          n.abRelation != 'splitAtSource'
        ) {
          const o = t.targetPosition.root.rootName == '$graveyard'
          const i = e.targetPosition.root.rootName == '$graveyard'
          const r = o && !i
          const s = i && !o
          const a = s || (!r && n.aIsStrong)
          if (a) {
            const n = e.targetPosition._getTransformedByMergeOperation(e)
            const o = t.targetPosition._getTransformedByMergeOperation(e)
            return [new kA(n, t.howMany, o, 0)]
          } else {
            return [new EA(0)]
          }
        }
        if (t.sourcePosition.hasSameParentAs(e.targetPosition)) {
          t.howMany += e.howMany
        }
        t.sourcePosition = t.sourcePosition._getTransformedByMergeOperation(e)
        t.targetPosition = t.targetPosition._getTransformedByMergeOperation(e)
        if (!t.graveyardPosition.isEqual(e.graveyardPosition) || !n.aIsStrong) {
          t.graveyardPosition = t.graveyardPosition._getTransformedByMergeOperation(e)
        }
        return [t]
      })
      NA(_A, kA, (t, e, n) => {
        const o = Pb._createFromPositionAndShift(e.sourcePosition, e.howMany)
        if (e.type == 'remove' && !n.bWasUndone && !n.forceWeakRemove) {
          if (t.deletionPosition.hasSameParentAs(e.sourcePosition) && o.containsPosition(t.sourcePosition)) {
            return [new EA(0)]
          }
        }
        if (t.sourcePosition.hasSameParentAs(e.targetPosition)) {
          t.howMany += e.howMany
        }
        if (t.sourcePosition.hasSameParentAs(e.sourcePosition)) {
          t.howMany -= e.howMany
        }
        t.sourcePosition = t.sourcePosition._getTransformedByMoveOperation(e)
        t.targetPosition = t.targetPosition._getTransformedByMoveOperation(e)
        if (!t.graveyardPosition.isEqual(e.targetPosition)) {
          t.graveyardPosition = t.graveyardPosition._getTransformedByMoveOperation(e)
        }
        return [t]
      })
      NA(_A, AA, (t, e, n) => {
        if (e.graveyardPosition) {
          t.graveyardPosition = t.graveyardPosition._getTransformedByDeletion(e.graveyardPosition, 1)
          if (t.deletionPosition.isEqual(e.graveyardPosition)) {
            t.howMany = e.howMany
          }
        }
        if (t.targetPosition.isEqual(e.splitPosition)) {
          const o = e.howMany != 0
          const i = e.graveyardPosition && t.deletionPosition.isEqual(e.graveyardPosition)
          if (o || i || n.abRelation == 'mergeTargetNotMoved') {
            t.sourcePosition = t.sourcePosition._getTransformedBySplitOperation(e)
            return [t]
          }
        }
        if (t.sourcePosition.isEqual(e.splitPosition)) {
          if (n.abRelation == 'mergeSourceNotMoved') {
            t.howMany = 0
            t.targetPosition = t.targetPosition._getTransformedBySplitOperation(e)
            return [t]
          }
          if (n.abRelation == 'mergeSameElement' || t.sourcePosition.offset > 0) {
            t.sourcePosition = e.moveTargetPosition.clone()
            t.targetPosition = t.targetPosition._getTransformedBySplitOperation(e)
            return [t]
          }
        }
        if (t.sourcePosition.hasSameParentAs(e.splitPosition)) {
          t.howMany = e.splitPosition.offset
        }
        t.sourcePosition = t.sourcePosition._getTransformedBySplitOperation(e)
        t.targetPosition = t.targetPosition._getTransformedBySplitOperation(e)
        return [t]
      })
      NA(kA, wA, (t, e) => {
        const n = Pb._createFromPositionAndShift(t.sourcePosition, t.howMany)
        const o = n._getTransformedByInsertOperation(e, false)[0]
        t.sourcePosition = o.start
        t.howMany = o.end.offset - o.start.offset
        if (!t.targetPosition.isEqual(e.position)) {
          t.targetPosition = t.targetPosition._getTransformedByInsertOperation(e)
        }
        return [t]
      })
      NA(kA, kA, (t, e, n) => {
        const o = Pb._createFromPositionAndShift(t.sourcePosition, t.howMany)
        const i = Pb._createFromPositionAndShift(e.sourcePosition, e.howMany)
        let r = n.aIsStrong
        let s = !n.aIsStrong
        if (n.abRelation == 'insertBefore' || n.baRelation == 'insertAfter') {
          s = true
        } else if (n.abRelation == 'insertAfter' || n.baRelation == 'insertBefore') {
          s = false
        }
        let a
        if (t.targetPosition.isEqual(e.targetPosition) && s) {
          a = t.targetPosition._getTransformedByDeletion(e.sourcePosition, e.howMany)
        } else {
          a = t.targetPosition._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany)
        }
        if (UA(t, e) && UA(e, t)) {
          return [e.getReversed()]
        }
        const c = o.containsPosition(e.targetPosition)
        if (c && o.containsRange(i, true)) {
          o.start = o.start._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany)
          o.end = o.end._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany)
          return WA([o], a)
        }
        const l = i.containsPosition(t.targetPosition)
        if (l && i.containsRange(o, true)) {
          o.start = o.start._getCombined(e.sourcePosition, e.getMovedRangeStart())
          o.end = o.end._getCombined(e.sourcePosition, e.getMovedRangeStart())
          return WA([o], a)
        }
        const d = Dt(t.sourcePosition.getParentPath(), e.sourcePosition.getParentPath())
        if (d == 'prefix' || d == 'extension') {
          o.start = o.start._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany)
          o.end = o.end._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany)
          return WA([o], a)
        }
        if (t.type == 'remove' && e.type != 'remove' && !n.aWasUndone && !n.forceWeakRemove) {
          r = true
        } else if (t.type != 'remove' && e.type == 'remove' && !n.bWasUndone && !n.forceWeakRemove) {
          r = false
        }
        const u = []
        const h = o.getDifference(i)
        for (const t of h) {
          t.start = t.start._getTransformedByDeletion(e.sourcePosition, e.howMany)
          t.end = t.end._getTransformedByDeletion(e.sourcePosition, e.howMany)
          const n = Dt(t.start.getParentPath(), e.getMovedRangeStart().getParentPath()) == 'same'
          const o = t._getTransformedByInsertion(e.getMovedRangeStart(), e.howMany, n)
          u.push(...o)
        }
        const g = o.getIntersection(i)
        if (g !== null && r) {
          g.start = g.start._getCombined(e.sourcePosition, e.getMovedRangeStart())
          g.end = g.end._getCombined(e.sourcePosition, e.getMovedRangeStart())
          if (u.length === 0) {
            u.push(g)
          } else if (u.length == 1) {
            if (i.start.isBefore(o.start) || i.start.isEqual(o.start)) {
              u.unshift(g)
            } else {
              u.push(g)
            }
          } else {
            u.splice(1, 0, g)
          }
        }
        if (u.length === 0) {
          return [new EA(t.baseVersion)]
        }
        return WA(u, a)
      })
      NA(kA, AA, (t, e, n) => {
        let o = t.targetPosition.clone()
        if (
          !t.targetPosition.isEqual(e.insertionPosition) ||
          !e.graveyardPosition ||
          n.abRelation == 'moveTargetAfter'
        ) {
          o = t.targetPosition._getTransformedBySplitOperation(e)
        }
        const i = Pb._createFromPositionAndShift(t.sourcePosition, t.howMany)
        if (i.end.isEqual(e.insertionPosition)) {
          if (!e.graveyardPosition) {
            t.howMany++
          }
          t.targetPosition = o
          return [t]
        }
        if (i.start.hasSameParentAs(e.splitPosition) && i.containsPosition(e.splitPosition)) {
          let t = new Pb(e.splitPosition, i.end)
          t = t._getTransformedBySplitOperation(e)
          const n = [new Pb(i.start, e.splitPosition), t]
          return WA(n, o)
        }
        if (t.targetPosition.isEqual(e.splitPosition) && n.abRelation == 'insertAtSource') {
          o = e.moveTargetPosition
        }
        if (t.targetPosition.isEqual(e.insertionPosition) && n.abRelation == 'insertBetween') {
          o = t.targetPosition
        }
        const r = i._getTransformedBySplitOperation(e)
        const s = [r]
        if (e.graveyardPosition) {
          const o = i.start.isEqual(e.graveyardPosition) || i.containsPosition(e.graveyardPosition)
          if (t.howMany > 1 && o && !n.aWasUndone) {
            s.push(Pb._createFromPositionAndShift(e.insertionPosition, 1))
          }
        }
        return WA(s, o)
      })
      NA(kA, _A, (t, e, n) => {
        const o = Pb._createFromPositionAndShift(t.sourcePosition, t.howMany)
        if (e.deletionPosition.hasSameParentAs(t.sourcePosition) && o.containsPosition(e.sourcePosition)) {
          if (t.type == 'remove' && !n.forceWeakRemove) {
            if (!n.aWasUndone) {
              const n = []
              let o = e.graveyardPosition.clone()
              let i = e.targetPosition._getTransformedByMergeOperation(e)
              if (t.howMany > 1) {
                n.push(new kA(t.sourcePosition, t.howMany - 1, t.targetPosition, 0))
                o = o._getTransformedByMove(t.sourcePosition, t.targetPosition, t.howMany - 1)
                i = i._getTransformedByMove(t.sourcePosition, t.targetPosition, t.howMany - 1)
              }
              const r = e.deletionPosition._getCombined(t.sourcePosition, t.targetPosition)
              const s = new kA(o, 1, r, 0)
              const a = s.getMovedRangeStart().path.slice()
              a.push(0)
              const c = new Db(s.targetPosition.root, a)
              i = i._getTransformedByMove(o, r, 1)
              const l = new kA(i, e.howMany, c, 0)
              n.push(s)
              n.push(l)
              return n
            }
          } else {
            if (t.howMany == 1) {
              if (!n.bWasUndone) {
                return [new EA(0)]
              } else {
                t.sourcePosition = e.graveyardPosition.clone()
                t.targetPosition = t.targetPosition._getTransformedByMergeOperation(e)
                return [t]
              }
            }
          }
        }
        const i = Pb._createFromPositionAndShift(t.sourcePosition, t.howMany)
        const r = i._getTransformedByMergeOperation(e)
        t.sourcePosition = r.start
        t.howMany = r.end.offset - r.start.offset
        t.targetPosition = t.targetPosition._getTransformedByMergeOperation(e)
        return [t]
      })
      NA(DA, wA, (t, e) => {
        t.position = t.position._getTransformedByInsertOperation(e)
        return [t]
      })
      NA(DA, _A, (t, e) => {
        if (t.position.isEqual(e.deletionPosition)) {
          t.position = e.graveyardPosition.clone()
          t.position.stickiness = 'toNext'
          return [t]
        }
        t.position = t.position._getTransformedByMergeOperation(e)
        return [t]
      })
      NA(DA, kA, (t, e) => {
        t.position = t.position._getTransformedByMoveOperation(e)
        return [t]
      })
      NA(DA, DA, (t, e, n) => {
        if (t.position.isEqual(e.position)) {
          if (n.aIsStrong) {
            t.oldName = e.newName
          } else {
            return [new EA(0)]
          }
        }
        return [t]
      })
      NA(DA, AA, (t, e) => {
        const n = t.position.path
        const o = e.splitPosition.getParentPath()
        if (Dt(n, o) == 'same' && !e.graveyardPosition) {
          const e = new DA(t.position.getShiftedBy(1), t.oldName, t.newName, 0)
          return [t, e]
        }
        t.position = t.position._getTransformedBySplitOperation(e)
        return [t]
      })
      NA(TA, TA, (t, e, n) => {
        if (t.root === e.root && t.key === e.key) {
          if (!n.aIsStrong || t.newValue === e.newValue) {
            return [new EA(0)]
          } else {
            t.oldValue = e.newValue
          }
        }
        return [t]
      })
      NA(IA, IA, (t, e) => {
        if (t.rootName === e.rootName && t.isAdd === e.isAdd) {
          return [new EA(0)]
        }
        return [t]
      })
      NA(AA, wA, (t, e) => {
        if (t.splitPosition.hasSameParentAs(e.position) && t.splitPosition.offset < e.position.offset) {
          t.howMany += e.howMany
        }
        t.splitPosition = t.splitPosition._getTransformedByInsertOperation(e)
        t.insertionPosition = t.insertionPosition._getTransformedByInsertOperation(e)
        return [t]
      })
      NA(AA, _A, (t, e, n) => {
        if (!t.graveyardPosition && !n.bWasUndone && t.splitPosition.hasSameParentAs(e.sourcePosition)) {
          const n = e.graveyardPosition.path.slice()
          n.push(0)
          const o = new Db(e.graveyardPosition.root, n)
          const i = AA.getInsertionPosition(new Db(e.graveyardPosition.root, n))
          const r = new AA(o, 0, i, null, 0)
          t.splitPosition = t.splitPosition._getTransformedByMergeOperation(e)
          t.insertionPosition = AA.getInsertionPosition(t.splitPosition)
          t.graveyardPosition = r.insertionPosition.clone()
          t.graveyardPosition.stickiness = 'toNext'
          return [r, t]
        }
        if (t.splitPosition.hasSameParentAs(e.deletionPosition) && !t.splitPosition.isAfter(e.deletionPosition)) {
          t.howMany--
        }
        if (t.splitPosition.hasSameParentAs(e.targetPosition)) {
          t.howMany += e.howMany
        }
        t.splitPosition = t.splitPosition._getTransformedByMergeOperation(e)
        t.insertionPosition = AA.getInsertionPosition(t.splitPosition)
        if (t.graveyardPosition) {
          t.graveyardPosition = t.graveyardPosition._getTransformedByMergeOperation(e)
        }
        return [t]
      })
      NA(AA, kA, (t, e, n) => {
        const o = Pb._createFromPositionAndShift(e.sourcePosition, e.howMany)
        if (t.graveyardPosition) {
          const i = o.start.isEqual(t.graveyardPosition) || o.containsPosition(t.graveyardPosition)
          if (!n.bWasUndone && i) {
            const n = t.splitPosition._getTransformedByMoveOperation(e)
            const o = t.graveyardPosition._getTransformedByMoveOperation(e)
            const i = o.path.slice()
            i.push(0)
            const r = new Db(o.root, i)
            const s = new kA(n, t.howMany, r, 0)
            return [s]
          }
          t.graveyardPosition = t.graveyardPosition._getTransformedByMoveOperation(e)
        }
        const i = t.splitPosition.isEqual(e.targetPosition)
        if (i && (n.baRelation == 'insertAtSource' || n.abRelation == 'splitBefore')) {
          t.howMany += e.howMany
          t.splitPosition = t.splitPosition._getTransformedByDeletion(e.sourcePosition, e.howMany)
          t.insertionPosition = AA.getInsertionPosition(t.splitPosition)
          return [t]
        }
        if (i && n.abRelation && n.abRelation.howMany) {
          const { howMany: e, offset: o } = n.abRelation
          t.howMany += e
          t.splitPosition = t.splitPosition.getShiftedBy(o)
          return [t]
        }
        if (t.splitPosition.hasSameParentAs(e.sourcePosition) && o.containsPosition(t.splitPosition)) {
          const n = e.howMany - (t.splitPosition.offset - e.sourcePosition.offset)
          t.howMany -= n
          if (t.splitPosition.hasSameParentAs(e.targetPosition) && t.splitPosition.offset < e.targetPosition.offset) {
            t.howMany += e.howMany
          }
          t.splitPosition = e.sourcePosition.clone()
          t.insertionPosition = AA.getInsertionPosition(t.splitPosition)
          return [t]
        }
        if (!e.sourcePosition.isEqual(e.targetPosition)) {
          if (t.splitPosition.hasSameParentAs(e.sourcePosition) && t.splitPosition.offset <= e.sourcePosition.offset) {
            t.howMany -= e.howMany
          }
          if (t.splitPosition.hasSameParentAs(e.targetPosition) && t.splitPosition.offset < e.targetPosition.offset) {
            t.howMany += e.howMany
          }
        }
        t.splitPosition.stickiness = 'toNone'
        t.splitPosition = t.splitPosition._getTransformedByMoveOperation(e)
        t.splitPosition.stickiness = 'toNext'
        if (t.graveyardPosition) {
          t.insertionPosition = t.insertionPosition._getTransformedByMoveOperation(e)
        } else {
          t.insertionPosition = AA.getInsertionPosition(t.splitPosition)
        }
        return [t]
      })
      NA(AA, AA, (t, e, n) => {
        if (t.splitPosition.isEqual(e.splitPosition)) {
          if (!t.graveyardPosition && !e.graveyardPosition) {
            return [new EA(0)]
          }
          if (t.graveyardPosition && e.graveyardPosition && t.graveyardPosition.isEqual(e.graveyardPosition)) {
            return [new EA(0)]
          }
          if (n.abRelation == 'splitBefore') {
            t.howMany = 0
            t.graveyardPosition = t.graveyardPosition._getTransformedBySplitOperation(e)
            return [t]
          }
        }
        if (t.graveyardPosition && e.graveyardPosition && t.graveyardPosition.isEqual(e.graveyardPosition)) {
          const o = t.splitPosition.root.rootName == '$graveyard'
          const i = e.splitPosition.root.rootName == '$graveyard'
          const r = o && !i
          const s = i && !o
          const a = s || (!r && n.aIsStrong)
          if (a) {
            const n = []
            if (e.howMany) {
              n.push(new kA(e.moveTargetPosition, e.howMany, e.splitPosition, 0))
            }
            if (t.howMany) {
              n.push(new kA(t.splitPosition, t.howMany, t.moveTargetPosition, 0))
            }
            return n
          } else {
            return [new EA(0)]
          }
        }
        if (t.graveyardPosition) {
          t.graveyardPosition = t.graveyardPosition._getTransformedBySplitOperation(e)
        }
        if (t.splitPosition.isEqual(e.insertionPosition) && n.abRelation == 'splitBefore') {
          t.howMany++
          return [t]
        }
        if (e.splitPosition.isEqual(t.insertionPosition) && n.baRelation == 'splitBefore') {
          const n = e.insertionPosition.path.slice()
          n.push(0)
          const o = new Db(e.insertionPosition.root, n)
          const i = new kA(t.insertionPosition, 1, o, 0)
          return [t, i]
        }
        if (t.splitPosition.hasSameParentAs(e.splitPosition) && t.splitPosition.offset < e.splitPosition.offset) {
          t.howMany -= e.howMany
        }
        t.splitPosition = t.splitPosition._getTransformedBySplitOperation(e)
        t.insertionPosition = AA.getInsertionPosition(t.splitPosition)
        return [t]
      })
      function UA(t, e) {
        return t.targetPosition._getTransformedByDeletion(e.sourcePosition, e.howMany) === null
      }
      function WA(t, e) {
        const n = []
        for (let o = 0; o < t.length; o++) {
          const i = t[o]
          const r = new kA(i.start, i.end.offset - i.start.offset, e, 0)
          n.push(r)
          for (let e = o + 1; e < t.length; e++) {
            t[e] = t[e]._getTransformedByMove(r.sourcePosition, r.targetPosition, r.howMany)[0]
          }
          e = e._getTransformedByMove(r.sourcePosition, r.targetPosition, r.howMany)
        }
        return n
      }
      class GA extends K(Db) {
        constructor(t, e, n = 'toNone') {
          super(t, e, n)
          if (!this.root.is('rootElement')) {
            throw new P('model-liveposition-root-not-rootelement', t)
          }
          qA.call(this)
        }
        detach() {
          this.stopListening()
        }
        toPosition() {
          return new Db(this.root, this.path.slice(), this.stickiness)
        }
        static fromPosition(t, e) {
          return new this(t.root, t.path.slice(), e ? e : t.stickiness)
        }
      }
      GA.prototype.is = function (t) {
        return t === 'livePosition' || t === 'model:livePosition' || t == 'position' || t === 'model:position'
      }
      function qA() {
        this.listenTo(
          this.root.document.model,
          'applyOperation',
          (t, e) => {
            const n = e[0]
            if (!n.isDocumentOperation) {
              return
            }
            $A.call(this, n)
          },
          { priority: 'low' },
        )
      }
      function $A(t) {
        const e = this.getTransformedByOperation(t)
        if (!this.isEqual(e)) {
          const t = this.toPosition()
          this.path = e.path
          this.root = e.root
          this.fire('change', t)
        }
      }
      class KA {
        constructor(t = {}) {
          if (typeof t === 'string') {
            t = t === 'transparent' ? { isUndoable: false } : {}
            L('batch-constructor-deprecated-string-type')
          }
          const { isUndoable: e = true, isLocal: n = true, isUndo: o = false, isTyping: i = false } = t
          this.operations = []
          this.isUndoable = e
          this.isLocal = n
          this.isUndo = o
          this.isTyping = i
        }
        get type() {
          L('batch-type-deprecated')
          return 'default'
        }
        get baseVersion() {
          for (const t of this.operations) {
            if (t.baseVersion !== null) {
              return t.baseVersion
            }
          }
          return null
        }
        addOperation(t) {
          t.batch = this
          this.operations.push(t)
          return t
        }
      }
      class YA {
        constructor(t) {
          this._changesInElement = new Map()
          this._elementSnapshots = new Map()
          this._changedMarkers = new Map()
          this._changedRoots = new Map()
          this._changeCount = 0
          this._cachedChanges = null
          this._cachedChangesWithGraveyard = null
          this._refreshedItems = new Set()
          this._markerCollection = t
        }
        get isEmpty() {
          return this._changesInElement.size == 0 && this._changedMarkers.size == 0 && this._changedRoots.size == 0
        }
        bufferOperation(t) {
          const e = t
          switch (e.type) {
            case 'insert': {
              if (this._isInInsertedElement(e.position.parent)) {
                return
              }
              this._markInsert(e.position.parent, e.position.offset, e.nodes.maxOffset)
              break
            }
            case 'addAttribute':
            case 'removeAttribute':
            case 'changeAttribute': {
              for (const t of e.range.getItems({ shallow: true })) {
                if (this._isInInsertedElement(t.parent)) {
                  continue
                }
                this._markAttribute(t)
              }
              break
            }
            case 'remove':
            case 'move':
            case 'reinsert': {
              if (
                e.sourcePosition.isEqual(e.targetPosition) ||
                e.sourcePosition.getShiftedBy(e.howMany).isEqual(e.targetPosition)
              ) {
                return
              }
              const t = this._isInInsertedElement(e.sourcePosition.parent)
              const n = this._isInInsertedElement(e.targetPosition.parent)
              if (!t) {
                this._markRemove(e.sourcePosition.parent, e.sourcePosition.offset, e.howMany)
              }
              if (!n) {
                this._markInsert(e.targetPosition.parent, e.getMovedRangeStart().offset, e.howMany)
              }
              break
            }
            case 'rename': {
              if (this._isInInsertedElement(e.position.parent)) {
                return
              }
              this._markRemove(e.position.parent, e.position.offset, 1)
              this._markInsert(e.position.parent, e.position.offset, 1)
              const t = Pb._createFromPositionAndShift(e.position, 1)
              for (const e of this._markerCollection.getMarkersIntersectingRange(t)) {
                const t = e.getData()
                this.bufferMarkerChange(e.name, t, t)
              }
              break
            }
            case 'split': {
              const t = e.splitPosition.parent
              if (!this._isInInsertedElement(t)) {
                this._markRemove(t, e.splitPosition.offset, e.howMany)
              }
              if (!this._isInInsertedElement(e.insertionPosition.parent)) {
                this._markInsert(e.insertionPosition.parent, e.insertionPosition.offset, 1)
              }
              if (e.graveyardPosition) {
                this._markRemove(e.graveyardPosition.parent, e.graveyardPosition.offset, 1)
              }
              break
            }
            case 'merge': {
              const t = e.sourcePosition.parent
              if (!this._isInInsertedElement(t.parent)) {
                this._markRemove(t.parent, t.startOffset, 1)
              }
              const n = e.graveyardPosition.parent
              this._markInsert(n, e.graveyardPosition.offset, 1)
              const o = e.targetPosition.parent
              if (!this._isInInsertedElement(o)) {
                this._markInsert(o, e.targetPosition.offset, t.maxOffset)
              }
              break
            }
            case 'detachRoot':
            case 'addRoot': {
              const t = e.affectedSelectable
              if (!t._isLoaded) {
                return
              }
              if (t.isAttached() == e.isAdd) {
                return
              }
              this._bufferRootStateChange(e.rootName, e.isAdd)
              break
            }
            case 'addRootAttribute':
            case 'removeRootAttribute':
            case 'changeRootAttribute': {
              if (!e.root._isLoaded) {
                return
              }
              const t = e.root.rootName
              this._bufferRootAttributeChange(t, e.key, e.oldValue, e.newValue)
              break
            }
          }
          this._cachedChanges = null
        }
        bufferMarkerChange(t, e, n) {
          if (e.range && e.range.root.is('rootElement') && !e.range.root._isLoaded) {
            e.range = null
          }
          if (n.range && n.range.root.is('rootElement') && !n.range.root._isLoaded) {
            n.range = null
          }
          let o = this._changedMarkers.get(t)
          if (!o) {
            o = { newMarkerData: n, oldMarkerData: e }
            this._changedMarkers.set(t, o)
          } else {
            o.newMarkerData = n
          }
          if (o.oldMarkerData.range == null && n.range == null) {
            this._changedMarkers.delete(t)
          }
        }
        getMarkersToRemove() {
          const t = []
          for (const [e, n] of this._changedMarkers) {
            if (n.oldMarkerData.range != null) {
              t.push({ name: e, range: n.oldMarkerData.range })
            }
          }
          return t
        }
        getMarkersToAdd() {
          const t = []
          for (const [e, n] of this._changedMarkers) {
            if (n.newMarkerData.range != null) {
              t.push({ name: e, range: n.newMarkerData.range })
            }
          }
          return t
        }
        getChangedMarkers() {
          return Array.from(this._changedMarkers).map(([t, e]) => ({
            name: t,
            data: { oldRange: e.oldMarkerData.range, newRange: e.newMarkerData.range },
          }))
        }
        hasDataChanges() {
          if (this._changesInElement.size > 0) {
            return true
          }
          if (this._changedRoots.size > 0) {
            return true
          }
          for (const { newMarkerData: t, oldMarkerData: e } of this._changedMarkers.values()) {
            if (t.affectsData !== e.affectsData) {
              return true
            }
            if (t.affectsData) {
              const n = t.range && !e.range
              const o = !t.range && e.range
              const i = t.range && e.range && !t.range.isEqual(e.range)
              if (n || o || i) {
                return true
              }
            }
          }
          return false
        }
        getChanges(t = {}) {
          if (this._cachedChanges) {
            if (t.includeChangesInGraveyard) {
              return this._cachedChangesWithGraveyard.slice()
            } else {
              return this._cachedChanges.slice()
            }
          }
          let e = []
          for (const t of this._changesInElement.keys()) {
            const n = this._changesInElement.get(t).sort((t, e) => {
              if (t.offset === e.offset) {
                if (t.type != e.type) {
                  return t.type == 'remove' ? -1 : 1
                }
                return 0
              }
              return t.offset < e.offset ? -1 : 1
            })
            const o = this._elementSnapshots.get(t)
            const i = ZA(t.getChildren())
            const r = QA(o.length, n)
            let s = 0
            let a = 0
            for (const n of r) {
              if (n === 'i') {
                e.push(this._getInsertDiff(t, s, i[s]))
                s++
              } else if (n === 'r') {
                e.push(this._getRemoveDiff(t, s, o[a]))
                a++
              } else if (n === 'a') {
                const n = i[s].attributes
                const r = o[a].attributes
                let c
                if (i[s].name == '$text') {
                  c = new Pb(Db._createAt(t, s), Db._createAt(t, s + 1))
                } else {
                  const e = t.offsetToIndex(s)
                  c = new Pb(Db._createAt(t, s), Db._createAt(t.getChild(e), 0))
                }
                e.push(...this._getAttributesDiff(c, r, n))
                s++
                a++
              } else {
                s++
                a++
              }
            }
          }
          e.sort((t, e) => {
            if (t.position.root != e.position.root) {
              return t.position.root.rootName < e.position.root.rootName ? -1 : 1
            }
            if (t.position.isEqual(e.position)) {
              return t.changeCount - e.changeCount
            }
            return t.position.isBefore(e.position) ? -1 : 1
          })
          for (let t = 1, n = 0; t < e.length; t++) {
            const o = e[n]
            const i = e[t]
            const r =
              o.type == 'remove' &&
              i.type == 'remove' &&
              o.name == '$text' &&
              i.name == '$text' &&
              o.position.isEqual(i.position)
            const s =
              o.type == 'insert' &&
              i.type == 'insert' &&
              o.name == '$text' &&
              i.name == '$text' &&
              o.position.parent == i.position.parent &&
              o.position.offset + o.length == i.position.offset
            const a =
              o.type == 'attribute' &&
              i.type == 'attribute' &&
              o.position.parent == i.position.parent &&
              o.range.isFlat &&
              i.range.isFlat &&
              o.position.offset + o.length == i.position.offset &&
              o.attributeKey == i.attributeKey &&
              o.attributeOldValue == i.attributeOldValue &&
              o.attributeNewValue == i.attributeNewValue
            if (r || s || a) {
              o.length++
              if (a) {
                o.range.end = o.range.end.getShiftedBy(1)
              }
              e[t] = null
            } else {
              n = t
            }
          }
          e = e.filter((t) => t)
          for (const t of e) {
            delete t.changeCount
            if (t.type == 'attribute') {
              delete t.position
              delete t.length
            }
          }
          this._changeCount = 0
          this._cachedChangesWithGraveyard = e
          this._cachedChanges = e.filter(JA)
          if (t.includeChangesInGraveyard) {
            return this._cachedChangesWithGraveyard.slice()
          } else {
            return this._cachedChanges.slice()
          }
        }
        getChangedRoots() {
          return Array.from(this._changedRoots.values()).map((t) => {
            const e = { ...t }
            if (e.state !== undefined) {
              delete e.attributes
            }
            return e
          })
        }
        getRefreshedItems() {
          return new Set(this._refreshedItems)
        }
        reset() {
          this._changesInElement.clear()
          this._elementSnapshots.clear()
          this._changedMarkers.clear()
          this._changedRoots.clear()
          this._refreshedItems = new Set()
          this._cachedChanges = null
        }
        _bufferRootStateChange(t, e) {
          if (!this._changedRoots.has(t)) {
            this._changedRoots.set(t, { name: t, state: e ? 'attached' : 'detached' })
            return
          }
          const n = this._changedRoots.get(t)
          if (n.state !== undefined) {
            delete n.state
            if (n.attributes === undefined) {
              this._changedRoots.delete(t)
            }
          } else {
            n.state = e ? 'attached' : 'detached'
          }
        }
        _bufferRootAttributeChange(t, e, n, o) {
          const i = this._changedRoots.get(t) || { name: t }
          const r = i.attributes || {}
          if (r[e]) {
            const t = r[e]
            if (o === t.oldValue) {
              delete r[e]
            } else {
              t.newValue = o
            }
          } else {
            r[e] = { oldValue: n, newValue: o }
          }
          if (Object.entries(r).length === 0) {
            delete i.attributes
            if (i.state === undefined) {
              this._changedRoots.delete(t)
            }
          } else {
            i.attributes = r
            this._changedRoots.set(t, i)
          }
        }
        _refreshItem(t) {
          if (this._isInInsertedElement(t.parent)) {
            return
          }
          this._markRemove(t.parent, t.startOffset, t.offsetSize)
          this._markInsert(t.parent, t.startOffset, t.offsetSize)
          this._refreshedItems.add(t)
          const e = Pb._createOn(t)
          for (const t of this._markerCollection.getMarkersIntersectingRange(e)) {
            const e = t.getData()
            this.bufferMarkerChange(t.name, e, e)
          }
          this._cachedChanges = null
        }
        _bufferRootLoad(t) {
          if (!t.isAttached()) {
            return
          }
          this._bufferRootStateChange(t.rootName, true)
          this._markInsert(t, 0, t.maxOffset)
          for (const e of t.getAttributeKeys()) {
            this._bufferRootAttributeChange(t.rootName, e, null, t.getAttribute(e))
          }
          for (const e of this._markerCollection) {
            if (e.getRange().root == t) {
              const t = e.getData()
              this.bufferMarkerChange(e.name, { ...t, range: null }, t)
            }
          }
        }
        _markInsert(t, e, n) {
          if (t.root.is('rootElement') && !t.root._isLoaded) {
            return
          }
          const o = { type: 'insert', offset: e, howMany: n, count: this._changeCount++ }
          this._markChange(t, o)
        }
        _markRemove(t, e, n) {
          if (t.root.is('rootElement') && !t.root._isLoaded) {
            return
          }
          const o = { type: 'remove', offset: e, howMany: n, count: this._changeCount++ }
          this._markChange(t, o)
          this._removeAllNestedChanges(t, e, n)
        }
        _markAttribute(t) {
          if (t.root.is('rootElement') && !t.root._isLoaded) {
            return
          }
          const e = { type: 'attribute', offset: t.startOffset, howMany: t.offsetSize, count: this._changeCount++ }
          this._markChange(t.parent, e)
        }
        _markChange(t, e) {
          this._makeSnapshot(t)
          const n = this._getChangesForElement(t)
          this._handleChange(e, n)
          n.push(e)
          for (let t = 0; t < n.length; t++) {
            if (n[t].howMany < 1) {
              n.splice(t, 1)
              t--
            }
          }
        }
        _getChangesForElement(t) {
          let e
          if (this._changesInElement.has(t)) {
            e = this._changesInElement.get(t)
          } else {
            e = []
            this._changesInElement.set(t, e)
          }
          return e
        }
        _makeSnapshot(t) {
          if (!this._elementSnapshots.has(t)) {
            this._elementSnapshots.set(t, ZA(t.getChildren()))
          }
        }
        _handleChange(t, e) {
          t.nodesToHandle = t.howMany
          for (const n of e) {
            const o = t.offset + t.howMany
            const i = n.offset + n.howMany
            if (t.type == 'insert') {
              if (n.type == 'insert') {
                if (t.offset <= n.offset) {
                  n.offset += t.howMany
                } else if (t.offset < i) {
                  n.howMany += t.nodesToHandle
                  t.nodesToHandle = 0
                }
              }
              if (n.type == 'remove') {
                if (t.offset < n.offset) {
                  n.offset += t.howMany
                }
              }
              if (n.type == 'attribute') {
                if (t.offset <= n.offset) {
                  n.offset += t.howMany
                } else if (t.offset < i) {
                  const i = n.howMany
                  n.howMany = t.offset - n.offset
                  e.unshift({ type: 'attribute', offset: o, howMany: i - n.howMany, count: this._changeCount++ })
                }
              }
            }
            if (t.type == 'remove') {
              if (n.type == 'insert') {
                if (o <= n.offset) {
                  n.offset -= t.howMany
                } else if (o <= i) {
                  if (t.offset < n.offset) {
                    const e = o - n.offset
                    n.offset = t.offset
                    n.howMany -= e
                    t.nodesToHandle -= e
                  } else {
                    n.howMany -= t.nodesToHandle
                    t.nodesToHandle = 0
                  }
                } else {
                  if (t.offset <= n.offset) {
                    t.nodesToHandle -= n.howMany
                    n.howMany = 0
                  } else if (t.offset < i) {
                    const e = i - t.offset
                    n.howMany -= e
                    t.nodesToHandle -= e
                  }
                }
              }
              if (n.type == 'remove') {
                if (o <= n.offset) {
                  n.offset -= t.howMany
                } else if (t.offset < n.offset) {
                  t.nodesToHandle += n.howMany
                  n.howMany = 0
                }
              }
              if (n.type == 'attribute') {
                if (o <= n.offset) {
                  n.offset -= t.howMany
                } else if (t.offset < n.offset) {
                  const e = o - n.offset
                  n.offset = t.offset
                  n.howMany -= e
                } else if (t.offset < i) {
                  if (o <= i) {
                    const o = n.howMany
                    n.howMany = t.offset - n.offset
                    const i = o - n.howMany - t.nodesToHandle
                    e.unshift({ type: 'attribute', offset: t.offset, howMany: i, count: this._changeCount++ })
                  } else {
                    n.howMany -= i - t.offset
                  }
                }
              }
            }
            if (t.type == 'attribute') {
              if (n.type == 'insert') {
                if (t.offset < n.offset && o > n.offset) {
                  if (o > i) {
                    const t = { type: 'attribute', offset: i, howMany: o - i, count: this._changeCount++ }
                    this._handleChange(t, e)
                    e.push(t)
                  }
                  t.nodesToHandle = n.offset - t.offset
                  t.howMany = t.nodesToHandle
                } else if (t.offset >= n.offset && t.offset < i) {
                  if (o > i) {
                    t.nodesToHandle = o - i
                    t.offset = i
                  } else {
                    t.nodesToHandle = 0
                  }
                }
              }
              if (n.type == 'remove') {
                if (t.offset < n.offset && o > n.offset) {
                  const i = { type: 'attribute', offset: n.offset, howMany: o - n.offset, count: this._changeCount++ }
                  this._handleChange(i, e)
                  e.push(i)
                  t.nodesToHandle = n.offset - t.offset
                  t.howMany = t.nodesToHandle
                }
              }
              if (n.type == 'attribute') {
                if (t.offset >= n.offset && o <= i) {
                  t.nodesToHandle = 0
                  t.howMany = 0
                  t.offset = 0
                } else if (t.offset <= n.offset && o >= i) {
                  n.howMany = 0
                }
              }
            }
          }
          t.howMany = t.nodesToHandle
          delete t.nodesToHandle
        }
        _getInsertDiff(t, e, n) {
          return {
            type: 'insert',
            position: Db._createAt(t, e),
            name: n.name,
            attributes: new Map(n.attributes),
            length: 1,
            changeCount: this._changeCount++,
          }
        }
        _getRemoveDiff(t, e, n) {
          return {
            type: 'remove',
            position: Db._createAt(t, e),
            name: n.name,
            attributes: new Map(n.attributes),
            length: 1,
            changeCount: this._changeCount++,
          }
        }
        _getAttributesDiff(t, e, n) {
          const o = []
          n = new Map(n)
          for (const [i, r] of e) {
            const e = n.has(i) ? n.get(i) : null
            if (e !== r) {
              o.push({
                type: 'attribute',
                position: t.start,
                range: t.clone(),
                length: 1,
                attributeKey: i,
                attributeOldValue: r,
                attributeNewValue: e,
                changeCount: this._changeCount++,
              })
            }
            n.delete(i)
          }
          for (const [e, i] of n) {
            o.push({
              type: 'attribute',
              position: t.start,
              range: t.clone(),
              length: 1,
              attributeKey: e,
              attributeOldValue: null,
              attributeNewValue: i,
              changeCount: this._changeCount++,
            })
          }
          return o
        }
        _isInInsertedElement(t) {
          const e = t.parent
          if (!e) {
            return false
          }
          const n = this._changesInElement.get(e)
          const o = t.startOffset
          if (n) {
            for (const t of n) {
              if (t.type == 'insert' && o >= t.offset && o < t.offset + t.howMany) {
                return true
              }
            }
          }
          return this._isInInsertedElement(e)
        }
        _removeAllNestedChanges(t, e, n) {
          const o = new Pb(Db._createAt(t, e), Db._createAt(t, e + n))
          for (const t of o.getItems({ shallow: true })) {
            if (t.is('element')) {
              this._elementSnapshots.delete(t)
              this._changesInElement.delete(t)
              this._removeAllNestedChanges(t, 0, t.maxOffset)
            }
          }
        }
      }
      function ZA(t) {
        const e = []
        for (const n of t) {
          if (n.is('$text')) {
            for (let t = 0; t < n.data.length; t++) {
              e.push({ name: '$text', attributes: new Map(n.getAttributes()) })
            }
          } else {
            e.push({ name: n.name, attributes: new Map(n.getAttributes()) })
          }
        }
        return e
      }
      function QA(t, e) {
        const n = []
        let o = 0
        let i = 0
        for (const t of e) {
          if (t.offset > o) {
            for (let e = 0; e < t.offset - o; e++) {
              n.push('e')
            }
            i += t.offset - o
          }
          if (t.type == 'insert') {
            for (let e = 0; e < t.howMany; e++) {
              n.push('i')
            }
            o = t.offset + t.howMany
          } else if (t.type == 'remove') {
            for (let e = 0; e < t.howMany; e++) {
              n.push('r')
            }
            o = t.offset
            i += t.howMany
          } else {
            n.push(...'a'.repeat(t.howMany).split(''))
            o = t.offset + t.howMany
            i += t.howMany
          }
        }
        if (i < t) {
          for (let e = 0; e < t - i - o; e++) {
            n.push('e')
          }
        }
        return n
      }
      function JA(t) {
        const e = 'position' in t && t.position.root.rootName == '$graveyard'
        const n = 'range' in t && t.range.root.rootName == '$graveyard'
        return !e && !n
      }
      class XA {
        constructor() {
          this._operations = []
          this._undoPairs = new Map()
          this._undoneOperations = new Set()
          this._baseVersionToOperationIndex = new Map()
          this._version = 0
          this._gaps = new Map()
        }
        get version() {
          return this._version
        }
        set version(t) {
          if (this._operations.length && t > this._version + 1) {
            this._gaps.set(this._version, t)
          }
          this._version = t
        }
        get lastOperation() {
          return this._operations[this._operations.length - 1]
        }
        addOperation(t) {
          if (t.baseVersion !== this.version) {
            throw new P('model-document-history-addoperation-incorrect-version', this, {
              operation: t,
              historyVersion: this.version,
            })
          }
          this._operations.push(t)
          this._version++
          this._baseVersionToOperationIndex.set(t.baseVersion, this._operations.length - 1)
        }
        getOperations(t, e = this.version) {
          if (!this._operations.length) {
            return []
          }
          const n = this._operations[0]
          if (t === undefined) {
            t = n.baseVersion
          }
          let o = e - 1
          for (const [e, n] of this._gaps) {
            if (t > e && t < n) {
              t = n
            }
            if (o > e && o < n) {
              o = e - 1
            }
          }
          if (o < n.baseVersion || t > this.lastOperation.baseVersion) {
            return []
          }
          let i = this._baseVersionToOperationIndex.get(t)
          if (i === undefined) {
            i = 0
          }
          let r = this._baseVersionToOperationIndex.get(o)
          if (r === undefined) {
            r = this._operations.length - 1
          }
          return this._operations.slice(i, r + 1)
        }
        getOperation(t) {
          const e = this._baseVersionToOperationIndex.get(t)
          if (e === undefined) {
            return
          }
          return this._operations[e]
        }
        setOperationAsUndone(t, e) {
          this._undoPairs.set(e, t)
          this._undoneOperations.add(t)
        }
        isUndoingOperation(t) {
          return this._undoPairs.has(t)
        }
        isUndoneOperation(t) {
          return this._undoneOperations.has(t)
        }
        getUndoneOperation(t) {
          return this._undoPairs.get(t)
        }
        reset() {
          this._version = 0
          this._undoPairs = new Map()
          this._operations = []
          this._undoneOperations = new Set()
          this._gaps = new Map()
          this._baseVersionToOperationIndex = new Map()
        }
      }
      class t_ extends vb {
        constructor(t, e, n = 'main') {
          super(e)
          this._isAttached = true
          this._isLoaded = true
          this._document = t
          this.rootName = n
        }
        get document() {
          return this._document
        }
        isAttached() {
          return this._isAttached
        }
        toJSON() {
          return this.rootName
        }
      }
      t_.prototype.is = function (t, e) {
        if (!e) {
          return (
            t === 'rootElement' ||
            t === 'model:rootElement' ||
            t === 'element' ||
            t === 'model:element' ||
            t === 'node' ||
            t === 'model:node'
          )
        }
        return (
          e === this.name &&
          (t === 'rootElement' || t === 'model:rootElement' || t === 'element' || t === 'model:element')
        )
      }
      const e_ = '$graveyard'
      class n_ extends K() {
        constructor(t) {
          super()
          this.model = t
          this.history = new XA()
          this.selection = new ek(this)
          this.roots = new pl({ idProperty: 'rootName' })
          this.differ = new YA(t.markers)
          this.isReadOnly = false
          this._postFixers = new Set()
          this._hasSelectionChangedFromTheLastChangeBlock = false
          this.createRoot('$root', e_)
          this.listenTo(
            t,
            'applyOperation',
            (t, e) => {
              const n = e[0]
              if (n.isDocumentOperation) {
                this.differ.bufferOperation(n)
              }
            },
            { priority: 'high' },
          )
          this.listenTo(
            t,
            'applyOperation',
            (t, e) => {
              const n = e[0]
              if (n.isDocumentOperation) {
                this.history.addOperation(n)
              }
            },
            { priority: 'low' },
          )
          this.listenTo(this.selection, 'change', () => {
            this._hasSelectionChangedFromTheLastChangeBlock = true
          })
          this.listenTo(t.markers, 'update', (t, e, n, o, i) => {
            const r = { ...e.getData(), range: o }
            this.differ.bufferMarkerChange(e.name, i, r)
            if (n === null) {
              e.on('change', (t, n) => {
                const o = e.getData()
                this.differ.bufferMarkerChange(e.name, { ...o, range: n }, o)
              })
            }
          })
          this.registerPostFixer((t) => {
            let e = false
            for (const n of this.roots) {
              if (!n.isAttached() && !n.isEmpty) {
                t.remove(t.createRangeIn(n))
                e = true
              }
            }
            for (const n of this.model.markers) {
              if (!n.getRange().root.isAttached()) {
                t.removeMarker(n)
                e = true
              }
            }
            return e
          })
        }
        get version() {
          return this.history.version
        }
        set version(t) {
          this.history.version = t
        }
        get graveyard() {
          return this.getRoot(e_)
        }
        createRoot(t = '$root', e = 'main') {
          if (this.roots.get(e)) {
            throw new P('model-document-createroot-name-exists', this, { name: e })
          }
          const n = new t_(this, t, e)
          this.roots.add(n)
          return n
        }
        destroy() {
          this.selection.destroy()
          this.stopListening()
        }
        getRoot(t = 'main') {
          return this.roots.get(t)
        }
        getRootNames(t = false) {
          return this.getRoots(t).map((t) => t.rootName)
        }
        getRoots(t = false) {
          return Array.from(this.roots).filter((e) => e != this.graveyard && (t || e.isAttached()) && e._isLoaded)
        }
        registerPostFixer(t) {
          this._postFixers.add(t)
        }
        toJSON() {
          const t = Qu(this)
          t.selection = '[engine.model.DocumentSelection]'
          t.model = '[engine.model.Model]'
          return t
        }
        _handleChangeBlock(t) {
          if (this._hasDocumentChangedFromTheLastChangeBlock()) {
            this._callPostFixers(t)
            this.selection.refresh()
            if (this.differ.hasDataChanges()) {
              this.fire('change:data', t.batch)
            } else {
              this.fire('change', t.batch)
            }
            this.selection.refresh()
            this.differ.reset()
          }
          this._hasSelectionChangedFromTheLastChangeBlock = false
        }
        _hasDocumentChangedFromTheLastChangeBlock() {
          return !this.differ.isEmpty || this._hasSelectionChangedFromTheLastChangeBlock
        }
        _getDefaultRoot() {
          const t = this.getRoots()
          return t.length ? t[0] : this.graveyard
        }
        _getDefaultRange() {
          const t = this._getDefaultRoot()
          const e = this.model
          const n = e.schema
          const o = e.createPositionFromPath(t, [0])
          const i = n.getNearestSelectionRange(o)
          return i || e.createRange(o)
        }
        _validateSelectionRange(t) {
          return o_(t.start) && o_(t.end)
        }
        _callPostFixers(t) {
          let e = false
          do {
            for (const n of this._postFixers) {
              this.selection.refresh()
              e = n(t)
              if (e) {
                break
              }
            }
          } while (e)
        }
      }
      function o_(t) {
        const e = t.textNode
        if (e) {
          const n = e.data
          const o = t.offset - e.startOffset
          return !Il(n, o) && !Sl(n, o)
        }
        return true
      }
      class i_ extends K() {
        constructor() {
          super(...arguments)
          this._markers = new Map()
        }
        [Symbol.iterator]() {
          return this._markers.values()
        }
        has(t) {
          const e = t instanceof r_ ? t.name : t
          return this._markers.has(e)
        }
        get(t) {
          return this._markers.get(t) || null
        }
        _set(t, e, n = false, o = false) {
          const i = t instanceof r_ ? t.name : t
          if (i.includes(',')) {
            throw new P('markercollection-incorrect-marker-name', this)
          }
          const r = this._markers.get(i)
          if (r) {
            const t = r.getData()
            const s = r.getRange()
            let a = false
            if (!s.isEqual(e)) {
              r._attachLiveRange(Zb.fromRange(e))
              a = true
            }
            if (n != r.managedUsingOperations) {
              r._managedUsingOperations = n
              a = true
            }
            if (typeof o === 'boolean' && o != r.affectsData) {
              r._affectsData = o
              a = true
            }
            if (a) {
              this.fire(`update:${i}`, r, s, e, t)
            }
            return r
          }
          const s = Zb.fromRange(e)
          const a = new r_(i, s, n, o)
          this._markers.set(i, a)
          this.fire(`update:${i}`, a, null, e, { ...a.getData(), range: null })
          return a
        }
        _remove(t) {
          const e = t instanceof r_ ? t.name : t
          const n = this._markers.get(e)
          if (n) {
            this._markers.delete(e)
            this.fire(`update:${e}`, n, n.getRange(), null, n.getData())
            this._destroyMarker(n)
            return true
          }
          return false
        }
        _refresh(t) {
          const e = t instanceof r_ ? t.name : t
          const n = this._markers.get(e)
          if (!n) {
            throw new P('markercollection-refresh-marker-not-exists', this)
          }
          const o = n.getRange()
          this.fire(`update:${e}`, n, o, o, n.getData())
        }
        *getMarkersAtPosition(t) {
          for (const e of this) {
            if (e.getRange().containsPosition(t)) {
              yield e
            }
          }
        }
        *getMarkersIntersectingRange(t) {
          for (const e of this) {
            if (e.getRange().getIntersection(t) !== null) {
              yield e
            }
          }
        }
        destroy() {
          for (const t of this._markers.values()) {
            this._destroyMarker(t)
          }
          this._markers = null
          this.stopListening()
        }
        *getMarkersGroup(t) {
          for (const e of this._markers.values()) {
            if (e.name.startsWith(t + ':')) {
              yield e
            }
          }
        }
        _destroyMarker(t) {
          t.stopListening()
          t._detachLiveRange()
        }
      }
      class r_ extends K(kb) {
        constructor(t, e, n, o) {
          super()
          this.name = t
          this._liveRange = this._attachLiveRange(e)
          this._managedUsingOperations = n
          this._affectsData = o
        }
        get managedUsingOperations() {
          if (!this._liveRange) {
            throw new P('marker-destroyed', this)
          }
          return this._managedUsingOperations
        }
        get affectsData() {
          if (!this._liveRange) {
            throw new P('marker-destroyed', this)
          }
          return this._affectsData
        }
        getData() {
          return {
            range: this.getRange(),
            affectsData: this.affectsData,
            managedUsingOperations: this.managedUsingOperations,
          }
        }
        getStart() {
          if (!this._liveRange) {
            throw new P('marker-destroyed', this)
          }
          return this._liveRange.start.clone()
        }
        getEnd() {
          if (!this._liveRange) {
            throw new P('marker-destroyed', this)
          }
          return this._liveRange.end.clone()
        }
        getRange() {
          if (!this._liveRange) {
            throw new P('marker-destroyed', this)
          }
          return this._liveRange.toRange()
        }
        _attachLiveRange(t) {
          if (this._liveRange) {
            this._detachLiveRange()
          }
          t.delegate('change:range').to(this)
          t.delegate('change:content').to(this)
          this._liveRange = t
          return t
        }
        _detachLiveRange() {
          this._liveRange.stopDelegating('change:range', this)
          this._liveRange.stopDelegating('change:content', this)
          this._liveRange.detach()
          this._liveRange = null
        }
      }
      r_.prototype.is = function (t) {
        return t === 'marker' || t === 'model:marker'
      }
      class s_ extends lA {
        constructor(t, e) {
          super(null)
          this.sourcePosition = t.clone()
          this.howMany = e
        }
        get type() {
          return 'detach'
        }
        get affectedSelectable() {
          return null
        }
        toJSON() {
          const t = super.toJSON()
          t.sourcePosition = this.sourcePosition.toJSON()
          return t
        }
        _validate() {
          if (this.sourcePosition.root.document) {
            throw new P('detach-operation-on-document-node', this)
          }
        }
        _execute() {
          uA(Pb._createFromPositionAndShift(this.sourcePosition, this.howMany))
        }
        static get className() {
          return 'DetachOperation'
        }
      }
      class a_ extends kb {
        constructor(t) {
          super()
          this.markers = new Map()
          this._children = new Ab()
          if (t) {
            this._insertChild(0, t)
          }
        }
        [Symbol.iterator]() {
          return this.getChildren()
        }
        get childCount() {
          return this._children.length
        }
        get maxOffset() {
          return this._children.maxOffset
        }
        get isEmpty() {
          return this.childCount === 0
        }
        get nextSibling() {
          return null
        }
        get previousSibling() {
          return null
        }
        get root() {
          return this
        }
        get parent() {
          return null
        }
        get document() {
          return null
        }
        isAttached() {
          return false
        }
        getAncestors() {
          return []
        }
        getChild(t) {
          return this._children.getNode(t)
        }
        getChildren() {
          return this._children[Symbol.iterator]()
        }
        getChildIndex(t) {
          return this._children.getNodeIndex(t)
        }
        getChildStartOffset(t) {
          return this._children.getNodeStartOffset(t)
        }
        getPath() {
          return []
        }
        getNodeByPath(t) {
          let e = this
          for (const n of t) {
            e = e.getChild(e.offsetToIndex(n))
          }
          return e
        }
        offsetToIndex(t) {
          return this._children.offsetToIndex(t)
        }
        toJSON() {
          const t = []
          for (const e of this._children) {
            t.push(e.toJSON())
          }
          return t
        }
        static fromJSON(t) {
          const e = []
          for (const n of t) {
            if (n.name) {
              e.push(vb.fromJSON(n))
            } else {
              e.push(_b.fromJSON(n))
            }
          }
          return new a_(e)
        }
        _appendChild(t) {
          this._insertChild(this.childCount, t)
        }
        _insertChild(t, e) {
          const n = c_(e)
          for (const t of n) {
            if (t.parent !== null) {
              t._remove()
            }
            t.parent = this
          }
          this._children._insertNodes(t, n)
        }
        _removeChildren(t, e = 1) {
          const n = this._children._removeNodes(t, e)
          for (const t of n) {
            t.parent = null
          }
          return n
        }
      }
      a_.prototype.is = function (t) {
        return t === 'documentFragment' || t === 'model:documentFragment'
      }
      function c_(t) {
        if (typeof t == 'string') {
          return [new _b(t)]
        }
        if (!Tt(t)) {
          t = [t]
        }
        return Array.from(t).map((t) => {
          if (typeof t == 'string') {
            return new _b(t)
          }
          if (t instanceof Cb) {
            return new _b(t.data, t.getAttributes())
          }
          return t
        })
      }
      class l_ {
        constructor(t, e) {
          this.model = t
          this.batch = e
        }
        createText(t, e) {
          return new _b(t, e)
        }
        createElement(t, e) {
          return new vb(t, e)
        }
        createDocumentFragment() {
          return new a_()
        }
        cloneElement(t, e = true) {
          return t._clone(e)
        }
        insert(t, e, n = 0) {
          this._assertWriterUsedCorrectly()
          if (t instanceof _b && t.data == '') {
            return
          }
          const o = Db._createAt(e, n)
          if (t.parent) {
            if (f_(t.root, o.root)) {
              this.move(Pb._createOn(t), o)
              return
            } else {
              if (t.root.document) {
                throw new P('model-writer-insert-forbidden-move', this)
              } else {
                this.remove(t)
              }
            }
          }
          const i = o.root.document ? o.root.document.version : null
          const r = new wA(o, t, i)
          if (t instanceof _b) {
            r.shouldReceiveAttributes = true
          }
          this.batch.addOperation(r)
          this.model.applyOperation(r)
          if (t instanceof a_) {
            for (const [e, n] of t.markers) {
              const t = Db._createAt(n.root, 0)
              const i = new Pb(n.start._getCombined(t, o), n.end._getCombined(t, o))
              const r = { range: i, usingOperation: true, affectsData: true }
              if (this.model.markers.has(e)) {
                this.updateMarker(e, r)
              } else {
                this.addMarker(e, r)
              }
            }
          }
        }
        insertText(t, e, n, o) {
          if (e instanceof a_ || e instanceof vb || e instanceof Db) {
            this.insert(this.createText(t), e, n)
          } else {
            this.insert(this.createText(t, e), n, o)
          }
        }
        insertElement(t, e, n, o) {
          if (e instanceof a_ || e instanceof vb || e instanceof Db) {
            this.insert(this.createElement(t), e, n)
          } else {
            this.insert(this.createElement(t, e), n, o)
          }
        }
        append(t, e) {
          this.insert(t, e, 'end')
        }
        appendText(t, e, n) {
          if (e instanceof a_ || e instanceof vb) {
            this.insert(this.createText(t), e, 'end')
          } else {
            this.insert(this.createText(t, e), n, 'end')
          }
        }
        appendElement(t, e, n) {
          if (e instanceof a_ || e instanceof vb) {
            this.insert(this.createElement(t), e, 'end')
          } else {
            this.insert(this.createElement(t, e), n, 'end')
          }
        }
        setAttribute(t, e, n) {
          this._assertWriterUsedCorrectly()
          if (n instanceof Pb) {
            const o = n.getMinimalFlatRanges()
            for (const n of o) {
              d_(this, t, e, n)
            }
          } else {
            u_(this, t, e, n)
          }
        }
        setAttributes(t, e) {
          for (const [n, o] of _l(t)) {
            this.setAttribute(n, o, e)
          }
        }
        removeAttribute(t, e) {
          this._assertWriterUsedCorrectly()
          if (e instanceof Pb) {
            const n = e.getMinimalFlatRanges()
            for (const e of n) {
              d_(this, t, null, e)
            }
          } else {
            u_(this, t, null, e)
          }
        }
        clearAttributes(t) {
          this._assertWriterUsedCorrectly()
          const e = (t) => {
            for (const e of t.getAttributeKeys()) {
              this.removeAttribute(e, t)
            }
          }
          if (!(t instanceof Pb)) {
            e(t)
          } else {
            for (const n of t.getItems()) {
              e(n)
            }
          }
        }
        move(t, e, n) {
          this._assertWriterUsedCorrectly()
          if (!(t instanceof Pb)) {
            throw new P('writer-move-invalid-range', this)
          }
          if (!t.isFlat) {
            throw new P('writer-move-range-not-flat', this)
          }
          const o = Db._createAt(e, n)
          if (o.isEqual(t.start)) {
            return
          }
          this._addOperationForAffectedMarkers('move', t)
          if (!f_(t.root, o.root)) {
            throw new P('writer-move-different-document', this)
          }
          const i = t.root.document ? t.root.document.version : null
          const r = new kA(t.start, t.end.offset - t.start.offset, o, i)
          this.batch.addOperation(r)
          this.model.applyOperation(r)
        }
        remove(t) {
          this._assertWriterUsedCorrectly()
          const e = t instanceof Pb ? t : Pb._createOn(t)
          const n = e.getMinimalFlatRanges().reverse()
          for (const t of n) {
            this._addOperationForAffectedMarkers('move', t)
            g_(t.start, t.end.offset - t.start.offset, this.batch, this.model)
          }
        }
        merge(t) {
          this._assertWriterUsedCorrectly()
          const e = t.nodeBefore
          const n = t.nodeAfter
          this._addOperationForAffectedMarkers('merge', t)
          if (!(e instanceof vb)) {
            throw new P('writer-merge-no-element-before', this)
          }
          if (!(n instanceof vb)) {
            throw new P('writer-merge-no-element-after', this)
          }
          if (!t.root.document) {
            this._mergeDetached(t)
          } else {
            this._merge(t)
          }
        }
        createPositionFromPath(t, e, n) {
          return this.model.createPositionFromPath(t, e, n)
        }
        createPositionAt(t, e) {
          return this.model.createPositionAt(t, e)
        }
        createPositionAfter(t) {
          return this.model.createPositionAfter(t)
        }
        createPositionBefore(t) {
          return this.model.createPositionBefore(t)
        }
        createRange(t, e) {
          return this.model.createRange(t, e)
        }
        createRangeIn(t) {
          return this.model.createRangeIn(t)
        }
        createRangeOn(t) {
          return this.model.createRangeOn(t)
        }
        createSelection(...t) {
          return this.model.createSelection(...t)
        }
        _mergeDetached(t) {
          const e = t.nodeBefore
          const n = t.nodeAfter
          this.move(Pb._createIn(n), Db._createAt(e, 'end'))
          this.remove(n)
        }
        _merge(t) {
          const e = Db._createAt(t.nodeBefore, 'end')
          const n = Db._createAt(t.nodeAfter, 0)
          const o = t.root.document.graveyard
          const i = new Db(o, [0])
          const r = t.root.document.version
          const s = new _A(n, t.nodeAfter.maxOffset, e, i, r)
          this.batch.addOperation(s)
          this.model.applyOperation(s)
        }
        rename(t, e) {
          this._assertWriterUsedCorrectly()
          if (!(t instanceof vb)) {
            throw new P('writer-rename-not-element-instance', this)
          }
          const n = t.root.document ? t.root.document.version : null
          const o = new DA(Db._createBefore(t), t.name, e, n)
          this.batch.addOperation(o)
          this.model.applyOperation(o)
        }
        split(t, e) {
          this._assertWriterUsedCorrectly()
          let n = t.parent
          if (!n.parent) {
            throw new P('writer-split-element-no-parent', this)
          }
          if (!e) {
            e = n.parent
          }
          if (!t.parent.getAncestors({ includeSelf: true }).includes(e)) {
            throw new P('writer-split-invalid-limit-element', this)
          }
          let o
          let i
          do {
            const e = n.root.document ? n.root.document.version : null
            const r = n.maxOffset - t.offset
            const s = AA.getInsertionPosition(t)
            const a = new AA(t, r, s, null, e)
            this.batch.addOperation(a)
            this.model.applyOperation(a)
            if (!o && !i) {
              o = n
              i = t.parent.nextSibling
            }
            t = this.createPositionAfter(t.parent)
            n = t.parent
          } while (n !== e)
          return { position: t, range: new Pb(Db._createAt(o, 'end'), Db._createAt(i, 0)) }
        }
        wrap(t, e) {
          this._assertWriterUsedCorrectly()
          if (!t.isFlat) {
            throw new P('writer-wrap-range-not-flat', this)
          }
          const n = e instanceof vb ? e : new vb(e)
          if (n.childCount > 0) {
            throw new P('writer-wrap-element-not-empty', this)
          }
          if (n.parent !== null) {
            throw new P('writer-wrap-element-attached', this)
          }
          this.insert(n, t.start)
          const o = new Pb(t.start.getShiftedBy(1), t.end.getShiftedBy(1))
          this.move(o, Db._createAt(n, 0))
        }
        unwrap(t) {
          this._assertWriterUsedCorrectly()
          if (t.parent === null) {
            throw new P('writer-unwrap-element-no-parent', this)
          }
          this.move(Pb._createIn(t), this.createPositionAfter(t))
          this.remove(t)
        }
        addMarker(t, e) {
          this._assertWriterUsedCorrectly()
          if (!e || typeof e.usingOperation != 'boolean') {
            throw new P('writer-addmarker-no-usingoperation', this)
          }
          const n = e.usingOperation
          const o = e.range
          const i = e.affectsData === undefined ? false : e.affectsData
          if (this.model.markers.has(t)) {
            throw new P('writer-addmarker-marker-exists', this)
          }
          if (!o) {
            throw new P('writer-addmarker-no-range', this)
          }
          if (!n) {
            return this.model.markers._set(t, o, n, i)
          }
          h_(this, t, null, o, i)
          return this.model.markers.get(t)
        }
        updateMarker(t, e) {
          this._assertWriterUsedCorrectly()
          const n = typeof t == 'string' ? t : t.name
          const o = this.model.markers.get(n)
          if (!o) {
            throw new P('writer-updatemarker-marker-not-exists', this)
          }
          if (!e) {
            L('writer-updatemarker-reconvert-using-editingcontroller', { markerName: n })
            this.model.markers._refresh(o)
            return
          }
          const i = typeof e.usingOperation == 'boolean'
          const r = typeof e.affectsData == 'boolean'
          const s = r ? e.affectsData : o.affectsData
          if (!i && !e.range && !r) {
            throw new P('writer-updatemarker-wrong-options', this)
          }
          const a = o.getRange()
          const c = e.range ? e.range : a
          if (i && e.usingOperation !== o.managedUsingOperations) {
            if (e.usingOperation) {
              h_(this, n, null, c, s)
            } else {
              h_(this, n, a, null, s)
              this.model.markers._set(n, c, undefined, s)
            }
            return
          }
          if (o.managedUsingOperations) {
            h_(this, n, a, c, s)
          } else {
            this.model.markers._set(n, c, undefined, s)
          }
        }
        removeMarker(t) {
          this._assertWriterUsedCorrectly()
          const e = typeof t == 'string' ? t : t.name
          if (!this.model.markers.has(e)) {
            throw new P('writer-removemarker-no-marker', this)
          }
          const n = this.model.markers.get(e)
          if (!n.managedUsingOperations) {
            this.model.markers._remove(e)
            return
          }
          const o = n.getRange()
          h_(this, e, o, null, n.affectsData)
        }
        addRoot(t, e = '$root') {
          this._assertWriterUsedCorrectly()
          const n = this.model.document.getRoot(t)
          if (n && n.isAttached()) {
            throw new P('writer-addroot-root-exists', this)
          }
          const o = this.model.document
          const i = new IA(t, e, true, o, o.version)
          this.batch.addOperation(i)
          this.model.applyOperation(i)
          return this.model.document.getRoot(t)
        }
        detachRoot(t) {
          this._assertWriterUsedCorrectly()
          const e = typeof t == 'string' ? this.model.document.getRoot(t) : t
          if (!e || !e.isAttached()) {
            throw new P('writer-detachroot-no-root', this)
          }
          for (const t of this.model.markers) {
            if (t.getRange().root === e) {
              this.removeMarker(t)
            }
          }
          for (const t of e.getAttributeKeys()) {
            this.removeAttribute(t, e)
          }
          this.remove(this.createRangeIn(e))
          const n = this.model.document
          const o = new IA(e.rootName, e.name, false, n, n.version)
          this.batch.addOperation(o)
          this.model.applyOperation(o)
        }
        setSelection(...t) {
          this._assertWriterUsedCorrectly()
          this.model.document.selection._setTo(...t)
        }
        setSelectionFocus(t, e) {
          this._assertWriterUsedCorrectly()
          this.model.document.selection._setFocus(t, e)
        }
        setSelectionAttribute(t, e) {
          this._assertWriterUsedCorrectly()
          if (typeof t === 'string') {
            this._setSelectionAttribute(t, e)
          } else {
            for (const [e, n] of _l(t)) {
              this._setSelectionAttribute(e, n)
            }
          }
        }
        removeSelectionAttribute(t) {
          this._assertWriterUsedCorrectly()
          if (typeof t === 'string') {
            this._removeSelectionAttribute(t)
          } else {
            for (const e of t) {
              this._removeSelectionAttribute(e)
            }
          }
        }
        overrideSelectionGravity() {
          return this.model.document.selection._overrideGravity()
        }
        restoreSelectionGravity(t) {
          this.model.document.selection._restoreGravity(t)
        }
        _setSelectionAttribute(t, e) {
          const n = this.model.document.selection
          if (n.isCollapsed && n.anchor.parent.isEmpty) {
            const o = ek._getStoreAttributeKey(t)
            this.setAttribute(o, e, n.anchor.parent)
          }
          n._setAttribute(t, e)
        }
        _removeSelectionAttribute(t) {
          const e = this.model.document.selection
          if (e.isCollapsed && e.anchor.parent.isEmpty) {
            const n = ek._getStoreAttributeKey(t)
            this.removeAttribute(n, e.anchor.parent)
          }
          e._removeAttribute(t)
        }
        _assertWriterUsedCorrectly() {
          if (this.model._currentWriter !== this) {
            throw new P('writer-incorrect-use', this)
          }
        }
        _addOperationForAffectedMarkers(t, e) {
          for (const n of this.model.markers) {
            if (!n.managedUsingOperations) {
              continue
            }
            const o = n.getRange()
            let i = false
            if (t === 'move') {
              const t = e
              i =
                t.containsPosition(o.start) ||
                t.start.isEqual(o.start) ||
                t.containsPosition(o.end) ||
                t.end.isEqual(o.end)
            } else {
              const t = e
              const n = t.nodeBefore
              const r = t.nodeAfter
              const s = o.start.parent == n && o.start.isAtEnd
              const a = o.end.parent == r && o.end.offset == 0
              const c = o.end.nodeAfter == r
              const l = o.start.nodeAfter == r
              i = s || a || c || l
            }
            if (i) {
              this.updateMarker(n.name, { range: o })
            }
          }
        }
      }
      function d_(t, e, n, o) {
        const i = t.model
        const r = i.document
        let s = o.start
        let a
        let c
        let l
        for (const t of o.getWalker({ shallow: true })) {
          l = t.item.getAttribute(e)
          if (a && c != l) {
            if (c != n) {
              d()
            }
            s = a
          }
          a = t.nextPosition
          c = l
        }
        if (a instanceof Db && a != s && c != n) {
          d()
        }
        function d() {
          const o = new Pb(s, a)
          const l = o.root.document ? r.version : null
          const d = new xA(o, e, c, n, l)
          t.batch.addOperation(d)
          i.applyOperation(d)
        }
      }
      function u_(t, e, n, o) {
        const i = t.model
        const r = i.document
        const s = o.getAttribute(e)
        let a, c
        if (s != n) {
          const l = o.root === o
          if (l) {
            const t = o.document ? r.version : null
            c = new TA(o, e, s, n, t)
          } else {
            a = new Pb(Db._createBefore(o), t.createPositionAfter(o))
            const i = a.root.document ? r.version : null
            c = new xA(a, e, s, n, i)
          }
          t.batch.addOperation(c)
          i.applyOperation(c)
        }
      }
      function h_(t, e, n, o, i) {
        const r = t.model
        const s = r.document
        const a = new CA(e, n, o, r.markers, !!i, s.version)
        t.batch.addOperation(a)
        r.applyOperation(a)
      }
      function g_(t, e, n, o) {
        let i
        if (t.root.document) {
          const n = o.document
          const r = new Db(n.graveyard, [0])
          i = new kA(t, e, r, n.version)
        } else {
          i = new s_(t, e)
        }
        n.addOperation(i)
        o.applyOperation(i)
      }
      function f_(t, e) {
        if (t === e) {
          return true
        }
        if (t instanceof t_ && e instanceof t_) {
          return true
        }
        return false
      }
      function m_(t, e, n = {}) {
        if (e.isCollapsed) {
          return
        }
        const o = e.getFirstRange()
        if (o.root.rootName == '$graveyard') {
          return
        }
        const i = t.schema
        t.change((t) => {
          if (!n.doNotResetEntireContent && T_(i, e)) {
            D_(t, e)
            return
          }
          const r = {}
          if (!n.doNotAutoparagraph) {
            const t = e.getSelectedElement()
            if (t) {
              Object.assign(r, i.getAttributesWithProperty(t, 'copyOnReplace', true))
            }
          }
          const [s, a] = p_(o)
          if (!s.isTouching(a)) {
            t.remove(t.createRange(s, a))
          }
          if (!n.leaveUnmerged) {
            k_(t, s, a)
            i.removeDisallowedAttributes(s.parent.getChildren(), t)
          }
          I_(t, e, s)
          if (!n.doNotAutoparagraph && y_(i, s)) {
            E_(t, s, e, r)
          }
          s.detach()
          a.detach()
        })
      }
      function p_(t) {
        const e = t.root.document.model
        const n = t.start
        let o = t.end
        if (e.hasContent(t, { ignoreMarkers: true })) {
          const n = b_(o)
          if (n && o.isTouching(e.createPositionAt(n, 0))) {
            const n = e.createSelection(t)
            e.modifySelection(n, { direction: 'backward' })
            const i = n.getLastPosition()
            const r = e.createRange(i, o)
            if (!e.hasContent(r, { ignoreMarkers: true })) {
              o = i
            }
          }
        }
        return [GA.fromPosition(n, 'toPrevious'), GA.fromPosition(o, 'toNext')]
      }
      function b_(t) {
        const e = t.parent
        const n = e.root.document.model.schema
        const o = e.getAncestors({ parentFirst: true, includeSelf: true })
        for (const t of o) {
          if (n.isLimit(t)) {
            return null
          }
          if (n.isBlock(t)) {
            return t
          }
        }
      }
      function k_(t, e, n) {
        const o = t.model
        if (!C_(t.model.schema, e, n)) {
          return
        }
        const [i, r] = v_(e, n)
        if (!i || !r) {
          return
        }
        if (!o.hasContent(i, { ignoreMarkers: true }) && o.hasContent(r, { ignoreMarkers: true })) {
          A_(t, e, n, i.parent)
        } else {
          w_(t, e, n, i.parent)
        }
      }
      function w_(t, e, n, o) {
        const i = e.parent
        const r = n.parent
        if (i == o || r == o) {
          return
        }
        e = t.createPositionAfter(i)
        n = t.createPositionBefore(r)
        if (!n.isEqual(e)) {
          t.insert(r, e)
        }
        t.merge(e)
        while (n.parent.isEmpty) {
          const e = n.parent
          n = t.createPositionBefore(e)
          t.remove(e)
        }
        if (!C_(t.model.schema, e, n)) {
          return
        }
        w_(t, e, n, o)
      }
      function A_(t, e, n, o) {
        const i = e.parent
        const r = n.parent
        if (i == o || r == o) {
          return
        }
        e = t.createPositionAfter(i)
        n = t.createPositionBefore(r)
        if (!n.isEqual(e)) {
          t.insert(i, n)
        }
        while (e.parent.isEmpty) {
          const n = e.parent
          e = t.createPositionBefore(n)
          t.remove(n)
        }
        n = t.createPositionBefore(r)
        __(t, n)
        if (!C_(t.model.schema, e, n)) {
          return
        }
        A_(t, e, n, o)
      }
      function __(t, e) {
        const n = e.nodeBefore
        const o = e.nodeAfter
        if (n.name != o.name) {
          t.rename(n, o.name)
        }
        t.clearAttributes(n)
        t.setAttributes(Object.fromEntries(o.getAttributes()), n)
        t.merge(e)
      }
      function C_(t, e, n) {
        const o = e.parent
        const i = n.parent
        if (o == i) {
          return false
        }
        if (t.isLimit(o) || t.isLimit(i)) {
          return false
        }
        return x_(e, n, t)
      }
      function v_(t, e) {
        const n = t.getAncestors()
        const o = e.getAncestors()
        let i = 0
        while (n[i] && n[i] == o[i]) {
          i++
        }
        return [n[i], o[i]]
      }
      function y_(t, e) {
        const n = t.checkChild(e, '$text')
        const o = t.checkChild(e, 'paragraph')
        return !n && o
      }
      function x_(t, e, n) {
        const o = new Pb(t, e)
        for (const t of o.getWalker()) {
          if (n.isLimit(t.item)) {
            return false
          }
        }
        return true
      }
      function E_(t, e, n, o = {}) {
        const i = t.createElement('paragraph')
        t.model.schema.setAllowedAttributes(i, o, t)
        t.insert(i, e)
        I_(t, n, t.createPositionAt(i, 0))
      }
      function D_(t, e) {
        const n = t.model.schema.getLimitElement(e)
        t.remove(t.createRangeIn(n))
        E_(t, t.createPositionAt(n, 0), e)
      }
      function T_(t, e) {
        const n = t.getLimitElement(e)
        if (!e.containsEntireContent(n)) {
          return false
        }
        const o = e.getFirstRange()
        if (o.start.parent == o.end.parent) {
          return false
        }
        return t.checkChild(n, 'paragraph')
      }
      function I_(t, e, n) {
        if (e instanceof ek) {
          t.setSelection(n)
        } else {
          e.setTo(n)
        }
      }
      function S_(t, e) {
        return t.change((t) => {
          const n = t.createDocumentFragment()
          const o = e.getFirstRange()
          if (!o || o.isCollapsed) {
            return n
          }
          const i = o.start.root
          const r = o.start.getCommonPath(o.end)
          const s = i.getNodeByPath(r)
          let a
          if (o.start.parent == o.end.parent) {
            a = o
          } else {
            a = t.createRange(
              t.createPositionAt(s, o.start.path[r.length]),
              t.createPositionAt(s, o.end.path[r.length] + 1),
            )
          }
          const c = a.end.offset - a.start.offset
          for (const e of a.getItems({ shallow: true })) {
            if (e.is('$textProxy')) {
              t.appendText(e.data, e.getAttributes(), n)
            } else {
              t.append(t.cloneElement(e, true), n)
            }
          }
          if (a != o) {
            const e = o._getTransformedByMove(a.start, t.createPositionAt(n, 0), c)[0]
            const i = t.createRange(t.createPositionAt(n, 0), e.start)
            const r = t.createRange(e.end, t.createPositionAt(n, 'end'))
            M_(r, t)
            M_(i, t)
          }
          return n
        })
      }
      function M_(t, e) {
        const n = []
        Array.from(t.getItems({ direction: 'backward' }))
          .map((t) => e.createRangeOn(t))
          .filter((e) => {
            const n =
              (e.start.isAfter(t.start) || e.start.isEqual(t.start)) && (e.end.isBefore(t.end) || e.end.isEqual(t.end))
            return n
          })
          .forEach((t) => {
            n.push(t.start.parent)
            e.remove(t)
          })
        n.forEach((t) => {
          let n = t
          while (n.parent && n.isEmpty) {
            const t = e.createRangeOn(n)
            n = n.parent
            e.remove(t)
          }
        })
      }
      function B_(t, e, n) {
        return t.change((o) => {
          const i = n ? n : t.document.selection
          if (!i.isCollapsed) {
            t.deleteContent(i, { doNotAutoparagraph: true })
          }
          const r = new N_(t, o, i.anchor)
          const s = []
          let a
          if (e.is('documentFragment')) {
            if (e.markers.size) {
              const t = []
              for (const [n, o] of e.markers) {
                const { start: e, end: i } = o
                const r = e.isEqual(i)
                t.push({ position: e, name: n, isCollapsed: r }, { position: i, name: n, isCollapsed: r })
              }
              t.sort(({ position: t }, { position: e }) => (t.isBefore(e) ? 1 : -1))
              for (const { position: n, name: i, isCollapsed: r } of t) {
                let t = null
                let a = null
                const c = n.parent === e && n.isAtStart
                const l = n.parent === e && n.isAtEnd
                if (!c && !l) {
                  t = o.createElement('$marker')
                  o.insert(t, n)
                } else if (r) {
                  a = c ? 'start' : 'end'
                }
                s.push({ name: i, element: t, collapsed: a })
              }
            }
            a = e.getChildren()
          } else {
            a = [e]
          }
          r.handleNodes(a)
          let c = r.getSelectionRange()
          if (e.is('documentFragment') && s.length) {
            const t = c ? Zb.fromRange(c) : null
            const e = {}
            for (let t = s.length - 1; t >= 0; t--) {
              const { name: n, element: i, collapsed: a } = s[t]
              const c = !e[n]
              if (c) {
                e[n] = []
              }
              if (i) {
                const t = o.createPositionAt(i, 'before')
                e[n].push(t)
                o.remove(i)
              } else {
                const t = r.getAffectedRange()
                if (!t) {
                  if (a) {
                    e[n].push(r.position)
                  }
                  continue
                }
                if (a) {
                  e[n].push(t[a])
                } else {
                  e[n].push(c ? t.start : t.end)
                }
              }
            }
            for (const [t, [n, i]] of Object.entries(e)) {
              if (n && i && n.root === i.root) {
                o.addMarker(t, { usingOperation: true, affectsData: true, range: new Pb(n, i) })
              }
            }
            if (t) {
              c = t.toRange()
              t.detach()
            }
          }
          if (c) {
            if (i instanceof ek) {
              o.setSelection(c)
            } else {
              i.setTo(c)
            }
          } else {
          }
          const l = r.getAffectedRange() || t.createRange(i.anchor)
          r.destroy()
          return l
        })
      }
      class N_ {
        constructor(t, e, n) {
          this._firstNode = null
          this._lastNode = null
          this._lastAutoParagraph = null
          this._filterAttributesOf = []
          this._affectedStart = null
          this._affectedEnd = null
          this._nodeToSelect = null
          this.model = t
          this.writer = e
          this.position = n
          this.canMergeWith = new Set([this.position.parent])
          this.schema = t.schema
          this._documentFragment = e.createDocumentFragment()
          this._documentFragmentPosition = e.createPositionAt(this._documentFragment, 0)
        }
        handleNodes(t) {
          for (const e of Array.from(t)) {
            this._handleNode(e)
          }
          this._insertPartialFragment()
          if (this._lastAutoParagraph) {
            this._updateLastNodeFromAutoParagraph(this._lastAutoParagraph)
          }
          this._mergeOnRight()
          this.schema.removeDisallowedAttributes(this._filterAttributesOf, this.writer)
          this._filterAttributesOf = []
        }
        _updateLastNodeFromAutoParagraph(t) {
          const e = this.writer.createPositionAfter(this._lastNode)
          const n = this.writer.createPositionAfter(t)
          if (n.isAfter(e)) {
            this._lastNode = t
            if (this.position.parent != t || !this.position.isAtEnd) {
              throw new P('insertcontent-invalid-insertion-position', this)
            }
            this.position = n
            this._setAffectedBoundaries(this.position)
          }
        }
        getSelectionRange() {
          if (this._nodeToSelect) {
            return Pb._createOn(this._nodeToSelect)
          }
          return this.model.schema.getNearestSelectionRange(this.position)
        }
        getAffectedRange() {
          if (!this._affectedStart) {
            return null
          }
          return new Pb(this._affectedStart, this._affectedEnd)
        }
        destroy() {
          if (this._affectedStart) {
            this._affectedStart.detach()
          }
          if (this._affectedEnd) {
            this._affectedEnd.detach()
          }
        }
        _handleNode(t) {
          if (this.schema.isObject(t)) {
            this._handleObject(t)
            return
          }
          let e = this._checkAndAutoParagraphToAllowedPosition(t)
          if (!e) {
            e = this._checkAndSplitToAllowedPosition(t)
            if (!e) {
              this._handleDisallowedNode(t)
              return
            }
          }
          this._appendToFragment(t)
          if (!this._firstNode) {
            this._firstNode = t
          }
          this._lastNode = t
        }
        _insertPartialFragment() {
          if (this._documentFragment.isEmpty) {
            return
          }
          const t = GA.fromPosition(this.position, 'toNext')
          this._setAffectedBoundaries(this.position)
          if (this._documentFragment.getChild(0) == this._firstNode) {
            this.writer.insert(this._firstNode, this.position)
            this._mergeOnLeft()
            this.position = t.toPosition()
          }
          if (!this._documentFragment.isEmpty) {
            this.writer.insert(this._documentFragment, this.position)
          }
          this._documentFragmentPosition = this.writer.createPositionAt(this._documentFragment, 0)
          this.position = t.toPosition()
          t.detach()
        }
        _handleObject(t) {
          if (this._checkAndSplitToAllowedPosition(t)) {
            this._appendToFragment(t)
          } else {
            this._tryAutoparagraphing(t)
          }
        }
        _handleDisallowedNode(t) {
          if (t.is('element')) {
            this.handleNodes(t.getChildren())
          } else {
            this._tryAutoparagraphing(t)
          }
        }
        _appendToFragment(t) {
          if (!this.schema.checkChild(this.position, t)) {
            throw new P('insertcontent-wrong-position', this, { node: t, position: this.position })
          }
          this.writer.insert(t, this._documentFragmentPosition)
          this._documentFragmentPosition = this._documentFragmentPosition.getShiftedBy(t.offsetSize)
          if (this.schema.isObject(t) && !this.schema.checkChild(this.position, '$text')) {
            this._nodeToSelect = t
          } else {
            this._nodeToSelect = null
          }
          this._filterAttributesOf.push(t)
        }
        _setAffectedBoundaries(t) {
          if (!this._affectedStart) {
            this._affectedStart = GA.fromPosition(t, 'toPrevious')
          }
          if (!this._affectedEnd || this._affectedEnd.isBefore(t)) {
            if (this._affectedEnd) {
              this._affectedEnd.detach()
            }
            this._affectedEnd = GA.fromPosition(t, 'toNext')
          }
        }
        _mergeOnLeft() {
          const t = this._firstNode
          if (!(t instanceof vb)) {
            return
          }
          if (!this._canMergeLeft(t)) {
            return
          }
          const e = GA._createBefore(t)
          e.stickiness = 'toNext'
          const n = GA.fromPosition(this.position, 'toNext')
          if (this._affectedStart.isEqual(e)) {
            this._affectedStart.detach()
            this._affectedStart = GA._createAt(e.nodeBefore, 'end', 'toPrevious')
          }
          if (this._firstNode === this._lastNode) {
            this._firstNode = e.nodeBefore
            this._lastNode = e.nodeBefore
          }
          this.writer.merge(e)
          if (e.isEqual(this._affectedEnd) && this._firstNode === this._lastNode) {
            this._affectedEnd.detach()
            this._affectedEnd = GA._createAt(e.nodeBefore, 'end', 'toNext')
          }
          this.position = n.toPosition()
          n.detach()
          this._filterAttributesOf.push(this.position.parent)
          e.detach()
        }
        _mergeOnRight() {
          const t = this._lastNode
          if (!(t instanceof vb)) {
            return
          }
          if (!this._canMergeRight(t)) {
            return
          }
          const e = GA._createAfter(t)
          e.stickiness = 'toNext'
          if (!this.position.isEqual(e)) {
            throw new P('insertcontent-invalid-insertion-position', this)
          }
          this.position = Db._createAt(e.nodeBefore, 'end')
          const n = GA.fromPosition(this.position, 'toPrevious')
          if (this._affectedEnd.isEqual(e)) {
            this._affectedEnd.detach()
            this._affectedEnd = GA._createAt(e.nodeBefore, 'end', 'toNext')
          }
          if (this._firstNode === this._lastNode) {
            this._firstNode = e.nodeBefore
            this._lastNode = e.nodeBefore
          }
          this.writer.merge(e)
          if (e.getShiftedBy(-1).isEqual(this._affectedStart) && this._firstNode === this._lastNode) {
            this._affectedStart.detach()
            this._affectedStart = GA._createAt(e.nodeBefore, 0, 'toPrevious')
          }
          this.position = n.toPosition()
          n.detach()
          this._filterAttributesOf.push(this.position.parent)
          e.detach()
        }
        _canMergeLeft(t) {
          const e = t.previousSibling
          return e instanceof vb && this.canMergeWith.has(e) && this.model.schema.checkMerge(e, t)
        }
        _canMergeRight(t) {
          const e = t.nextSibling
          return e instanceof vb && this.canMergeWith.has(e) && this.model.schema.checkMerge(t, e)
        }
        _tryAutoparagraphing(t) {
          const e = this.writer.createElement('paragraph')
          if (this._getAllowedIn(this.position.parent, e) && this.schema.checkChild(e, t)) {
            e._appendChild(t)
            this._handleNode(e)
          }
        }
        _checkAndAutoParagraphToAllowedPosition(t) {
          if (this.schema.checkChild(this.position.parent, t)) {
            return true
          }
          if (!this.schema.checkChild(this.position.parent, 'paragraph') || !this.schema.checkChild('paragraph', t)) {
            return false
          }
          this._insertPartialFragment()
          const e = this.writer.createElement('paragraph')
          this.writer.insert(e, this.position)
          this._setAffectedBoundaries(this.position)
          this._lastAutoParagraph = e
          this.position = this.writer.createPositionAt(e, 0)
          return true
        }
        _checkAndSplitToAllowedPosition(t) {
          const e = this._getAllowedIn(this.position.parent, t)
          if (!e) {
            return false
          }
          if (e != this.position.parent) {
            this._insertPartialFragment()
          }
          while (e != this.position.parent) {
            if (this.position.isAtStart) {
              const t = this.position.parent
              this.position = this.writer.createPositionBefore(t)
              if (t.isEmpty && t.parent === e) {
                this.writer.remove(t)
              }
            } else if (this.position.isAtEnd) {
              this.position = this.writer.createPositionAfter(this.position.parent)
            } else {
              const t = this.writer.createPositionAfter(this.position.parent)
              this._setAffectedBoundaries(this.position)
              this.writer.split(this.position)
              this.position = t
              this.canMergeWith.add(this.position.nodeAfter)
            }
          }
          return true
        }
        _getAllowedIn(t, e) {
          if (this.schema.checkChild(t, e)) {
            return t
          }
          if (this.schema.isLimit(t)) {
            return null
          }
          return this._getAllowedIn(t.parent, e)
        }
      }
      function P_(t, e, n = 'auto') {
        const o = t.getSelectedElement()
        if (o && e.schema.isObject(o) && !e.schema.isInline(o)) {
          if (n == 'before' || n == 'after') {
            return e.createRange(e.createPositionAt(o, n))
          }
          return e.createRangeOn(o)
        }
        const i = bl(t.getSelectedBlocks())
        if (!i) {
          return e.createRange(t.focus)
        }
        if (i.isEmpty) {
          return e.createRange(e.createPositionAt(i, 0))
        }
        const r = e.createPositionAfter(i)
        if (t.focus.isTouching(r)) {
          return e.createRange(r)
        }
        return e.createRange(e.createPositionBefore(i))
      }
      function L_(t, e, n, o = {}) {
        if (!t.schema.isObject(e)) {
          throw new P('insertobject-element-not-an-object', t, { object: e })
        }
        const i = n ? n : t.document.selection
        let r = i
        if (o.findOptimalPosition && t.schema.isBlock(e)) {
          r = t.createSelection(P_(i, t, o.findOptimalPosition))
        }
        const s = bl(i.getSelectedBlocks())
        const a = {}
        if (s) {
          Object.assign(a, t.schema.getAttributesWithProperty(s, 'copyOnReplace', true))
        }
        return t.change((n) => {
          if (!r.isCollapsed) {
            t.deleteContent(r, { doNotAutoparagraph: true })
          }
          let i = e
          const s = r.anchor.parent
          if (
            !t.schema.checkChild(s, e) &&
            t.schema.checkChild(s, 'paragraph') &&
            t.schema.checkChild('paragraph', e)
          ) {
            i = n.createElement('paragraph')
            n.insert(e, i)
          }
          t.schema.setAllowedAttributes(i, a, n)
          const c = t.insertContent(i, r)
          if (c.isCollapsed) {
            return c
          }
          if (o.setSelection) {
            z_(n, e, o.setSelection, a)
          }
          return c
        })
      }
      function z_(t, e, n, o) {
        const i = t.model
        if (n == 'on') {
          t.setSelection(e, 'on')
          return
        }
        if (n != 'after') {
          throw new P('insertobject-invalid-place-parameter-value', i)
        }
        let r = e.nextSibling
        if (i.schema.isInline(e)) {
          t.setSelection(e, 'after')
          return
        }
        const s = r && i.schema.checkChild(r, '$text')
        if (!s && i.schema.checkChild(e.parent, 'paragraph')) {
          r = t.createElement('paragraph')
          i.schema.setAllowedAttributes(r, o, t)
          i.insertContent(r, t.createPositionAfter(e))
        }
        if (r) {
          t.setSelection(r, 0)
        }
      }
      const R_ = ' ,.?!:;"-()'
      function O_(t, e, n = {}) {
        const o = t.schema
        const i = n.direction != 'backward'
        const r = n.unit ? n.unit : 'character'
        const s = !!n.treatEmojiAsSingleUnit
        const a = e.focus
        const c = new xb({ boundaries: H_(a, i), singleCharacters: true, direction: i ? 'forward' : 'backward' })
        const l = { walker: c, schema: o, isForward: i, unit: r, treatEmojiAsSingleUnit: s }
        let d
        while ((d = c.next())) {
          if (d.done) {
            return
          }
          const n = V_(l, d.value)
          if (n) {
            if (e instanceof ek) {
              t.change((t) => {
                t.setSelectionFocus(n)
              })
            } else {
              e.setFocus(n)
            }
            return
          }
        }
      }
      function V_(t, e) {
        const { isForward: n, walker: o, unit: i, schema: r, treatEmojiAsSingleUnit: s } = t
        const { type: a, item: c, nextPosition: l } = e
        if (a == 'text') {
          if (t.unit === 'word') {
            return j_(o, n)
          }
          return F_(o, i, s)
        }
        if (a == (n ? 'elementStart' : 'elementEnd')) {
          if (r.isSelectable(c)) {
            return Db._createAt(c, n ? 'after' : 'before')
          }
          if (r.checkChild(l, '$text')) {
            return l
          }
        } else {
          if (r.isLimit(c)) {
            o.skip(() => true)
            return
          }
          if (r.checkChild(l, '$text')) {
            return l
          }
        }
      }
      function F_(t, e, n) {
        const o = t.position.textNode
        if (o) {
          const i = o.data
          let r = t.position.offset - o.startOffset
          while (Il(i, r) || (e == 'character' && Sl(i, r)) || (n && Bl(i, r))) {
            t.next()
            r = t.position.offset - o.startOffset
          }
        }
        return t.position
      }
      function j_(t, e) {
        let n = t.position.textNode
        if (!n) {
          n = e ? t.position.nodeAfter : t.position.nodeBefore
        }
        while (n && n.is('$text')) {
          const o = t.position.offset - n.startOffset
          if (W_(n, o, e)) {
            n = e ? t.position.nodeAfter : t.position.nodeBefore
          } else if (U_(n.data, o, e)) {
            break
          } else {
            t.next()
          }
        }
        return t.position
      }
      function H_(t, e) {
        const n = t.root
        const o = Db._createAt(n, e ? 'end' : 0)
        if (e) {
          return new Pb(t, o)
        } else {
          return new Pb(o, t)
        }
      }
      function U_(t, e, n) {
        const o = e + (n ? 0 : -1)
        return R_.includes(t.charAt(o))
      }
      function W_(t, e, n) {
        return e === (n ? t.offsetSize : 0)
      }
      class G_ extends ft() {
        constructor() {
          super()
          this.markers = new i_()
          this.document = new n_(this)
          this.schema = new Nw()
          this._pendingChanges = []
          this._currentWriter = null
          ;['deleteContent', 'modifySelection', 'getSelectedContent', 'applyOperation'].forEach((t) => this.decorate(t))
          this.on(
            'applyOperation',
            (t, e) => {
              const n = e[0]
              n._validate()
            },
            { priority: 'highest' },
          )
          this.schema.register('$root', { isLimit: true })
          this.schema.register('$container', { allowIn: ['$root', '$container'] })
          this.schema.register('$block', { allowIn: ['$root', '$container'], isBlock: true })
          this.schema.register('$blockObject', { allowWhere: '$block', isBlock: true, isObject: true })
          this.schema.register('$inlineObject', {
            allowWhere: '$text',
            allowAttributesOf: '$text',
            isInline: true,
            isObject: true,
          })
          this.schema.register('$text', { allowIn: '$block', isInline: true, isContent: true })
          this.schema.register('$clipboardHolder', { allowContentOf: '$root', allowChildren: '$text', isLimit: true })
          this.schema.register('$documentFragment', { allowContentOf: '$root', allowChildren: '$text', isLimit: true })
          this.schema.register('$marker')
          this.schema.addChildCheck((t, e) => {
            if (e.name === '$marker') {
              return true
            }
          })
          ww(this)
          this.document.registerPostFixer(Zk)
          this.on('insertContent', (t, [e, n]) => {
            t.return = B_(this, e, n)
          })
          this.on('insertObject', (t, [e, n, o]) => {
            t.return = L_(this, e, n, o)
          })
          this.on('canEditAt', (t) => {
            const e = !this.document.isReadOnly
            t.return = e
            if (!e) {
              t.stop()
            }
          })
        }
        change(t) {
          try {
            if (this._pendingChanges.length === 0) {
              this._pendingChanges.push({ batch: new KA(), callback: t })
              return this._runPendingChanges()[0]
            } else {
              return t(this._currentWriter)
            }
          } catch (t) {
            P.rethrowUnexpectedError(t, this)
          }
        }
        enqueueChange(t, e) {
          try {
            if (!t) {
              t = new KA()
            } else if (typeof t === 'function') {
              e = t
              t = new KA()
            } else if (!(t instanceof KA)) {
              t = new KA(t)
            }
            this._pendingChanges.push({ batch: t, callback: e })
            if (this._pendingChanges.length == 1) {
              this._runPendingChanges()
            }
          } catch (t) {
            P.rethrowUnexpectedError(t, this)
          }
        }
        applyOperation(t) {
          t._execute()
        }
        insertContent(t, e, n, ...o) {
          const i = q_(e, n)
          return this.fire('insertContent', [t, i, n, ...o])
        }
        insertObject(t, e, n, o, ...i) {
          const r = q_(e, n)
          return this.fire('insertObject', [t, r, o, o, ...i])
        }
        deleteContent(t, e) {
          m_(this, t, e)
        }
        modifySelection(t, e) {
          O_(this, t, e)
        }
        getSelectedContent(t) {
          return S_(this, t)
        }
        hasContent(t, e = {}) {
          const n = t instanceof Pb ? t : Pb._createIn(t)
          if (n.isCollapsed) {
            return false
          }
          const { ignoreWhitespaces: o = false, ignoreMarkers: i = false } = e
          if (!i) {
            for (const t of this.markers.getMarkersIntersectingRange(n)) {
              if (t.affectsData) {
                return true
              }
            }
          }
          for (const t of n.getItems()) {
            if (this.schema.isContent(t)) {
              if (t.is('$textProxy')) {
                if (!o) {
                  return true
                } else if (t.data.search(/\S/) !== -1) {
                  return true
                }
              } else {
                return true
              }
            }
          }
          return false
        }
        canEditAt(t) {
          const e = q_(t)
          return this.fire('canEditAt', [e])
        }
        createPositionFromPath(t, e, n) {
          return new Db(t, e, n)
        }
        createPositionAt(t, e) {
          return Db._createAt(t, e)
        }
        createPositionAfter(t) {
          return Db._createAfter(t)
        }
        createPositionBefore(t) {
          return Db._createBefore(t)
        }
        createRange(t, e) {
          return new Pb(t, e)
        }
        createRangeIn(t) {
          return Pb._createIn(t)
        }
        createRangeOn(t) {
          return Pb._createOn(t)
        }
        createSelection(...t) {
          return new Hb(...t)
        }
        createBatch(t) {
          return new KA(t)
        }
        createOperationFromJSON(t) {
          return MA.fromJSON(t, this.document)
        }
        destroy() {
          this.document.destroy()
          this.stopListening()
        }
        _runPendingChanges() {
          const t = []
          this.fire('_beforeChanges')
          try {
            while (this._pendingChanges.length) {
              const e = this._pendingChanges[0].batch
              this._currentWriter = new l_(this, e)
              const n = this._pendingChanges[0].callback(this._currentWriter)
              t.push(n)
              this.document._handleChangeBlock(this._currentWriter)
              this._pendingChanges.shift()
              this._currentWriter = null
            }
          } finally {
            this._pendingChanges.length = 0
            this._currentWriter = null
            this.fire('_afterChanges')
          }
          return t
        }
      }
      function q_(t, e) {
        if (!t) {
          return
        }
        if (t instanceof Hb || t instanceof ek) {
          return t
        }
        if (t instanceof wb) {
          if (e || e === 0) {
            return new Hb(t, e)
          } else if (t.is('rootElement')) {
            return new Hb(t, 'in')
          } else {
            return new Hb(t, 'on')
          }
        }
        return new Hb(t)
      }
      class $_ extends Lm {
        constructor() {
          super(...arguments)
          this.domEventType = 'click'
        }
        onDomEvent(t) {
          this.fire(t.type, t)
        }
      }
      class K_ extends Lm {
        constructor() {
          super(...arguments)
          this.domEventType = ['mousedown', 'mouseup', 'mouseover', 'mouseout']
        }
        onDomEvent(t) {
          this.fire(t.type, t)
        }
      }
      class Y_ {
        constructor(t) {
          this.document = t
        }
        createDocumentFragment(t) {
          return new zf(this.document, t)
        }
        createElement(t, e, n) {
          return new Xg(this.document, t, e, n)
        }
        createText(t) {
          return new Xu(this.document, t)
        }
        clone(t, e = false) {
          return t._clone(e)
        }
        appendChild(t, e) {
          return e._appendChild(t)
        }
        insertChild(t, e, n) {
          return n._insertChild(t, e)
        }
        removeChildren(t, e, n) {
          return n._removeChildren(t, e)
        }
        remove(t) {
          const e = t.parent
          if (e) {
            return this.removeChildren(e.getChildIndex(t), 1, e)
          }
          return []
        }
        replace(t, e) {
          const n = t.parent
          if (n) {
            const o = n.getChildIndex(t)
            this.removeChildren(o, 1, n)
            this.insertChild(o, e, n)
            return true
          }
          return false
        }
        unwrapElement(t) {
          const e = t.parent
          if (e) {
            const n = e.getChildIndex(t)
            this.remove(t)
            this.insertChild(n, t.getChildren(), e)
          }
        }
        rename(t, e) {
          const n = new Xg(this.document, t, e.getAttributes(), e.getChildren())
          return this.replace(e, n) ? n : null
        }
        setAttribute(t, e, n) {
          n._setAttribute(t, e)
        }
        removeAttribute(t, e) {
          e._removeAttribute(t)
        }
        addClass(t, e) {
          e._addClass(t)
        }
        removeClass(t, e) {
          e._removeClass(t)
        }
        setStyle(t, e, n) {
          if (pe(t) && n === undefined) {
            e._setStyle(t)
          } else {
            n._setStyle(t, e)
          }
        }
        removeStyle(t, e) {
          e._removeStyle(t)
        }
        setCustomProperty(t, e, n) {
          n._setCustomProperty(t, e)
        }
        removeCustomProperty(t, e) {
          return e._removeCustomProperty(t)
        }
        createPositionAt(t, e) {
          return df._createAt(t, e)
        }
        createPositionAfter(t) {
          return df._createAfter(t)
        }
        createPositionBefore(t) {
          return df._createBefore(t)
        }
        createRange(t, e) {
          return new uf(t, e)
        }
        createRangeOn(t) {
          return uf._createOn(t)
        }
        createRangeIn(t) {
          return uf._createIn(t)
        }
        createSelection(...t) {
          return new gf(...t)
        }
      }
      const Z_ = /^#([0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/i
      const Q_ = /^rgb\([ ]?([0-9]{1,3}[ %]?,[ ]?){2,3}[0-9]{1,3}[ %]?\)$/i
      const J_ = /^rgba\([ ]?([0-9]{1,3}[ %]?,[ ]?){3}(1|[0-9]+%|[0]?\.?[0-9]+)\)$/i
      const X_ = /^hsl\([ ]?([0-9]{1,3}[ %]?[,]?[ ]*){3}(1|[0-9]+%|[0]?\.?[0-9]+)?\)$/i
      const tC = /^hsla\([ ]?([0-9]{1,3}[ %]?,[ ]?){2,3}(1|[0-9]+%|[0]?\.?[0-9]+)\)$/i
      const eC = /\w+\((?:[^()]|\([^()]*\))*\)|\S+/gi
      const nC = new Set([
        'black',
        'silver',
        'gray',
        'white',
        'maroon',
        'red',
        'purple',
        'fuchsia',
        'green',
        'lime',
        'olive',
        'yellow',
        'navy',
        'blue',
        'teal',
        'aqua',
        'orange',
        'aliceblue',
        'antiquewhite',
        'aquamarine',
        'azure',
        'beige',
        'bisque',
        'blanchedalmond',
        'blueviolet',
        'brown',
        'burlywood',
        'cadetblue',
        'chartreuse',
        'chocolate',
        'coral',
        'cornflowerblue',
        'cornsilk',
        'crimson',
        'cyan',
        'darkblue',
        'darkcyan',
        'darkgoldenrod',
        'darkgray',
        'darkgreen',
        'darkgrey',
        'darkkhaki',
        'darkmagenta',
        'darkolivegreen',
        'darkorange',
        'darkorchid',
        'darkred',
        'darksalmon',
        'darkseagreen',
        'darkslateblue',
        'darkslategray',
        'darkslategrey',
        'darkturquoise',
        'darkviolet',
        'deeppink',
        'deepskyblue',
        'dimgray',
        'dimgrey',
        'dodgerblue',
        'firebrick',
        'floralwhite',
        'forestgreen',
        'gainsboro',
        'ghostwhite',
        'gold',
        'goldenrod',
        'greenyellow',
        'grey',
        'honeydew',
        'hotpink',
        'indianred',
        'indigo',
        'ivory',
        'khaki',
        'lavender',
        'lavenderblush',
        'lawngreen',
        'lemonchiffon',
        'lightblue',
        'lightcoral',
        'lightcyan',
        'lightgoldenrodyellow',
        'lightgray',
        'lightgreen',
        'lightgrey',
        'lightpink',
        'lightsalmon',
        'lightseagreen',
        'lightskyblue',
        'lightslategray',
        'lightslategrey',
        'lightsteelblue',
        'lightyellow',
        'limegreen',
        'linen',
        'magenta',
        'mediumaquamarine',
        'mediumblue',
        'mediumorchid',
        'mediumpurple',
        'mediumseagreen',
        'mediumslateblue',
        'mediumspringgreen',
        'mediumturquoise',
        'mediumvioletred',
        'midnightblue',
        'mintcream',
        'mistyrose',
        'moccasin',
        'navajowhite',
        'oldlace',
        'olivedrab',
        'orangered',
        'orchid',
        'palegoldenrod',
        'palegreen',
        'paleturquoise',
        'palevioletred',
        'papayawhip',
        'peachpuff',
        'peru',
        'pink',
        'plum',
        'powderblue',
        'rosybrown',
        'royalblue',
        'saddlebrown',
        'salmon',
        'sandybrown',
        'seagreen',
        'seashell',
        'sienna',
        'skyblue',
        'slateblue',
        'slategray',
        'slategrey',
        'snow',
        'springgreen',
        'steelblue',
        'tan',
        'thistle',
        'tomato',
        'turquoise',
        'violet',
        'wheat',
        'whitesmoke',
        'yellowgreen',
        'activeborder',
        'activecaption',
        'appworkspace',
        'background',
        'buttonface',
        'buttonhighlight',
        'buttonshadow',
        'buttontext',
        'captiontext',
        'graytext',
        'highlight',
        'highlighttext',
        'inactiveborder',
        'inactivecaption',
        'inactivecaptiontext',
        'infobackground',
        'infotext',
        'menu',
        'menutext',
        'scrollbar',
        'threeddarkshadow',
        'threedface',
        'threedhighlight',
        'threedlightshadow',
        'threedshadow',
        'window',
        'windowframe',
        'windowtext',
        'rebeccapurple',
        'currentcolor',
        'transparent',
      ])
      function oC(t) {
        if (t.startsWith('#')) {
          return Z_.test(t)
        }
        if (t.startsWith('rgb')) {
          return Q_.test(t) || J_.test(t)
        }
        if (t.startsWith('hsl')) {
          return X_.test(t) || tC.test(t)
        }
        return nC.has(t.toLowerCase())
      }
      const iC = null && ['none', 'hidden', 'dotted', 'dashed', 'solid', 'double', 'groove', 'ridge', 'inset', 'outset']
      function rC(t) {
        return iC.includes(t)
      }
      const sC = /^([+-]?[0-9]*([.][0-9]+)?(px|cm|mm|in|pc|pt|ch|em|ex|rem|vh|vw|vmin|vmax)|0)$/
      function aC(t) {
        return sC.test(t)
      }
      const cC = /^[+-]?[0-9]*([.][0-9]+)?%$/
      function lC(t) {
        return cC.test(t)
      }
      const dC = null && ['repeat-x', 'repeat-y', 'repeat', 'space', 'round', 'no-repeat']
      function uC(t) {
        return dC.includes(t)
      }
      const hC = null && ['center', 'top', 'bottom', 'left', 'right']
      function gC(t) {
        return hC.includes(t)
      }
      const fC = null && ['fixed', 'scroll', 'local']
      function mC(t) {
        return fC.includes(t)
      }
      const pC = /^url\(/
      function bC(t) {
        return pC.test(t)
      }
      function kC(t = '') {
        if (t === '') {
          return { top: undefined, right: undefined, bottom: undefined, left: undefined }
        }
        const e = CC(t)
        const n = e[0]
        const o = e[2] || n
        const i = e[1] || n
        const r = e[3] || i
        return { top: n, bottom: o, right: i, left: r }
      }
      function wC(t) {
        return (e) => {
          const { top: n, right: o, bottom: i, left: r } = e
          const s = []
          if (![n, o, r, i].every((t) => !!t)) {
            if (n) {
              s.push([t + '-top', n])
            }
            if (o) {
              s.push([t + '-right', o])
            }
            if (i) {
              s.push([t + '-bottom', i])
            }
            if (r) {
              s.push([t + '-left', r])
            }
          } else {
            s.push([t, AC(e)])
          }
          return s
        }
      }
      function AC({ top: t, right: e, bottom: n, left: o }) {
        const i = []
        if (o !== e) {
          i.push(t, e, n, o)
        } else if (n !== t) {
          i.push(t, e, n)
        } else if (e !== t) {
          i.push(t, e)
        } else {
          i.push(t)
        }
        return i.join(' ')
      }
      function _C(t) {
        return (e) => ({ path: t, value: kC(e) })
      }
      function CC(t) {
        const e = t.matchAll(eC)
        return Array.from(e).map((t) => t[0])
      }
      function vC(t) {
        t.setNormalizer('background', yC())
        t.setNormalizer('background-color', xC())
        t.setReducer('background', EC())
        t.setStyleRelation('background', ['background-color'])
      }
      function yC() {
        return (t) => {
          const e = {}
          const n = getShorthandValues(t)
          for (const t of n) {
            if (isRepeat(t)) {
              e.repeat = e.repeat || []
              e.repeat.push(t)
            } else if (isPosition(t)) {
              e.position = e.position || []
              e.position.push(t)
            } else if (isAttachment(t)) {
              e.attachment = t
            } else if (isColor(t)) {
              e.color = t
            } else if (isURL(t)) {
              e.image = t
            }
          }
          return { path: 'background', value: e }
        }
      }
      function xC() {
        return (t) => ({ path: 'background.color', value: t })
      }
      function EC() {
        return (t) => {
          const e = []
          e.push(['background-color', t.color])
          return e
        }
      }
      function DC(t) {
        t.setNormalizer('border', TC())
        t.setNormalizer('border-top', IC('top'))
        t.setNormalizer('border-right', IC('right'))
        t.setNormalizer('border-bottom', IC('bottom'))
        t.setNormalizer('border-left', IC('left'))
        t.setNormalizer('border-color', SC('color'))
        t.setNormalizer('border-width', SC('width'))
        t.setNormalizer('border-style', SC('style'))
        t.setNormalizer('border-top-color', BC('color', 'top'))
        t.setNormalizer('border-top-style', BC('style', 'top'))
        t.setNormalizer('border-top-width', BC('width', 'top'))
        t.setNormalizer('border-right-color', BC('color', 'right'))
        t.setNormalizer('border-right-style', BC('style', 'right'))
        t.setNormalizer('border-right-width', BC('width', 'right'))
        t.setNormalizer('border-bottom-color', BC('color', 'bottom'))
        t.setNormalizer('border-bottom-style', BC('style', 'bottom'))
        t.setNormalizer('border-bottom-width', BC('width', 'bottom'))
        t.setNormalizer('border-left-color', BC('color', 'left'))
        t.setNormalizer('border-left-style', BC('style', 'left'))
        t.setNormalizer('border-left-width', BC('width', 'left'))
        t.setExtractor('border-top', NC('top'))
        t.setExtractor('border-right', NC('right'))
        t.setExtractor('border-bottom', NC('bottom'))
        t.setExtractor('border-left', NC('left'))
        t.setExtractor('border-top-color', 'border.color.top')
        t.setExtractor('border-right-color', 'border.color.right')
        t.setExtractor('border-bottom-color', 'border.color.bottom')
        t.setExtractor('border-left-color', 'border.color.left')
        t.setExtractor('border-top-width', 'border.width.top')
        t.setExtractor('border-right-width', 'border.width.right')
        t.setExtractor('border-bottom-width', 'border.width.bottom')
        t.setExtractor('border-left-width', 'border.width.left')
        t.setExtractor('border-top-style', 'border.style.top')
        t.setExtractor('border-right-style', 'border.style.right')
        t.setExtractor('border-bottom-style', 'border.style.bottom')
        t.setExtractor('border-left-style', 'border.style.left')
        t.setReducer('border-color', getBoxSidesValueReducer('border-color'))
        t.setReducer('border-style', getBoxSidesValueReducer('border-style'))
        t.setReducer('border-width', getBoxSidesValueReducer('border-width'))
        t.setReducer('border-top', RC('top'))
        t.setReducer('border-right', RC('right'))
        t.setReducer('border-bottom', RC('bottom'))
        t.setReducer('border-left', RC('left'))
        t.setReducer('border', zC())
        t.setStyleRelation('border', [
          'border-color',
          'border-style',
          'border-width',
          'border-top',
          'border-right',
          'border-bottom',
          'border-left',
          'border-top-color',
          'border-right-color',
          'border-bottom-color',
          'border-left-color',
          'border-top-style',
          'border-right-style',
          'border-bottom-style',
          'border-left-style',
          'border-top-width',
          'border-right-width',
          'border-bottom-width',
          'border-left-width',
        ])
        t.setStyleRelation('border-color', [
          'border-top-color',
          'border-right-color',
          'border-bottom-color',
          'border-left-color',
        ])
        t.setStyleRelation('border-style', [
          'border-top-style',
          'border-right-style',
          'border-bottom-style',
          'border-left-style',
        ])
        t.setStyleRelation('border-width', [
          'border-top-width',
          'border-right-width',
          'border-bottom-width',
          'border-left-width',
        ])
        t.setStyleRelation('border-top', ['border-top-color', 'border-top-style', 'border-top-width'])
        t.setStyleRelation('border-right', ['border-right-color', 'border-right-style', 'border-right-width'])
        t.setStyleRelation('border-bottom', ['border-bottom-color', 'border-bottom-style', 'border-bottom-width'])
        t.setStyleRelation('border-left', ['border-left-color', 'border-left-style', 'border-left-width'])
      }
      function TC() {
        return (t) => {
          const { color: e, style: n, width: o } = LC(t)
          return {
            path: 'border',
            value: { color: getBoxSidesValues(e), style: getBoxSidesValues(n), width: getBoxSidesValues(o) },
          }
        }
      }
      function IC(t) {
        return (e) => {
          const { color: n, style: o, width: i } = LC(e)
          const r = {}
          if (n !== undefined) {
            r.color = { [t]: n }
          }
          if (o !== undefined) {
            r.style = { [t]: o }
          }
          if (i !== undefined) {
            r.width = { [t]: i }
          }
          return { path: 'border', value: r }
        }
      }
      function SC(t) {
        return (e) => ({ path: 'border', value: MC(e, t) })
      }
      function MC(t, e) {
        return { [e]: getBoxSidesValues(t) }
      }
      function BC(t, e) {
        return (n) => ({ path: 'border', value: { [t]: { [e]: n } } })
      }
      function NC(t) {
        return (e, n) => {
          if (n.border) {
            return PC(n.border, t)
          }
        }
      }
      function PC(t, e) {
        const n = {}
        if (t.width && t.width[e]) {
          n.width = t.width[e]
        }
        if (t.style && t.style[e]) {
          n.style = t.style[e]
        }
        if (t.color && t.color[e]) {
          n.color = t.color[e]
        }
        return n
      }
      function LC(t) {
        const e = {}
        const n = getShorthandValues(t)
        for (const t of n) {
          if (isLength(t) || /thin|medium|thick/.test(t)) {
            e.width = t
          } else if (isLineStyle(t)) {
            e.style = t
          } else {
            e.color = t
          }
        }
        return e
      }
      function zC() {
        return (e) => {
          const n = PC(e, 'top')
          const o = PC(e, 'right')
          const i = PC(e, 'bottom')
          const r = PC(e, 'left')
          const s = [n, o, i, r]
          const a = { width: t(s, 'width'), style: t(s, 'style'), color: t(s, 'color') }
          const c = OC(a, 'all')
          if (c.length) {
            return c
          }
          const l = Object.entries(a).reduce((t, [e, n]) => {
            if (n) {
              t.push([`border-${e}`, n])
              s.forEach((t) => delete t[e])
            }
            return t
          }, [])
          return [...l, ...OC(n, 'top'), ...OC(o, 'right'), ...OC(i, 'bottom'), ...OC(r, 'left')]
        }
        function t(t, e) {
          return t.map((t) => t[e]).reduce((t, e) => (t == e ? t : null))
        }
      }
      function RC(t) {
        return (e) => OC(e, t)
      }
      function OC(t, e) {
        const n = []
        if (t && t.width) {
          n.push('width')
        }
        if (t && t.style) {
          n.push('style')
        }
        if (t && t.color) {
          n.push('color')
        }
        if (n.length == 3) {
          const o = n.map((e) => t[e]).join(' ')
          return [e == 'all' ? ['border', o] : [`border-${e}`, o]]
        }
        if (e == 'all') {
          return []
        }
        return n.map((n) => [`border-${e}-${n}`, t[n]])
      }
      function VC(t) {
        t.setNormalizer('margin', getPositionShorthandNormalizer('margin'))
        t.setNormalizer('margin-top', (t) => ({ path: 'margin.top', value: t }))
        t.setNormalizer('margin-right', (t) => ({ path: 'margin.right', value: t }))
        t.setNormalizer('margin-bottom', (t) => ({ path: 'margin.bottom', value: t }))
        t.setNormalizer('margin-left', (t) => ({ path: 'margin.left', value: t }))
        t.setReducer('margin', getBoxSidesValueReducer('margin'))
        t.setStyleRelation('margin', ['margin-top', 'margin-right', 'margin-bottom', 'margin-left'])
      }
      function FC(t) {
        t.setNormalizer('padding', getPositionShorthandNormalizer('padding'))
        t.setNormalizer('padding-top', (t) => ({ path: 'padding.top', value: t }))
        t.setNormalizer('padding-right', (t) => ({ path: 'padding.right', value: t }))
        t.setNormalizer('padding-bottom', (t) => ({ path: 'padding.bottom', value: t }))
        t.setNormalizer('padding-left', (t) => ({ path: 'padding.left', value: t }))
        t.setReducer('padding', getBoxSidesValueReducer('padding'))
        t.setStyleRelation('padding', ['padding-top', 'padding-right', 'padding-bottom', 'padding-left'])
      }
      class jC {
        constructor() {
          this._commands = new Map()
        }
        add(t, e) {
          this._commands.set(t, e)
        }
        get(t) {
          return this._commands.get(t)
        }
        execute(t, ...e) {
          const n = this.get(t)
          if (!n) {
            throw new P('commandcollection-command-not-found', this, { commandName: t })
          }
          return n.execute(...e)
        }
        *names() {
          yield* this._commands.keys()
        }
        *commands() {
          yield* this._commands.values()
        }
        [Symbol.iterator]() {
          return this._commands[Symbol.iterator]()
        }
        destroy() {
          for (const t of this.commands()) {
            t.destroy()
          }
        }
      }
      class HC extends wl {
        constructor(t) {
          super()
          this.editor = t
        }
        set(t, e, n = {}) {
          if (typeof e == 'string') {
            const t = e
            e = (e, n) => {
              this.editor.execute(t)
              n()
            }
          }
          super.set(t, e, n)
        }
      }
      class UC extends ft() {
        constructor(t = {}) {
          super()
          const e = this.constructor
          const n = t.language || (e.defaultConfig && e.defaultConfig.language)
          this._context = t.context || new Nu({ language: n })
          this._context._addEditor(this, !t.context)
          const o = Array.from(e.builtinPlugins || [])
          this.config = new qa(t, e.defaultConfig)
          this.config.define('plugins', o)
          this.config.define(this._context._getEditorConfig())
          this.plugins = new Bu(this, o, this._context.plugins)
          this.locale = this._context.locale
          this.t = this.locale.t
          this._readOnlyLocks = new Set()
          this.commands = new jC()
          this.set('state', 'initializing')
          this.once('ready', () => (this.state = 'ready'), { priority: 'high' })
          this.once('destroy', () => (this.state = 'destroyed'), { priority: 'high' })
          this.model = new G_()
          this.on('change:isReadOnly', () => {
            this.model.document.isReadOnly = this.isReadOnly
          })
          const i = new Yg()
          this.data = new iA(this.model, i)
          this.editing = new Tw(this.model, i)
          this.editing.view.document.bind('isReadOnly').to(this)
          this.conversion = new sA(
            [this.editing.downcastDispatcher, this.data.downcastDispatcher],
            this.data.upcastDispatcher,
          )
          this.conversion.addAlias('dataDowncast', this.data.downcastDispatcher)
          this.conversion.addAlias('editingDowncast', this.editing.downcastDispatcher)
          this.keystrokes = new HC(this)
          this.keystrokes.listenTo(this.editing.view.document)
        }
        get isReadOnly() {
          return this._readOnlyLocks.size > 0
        }
        set isReadOnly(t) {
          throw new P('editor-isreadonly-has-no-setter')
        }
        enableReadOnlyMode(t) {
          if (typeof t !== 'string' && typeof t !== 'symbol') {
            throw new P('editor-read-only-lock-id-invalid', null, { lockId: t })
          }
          if (this._readOnlyLocks.has(t)) {
            return
          }
          this._readOnlyLocks.add(t)
          if (this._readOnlyLocks.size === 1) {
            this.fire('change:isReadOnly', 'isReadOnly', true, false)
          }
        }
        disableReadOnlyMode(t) {
          if (typeof t !== 'string' && typeof t !== 'symbol') {
            throw new P('editor-read-only-lock-id-invalid', null, { lockId: t })
          }
          if (!this._readOnlyLocks.has(t)) {
            return
          }
          this._readOnlyLocks.delete(t)
          if (this._readOnlyLocks.size === 0) {
            this.fire('change:isReadOnly', 'isReadOnly', false, true)
          }
        }
        initPlugins() {
          const t = this.config
          const e = t.get('plugins')
          const n = t.get('removePlugins') || []
          const o = t.get('extraPlugins') || []
          const i = t.get('substitutePlugins') || []
          return this.plugins.init(e.concat(o), n, i)
        }
        destroy() {
          let t = Promise.resolve()
          if (this.state == 'initializing') {
            t = new Promise((t) => this.once('ready', t))
          }
          return t
            .then(() => {
              this.fire('destroy')
              this.stopListening()
              this.commands.destroy()
            })
            .then(() => this.plugins.destroy())
            .then(() => {
              this.model.destroy()
              this.data.destroy()
              this.editing.destroy()
              this.keystrokes.destroy()
            })
            .then(() => this._context._removeEditor(this))
        }
        execute(t, ...e) {
          try {
            return this.commands.execute(t, ...e)
          } catch (t) {
            P.rethrowUnexpectedError(t, this)
          }
        }
        focus() {
          this.editing.view.focus()
        }
        static create(...t) {
          throw new Error('This is an abstract method.')
        }
      }
      function WC(t) {
        if (!Ke(t.updateSourceElement)) {
          throw new P('attachtoform-missing-elementapi-interface', t)
        }
        const e = t.sourceElement
        if (GC(e) && e.form) {
          let n
          const o = e.form
          const i = () => t.updateSourceElement()
          if (Ke(o.submit)) {
            n = o.submit
            o.submit = () => {
              i()
              n.apply(o)
            }
          }
          o.addEventListener('submit', i)
          t.on('destroy', () => {
            o.removeEventListener('submit', i)
            if (n) {
              o.submit = n
            }
          })
        }
      }
      function GC(t) {
        return !!t && t.tagName.toLowerCase() === 'textarea'
      }
      function qC(t) {
        class e extends t {
          setData(t) {
            this.data.set(t)
          }
          getData(t) {
            return this.data.get(t)
          }
        }
        return e
      }
      {
        const t = qC(Object)
        qC.setData = t.prototype.setData
        qC.getData = t.prototype.getData
      }
      function $C(t) {
        class e extends t {
          updateSourceElement(t = this.data.get()) {
            if (!this.sourceElement) {
              throw new P('editor-missing-sourceelement', this)
            }
            const e = this.config.get('updateSourceElementOnDestroy')
            const n = this.sourceElement instanceof HTMLTextAreaElement
            if (!e && !n) {
              Ac(this.sourceElement, '')
              return
            }
            Ac(this.sourceElement, t)
          }
        }
        return e
      }
      $C.updateSourceElement = $C(Object).prototype.updateSourceElement
      function KC(t, e) {
        if (e.ckeditorInstance) {
          throw new CKEditorError('editor-source-element-already-used', t)
        }
        e.ckeditorInstance = t
        t.once('destroy', () => {
          delete e.ckeditorInstance
        })
      }
      class YC extends Pu {
        static get pluginName() {
          return 'PendingActions'
        }
        init() {
          this.set('hasAny', false)
          this._actions = new pl({ idProperty: '_id' })
          this._actions.delegate('add', 'remove').to(this)
        }
        add(t) {
          if (typeof t !== 'string') {
            throw new P('pendingactions-add-invalid-message', this)
          }
          const e = new (ft())()
          e.set('message', t)
          this._actions.add(e)
          this.hasAny = true
          return e
        }
        remove(t) {
          this._actions.remove(t)
          this.hasAny = !!this._actions.length
        }
        get first() {
          return this._actions.get(0)
        }
        [Symbol.iterator]() {
          return this._actions[Symbol.iterator]()
        }
      }
      const ZC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.591 10.177 4.243 4.242a1 1 0 0 1-1.415 1.415l-4.242-4.243-4.243 4.243a1 1 0 0 1-1.414-1.415l4.243-4.242L4.52 5.934A1 1 0 0 1 5.934 4.52l4.243 4.243 4.242-4.243a1 1 0 1 1 1.415 1.414l-4.243 4.243z"/></svg>'
      const QC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 16h9a1 1 0 0 1 0 2H2a1 1 0 0 1 0-2z"/><path d="M17 1a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h14zm0 1.5H3a.5.5 0 0 0-.492.41L2.5 3v9a.5.5 0 0 0 .41.492L3 12.5h14a.5.5 0 0 0 .492-.41L17.5 12V3a.5.5 0 0 0-.41-.492L17 2.5z" fill-opacity=".6"/></svg>'
      const JC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.972 16.615a.997.997 0 0 1-.744-.292l-4.596-4.596a1 1 0 1 1 1.414-1.414l3.926 3.926 9.937-9.937a1 1 0 0 1 1.414 1.415L7.717 16.323a.997.997 0 0 1-.745.292z"/></svg>'
      const XC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.333 2 .19 2.263a5.899 5.899 0 0 1 1.458.604L14.714 3.4 16.6 5.286l-1.467 1.733c.263.452.468.942.605 1.46L18 8.666v2.666l-2.263.19a5.899 5.899 0 0 1-.604 1.458l1.467 1.733-1.886 1.886-1.733-1.467a5.899 5.899 0 0 1-1.46.605L11.334 18H8.667l-.19-2.263a5.899 5.899 0 0 1-1.458-.604L5.286 16.6 3.4 14.714l1.467-1.733a5.899 5.899 0 0 1-.604-1.458L2 11.333V8.667l2.262-.189a5.899 5.899 0 0 1 .605-1.459L3.4 5.286 5.286 3.4l1.733 1.467a5.899 5.899 0 0 1 1.46-.605L8.666 2h2.666zM10 6.267a3.733 3.733 0 1 0 0 7.466 3.733 3.733 0 0 0 0-7.466z"/></svg>'
      const tv =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m8.636 9.531-2.758 3.94a.5.5 0 0 0 .122.696l3.224 2.284h1.314l2.636-3.736L8.636 9.53zm.288 8.451L5.14 15.396a2 2 0 0 1-.491-2.786l6.673-9.53a2 2 0 0 1 2.785-.49l3.742 2.62a2 2 0 0 1 .491 2.785l-7.269 10.053-2.147-.066z"/><path d="M4 18h5.523v-1H4zm-2 0h1v-1H2z"/></svg>'
      const ev =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M5.085 6.22 2.943 4.078a.75.75 0 1 1 1.06-1.06l2.592 2.59A11.094 11.094 0 0 1 10 5.068c4.738 0 8.578 3.101 8.578 5.083 0 1.197-1.401 2.803-3.555 3.887l1.714 1.713a.75.75 0 0 1-.09 1.138.488.488 0 0 1-.15.084.75.75 0 0 1-.821-.16L6.17 7.304c-.258.11-.51.233-.757.365l6.239 6.24-.006.005.78.78c-.388.094-.78.166-1.174.215l-1.11-1.11h.011L4.55 8.197a7.2 7.2 0 0 0-.665.514l-.112.098 4.897 4.897-.005.006 1.276 1.276a10.164 10.164 0 0 1-1.477-.117l-.479-.479-.009.009-4.863-4.863-.022.031a2.563 2.563 0 0 0-.124.2c-.043.077-.08.158-.108.241a.534.534 0 0 0-.028.133.29.29 0 0 0 .008.072.927.927 0 0 0 .082.226c.067.133.145.26.234.379l3.242 3.365.025.01.59.623c-3.265-.918-5.59-3.155-5.59-4.668 0-1.194 1.448-2.838 3.663-3.93zm7.07.531a4.632 4.632 0 0 1 1.108 5.992l.345.344.046-.018a9.313 9.313 0 0 0 2-1.112c.256-.187.5-.392.727-.613.137-.134.27-.277.392-.431.072-.091.141-.185.203-.286.057-.093.107-.19.148-.292a.72.72 0 0 0 .036-.12.29.29 0 0 0 .008-.072.492.492 0 0 0-.028-.133.999.999 0 0 0-.036-.096 2.165 2.165 0 0 0-.071-.145 2.917 2.917 0 0 0-.125-.2 3.592 3.592 0 0 0-.263-.335 5.444 5.444 0 0 0-.53-.523 7.955 7.955 0 0 0-1.054-.768 9.766 9.766 0 0 0-1.879-.891c-.337-.118-.68-.219-1.027-.301zm-2.85.21-.069.002a.508.508 0 0 0-.254.097.496.496 0 0 0-.104.679.498.498 0 0 0 .326.199l.045.005c.091.003.181.003.272.012a2.45 2.45 0 0 1 2.017 1.513c.024.061.043.125.069.185a.494.494 0 0 0 .45.287h.008a.496.496 0 0 0 .35-.158.482.482 0 0 0 .13-.335.638.638 0 0 0-.048-.219 3.379 3.379 0 0 0-.36-.723 3.438 3.438 0 0 0-2.791-1.543l-.028-.001h-.013z"/></svg>'
      const nv =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.91 10.54c.26-.23.64-.21.88.03l3.36 3.14 2.23-2.06a.64.64 0 0 1 .87 0l2.52 2.97V4.5H3.2v10.12l3.71-4.08zm10.27-7.51c.6 0 1.09.47 1.09 1.05v11.84c0 .59-.49 1.06-1.09 1.06H2.79c-.6 0-1.09-.47-1.09-1.06V4.08c0-.58.49-1.05 1.1-1.05h14.38zm-5.22 5.56a1.96 1.96 0 1 1 3.4-1.96 1.96 1.96 0 0 1-3.4 1.96z"/></svg>'
      const ov =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m9.239 13.938-2.88-1.663a.75.75 0 0 1 .75-1.3L9 12.067V4.75a.75.75 0 1 1 1.5 0v7.318l1.89-1.093a.75.75 0 0 1 .75 1.3l-2.879 1.663a.752.752 0 0 1-.511.187.752.752 0 0 1-.511-.187zM4.25 17a.75.75 0 1 1 0-1.5h10.5a.75.75 0 0 1 0 1.5H4.25z"/></svg>'
      const iv =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.75 11.875a.752.752 0 0 1 .508.184l2.883 1.666a.75.75 0 0 1-.659 1.344l-.091-.044-1.892-1.093.001 4.318a.75.75 0 1 1-1.5 0v-4.317l-1.89 1.092a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .51-.187zM15.25 9a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM9.75.375a.75.75 0 0 1 .75.75v4.318l1.89-1.093.092-.045a.75.75 0 0 1 .659 1.344l-2.883 1.667a.752.752 0 0 1-.508.184.752.752 0 0 1-.511-.187L6.359 5.65a.75.75 0 0 1 .75-1.299L9 5.442V1.125a.75.75 0 0 1 .75-.75z"/></svg>'
      const rv =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m10.261 7.062 2.88 1.663a.75.75 0 0 1-.75 1.3L10.5 8.933v7.317a.75.75 0 1 1-1.5 0V8.932l-1.89 1.093a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .511-.187.752.752 0 0 1 .511.187zM15.25 4a.75.75 0 1 1 0 1.5H4.75a.75.75 0 0 1 0-1.5h10.5z"/></svg>'
      const sv =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>'
      const av =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm2.286 4c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75z"/></svg>'
      const cv =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M18 3.75a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 8a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 4a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75zm0-8a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75z"/></svg>'
      const lv =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>'
      const dv =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>'
      const uv =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M15.003 7v5.5a1 1 0 0 1-1 1H5.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H6.5V12h6.997V7.5z"/></svg>'
      const hv =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>'
      const gv =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18 7v5.5a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1zm-1.505.5H3.504V12h12.991V7.5z"/></svg>'
      const fv =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>'
      const mv =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zm0-3H18v1.5h-4.5zm0-3H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>'
      const pv =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2zm0-9h5v1.5H2zm0 3h5v1.5H2zm0 3h5v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>'
      const bv =
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M18.095 2H1.905C.853 2 0 2.895 0 4v12c0 1.105.853 2 1.905 2h16.19C19.147 18 20 17.105 20 16V4c0-1.105-.853-2-1.905-2zm0 1.5c.263 0 .476.224.476.5v12c0 .276-.213.5-.476.5H1.905a.489.489 0 0 1-.476-.5V4c0-.276.213-.5.476-.5h16.19z"/></svg>'
      const kv =
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M13 6H2a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h11a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v8a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5V8a.5.5 0 0 1 .5-.5h11z"/></svg>'
      const wv =
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M7 10H2a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h5a2 2 0 0 0 2-2v-4a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-4a.5.5 0 0 1 .5-.5h5z"/></svg>'
      const Av =
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M10 8H2a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2v-6a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-6a.5.5 0 0 1 .5-.5h8z"/></svg>'
      const _v =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m7.3 17.37-.061.088a1.518 1.518 0 0 1-.934.535l-4.178.663-.806-4.153a1.495 1.495 0 0 1 .187-1.058l.056-.086L8.77 2.639c.958-1.351 2.803-1.076 4.296-.03 1.497 1.047 2.387 2.693 1.433 4.055L7.3 17.37zM9.14 4.728l-5.545 8.346 3.277 2.294 5.544-8.346L9.14 4.728zM6.07 16.512l-3.276-2.295.53 2.73 2.746-.435zM9.994 3.506 13.271 5.8c.316-.452-.16-1.333-1.065-1.966-.905-.634-1.895-.78-2.212-.328zM8 18.5 9.375 17H19v1.5H8z"/></svg>'
      const Cv =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.999 2H15a1 1 0 0 1 0 2h-1.004v13a1 1 0 1 1-2 0V4H8.999v13a1 1 0 1 1-2 0v-7A4 4 0 0 1 3 6a4 4 0 0 1 3.999-4z"/></svg>'
      const vv =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 10.423a6.5 6.5 0 0 1 6.056-6.408l.038.67C6.448 5.423 5.354 7.663 5.22 10H9c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574zm8 0a6.5 6.5 0 0 1 6.056-6.408l.038.67c-2.646.739-3.74 2.979-3.873 5.315H17c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574z"/></svg>'
      const yv =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><circle cx="9.5" cy="4.5" r="1.5"/><circle cx="9.5" cy="10.5" r="1.5"/><circle cx="9.5" cy="16.5" r="1.5"/></svg>'
      const xv =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.187 17H5.773c-.637 0-1.092-.138-1.364-.415-.273-.277-.409-.718-.409-1.323V4.738c0-.617.14-1.062.419-1.332.279-.27.73-.406 1.354-.406h4.68c.69 0 1.288.041 1.793.124.506.083.96.242 1.36.478.341.197.644.447.906.75a3.262 3.262 0 0 1 .808 2.162c0 1.401-.722 2.426-2.167 3.075C15.05 10.175 16 11.315 16 13.01a3.756 3.756 0 0 1-2.296 3.504 6.1 6.1 0 0 1-1.517.377c-.571.073-1.238.11-2 .11zm-.217-6.217H7v4.087h3.069c1.977 0 2.965-.69 2.965-2.072 0-.707-.256-1.22-.768-1.537-.512-.319-1.277-.478-2.296-.478zM7 5.13v3.619h2.606c.729 0 1.292-.067 1.69-.2a1.6 1.6 0 0 0 .91-.765c.165-.267.247-.566.247-.897 0-.707-.26-1.176-.778-1.409-.519-.232-1.31-.348-2.375-.348H7z"/></svg>'
      const Ev =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.5 5.5H7v5h3.5a2.5 2.5 0 1 0 0-5zM5 3h6.5v.025a5 5 0 0 1 0 9.95V13H7v4a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1z"/></svg>'
      const Dv =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 2a1 1 0 0 0-1 1v6H3a1 1 0 1 0 0 2h6v6a1 1 0 1 0 2 0v-6h6a1 1 0 1 0 0-2h-6V3a1 1 0 0 0-1-1Z"/></svg>'
      const Tv =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.816 11.5 7.038 4.785 4.261 11.5h5.555Zm.62 1.5H3.641l-1.666 4.028H.312l5.789-14h1.875l5.789 14h-1.663L10.436 13Z"/><path d="m12.09 17-.534-1.292.848-1.971.545 1.319L12.113 17h-.023Zm1.142-5.187.545 1.319L15.5 9.13l1.858 4.316h-3.45l.398.965h3.467L18.887 17H20l-3.873-9h-1.254l-1.641 3.813Z"/></svg>'
      const Iv =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M19 4.5 14 0H3v12.673l.868-1.041c.185-.222.4-.402.632-.54V1.5h8v5h5v7.626a2.24 2.24 0 0 1 1.5.822V4.5ZM14 5V2l3.3 3H14Zm-3.692 12.5c.062.105.133.206.213.303L11.52 19H8v-.876a2.243 2.243 0 0 0 1.82-.624h.488Zm7.518-.657a.75.75 0 0 0-1.152-.96L15.5 17.29V12H14v5.29l-1.174-1.408a.75.75 0 0 0-1.152.96l2.346 2.816a.95.95 0 0 0 1.46 0l2.346-2.815Zm-15.056-.38a.75.75 0 0 1-.096-1.056l2.346-2.815a.95.95 0 0 1 1.46 0l2.346 2.815a.75.75 0 1 1-1.152.96L6.5 14.96V20H5v-5.04l-1.174 1.408a.75.75 0 0 1-1.056.096Z"/></svg>'
      const Sv = {
        bold: xv,
        cancel: ZC,
        caption: QC,
        check: JC,
        cog: XC,
        eraser: tv,
        image: nv,
        lowVision: ev,
        importExport: Iv,
        paragraph: Ev,
        plus: Dv,
        text: Tv,
        alignBottom: ov,
        alignMiddle: iv,
        alignTop: rv,
        alignLeft: sv,
        alignCenter: av,
        alignRight: cv,
        alignJustify: lv,
        objectLeft: mv,
        objectCenter: uv,
        objectRight: pv,
        objectFullWidth: gv,
        objectInline: fv,
        objectBlockLeft: dv,
        objectBlockRight: hv,
        objectSizeFull: bv,
        objectSizeLarge: kv,
        objectSizeSmall: wv,
        objectSizeMedium: Av,
        pencil: _v,
        pilcrow: Cv,
        quote: vv,
        threeVerticalDots: yv,
      }
      var Mv = n(4768)
      var Bv = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      Bv.insert = 'head'
      Bv.singleton = true
      var Nv = Rl()(Mv.Z, Bv)
      const Pv = Mv.Z.locals || {}
      const { threeVerticalDots: Lv } = Sv
      const zv = {
        alignLeft: Sv.alignLeft,
        bold: Sv.bold,
        importExport: Sv.importExport,
        paragraph: Sv.paragraph,
        plus: Sv.plus,
        text: Sv.text,
        threeVerticalDots: Sv.threeVerticalDots,
      }
      class Rv extends Hl {
        constructor(t, e) {
          super(t)
          const n = this.bindTemplate
          const o = this.t
          this.options = e || {}
          this.set('ariaLabel', o('Editor toolbar'))
          this.set('maxWidth', 'auto')
          this.items = this.createCollection()
          this.focusTracker = new kl()
          this.keystrokes = new wl()
          this.set('class', undefined)
          this.set('isCompact', false)
          this.itemsView = new Ov(t)
          this.children = this.createCollection()
          this.children.add(this.itemsView)
          this.focusables = this.createCollection()
          const i = t.uiLanguageDirection === 'rtl'
          this._focusCycler = new _u({
            focusables: this.focusables,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: {
              focusPrevious: [i ? 'arrowright' : 'arrowleft', 'arrowup'],
              focusNext: [i ? 'arrowleft' : 'arrowright', 'arrowdown'],
            },
          })
          const r = ['ck', 'ck-toolbar', n.to('class'), n.if('isCompact', 'ck-toolbar_compact')]
          if (this.options.shouldGroupWhenFull && this.options.isFloating) {
            r.push('ck-toolbar_floating')
          }
          this.setTemplate({
            tag: 'div',
            attributes: {
              class: r,
              role: 'toolbar',
              'aria-label': n.to('ariaLabel'),
              style: { maxWidth: n.to('maxWidth') },
              tabindex: -1,
            },
            children: this.children,
            on: { mousedown: xu(this) },
          })
          this._behavior = this.options.shouldGroupWhenFull ? new Fv(this) : new Vv(this)
        }
        render() {
          super.render()
          this.focusTracker.add(this.element)
          for (const t of this.items) {
            this.focusTracker.add(t.element)
          }
          this.items.on('add', (t, e) => {
            this.focusTracker.add(e.element)
          })
          this.items.on('remove', (t, e) => {
            this.focusTracker.remove(e.element)
          })
          this.keystrokes.listenTo(this.element)
          this._behavior.render(this)
        }
        destroy() {
          this._behavior.destroy()
          this.focusTracker.destroy()
          this.keystrokes.destroy()
          return super.destroy()
        }
        focus() {
          this._focusCycler.focusFirst()
        }
        focusLast() {
          this._focusCycler.focusLast()
        }
        fillFromConfig(t, e, n) {
          this.items.addMany(this._buildItemsFromConfig(t, e, n))
        }
        _buildItemsFromConfig(t, e, n) {
          const o = Eu(t)
          const i = n || o.removeItems
          const r = this._cleanItemsConfiguration(o.items, e, i)
            .map((t) => {
              if (at(t)) {
                return this._createNestedToolbarDropdown(t, e, i)
              } else if (t === '|') {
                return new vu()
              } else if (t === '-') {
                return new yu()
              }
              return e.create(t)
            })
            .filter((t) => !!t)
          return r
        }
        _cleanItemsConfiguration(t, e, n) {
          const o = t.filter((t, o, i) => {
            if (t === '|') {
              return true
            }
            if (n.indexOf(t) !== -1) {
              return false
            }
            if (t === '-') {
              if (this.options.shouldGroupWhenFull) {
                L('toolbarview-line-break-ignored-when-grouping-items', i)
                return false
              }
              return true
            }
            if (!at(t) && !e.has(t)) {
              L('toolbarview-item-unavailable', { item: t })
              return false
            }
            return true
          })
          return this._cleanSeparatorsAndLineBreaks(o)
        }
        _cleanSeparatorsAndLineBreaks(t) {
          const e = (t) => t !== '-' && t !== '|'
          const n = t.length
          const o = t.findIndex(e)
          if (o === -1) {
            return []
          }
          const i = n - t.slice().reverse().findIndex(e)
          return t.slice(o, i).filter((t, n, o) => {
            if (e(t)) {
              return true
            }
            const i = n > 0 && o[n - 1] === t
            return !i
          })
        }
        _createNestedToolbarDropdown(t, e, n) {
          let { label: o, icon: i, items: r, tooltip: s = true, withText: a = false } = t
          r = this._cleanItemsConfiguration(r, e, n)
          if (!r.length) {
            return null
          }
          const c = this.locale
          const l = ay(c)
          if (!o) {
            L('toolbarview-nested-toolbar-dropdown-missing-label', t)
          }
          l.class = 'ck-toolbar__nested-toolbar-dropdown'
          l.buttonView.set({ label: o, tooltip: s, withText: !!a })
          if (i !== false) {
            l.buttonView.icon = zv[i] || i || Lv
          } else {
            l.buttonView.withText = true
          }
          cy(l, () => l.toolbarView._buildItemsFromConfig(r, e, n))
          return l
        }
      }
      class Ov extends Hl {
        constructor(t) {
          super(t)
          this.children = this.createCollection()
          this.setTemplate({ tag: 'div', attributes: { class: ['ck', 'ck-toolbar__items'] }, children: this.children })
        }
      }
      class Vv {
        constructor(t) {
          const e = t.bindTemplate
          t.set('isVertical', false)
          t.itemsView.children.bindTo(t.items).using((t) => t)
          t.focusables.bindTo(t.items).using((t) => t)
          t.extendTemplate({ attributes: { class: [e.if('isVertical', 'ck-toolbar_vertical')] } })
        }
        render() {}
        destroy() {}
      }
      class Fv {
        constructor(t) {
          this.resizeObserver = null
          this.cachedPadding = null
          this.shouldUpdateGroupingOnNextResize = false
          this.view = t
          this.viewChildren = t.children
          this.viewFocusables = t.focusables
          this.viewItemsView = t.itemsView
          this.viewFocusTracker = t.focusTracker
          this.viewLocale = t.locale
          this.ungroupedItems = t.createCollection()
          this.groupedItems = t.createCollection()
          this.groupedItemsDropdown = this._createGroupedItemsDropdown()
          t.itemsView.children.bindTo(this.ungroupedItems).using((t) => t)
          this.ungroupedItems.on('change', this._updateFocusCycleableItems.bind(this))
          t.children.on('change', this._updateFocusCycleableItems.bind(this))
          t.items.on('change', (t, e) => {
            const n = e.index
            const o = Array.from(e.added)
            for (const t of e.removed) {
              if (n >= this.ungroupedItems.length) {
                this.groupedItems.remove(t)
              } else {
                this.ungroupedItems.remove(t)
              }
            }
            for (let t = n; t < n + o.length; t++) {
              const e = o[t - n]
              if (t > this.ungroupedItems.length) {
                this.groupedItems.add(e, t - this.ungroupedItems.length)
              } else {
                this.ungroupedItems.add(e, t)
              }
            }
            this._updateGrouping()
          })
          t.extendTemplate({ attributes: { class: ['ck-toolbar_grouping'] } })
        }
        render(t) {
          this.viewElement = t.element
          this._enableGroupingOnResize()
          this._enableGroupingOnMaxWidthChange(t)
        }
        destroy() {
          this.groupedItemsDropdown.destroy()
          this.resizeObserver.destroy()
        }
        _updateGrouping() {
          if (!this.viewElement.ownerDocument.body.contains(this.viewElement)) {
            return
          }
          if (!Ec(this.viewElement)) {
            this.shouldUpdateGroupingOnNextResize = true
            return
          }
          const t = this.groupedItems.length
          let e
          while (this._areItemsOverflowing) {
            this._groupLastItem()
            e = true
          }
          if (!e && this.groupedItems.length) {
            while (this.groupedItems.length && !this._areItemsOverflowing) {
              this._ungroupFirstItem()
            }
            if (this._areItemsOverflowing) {
              this._groupLastItem()
            }
          }
          if (this.groupedItems.length !== t) {
            this.view.fire('groupedItemsUpdate')
          }
        }
        get _areItemsOverflowing() {
          if (!this.ungroupedItems.length) {
            return false
          }
          const t = this.viewElement
          const e = this.viewLocale.uiLanguageDirection
          const n = new dc(t.lastChild)
          const o = new dc(t)
          if (!this.cachedPadding) {
            const n = oc.window.getComputedStyle(t)
            const o = e === 'ltr' ? 'paddingRight' : 'paddingLeft'
            this.cachedPadding = Number.parseInt(n[o])
          }
          if (e === 'ltr') {
            return n.right > o.right - this.cachedPadding
          } else {
            return n.left < o.left + this.cachedPadding
          }
        }
        _enableGroupingOnResize() {
          let t
          this.resizeObserver = new wc(this.viewElement, (e) => {
            if (!t || t !== e.contentRect.width || this.shouldUpdateGroupingOnNextResize) {
              this.shouldUpdateGroupingOnNextResize = false
              this._updateGrouping()
              t = e.contentRect.width
            }
          })
          this._updateGrouping()
        }
        _enableGroupingOnMaxWidthChange(t) {
          t.on('change:maxWidth', () => {
            this._updateGrouping()
          })
        }
        _groupLastItem() {
          if (!this.groupedItems.length) {
            this.viewChildren.add(new vu())
            this.viewChildren.add(this.groupedItemsDropdown)
            this.viewFocusTracker.add(this.groupedItemsDropdown.element)
          }
          this.groupedItems.add(this.ungroupedItems.remove(this.ungroupedItems.last), 0)
        }
        _ungroupFirstItem() {
          this.ungroupedItems.add(this.groupedItems.remove(this.groupedItems.first))
          if (!this.groupedItems.length) {
            this.viewChildren.remove(this.groupedItemsDropdown)
            this.viewChildren.remove(this.viewChildren.last)
            this.viewFocusTracker.remove(this.groupedItemsDropdown.element)
          }
        }
        _createGroupedItemsDropdown() {
          const t = this.viewLocale
          const e = t.t
          const n = ay(t)
          n.class = 'ck-toolbar__grouped-dropdown'
          n.panelPosition = t.uiLanguageDirection === 'ltr' ? 'sw' : 'se'
          cy(n, this.groupedItems)
          n.buttonView.set({
            label: e('Show more items'),
            tooltip: true,
            tooltipPosition: t.uiLanguageDirection === 'rtl' ? 'se' : 'sw',
            icon: Lv,
          })
          return n
        }
        _updateFocusCycleableItems() {
          this.viewFocusables.clear()
          this.ungroupedItems.map((t) => {
            this.viewFocusables.add(t)
          })
          if (this.groupedItems.length) {
            this.viewFocusables.add(this.groupedItemsDropdown)
          }
        }
      }
      var jv = n(179)
      var Hv = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      Hv.insert = 'head'
      Hv.singleton = true
      var Uv = Rl()(jv.Z, Hv)
      const Wv = jv.Z.locals || {}
      class Gv extends Hl {
        constructor(t) {
          super(t)
          const e = this.bindTemplate
          this.items = this.createCollection()
          this.focusTracker = new kl()
          this.keystrokes = new wl()
          this._focusCycler = new _u({
            focusables: this.items,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: { focusPrevious: 'arrowup', focusNext: 'arrowdown' },
          })
          this.set('ariaLabel', undefined)
          this.set('role', undefined)
          this.setTemplate({
            tag: 'ul',
            attributes: { class: ['ck', 'ck-reset', 'ck-list'], role: e.to('role'), 'aria-label': e.to('ariaLabel') },
            children: this.items,
          })
        }
        render() {
          super.render()
          for (const t of this.items) {
            this.focusTracker.add(t.element)
          }
          this.items.on('add', (t, e) => {
            this.focusTracker.add(e.element)
          })
          this.items.on('remove', (t, e) => {
            this.focusTracker.remove(e.element)
          })
          this.keystrokes.listenTo(this.element)
        }
        destroy() {
          super.destroy()
          this.focusTracker.destroy()
          this.keystrokes.destroy()
        }
        focus() {
          this._focusCycler.focusFirst()
        }
        focusLast() {
          this._focusCycler.focusLast()
        }
      }
      class qv extends Hl {
        constructor(t) {
          super(t)
          const e = this.bindTemplate
          this.set('isVisible', true)
          this.children = this.createCollection()
          this.setTemplate({
            tag: 'li',
            attributes: {
              class: ['ck', 'ck-list__item', e.if('isVisible', 'ck-hidden', (t) => !t)],
              role: 'presentation',
            },
            children: this.children,
          })
        }
        focus() {
          this.children.first.focus()
        }
      }
      class $v extends Hl {
        constructor(t) {
          super(t)
          this.setTemplate({ tag: 'li', attributes: { class: ['ck', 'ck-list__separator'] } })
        }
      }
      var Kv = n(4791)
      var Yv = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      Yv.insert = 'head'
      Yv.singleton = true
      var Zv = Rl()(Kv.Z, Yv)
      const Qv = Kv.Z.locals || {}
      class Jv extends Hl {
        constructor(t) {
          super(t)
          const e = this.bindTemplate
          this.set('class', undefined)
          this.set('labelStyle', undefined)
          this.set('icon', undefined)
          this.set('isEnabled', true)
          this.set('isOn', false)
          this.set('isToggleable', false)
          this.set('isVisible', true)
          this.set('keystroke', undefined)
          this.set('withKeystroke', false)
          this.set('label', undefined)
          this.set('tabindex', -1)
          this.set('tooltip', false)
          this.set('tooltipPosition', 's')
          this.set('type', 'button')
          this.set('withText', false)
          this.children = this.createCollection()
          this.actionView = this._createActionView()
          this.arrowView = this._createArrowView()
          this.keystrokes = new wl()
          this.focusTracker = new kl()
          this.setTemplate({
            tag: 'div',
            attributes: {
              class: [
                'ck',
                'ck-splitbutton',
                e.to('class'),
                e.if('isVisible', 'ck-hidden', (t) => !t),
                this.arrowView.bindTemplate.if('isOn', 'ck-splitbutton_open'),
              ],
            },
            children: this.children,
          })
        }
        render() {
          super.render()
          this.children.add(this.actionView)
          this.children.add(this.arrowView)
          this.focusTracker.add(this.actionView.element)
          this.focusTracker.add(this.arrowView.element)
          this.keystrokes.listenTo(this.element)
          this.keystrokes.set('arrowright', (t, e) => {
            if (this.focusTracker.focusedElement === this.actionView.element) {
              this.arrowView.focus()
              e()
            }
          })
          this.keystrokes.set('arrowleft', (t, e) => {
            if (this.focusTracker.focusedElement === this.arrowView.element) {
              this.actionView.focus()
              e()
            }
          })
        }
        destroy() {
          super.destroy()
          this.focusTracker.destroy()
          this.keystrokes.destroy()
        }
        focus() {
          this.actionView.focus()
        }
        _createActionView() {
          const t = new Dd()
          t.bind(
            'icon',
            'isEnabled',
            'isOn',
            'isToggleable',
            'keystroke',
            'label',
            'tabindex',
            'tooltip',
            'tooltipPosition',
            'type',
            'withText',
          ).to(this)
          t.extendTemplate({ attributes: { class: 'ck-splitbutton__action' } })
          t.delegate('execute').to(this)
          return t
        }
        _createArrowView() {
          const t = new Dd()
          const e = t.bindTemplate
          t.icon = wu
          t.extendTemplate({
            attributes: {
              class: ['ck-splitbutton__arrow'],
              'data-cke-tooltip-disabled': e.to('isOn'),
              'aria-haspopup': true,
              'aria-expanded': e.to('isOn', (t) => String(t)),
            },
          })
          t.bind('isEnabled').to(this)
          t.bind('label').to(this)
          t.bind('tooltip').to(this)
          t.delegate('execute').to(this, 'open')
          return t
        }
      }
      var Xv = n(2704)
      var ty = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      ty.insert = 'head'
      ty.singleton = true
      var ey = Rl()(Xv.Z, ty)
      const ny = Xv.Z.locals || {}
      var oy = n(1883)
      var iy = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      iy.insert = 'head'
      iy.singleton = true
      var ry = Rl()(oy.Z, iy)
      const sy = oy.Z.locals || {}
      function ay(t, e = Au) {
        const n = new e(t)
        const o = new gu(t)
        const i = new ku(t, n, o)
        n.bind('isEnabled').to(i)
        if (n instanceof Jv) {
          n.arrowView.bind('isOn').to(i, 'isOpen')
        } else {
          n.bind('isOn').to(i, 'isOpen')
        }
        gy(i)
        return i
      }
      function cy(t, e, n = {}) {
        t.extendTemplate({ attributes: { class: ['ck-toolbar-dropdown'] } })
        if (t.isOpen) {
          ly(t, e, n)
        } else {
          t.once('change:isOpen', () => ly(t, e, n), { priority: 'highest' })
        }
        if (n.enableActiveItemFocusOnDropdownOpen) {
          hy(t, () => t.toolbarView.items.find((t) => t.isOn))
        }
      }
      function ly(t, e, n) {
        const o = t.locale
        const i = o.t
        const r = (t.toolbarView = new Rv(o))
        const s = typeof e == 'function' ? e() : e
        r.ariaLabel = n.ariaLabel || i('Dropdown toolbar')
        if (n.maxWidth) {
          r.maxWidth = n.maxWidth
        }
        if (n.class) {
          r.class = n.class
        }
        if (n.isCompact) {
          r.isCompact = n.isCompact
        }
        if (n.isVertical) {
          r.isVertical = true
        }
        if (s instanceof Pl) {
          r.items.bindTo(s).using((t) => t)
        } else {
          r.items.addMany(s)
        }
        t.panelView.children.add(r)
        r.items.delegate('execute').to(t)
      }
      function dy(t, e, n = {}) {
        if (t.isOpen) {
          uy(t, e, n)
        } else {
          t.once('change:isOpen', () => uy(t, e, n), { priority: 'highest' })
        }
        hy(t, () =>
          t.listView.items.find((t) => {
            if (t instanceof qv) {
              return t.children.first.isOn
            }
            return false
          }),
        )
      }
      function uy(t, e, n) {
        const o = t.locale
        const i = (t.listView = new Gv(o))
        const r = typeof e == 'function' ? e() : e
        i.ariaLabel = n.ariaLabel
        i.role = n.role
        i.items.bindTo(r).using((t) => {
          if (t.type === 'separator') {
            return new $v(o)
          } else if (t.type === 'button' || t.type === 'switchbutton') {
            const e = new qv(o)
            let n
            if (t.type === 'button') {
              n = new Dd(o)
            } else {
              n = new Bd(o)
            }
            n.bind(...Object.keys(t.model)).to(t.model)
            n.delegate('execute').to(e)
            e.children.add(n)
            return e
          }
          return null
        })
        t.panelView.children.add(i)
        i.items.delegate('execute').to(t)
      }
      function hy(t, e) {
        t.on(
          'change:isOpen',
          () => {
            if (!t.isOpen) {
              return
            }
            const n = e()
            if (!n) {
              return
            }
            if (typeof n.focus === 'function') {
              n.focus()
            } else {
              L('ui-dropdown-focus-child-on-open-child-missing-focus', { view: n })
            }
          },
          { priority: M.low - 10 },
        )
      }
      function gy(t) {
        fy(t)
        my(t)
        py(t)
        by(t)
        ky(t)
        wy(t)
      }
      function fy(e) {
        e.on('render', () => {
          t({
            emitter: e,
            activator: () => e.isOpen,
            callback: () => {
              e.isOpen = false
            },
            contextElements: () => [e.element, ...e.focusTracker._elements],
          })
        })
      }
      function my(t) {
        t.on('execute', (e) => {
          if (e.source instanceof Bd) {
            return
          }
          t.isOpen = false
        })
      }
      function py(t) {
        t.focusTracker.on('change:isFocused', (e, n, o) => {
          if (t.isOpen && !o) {
            t.isOpen = false
          }
        })
      }
      function by(t) {
        t.keystrokes.set('arrowdown', (e, n) => {
          if (t.isOpen) {
            t.panelView.focus()
            n()
          }
        })
        t.keystrokes.set('arrowup', (e, n) => {
          if (t.isOpen) {
            t.panelView.focusLast()
            n()
          }
        })
      }
      function ky(t) {
        t.on('change:isOpen', (e, n, o) => {
          if (o) {
            return
          }
          const i = t.panelView.element
          if (i && i.contains(oc.document.activeElement)) {
            t.buttonView.focus()
          }
        })
      }
      function wy(t) {
        t.on(
          'change:isOpen',
          (e, n, o) => {
            if (!o) {
              return
            }
            t.panelView.focus()
          },
          { priority: 'low' },
        )
      }
      function Ay(t, e, n) {
        const o = new uu(t.locale)
        o.set({ id: e, ariaDescribedById: n })
        o.bind('isReadOnly').to(t, 'isEnabled', (t) => !t)
        o.bind('hasError').to(t, 'errorText', (t) => !!t)
        o.on('input', () => {
          t.errorText = null
        })
        t.bind('isEmpty', 'isFocused', 'placeholder').to(o)
        return o
      }
      function _y(t, e, n) {
        const o = new InputNumberView(t.locale)
        o.set({ id: e, ariaDescribedById: n, inputMode: 'numeric' })
        o.bind('isReadOnly').to(t, 'isEnabled', (t) => !t)
        o.bind('hasError').to(t, 'errorText', (t) => !!t)
        o.on('input', () => {
          t.errorText = null
        })
        t.bind('isEmpty', 'isFocused', 'placeholder').to(o)
        return o
      }
      function Cy(t, e, n) {
        const o = createDropdown(t.locale)
        o.set({ id: e, ariaDescribedById: n })
        o.bind('isEnabled').to(t)
        return o
      }
      const vy = (t, e = 0, n = 1) => (t > n ? n : t < e ? e : t)
      const yy = (t, e = 0, n = Math.pow(10, e)) => Math.round(n * t) / n
      const xy = { grad: 360 / 400, turn: 360, rad: 360 / (Math.PI * 2) }
      const Ey = (t) => $y(Dy(t))
      const Dy = (t) => {
        if (t[0] === '#') t = t.substring(1)
        if (t.length < 6) {
          return {
            r: parseInt(t[0] + t[0], 16),
            g: parseInt(t[1] + t[1], 16),
            b: parseInt(t[2] + t[2], 16),
            a: t.length === 4 ? yy(parseInt(t[3] + t[3], 16) / 255, 2) : 1,
          }
        }
        return {
          r: parseInt(t.substring(0, 2), 16),
          g: parseInt(t.substring(2, 4), 16),
          b: parseInt(t.substring(4, 6), 16),
          a: t.length === 8 ? yy(parseInt(t.substring(6, 8), 16) / 255, 2) : 1,
        }
      }
      const Ty = (t, e = 'deg') => Number(t) * (xy[e] || 1)
      const Iy = (t) => {
        const e =
          /hsla?\(?\s*(-?\d*\.?\d+)(deg|rad|grad|turn)?[,\s]+(-?\d*\.?\d+)%?[,\s]+(-?\d*\.?\d+)%?,?\s*[/\s]*(-?\d*\.?\d+)?(%)?\s*\)?/i
        const n = e.exec(t)
        if (!n) return { h: 0, s: 0, v: 0, a: 1 }
        return My({
          h: Ty(n[1], n[2]),
          s: Number(n[3]),
          l: Number(n[4]),
          a: n[5] === undefined ? 1 : Number(n[5]) / (n[6] ? 100 : 1),
        })
      }
      const Sy = null && Iy
      const My = ({ h: t, s: e, l: n, a: o }) => {
        e *= (n < 50 ? n : 100 - n) / 100
        return { h: t, s: e > 0 ? ((2 * e) / (n + e)) * 100 : 0, v: n + e, a: o }
      }
      const By = (t) => qy(Oy(t))
      const Ny = ({ h: t, s: e, v: n, a: o }) => {
        const i = ((200 - e) * n) / 100
        return {
          h: yy(t),
          s: yy(i > 0 && i < 200 ? ((e * n) / 100 / (i <= 100 ? i : 200 - i)) * 100 : 0),
          l: yy(i / 2),
          a: yy(o, 2),
        }
      }
      const Py = (t) => {
        const { h: e, s: n, v: o } = Ky(t)
        return `hsv(${e}, ${n}%, ${o}%)`
      }
      const Ly = (t) => {
        const { h: e, s: n, v: o, a: i } = Ky(t)
        return `hsva(${e}, ${n}%, ${o}%, ${i})`
      }
      const zy = (t) => {
        const { h: e, s: n, l: o } = Ny(t)
        return `hsl(${e}, ${n}%, ${o}%)`
      }
      const Ry = (t) => {
        const { h: e, s: n, l: o, a: i } = Ny(t)
        return `hsla(${e}, ${n}%, ${o}%, ${i})`
      }
      const Oy = ({ h: t, s: e, v: n, a: o }) => {
        t = (t / 360) * 6
        e = e / 100
        n = n / 100
        const i = Math.floor(t),
          r = n * (1 - e),
          s = n * (1 - (t - i) * e),
          a = n * (1 - (1 - t + i) * e),
          c = i % 6
        return {
          r: yy([n, s, r, r, a, n][c] * 255),
          g: yy([a, n, n, s, r, r][c] * 255),
          b: yy([r, r, a, n, n, s][c] * 255),
          a: yy(o, 2),
        }
      }
      const Vy = (t) => {
        const { r: e, g: n, b: o } = Oy(t)
        return `rgb(${e}, ${n}, ${o})`
      }
      const Fy = (t) => {
        const { r: e, g: n, b: o, a: i } = Oy(t)
        return `rgba(${e}, ${n}, ${o}, ${i})`
      }
      const jy = (t) => {
        const e =
          /hsva?\(?\s*(-?\d*\.?\d+)(deg|rad|grad|turn)?[,\s]+(-?\d*\.?\d+)%?[,\s]+(-?\d*\.?\d+)%?,?\s*[/\s]*(-?\d*\.?\d+)?(%)?\s*\)?/i
        const n = e.exec(t)
        if (!n) return { h: 0, s: 0, v: 0, a: 1 }
        return Ky({
          h: Ty(n[1], n[2]),
          s: Number(n[3]),
          v: Number(n[4]),
          a: n[5] === undefined ? 1 : Number(n[5]) / (n[6] ? 100 : 1),
        })
      }
      const Hy = null && jy
      const Uy = (t) => {
        const e =
          /rgba?\(?\s*(-?\d*\.?\d+)(%)?[,\s]+(-?\d*\.?\d+)(%)?[,\s]+(-?\d*\.?\d+)(%)?,?\s*[/\s]*(-?\d*\.?\d+)?(%)?\s*\)?/i
        const n = e.exec(t)
        if (!n) return { h: 0, s: 0, v: 0, a: 1 }
        return $y({
          r: Number(n[1]) / (n[2] ? 100 / 255 : 1),
          g: Number(n[3]) / (n[4] ? 100 / 255 : 1),
          b: Number(n[5]) / (n[6] ? 100 / 255 : 1),
          a: n[7] === undefined ? 1 : Number(n[7]) / (n[8] ? 100 : 1),
        })
      }
      const Wy = null && Uy
      const Gy = (t) => {
        const e = t.toString(16)
        return e.length < 2 ? '0' + e : e
      }
      const qy = ({ r: t, g: e, b: n, a: o }) => {
        const i = o < 1 ? Gy(yy(o * 255)) : ''
        return '#' + Gy(t) + Gy(e) + Gy(n) + i
      }
      const $y = ({ r: t, g: e, b: n, a: o }) => {
        const i = Math.max(t, e, n)
        const r = i - Math.min(t, e, n)
        const s = r ? (i === t ? (e - n) / r : i === e ? 2 + (n - t) / r : 4 + (t - e) / r) : 0
        return { h: yy(60 * (s < 0 ? s + 6 : s)), s: yy(i ? (r / i) * 100 : 0), v: yy((i / 255) * 100), a: o }
      }
      const Ky = (t) => ({ h: round(t.h), s: round(t.s), v: round(t.v), a: round(t.a, 2) })
      const Yy = ({ r: t, g: e, b: n }) => ({ r: t, g: e, b: n })
      const Zy = ({ h: t, s: e, l: n }) => ({ h: t, s: e, l: n })
      const Qy = (t) => {
        const { h: e, s: n, v: o } = Ky(t)
        return { h: e, s: n, v: o }
      }
      const Jy = (t, e) => {
        if (t === e) return true
        for (const n in t) {
          if (t[n] !== e[n]) return false
        }
        return true
      }
      const Xy = (t, e) => t.replace(/\s/g, '') === e.replace(/\s/g, '')
      const tx = (t, e) => {
        if (t.toLowerCase() === e.toLowerCase()) return true
        return Jy(Dy(t), Dy(e))
      }
      const ex = {}
      const nx = (t) => {
        let e = ex[t]
        if (!e) {
          e = document.createElement('template')
          e.innerHTML = t
          ex[t] = e
        }
        return e
      }
      const ox = (t, e, n) => {
        t.dispatchEvent(new CustomEvent(e, { bubbles: true, detail: n }))
      }
      let ix = false
      const rx = (t) => 'touches' in t
      const sx = (t) => {
        if (ix && !rx(t)) return false
        if (!ix) ix = rx(t)
        return true
      }
      const ax = (t, e) => {
        const n = rx(e) ? e.touches[0] : e
        const o = t.el.getBoundingClientRect()
        ox(
          t.el,
          'move',
          t.getMove({
            x: vy((n.pageX - (o.left + window.pageXOffset)) / o.width),
            y: vy((n.pageY - (o.top + window.pageYOffset)) / o.height),
          }),
        )
      }
      const cx = (t, e) => {
        const n = e.keyCode
        if (n > 40 || (t.xy && n < 37) || n < 33) return
        e.preventDefault()
        ox(
          t.el,
          'move',
          t.getMove(
            {
              x:
                n === 39
                  ? 0.01
                  : n === 37
                  ? -0.01
                  : n === 34
                  ? 0.05
                  : n === 33
                  ? -0.05
                  : n === 35
                  ? 1
                  : n === 36
                  ? -1
                  : 0,
              y: n === 40 ? 0.01 : n === 38 ? -0.01 : 0,
            },
            true,
          ),
        )
      }
      class lx {
        constructor(t, e, n, o) {
          const i = nx(`<div role="slider" tabindex="0" part="${e}" ${n}><div part="${e}-pointer"></div></div>`)
          t.appendChild(i.content.cloneNode(true))
          const r = t.querySelector(`[part=${e}]`)
          r.addEventListener('mousedown', this)
          r.addEventListener('touchstart', this)
          r.addEventListener('keydown', this)
          this.el = r
          this.xy = o
          this.nodes = [r.firstChild, r]
        }
        set dragging(t) {
          const e = t ? document.addEventListener : document.removeEventListener
          e(ix ? 'touchmove' : 'mousemove', this)
          e(ix ? 'touchend' : 'mouseup', this)
        }
        handleEvent(t) {
          switch (t.type) {
            case 'mousedown':
            case 'touchstart':
              t.preventDefault()
              if (!sx(t) || (!ix && t.button != 0)) return
              this.el.focus()
              ax(this, t)
              this.dragging = true
              break
            case 'mousemove':
            case 'touchmove':
              t.preventDefault()
              ax(this, t)
              break
            case 'mouseup':
            case 'touchend':
              this.dragging = false
              break
            case 'keydown':
              cx(this, t)
              break
          }
        }
        style(t) {
          t.forEach((t, e) => {
            for (const n in t) {
              this.nodes[e].style.setProperty(n, t[n])
            }
          })
        }
      }
      class dx extends lx {
        constructor(t) {
          super(t, 'hue', 'aria-label="Hue" aria-valuemin="0" aria-valuemax="360"', false)
        }
        update({ h: t }) {
          this.h = t
          this.style([{ left: `${(t / 360) * 100}%`, color: zy({ h: t, s: 100, v: 100, a: 1 }) }])
          this.el.setAttribute('aria-valuenow', `${yy(t)}`)
        }
        getMove(t, e) {
          return { h: e ? vy(this.h + t.x * 360, 0, 360) : 360 * t.x }
        }
      }
      class ux extends lx {
        constructor(t) {
          super(t, 'saturation', 'aria-label="Color"', true)
        }
        update(t) {
          this.hsva = t
          this.style([
            { top: `${100 - t.v}%`, left: `${t.s}%`, color: zy(t) },
            { 'background-color': zy({ h: t.h, s: 100, v: 100, a: 1 }) },
          ])
          this.el.setAttribute('aria-valuetext', `Saturation ${yy(t.s)}%, Brightness ${yy(t.v)}%`)
        }
        getMove(t, e) {
          return {
            s: e ? vy(this.hsva.s + t.x * 100, 0, 100) : t.x * 100,
            v: e ? vy(this.hsva.v - t.y * 100, 0, 100) : Math.round(100 - t.y * 100),
          }
        }
      }
      const hx = `:host{display:flex;flex-direction:column;position:relative;width:200px;height:200px;user-select:none;-webkit-user-select:none;cursor:default}:host([hidden]){display:none!important}[role=slider]{position:relative;touch-action:none;user-select:none;-webkit-user-select:none;outline:0}[role=slider]:last-child{border-radius:0 0 8px 8px}[part$=pointer]{position:absolute;z-index:1;box-sizing:border-box;width:28px;height:28px;display:flex;place-content:center center;transform:translate(-50%,-50%);background-color:#fff;border:2px solid #fff;border-radius:50%;box-shadow:0 2px 4px rgba(0,0,0,.2)}[part$=pointer]::after{content:"";width:100%;height:100%;border-radius:inherit;background-color:currentColor}[role=slider]:focus [part$=pointer]{transform:translate(-50%,-50%) scale(1.1)}`
      const gx = `[part=hue]{flex:0 0 24px;background:linear-gradient(to right,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red 100%)}[part=hue-pointer]{top:50%;z-index:2}`
      const fx = `[part=saturation]{flex-grow:1;border-color:transparent;border-bottom:12px solid #000;border-radius:8px 8px 0 0;background-image:linear-gradient(to top,#000,transparent),linear-gradient(to right,#fff,rgba(255,255,255,0));box-shadow:inset 0 0 0 1px rgba(0,0,0,.05)}[part=saturation-pointer]{z-index:3}`
      const mx = Symbol('same')
      const px = Symbol('color')
      const bx = Symbol('hsva')
      const kx = Symbol('update')
      const wx = Symbol('parts')
      const Ax = Symbol('css')
      const _x = Symbol('sliders')
      class Cx extends HTMLElement {
        static get observedAttributes() {
          return ['color']
        }
        get [Ax]() {
          return [hx, gx, fx]
        }
        get [_x]() {
          return [ux, dx]
        }
        get color() {
          return this[px]
        }
        set color(t) {
          if (!this[mx](t)) {
            const e = this.colorModel.toHsva(t)
            this[kx](e)
            this[px] = t
          }
        }
        constructor() {
          super()
          const t = nx(`<style>${this[Ax].join('')}</style>`)
          const e = this.attachShadow({ mode: 'open' })
          e.appendChild(t.content.cloneNode(true))
          e.addEventListener('move', this)
          this[wx] = this[_x].map((t) => new t(e))
        }
        connectedCallback() {
          if (this.hasOwnProperty('color')) {
            const t = this.color
            delete this['color']
            this.color = t
          } else if (!this.color) {
            this.color = this.colorModel.defaultColor
          }
        }
        attributeChangedCallback(t, e, n) {
          const o = this.colorModel.fromAttr(n)
          if (!this[mx](o)) {
            this.color = o
          }
        }
        handleEvent(t) {
          const e = this[bx]
          const n = { ...e, ...t.detail }
          this[kx](n)
          let o
          if (!Jy(n, e) && !this[mx]((o = this.colorModel.fromHsva(n)))) {
            this[px] = o
            ox(this, 'color-changed', { value: o })
          }
        }
        [mx](t) {
          return this.color && this.colorModel.equal(t, this.color)
        }
        [kx](t) {
          this[bx] = t
          this[wx].forEach((e) => e.update(t))
        }
      }
      const vx = {
        defaultColor: '#000',
        toHsva: Ey,
        fromHsva: ({ h: t, s: e, v: n }) => By({ h: t, s: e, v: n, a: 1 }),
        equal: tx,
        fromAttr: (t) => t,
      }
      class yx extends Cx {
        get colorModel() {
          return vx
        }
      }
      class xx extends yx {}
      customElements.define('hex-color-picker', xx)
      var Ex = n(4257)
      var Dx = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      Dx.insert = 'head'
      Dx.singleton = true
      var Tx = Rl()(Ex.Z, Dx)
      const Ix = Ex.Z.locals || {}
      const Sx = 150
      class Mx extends (null && View) {
        constructor(t, e = {}) {
          super(t)
          this.set({ color: '', _hexColor: '' })
          this.hexInputRow = this._createInputRow()
          const n = this.createCollection()
          if (!e.hideInput) {
            n.add(this.hexInputRow)
          }
          this.setTemplate({ tag: 'div', attributes: { class: ['ck', 'ck-color-picker'], tabindex: -1 }, children: n })
          this._config = e
          this._debounceColorPickerEvent = debounce(
            (t) => {
              this.set('color', t)
              this.fire('colorSelected', { color: this.color })
            },
            Sx,
            { leading: true },
          )
          this.on('set:color', (t, e, n) => {
            t.return = convertColor(n, this._config.format || 'hsl')
          })
          this.on('change:color', () => {
            this._hexColor = Bx(this.color)
          })
          this.on('change:_hexColor', () => {
            if (document.activeElement !== this.picker) {
              this.picker.setAttribute('color', this._hexColor)
            }
            if (Bx(this.color) != Bx(this._hexColor)) {
              this.color = this._hexColor
            }
          })
        }
        render() {
          super.render()
          this.picker = global.document.createElement('hex-color-picker')
          this.picker.setAttribute('class', 'hex-color-picker')
          this.picker.setAttribute('tabindex', '-1')
          this._createSlidersView()
          if (this.element) {
            if (this.hexInputRow.element) {
              this.element.insertBefore(this.picker, this.hexInputRow.element)
            } else {
              this.element.appendChild(this.picker)
            }
            const t = document.createElement('style')
            t.textContent =
              '[role="slider"]:focus [part$="pointer"] {' +
              'border: 1px solid #fff;' +
              'outline: 1px solid var(--ck-color-focus-border);' +
              'box-shadow: 0 0 0 2px #fff;' +
              '}'
            this.picker.shadowRoot.appendChild(t)
          }
          this.picker.addEventListener('color-changed', (t) => {
            const e = t
            const n = e.detail.value
            this._debounceColorPickerEvent(n)
          })
        }
        focus() {
          if (!this._config.hideInput && (env.isGecko || env.isiOS || env.isSafari)) {
            const t = this.hexInputRow.children.get(1)
            t.focus()
          }
          const t = this.slidersView.first
          t.focus()
        }
        _createSlidersView() {
          const t = [...this.picker.shadowRoot.children]
          const e = t.filter((t) => t.getAttribute('role') === 'slider')
          const n = e.map((t) => {
            const e = new Nx(t)
            return e
          })
          this.slidersView = this.createCollection()
          n.forEach((t) => {
            this.slidersView.add(t)
          })
        }
        _createInputRow() {
          const t = new Px()
          const e = this._createColorInput()
          return new Lx(this.locale, [t, e])
        }
        _createColorInput() {
          const t = new LabeledFieldView(this.locale, createLabeledInputText)
          const { t: e } = this.locale
          t.set({ label: e('HEX'), class: 'color-picker-hex-input' })
          t.fieldView.bind('value').to(this, '_hexColor', (e) => {
            if (t.isFocused) {
              return t.fieldView.value
            } else {
              return e.startsWith('#') ? e.substring(1) : e
            }
          })
          t.fieldView.on('input', () => {
            const e = t.fieldView.element.value
            if (e) {
              const t = e.trim()
              const n = t.startsWith('#') ? t.substring(1) : t
              const o = [3, 4, 6, 8].includes(n.length) && /(([0-9a-fA-F]{2}){3,4}|([0-9a-fA-F]){3,4})/.test(n)
              if (o) {
                this._debounceColorPickerEvent('#' + n)
              }
            }
          })
          return t
        }
      }
      function Bx(t) {
        let e = convertToHex(t)
        if (!e) {
          e = '#000'
        }
        if (e.length === 4) {
          e = '#' + [e[1], e[1], e[2], e[2], e[3], e[3]].join('')
        }
        return e.toLowerCase()
      }
      class Nx extends (null && View) {
        constructor(t) {
          super()
          this.element = t
        }
        focus() {
          this.element.focus()
        }
      }
      class Px extends (null && View) {
        constructor(t) {
          super(t)
          this.setTemplate({ tag: 'div', attributes: { class: ['ck', 'ck-color-picker__hash-view'] }, children: '#' })
        }
      }
      class Lx extends (null && View) {
        constructor(t, e) {
          super(t)
          this.children = this.createCollection(e)
          this.setTemplate({
            tag: 'div',
            attributes: { class: ['ck', 'ck-color-picker__row'] },
            children: this.children,
          })
        }
      }
      class zx extends ft(pl) {
        constructor(t) {
          super(t)
          this.set('isEmpty', true)
          this.on('change', () => {
            this.set('isEmpty', this.length === 0)
          })
        }
        add(t, e) {
          if (this.find((e) => e.color === t.color)) {
            return this
          }
          return super.add(t, e)
        }
        hasColor(t) {
          return !!this.find((e) => e.color === t)
        }
      }
      class Rx extends (null && View) {
        constructor(
          t,
          {
            colors: e,
            columns: n,
            removeButtonLabel: o,
            documentColorsLabel: i,
            documentColorsCount: r,
            colorPickerLabel: s,
            focusTracker: a,
            focusables: c,
          },
        ) {
          super(t)
          const l = this.bindTemplate
          this.set('isVisible', true)
          this.focusTracker = a
          this.items = this.createCollection()
          this.colorDefinitions = e
          this.columns = n
          this.documentColors = new DocumentColorCollection()
          this.documentColorsCount = r
          this._focusables = c
          this._removeButtonLabel = o
          this._colorPickerLabel = s
          this._documentColorsLabel = i
          this.setTemplate({
            tag: 'div',
            attributes: { class: ['ck-color-grids-fragment', l.if('isVisible', 'ck-hidden', (t) => !t)] },
            children: this.items,
          })
          this.removeColorButtonView = this._createRemoveColorButton()
          this.items.add(this.removeColorButtonView)
        }
        updateDocumentColors(t, e) {
          const n = t.document
          const o = this.documentColorsCount
          this.documentColors.clear()
          for (const i of n.getRoots()) {
            const n = t.createRangeIn(i)
            for (const t of n.getItems()) {
              if (t.is('$textProxy') && t.hasAttribute(e)) {
                this._addColorToDocumentColors(t.getAttribute(e))
                if (this.documentColors.length >= o) {
                  return
                }
              }
            }
          }
        }
        updateSelectedColors() {
          const t = this.documentColorsGrid
          const e = this.staticColorsGrid
          const n = this.selectedColor
          e.selectedColor = n
          if (t) {
            t.selectedColor = n
          }
        }
        render() {
          super.render()
          this.staticColorsGrid = this._createStaticColorsGrid()
          this.items.add(this.staticColorsGrid)
          if (this.documentColorsCount) {
            const t = Template.bind(this.documentColors, this.documentColors)
            const e = new LabelView(this.locale)
            e.text = this._documentColorsLabel
            e.extendTemplate({ attributes: { class: ['ck', 'ck-color-grid__label', t.if('isEmpty', 'ck-hidden')] } })
            this.items.add(e)
            this.documentColorsGrid = this._createDocumentColorsGrid()
            this.items.add(this.documentColorsGrid)
          }
          this._createColorPickerButton()
          this._addColorSelectorElementsToFocusTracker()
          this.focus()
        }
        focus() {
          this.removeColorButtonView.focus()
        }
        destroy() {
          super.destroy()
        }
        addColorPickerButton() {
          if (this.colorPickerButtonView) {
            this.items.add(this.colorPickerButtonView)
            this.focusTracker.add(this.colorPickerButtonView.element)
            this._focusables.add(this.colorPickerButtonView)
          }
        }
        _addColorSelectorElementsToFocusTracker() {
          this.focusTracker.add(this.removeColorButtonView.element)
          this._focusables.add(this.removeColorButtonView)
          if (this.staticColorsGrid) {
            this.focusTracker.add(this.staticColorsGrid.element)
            this._focusables.add(this.staticColorsGrid)
          }
          if (this.documentColorsGrid) {
            this.focusTracker.add(this.documentColorsGrid.element)
            this._focusables.add(this.documentColorsGrid)
          }
        }
        _createColorPickerButton() {
          this.colorPickerButtonView = new ButtonView()
          this.colorPickerButtonView.set({
            label: this._colorPickerLabel,
            withText: true,
            icon: colorPaletteIcon,
            class: 'ck-color-selector__color-picker',
          })
          this.colorPickerButtonView.on('execute', () => {
            this.fire('colorPicker:show')
          })
        }
        _createRemoveColorButton() {
          const t = new ButtonView()
          t.set({ withText: true, icon: removeButtonIcon, label: this._removeButtonLabel })
          t.class = 'ck-color-selector__remove-color'
          t.on('execute', () => {
            this.fire('execute', { value: null, source: 'removeColorButton' })
          })
          t.render()
          return t
        }
        _createStaticColorsGrid() {
          const t = new ColorGridView(this.locale, { colorDefinitions: this.colorDefinitions, columns: this.columns })
          t.on('execute', (t, e) => {
            this.fire('execute', { value: e.value, source: 'staticColorsGrid' })
          })
          return t
        }
        _createDocumentColorsGrid() {
          const t = Template.bind(this.documentColors, this.documentColors)
          const e = new ColorGridView(this.locale, { columns: this.columns })
          e.extendTemplate({ attributes: { class: t.if('isEmpty', 'ck-hidden') } })
          e.items.bindTo(this.documentColors).using((t) => {
            const e = new ColorTileView()
            e.set({ color: t.color, hasBorder: t.options && t.options.hasBorder })
            if (t.label) {
              e.set({ label: t.label, tooltip: true })
            }
            e.on('execute', () => {
              this.fire('execute', { value: t.color, source: 'documentColorsGrid' })
            })
            return e
          })
          this.documentColors.on('change:isEmpty', (t, n, o) => {
            if (o) {
              e.selectedColor = null
            }
          })
          return e
        }
        _addColorToDocumentColors(t) {
          const e = this.colorDefinitions.find((e) => e.color === t)
          if (!e) {
            this.documentColors.add({ color: t, label: t, options: { hasBorder: false } })
          } else {
            this.documentColors.add(Object.assign({}, e))
          }
        }
      }
      class Ox extends (null && View) {
        constructor(t, { focusTracker: e, focusables: n, keystrokes: o, colorPickerViewConfig: i }) {
          super(t)
          this.items = this.createCollection()
          this.focusTracker = e
          this.keystrokes = o
          this.set('isVisible', false)
          this.set('selectedColor', undefined)
          this._focusables = n
          this._colorPickerViewConfig = i
          const r = this.bindTemplate
          const { saveButtonView: s, cancelButtonView: a } = this._createActionButtons()
          this.saveButtonView = s
          this.cancelButtonView = a
          this.actionBarView = this._createActionBarView({ saveButtonView: s, cancelButtonView: a })
          this.setTemplate({
            tag: 'div',
            attributes: { class: ['ck-color-picker-fragment', r.if('isVisible', 'ck-hidden', (t) => !t)] },
            children: this.items,
          })
        }
        render() {
          super.render()
          const t = new ColorPickerView(this.locale, { ...this._colorPickerViewConfig })
          this.colorPickerView = t
          this.colorPickerView.render()
          if (this.selectedColor) {
            t.color = this.selectedColor
          }
          this.listenTo(this, 'change:selectedColor', (e, n, o) => {
            t.color = o
          })
          this.items.add(this.colorPickerView)
          this.items.add(this.actionBarView)
          this._addColorPickersElementsToFocusTracker()
          this._stopPropagationOnArrowsKeys()
          this._executeOnEnterPress()
          this._executeUponColorChange()
        }
        destroy() {
          super.destroy()
        }
        focus() {
          this.colorPickerView.focus()
        }
        _executeOnEnterPress() {
          this.keystrokes.set('enter', (t) => {
            if (this.isVisible && this.focusTracker.focusedElement !== this.cancelButtonView.element) {
              this.fire('execute', { value: this.selectedColor })
              t.stopPropagation()
              t.preventDefault()
            }
          })
        }
        _stopPropagationOnArrowsKeys() {
          const t = (t) => t.stopPropagation()
          this.keystrokes.set('arrowright', t)
          this.keystrokes.set('arrowleft', t)
          this.keystrokes.set('arrowup', t)
          this.keystrokes.set('arrowdown', t)
        }
        _addColorPickersElementsToFocusTracker() {
          for (const t of this.colorPickerView.slidersView) {
            this.focusTracker.add(t.element)
            this._focusables.add(t)
          }
          const t = this.colorPickerView.hexInputRow.children.get(1)
          if (t.element) {
            this.focusTracker.add(t.element)
            this._focusables.add(t)
          }
          this.focusTracker.add(this.saveButtonView.element)
          this._focusables.add(this.saveButtonView)
          this.focusTracker.add(this.cancelButtonView.element)
          this._focusables.add(this.cancelButtonView)
        }
        _createActionBarView({ saveButtonView: t, cancelButtonView: e }) {
          const n = new View()
          const o = this.createCollection()
          o.add(t)
          o.add(e)
          n.setTemplate({ tag: 'div', attributes: { class: ['ck', 'ck-color-selector_action-bar'] }, children: o })
          return n
        }
        _createActionButtons() {
          const t = this.locale
          const e = t.t
          const n = new ButtonView(t)
          const o = new ButtonView(t)
          n.set({ icon: checkButtonIcon, class: 'ck-button-save', type: 'button', withText: false, label: e('Accept') })
          o.set({
            icon: cancelButtonIcon,
            class: 'ck-button-cancel',
            type: 'button',
            withText: false,
            label: e('Cancel'),
          })
          n.on('execute', () => {
            this.fire('execute', { source: 'colorPickerSaveButton', value: this.selectedColor })
          })
          o.on('execute', () => {
            this.fire('colorPicker:cancel')
          })
          return { saveButtonView: n, cancelButtonView: o }
        }
        _executeUponColorChange() {
          this.colorPickerView.on('colorSelected', (t, e) => {
            this.fire('execute', { value: e.color, source: 'colorPicker' })
            this.set('selectedColor', e.color)
          })
        }
      }
      var Vx = n(6306)
      var Fx = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      Fx.insert = 'head'
      Fx.singleton = true
      var jx = Rl()(Vx.Z, Fx)
      const Hx = Vx.Z.locals || {}
      class Ux extends (null && View) {
        constructor(
          t,
          {
            colors: e,
            columns: n,
            removeButtonLabel: o,
            documentColorsLabel: i,
            documentColorsCount: r,
            colorPickerLabel: s,
            colorPickerViewConfig: a,
          },
        ) {
          super(t)
          this.items = this.createCollection()
          this.focusTracker = new FocusTracker()
          this.keystrokes = new KeystrokeHandler()
          this._focusables = new ViewCollection()
          this._colorPickerViewConfig = a
          this._focusCycler = new FocusCycler({
            focusables: this._focusables,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: { focusPrevious: 'shift + tab', focusNext: 'tab' },
          })
          this.colorGridsFragmentView = new ColorGridsFragmentView(t, {
            colors: e,
            columns: n,
            removeButtonLabel: o,
            documentColorsLabel: i,
            documentColorsCount: r,
            colorPickerLabel: s,
            focusTracker: this.focusTracker,
            focusables: this._focusables,
          })
          this.colorPickerFragmentView = new ColorPickerFragmentView(t, {
            focusables: this._focusables,
            focusTracker: this.focusTracker,
            keystrokes: this.keystrokes,
            colorPickerViewConfig: a,
          })
          this.set('_isColorGridsFragmentVisible', true)
          this.set('_isColorPickerFragmentVisible', false)
          this.set('selectedColor', undefined)
          this.colorGridsFragmentView.bind('isVisible').to(this, '_isColorGridsFragmentVisible')
          this.colorPickerFragmentView.bind('isVisible').to(this, '_isColorPickerFragmentVisible')
          this.on('change:selectedColor', (t, e, n) => {
            this.colorGridsFragmentView.set('selectedColor', n)
            this.colorPickerFragmentView.set('selectedColor', n)
          })
          this.colorGridsFragmentView.on('change:selectedColor', (t, e, n) => {
            this.set('selectedColor', n)
          })
          this.colorPickerFragmentView.on('change:selectedColor', (t, e, n) => {
            this.set('selectedColor', n)
          })
          this.setTemplate({ tag: 'div', attributes: { class: ['ck', 'ck-color-selector'] }, children: this.items })
        }
        render() {
          super.render()
          this.keystrokes.listenTo(this.element)
        }
        destroy() {
          super.destroy()
          this.focusTracker.destroy()
          this.keystrokes.destroy()
        }
        appendUI() {
          this._appendColorGridsFragment()
          if (this._colorPickerViewConfig) {
            this._appendColorPickerFragment()
          }
        }
        showColorPickerFragment() {
          if (!this.colorPickerFragmentView.colorPickerView || this._isColorPickerFragmentVisible) {
            return
          }
          this._isColorPickerFragmentVisible = true
          this.colorPickerFragmentView.focus()
          this._isColorGridsFragmentVisible = false
        }
        showColorGridsFragment() {
          if (this._isColorGridsFragmentVisible) {
            return
          }
          this._isColorGridsFragmentVisible = true
          this.colorGridsFragmentView.focus()
          this._isColorPickerFragmentVisible = false
        }
        focus() {
          this._focusCycler.focusFirst()
        }
        focusLast() {
          this._focusCycler.focusLast()
        }
        updateDocumentColors(t, e) {
          this.colorGridsFragmentView.updateDocumentColors(t, e)
        }
        updateSelectedColors() {
          this.colorGridsFragmentView.updateSelectedColors()
        }
        _appendColorGridsFragment() {
          if (this.items.length) {
            return
          }
          this.items.add(this.colorGridsFragmentView)
          this.colorGridsFragmentView.delegate('execute').to(this)
          this.colorGridsFragmentView.delegate('colorPicker:show').to(this)
        }
        _appendColorPickerFragment() {
          if (this.items.length === 2) {
            return
          }
          this.items.add(this.colorPickerFragmentView)
          if (this.colorGridsFragmentView.colorPickerButtonView) {
            this.colorGridsFragmentView.colorPickerButtonView.on('execute', () => {
              this.showColorPickerFragment()
            })
          }
          this.colorGridsFragmentView.addColorPickerButton()
          this.colorPickerFragmentView.delegate('execute').to(this)
          this.colorPickerFragmentView.delegate('colorPicker:cancel').to(this)
        }
      }
      class Wx {
        constructor(t) {
          this._components = new Map()
          this.editor = t
        }
        *names() {
          for (const t of this._components.values()) {
            yield t.originalName
          }
        }
        add(t, e) {
          this._components.set(Gx(t), { callback: e, originalName: t })
        }
        create(t) {
          if (!this.has(t)) {
            throw new P('componentfactory-item-missing', this, { name: t })
          }
          return this._components.get(Gx(t)).callback(this.editor.locale)
        }
        has(t) {
          return this._components.has(Gx(t))
        }
      }
      function Gx(t) {
        return String(t).toLowerCase()
      }
      var qx = n(4460)
      var $x = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      $x.insert = 'head'
      $x.singleton = true
      var Kx = Rl()(qx.Z, $x)
      const Yx = qx.Z.locals || {}
      const Zx = _c('px')
      const Qx = oc.document.body
      class Jx extends Hl {
        constructor(t) {
          super(t)
          const e = this.bindTemplate
          this.set('top', 0)
          this.set('left', 0)
          this.set('position', 'arrow_nw')
          this.set('isVisible', false)
          this.set('withArrow', true)
          this.set('class', undefined)
          this._pinWhenIsVisibleCallback = null
          this.content = this.createCollection()
          this.setTemplate({
            tag: 'div',
            attributes: {
              class: [
                'ck',
                'ck-balloon-panel',
                e.to('position', (t) => `ck-balloon-panel_${t}`),
                e.if('isVisible', 'ck-balloon-panel_visible'),
                e.if('withArrow', 'ck-balloon-panel_with-arrow'),
                e.to('class'),
              ],
              style: { top: e.to('top', Zx), left: e.to('left', Zx) },
            },
            children: this.content,
          })
        }
        show() {
          this.isVisible = true
        }
        hide() {
          this.isVisible = false
        }
        attachTo(t) {
          this.show()
          const e = Jx.defaultPositions
          const n = Object.assign(
            {},
            {
              element: this.element,
              positions: [
                e.southArrowNorth,
                e.southArrowNorthMiddleWest,
                e.southArrowNorthMiddleEast,
                e.southArrowNorthWest,
                e.southArrowNorthEast,
                e.northArrowSouth,
                e.northArrowSouthMiddleWest,
                e.northArrowSouthMiddleEast,
                e.northArrowSouthWest,
                e.northArrowSouthEast,
                e.viewportStickyNorth,
              ],
              limiter: Qx,
              fitInViewport: true,
            },
            t,
          )
          const o = Jx._getOptimalPosition(n)
          const i = parseInt(o.left)
          const r = parseInt(o.top)
          const s = o.name
          const a = o.config || {}
          const { withArrow: c = true } = a
          this.top = r
          this.left = i
          this.position = s
          this.withArrow = c
        }
        pin(t) {
          this.unpin()
          this._pinWhenIsVisibleCallback = () => {
            if (this.isVisible) {
              this._startPinning(t)
            } else {
              this._stopPinning()
            }
          }
          this._startPinning(t)
          this.listenTo(this, 'change:isVisible', this._pinWhenIsVisibleCallback)
        }
        unpin() {
          if (this._pinWhenIsVisibleCallback) {
            this._stopPinning()
            this.stopListening(this, 'change:isVisible', this._pinWhenIsVisibleCallback)
            this._pinWhenIsVisibleCallback = null
            this.hide()
          }
        }
        _startPinning(t) {
          this.attachTo(t)
          const e = Xx(t.target)
          const n = t.limiter ? Xx(t.limiter) : Qx
          this.listenTo(
            oc.document,
            'scroll',
            (o, i) => {
              const r = i.target
              const s = e && r.contains(e)
              const a = n && r.contains(n)
              if (s || a || !e || !n) {
                this.attachTo(t)
              }
            },
            { useCapture: true },
          )
          this.listenTo(oc.window, 'resize', () => {
            this.attachTo(t)
          })
        }
        _stopPinning() {
          this.stopListening(oc.document, 'scroll')
          this.stopListening(oc.window, 'resize')
        }
      }
      Jx.arrowSideOffset = 25
      Jx.arrowHeightOffset = 10
      Jx.stickyVerticalOffset = 20
      Jx._getOptimalPosition = Tc
      Jx.defaultPositions = tE()
      function Xx(t) {
        if (Ga(t)) {
          return t
        }
        if (sc(t)) {
          return t.commonAncestorContainer
        }
        if (typeof t == 'function') {
          return Xx(t())
        }
        return null
      }
      function tE(t = {}) {
        const {
          sideOffset: e = Jx.arrowSideOffset,
          heightOffset: n = Jx.arrowHeightOffset,
          stickyVerticalOffset: o = Jx.stickyVerticalOffset,
          config: i,
        } = t
        return {
          northWestArrowSouthWest: (t, n) => ({
            top: r(t, n),
            left: t.left - e,
            name: 'arrow_sw',
            ...(i && { config: i }),
          }),
          northWestArrowSouthMiddleWest: (t, n) => ({
            top: r(t, n),
            left: t.left - n.width * 0.25 - e,
            name: 'arrow_smw',
            ...(i && { config: i }),
          }),
          northWestArrowSouth: (t, e) => ({
            top: r(t, e),
            left: t.left - e.width / 2,
            name: 'arrow_s',
            ...(i && { config: i }),
          }),
          northWestArrowSouthMiddleEast: (t, n) => ({
            top: r(t, n),
            left: t.left - n.width * 0.75 + e,
            name: 'arrow_sme',
            ...(i && { config: i }),
          }),
          northWestArrowSouthEast: (t, n) => ({
            top: r(t, n),
            left: t.left - n.width + e,
            name: 'arrow_se',
            ...(i && { config: i }),
          }),
          northArrowSouthWest: (t, n) => ({
            top: r(t, n),
            left: t.left + t.width / 2 - e,
            name: 'arrow_sw',
            ...(i && { config: i }),
          }),
          northArrowSouthMiddleWest: (t, n) => ({
            top: r(t, n),
            left: t.left + t.width / 2 - n.width * 0.25 - e,
            name: 'arrow_smw',
            ...(i && { config: i }),
          }),
          northArrowSouth: (t, e) => ({
            top: r(t, e),
            left: t.left + t.width / 2 - e.width / 2,
            name: 'arrow_s',
            ...(i && { config: i }),
          }),
          northArrowSouthMiddleEast: (t, n) => ({
            top: r(t, n),
            left: t.left + t.width / 2 - n.width * 0.75 + e,
            name: 'arrow_sme',
            ...(i && { config: i }),
          }),
          northArrowSouthEast: (t, n) => ({
            top: r(t, n),
            left: t.left + t.width / 2 - n.width + e,
            name: 'arrow_se',
            ...(i && { config: i }),
          }),
          northEastArrowSouthWest: (t, n) => ({
            top: r(t, n),
            left: t.right - e,
            name: 'arrow_sw',
            ...(i && { config: i }),
          }),
          northEastArrowSouthMiddleWest: (t, n) => ({
            top: r(t, n),
            left: t.right - n.width * 0.25 - e,
            name: 'arrow_smw',
            ...(i && { config: i }),
          }),
          northEastArrowSouth: (t, e) => ({
            top: r(t, e),
            left: t.right - e.width / 2,
            name: 'arrow_s',
            ...(i && { config: i }),
          }),
          northEastArrowSouthMiddleEast: (t, n) => ({
            top: r(t, n),
            left: t.right - n.width * 0.75 + e,
            name: 'arrow_sme',
            ...(i && { config: i }),
          }),
          northEastArrowSouthEast: (t, n) => ({
            top: r(t, n),
            left: t.right - n.width + e,
            name: 'arrow_se',
            ...(i && { config: i }),
          }),
          southWestArrowNorthWest: (t) => ({ top: s(t), left: t.left - e, name: 'arrow_nw', ...(i && { config: i }) }),
          southWestArrowNorthMiddleWest: (t, n) => ({
            top: s(t),
            left: t.left - n.width * 0.25 - e,
            name: 'arrow_nmw',
            ...(i && { config: i }),
          }),
          southWestArrowNorth: (t, e) => ({
            top: s(t),
            left: t.left - e.width / 2,
            name: 'arrow_n',
            ...(i && { config: i }),
          }),
          southWestArrowNorthMiddleEast: (t, n) => ({
            top: s(t),
            left: t.left - n.width * 0.75 + e,
            name: 'arrow_nme',
            ...(i && { config: i }),
          }),
          southWestArrowNorthEast: (t, n) => ({
            top: s(t),
            left: t.left - n.width + e,
            name: 'arrow_ne',
            ...(i && { config: i }),
          }),
          southArrowNorthWest: (t) => ({
            top: s(t),
            left: t.left + t.width / 2 - e,
            name: 'arrow_nw',
            ...(i && { config: i }),
          }),
          southArrowNorthMiddleWest: (t, n) => ({
            top: s(t),
            left: t.left + t.width / 2 - n.width * 0.25 - e,
            name: 'arrow_nmw',
            ...(i && { config: i }),
          }),
          southArrowNorth: (t, e) => ({
            top: s(t),
            left: t.left + t.width / 2 - e.width / 2,
            name: 'arrow_n',
            ...(i && { config: i }),
          }),
          southArrowNorthMiddleEast: (t, n) => ({
            top: s(t),
            left: t.left + t.width / 2 - n.width * 0.75 + e,
            name: 'arrow_nme',
            ...(i && { config: i }),
          }),
          southArrowNorthEast: (t, n) => ({
            top: s(t),
            left: t.left + t.width / 2 - n.width + e,
            name: 'arrow_ne',
            ...(i && { config: i }),
          }),
          southEastArrowNorthWest: (t) => ({ top: s(t), left: t.right - e, name: 'arrow_nw', ...(i && { config: i }) }),
          southEastArrowNorthMiddleWest: (t, n) => ({
            top: s(t),
            left: t.right - n.width * 0.25 - e,
            name: 'arrow_nmw',
            ...(i && { config: i }),
          }),
          southEastArrowNorth: (t, e) => ({
            top: s(t),
            left: t.right - e.width / 2,
            name: 'arrow_n',
            ...(i && { config: i }),
          }),
          southEastArrowNorthMiddleEast: (t, n) => ({
            top: s(t),
            left: t.right - n.width * 0.75 + e,
            name: 'arrow_nme',
            ...(i && { config: i }),
          }),
          southEastArrowNorthEast: (t, n) => ({
            top: s(t),
            left: t.right - n.width + e,
            name: 'arrow_ne',
            ...(i && { config: i }),
          }),
          westArrowEast: (t, e) => ({
            top: t.top + t.height / 2 - e.height / 2,
            left: t.left - e.width - n,
            name: 'arrow_e',
            ...(i && { config: i }),
          }),
          eastArrowWest: (t, e) => ({
            top: t.top + t.height / 2 - e.height / 2,
            left: t.right + n,
            name: 'arrow_w',
            ...(i && { config: i }),
          }),
          viewportStickyNorth: (t, e, n) => {
            if (!t.getIntersection(n)) {
              return null
            }
            return {
              top: n.top + o,
              left: t.left + t.width / 2 - e.width / 2,
              name: 'arrowless',
              config: { withArrow: false, ...i },
            }
          },
        }
        function r(t, e) {
          return t.top - e.height - n
        }
        function s(t) {
          return t.bottom + n
        }
      }
      var eE = n(3888)
      var nE = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      nE.insert = 'head'
      nE.singleton = true
      var oE = Rl()(eE.Z, nE)
      const iE = eE.Z.locals || {}
      const rE = 'ck-tooltip'
      class sE extends Ja() {
        constructor(t) {
          super()
          this._currentElementWithTooltip = null
          this._currentTooltipPosition = null
          this._resizeObserver = null
          sE._editors.add(t)
          if (sE._instance) {
            return sE._instance
          }
          sE._instance = this
          this.tooltipTextView = new Hl(t.locale)
          this.tooltipTextView.set('text', '')
          this.tooltipTextView.setTemplate({
            tag: 'span',
            attributes: { class: ['ck', 'ck-tooltip__text'] },
            children: [{ text: this.tooltipTextView.bindTemplate.to('text') }],
          })
          this.balloonPanelView = new Jx(t.locale)
          this.balloonPanelView.class = rE
          this.balloonPanelView.content.add(this.tooltipTextView)
          this._pinTooltipDebounced = np(this._pinTooltip, 600)
          this.listenTo(oc.document, 'mouseenter', this._onEnterOrFocus.bind(this), { useCapture: true })
          this.listenTo(oc.document, 'mouseleave', this._onLeaveOrBlur.bind(this), { useCapture: true })
          this.listenTo(oc.document, 'focus', this._onEnterOrFocus.bind(this), { useCapture: true })
          this.listenTo(oc.document, 'blur', this._onLeaveOrBlur.bind(this), { useCapture: true })
          this.listenTo(oc.document, 'scroll', this._onScroll.bind(this), { useCapture: true })
          this._watchdogExcluded = true
        }
        destroy(t) {
          const e = t.ui.view && t.ui.view.body
          sE._editors.delete(t)
          this.stopListening(t.ui)
          if (e && e.has(this.balloonPanelView)) {
            e.remove(this.balloonPanelView)
          }
          if (!sE._editors.size) {
            this._unpinTooltip()
            this.balloonPanelView.destroy()
            this.stopListening()
            sE._instance = null
          }
        }
        static getPositioningFunctions(t) {
          const e = sE.defaultBalloonPositions
          return {
            s: [e.southArrowNorth, e.southArrowNorthEast, e.southArrowNorthWest],
            n: [e.northArrowSouth],
            e: [e.eastArrowWest],
            w: [e.westArrowEast],
            sw: [e.southArrowNorthEast],
            se: [e.southArrowNorthWest],
          }[t]
        }
        _onEnterOrFocus(t, { target: e }) {
          const n = aE(e)
          if (!n) {
            return
          }
          if (n === this._currentElementWithTooltip) {
            return
          }
          this._unpinTooltip()
          this._pinTooltipDebounced(n, cE(n))
        }
        _onLeaveOrBlur(t, { target: e, relatedTarget: n }) {
          if (t.name === 'mouseleave') {
            if (!Ga(e)) {
              return
            }
            if (this._currentElementWithTooltip && e !== this._currentElementWithTooltip) {
              return
            }
            const t = aE(e)
            const o = aE(n)
            if (t && t !== o) {
              this._unpinTooltip()
            }
          } else {
            if (this._currentElementWithTooltip && e !== this._currentElementWithTooltip) {
              return
            }
            this._unpinTooltip()
          }
        }
        _onScroll(t, { target: e }) {
          if (!this._currentElementWithTooltip) {
            return
          }
          if (e.contains(this.balloonPanelView.element) && e.contains(this._currentElementWithTooltip)) {
            return
          }
          this._unpinTooltip()
        }
        _pinTooltip(t, { text: e, position: n, cssClass: o }) {
          const i = bl(sE._editors.values()).ui.view.body
          if (!i.has(this.balloonPanelView)) {
            i.add(this.balloonPanelView)
          }
          this.tooltipTextView.text = e
          this.balloonPanelView.pin({ target: t, positions: sE.getPositioningFunctions(n) })
          this._resizeObserver = new wc(t, () => {
            if (!Ec(t)) {
              this._unpinTooltip()
            }
          })
          this.balloonPanelView.class = [rE, o].filter((t) => t).join(' ')
          for (const t of sE._editors) {
            this.listenTo(t.ui, 'update', this._updateTooltipPosition.bind(this), { priority: 'low' })
          }
          this._currentElementWithTooltip = t
          this._currentTooltipPosition = n
        }
        _unpinTooltip() {
          this._pinTooltipDebounced.cancel()
          this.balloonPanelView.unpin()
          for (const t of sE._editors) {
            this.stopListening(t.ui, 'update')
          }
          this._currentElementWithTooltip = null
          this._currentTooltipPosition = null
          if (this._resizeObserver) {
            this._resizeObserver.destroy()
          }
        }
        _updateTooltipPosition() {
          if (!Ec(this._currentElementWithTooltip)) {
            this._unpinTooltip()
            return
          }
          this.balloonPanelView.pin({
            target: this._currentElementWithTooltip,
            positions: sE.getPositioningFunctions(this._currentTooltipPosition),
          })
        }
      }
      sE.defaultBalloonPositions = tE({ heightOffset: 5, sideOffset: 13 })
      sE._editors = new Set()
      sE._instance = null
      function aE(t) {
        if (!Ga(t)) {
          return null
        }
        return t.closest('[data-cke-tooltip-text]:not([data-cke-tooltip-disabled])')
      }
      function cE(t) {
        return {
          text: t.dataset.ckeTooltipText,
          position: t.dataset.ckeTooltipPosition || 's',
          cssClass: t.dataset.ckeTooltipClass || '',
        }
      }
      var lE = 'Expected a function'
      function dE(t, e, n) {
        var o = true,
          i = true
        if (typeof t != 'function') {
          throw new TypeError(lE)
        }
        if (at(n)) {
          o = 'leading' in n ? !!n.leading : o
          i = 'trailing' in n ? !!n.trailing : i
        }
        return np(t, e, { leading: o, maxWait: e, trailing: i })
      }
      const uE = dE
      const hE =
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 53 10"><path d="M31.724 1.492a15.139 15.139 0 0 0 .045 1.16 2.434 2.434 0 0 0-.687-.34 3.68 3.68 0 0 0-1.103-.166 2.332 2.332 0 0 0-1.14.255 1.549 1.549 0 0 0-.686.87c-.15.41-.225.98-.225 1.712 0 .939.148 1.659.444 2.161.297.503.792.754 1.487.754.452.015.9-.094 1.294-.316.296-.174.557-.4.771-.669l.14.852h1.282V.007h-1.623v1.485ZM31 6.496a1.77 1.77 0 0 1-.494.061.964.964 0 0 1-.521-.127.758.758 0 0 1-.296-.466 3.984 3.984 0 0 1-.093-.992 4.208 4.208 0 0 1 .098-1.052.753.753 0 0 1 .307-.477 1.08 1.08 0 0 1 .55-.122 2.4 2.4 0 0 1 .69.089l.483.144v2.553c-.11.076-.213.143-.307.2a1.73 1.73 0 0 1-.417.189ZM35.68 0l-.702.004c-.322.002-.482.168-.48.497l.004.581c.002.33.164.493.486.49l.702-.004c.322-.002.481-.167.48-.496L36.165.49c-.002-.33-.164-.493-.486-.491Zm.465 2.313-1.612.01.034 5.482 1.613-.01-.035-5.482ZM39.623.79 37.989.8 38 2.306l-.946.056.006 1.009.949-.006.024 2.983c.003.476.143.844.419 1.106.275.26.658.39 1.148.387.132 0 .293-.01.483-.03.19-.02.38-.046.57-.08.163-.028.324-.068.482-.119l-.183-1.095-.702.004a.664.664 0 0 1-.456-.123.553.553 0 0 1-.14-.422l-.016-2.621 1.513-.01-.006-1.064-1.514.01-.01-1.503Zm6.603 1.598c-.41-.184-.956-.274-1.636-.27-.673.004-1.215.101-1.627.29-.402.179-.72.505-.888.91-.18.419-.268.979-.264 1.68.004.688.1 1.24.285 1.655.172.404.495.724.9.894.414.18.957.268 1.63.264.68-.004 1.224-.099 1.632-.284.4-.176.714-.501.878-.905.176-.418.263-.971.258-1.658-.004-.702-.097-1.261-.28-1.677a1.696 1.696 0 0 0-.888-.9Zm-.613 3.607a.77.77 0 0 1-.337.501 1.649 1.649 0 0 1-1.317.009.776.776 0 0 1-.343-.497 4.066 4.066 0 0 1-.105-1.02 4.136 4.136 0 0 1 .092-1.03.786.786 0 0 1 .337-.507 1.59 1.59 0 0 1 1.316-.008.79.79 0 0 1 .344.502c.078.337.113.683.105 1.03.012.343-.019.685-.092 1.02Zm6.501-3.925a2.67 2.67 0 0 0-1.128.278c-.39.191-.752.437-1.072.73l-.157-.846-1.273.008.036 5.572 1.623-.01-.024-3.78c.35-.124.646-.22.887-.286.26-.075.53-.114.8-.118l.45-.003.144-1.546-.286.001ZM22.083 7.426l-1.576-2.532a2.137 2.137 0 0 0-.172-.253 1.95 1.95 0 0 0-.304-.29.138.138 0 0 1 .042-.04 1.7 1.7 0 0 0 .328-.374l1.75-2.71c.01-.015.025-.028.024-.048-.01-.01-.021-.007-.031-.007L20.49 1.17a.078.078 0 0 0-.075.045l-.868 1.384c-.23.366-.46.732-.688 1.099a.108.108 0 0 1-.112.06c-.098-.005-.196-.001-.294-.002-.018 0-.038.006-.055-.007.002-.02.002-.039.005-.058a4.6 4.6 0 0 0 .046-.701V1.203c0-.02-.009-.032-.03-.03h-.033L16.93 1.17c-.084 0-.073-.01-.073.076v6.491c-.001.018.006.028.025.027h1.494c.083 0 .072.007.072-.071v-2.19c0-.055-.003-.11-.004-.166a3.366 3.366 0 0 0-.05-.417h.06c.104 0 .209.002.313-.002a.082.082 0 0 1 .084.05c.535.913 1.07 1.824 1.607 2.736a.104.104 0 0 0 .103.062c.554-.003 1.107-.002 1.66-.002l.069-.003-.019-.032-.188-.304Zm5.029-.871c-.005-.08-.004-.08-.082-.08h-2.414c-.053 0-.106-.003-.159-.011a.279.279 0 0 1-.246-.209.558.558 0 0 1-.022-.15c0-.382 0-.762-.002-1.143 0-.032.007-.049.042-.044h2.504c.029.003.037-.012.034-.038V3.814c0-.089.013-.078-.076-.078h-2.44c-.07 0-.062.003-.062-.06v-.837c0-.047.004-.093.013-.14a.283.283 0 0 1 .241-.246.717.717 0 0 1 .146-.011h2.484c.024.002.035-.009.036-.033l.003-.038.03-.496c.01-.183.024-.365.034-.548.005-.085.003-.087-.082-.094-.218-.018-.437-.038-.655-.05a17.845 17.845 0 0 0-.657-.026 72.994 72.994 0 0 0-1.756-.016 1.7 1.7 0 0 0-.471.064 1.286 1.286 0 0 0-.817.655 1.349 1.349 0 0 0-.145.633v3.875c0 .072.003.144.011.216a1.27 1.27 0 0 0 .711 1.029c.228.113.48.167.734.158.757-.005 1.515.002 2.272-.042.274-.016.548-.034.82-.053.03-.002.043-.008.04-.041-.008-.104-.012-.208-.019-.312a69.964 69.964 0 0 1-.05-.768Zm-10.972.86-.127-1.075c-.004-.03-.014-.04-.044-.037a13.125 13.125 0 0 1-.998.073c-.336.01-.672.02-1.008.016a1.693 1.693 0 0 1-.347-.039.746.746 0 0 1-.45-.262 1.038 1.038 0 0 1-.167-.33 3.324 3.324 0 0 1-.126-.773 9.113 9.113 0 0 1-.015-.749c0-.285.022-.57.065-.852a1.94 1.94 0 0 1 .127-.46.728.728 0 0 1 .518-.443 1.64 1.64 0 0 1 .397-.048c.628-.001 1.255.003 1.882.05.022.001.033-.006.036-.026l.003-.031.06-.55c.019-.177.036-.355.057-.532.004-.034-.005-.046-.04-.056a5.595 5.595 0 0 0-1.213-.21 10.783 10.783 0 0 0-.708-.02 5.09 5.09 0 0 0-.719.041 3.477 3.477 0 0 0-.625.14 1.912 1.912 0 0 0-.807.497c-.185.2-.33.433-.424.688a4.311 4.311 0 0 0-.24 1.096 7.262 7.262 0 0 0-.042.86c-.006.43.024.86.091 1.286.04.25.104.497.193.734.098.279.26.53.473.734.214.205.473.358.756.446.344.11.702.17 1.063.177a8.505 8.505 0 0 0 1.578-.083 6.11 6.11 0 0 0 .766-.18c.03-.008.047-.023.037-.057a.157.157 0 0 1-.003-.025Z"/><path d="M6.016 6.69a1.592 1.592 0 0 0-.614.21c-.23.132-.422.32-.56.546-.044.072-.287.539-.287.539l-.836 1.528.009.006c.038.025.08.046.123.063.127.046.26.07.395.073.505.023 1.011-.007 1.517-.003.29.009.58.002.869-.022a.886.886 0 0 0 .395-.116.962.962 0 0 0 .312-.286c.056-.083.114-.163.164-.249.24-.408.48-.816.718-1.226.075-.128.148-.257.222-.386l.112-.192a1.07 1.07 0 0 0 .153-.518l-1.304.023s-1.258-.005-1.388.01Z"/><path d="m2.848 9.044.76-1.39.184-.352c-.124-.067-.245-.14-.367-.21-.346-.204-.706-.384-1.045-.6a.984.984 0 0 1-.244-.207c-.108-.134-.136-.294-.144-.46-.021-.409-.002-.818-.009-1.227-.003-.195 0-.39.003-.585.004-.322.153-.553.427-.713l.833-.488c.22-.13.44-.257.662-.385.05-.029.105-.052.158-.077.272-.128.519-.047.76.085l.044.028c.123.06.242.125.358.196.318.178.635.357.952.537.095.056.187.117.275.184.194.144.254.35.266.578.016.284.007.569.006.853-.001.28.004.558 0 .838.592-.003 1.259 0 1.259 0l.723-.013c-.003-.292-.007-.584-.007-.876 0-.524.015-1.048-.016-1.571-.024-.42-.135-.8-.492-1.067a5.02 5.02 0 0 0-.506-.339A400.52 400.52 0 0 0 5.94.787C5.722.664 5.513.524 5.282.423 5.255.406 5.228.388 5.2.373 4.758.126 4.305-.026 3.807.21c-.097.046-.197.087-.29.14A699.896 699.896 0 0 0 .783 1.948c-.501.294-.773.717-.778 1.31-.004.36-.009.718-.001 1.077.016.754-.017 1.508.024 2.261.016.304.07.6.269.848.127.15.279.28.448.382.622.4 1.283.734 1.92 1.11l.183.109Z"/></svg>'
      const gE = 53
      const fE = 10
      const mE = 50
      const pE = 350
      const bE = 'Powered by'
      const kE = { top: -99999, left: -99999, name: 'invalid', config: { withArrow: false } }
      class wE extends Ja() {
        constructor(t) {
          super()
          this.editor = t
          this._balloonView = null
          this._lastFocusedEditableElement = null
          this._showBalloonThrottled = uE(this._showBalloon.bind(this), 50, { leading: true })
          t.on('ready', this._handleEditorReady.bind(this))
        }
        destroy() {
          const t = this._balloonView
          if (t) {
            t.unpin()
            this._balloonView = null
          }
          this._showBalloonThrottled.cancel()
          this.stopListening()
        }
        _handleEditorReady() {
          const t = this.editor
          const e = !!t.config.get('ui.poweredBy.forceVisible')
          if (!e && xl(t.config.get('licenseKey')) === 'VALID') {
            return
          }
          if (!t.ui.view) {
            return
          }
          t.ui.focusTracker.on('change:isFocused', (t, e, n) => {
            this._updateLastFocusedEditableElement()
            if (n) {
              this._showBalloon()
            } else {
              this._hideBalloon()
            }
          })
          t.ui.focusTracker.on('change:focusedElement', (t, e, n) => {
            this._updateLastFocusedEditableElement()
            if (n) {
              this._showBalloon()
            }
          })
          t.ui.on('update', () => {
            this._showBalloonThrottled()
          })
        }
        _createBalloonView() {
          const t = this.editor
          const e = (this._balloonView = new Jx())
          const n = xE(t)
          const o = new AE(t.locale, n.label)
          e.content.add(o)
          e.set({ class: 'ck-powered-by-balloon' })
          t.ui.view.body.add(e)
          t.ui.focusTracker.add(e.element)
          this._balloonView = e
        }
        _showBalloon() {
          if (!this._lastFocusedEditableElement) {
            return
          }
          const t = _E(this.editor, this._lastFocusedEditableElement)
          if (t) {
            if (!this._balloonView) {
              this._createBalloonView()
            }
            this._balloonView.pin(t)
          }
        }
        _hideBalloon() {
          if (this._balloonView) {
            this._balloonView.unpin()
          }
        }
        _updateLastFocusedEditableElement() {
          const t = this.editor
          const e = t.ui.focusTracker.isFocused
          const n = t.ui.focusTracker.focusedElement
          if (!e || !n) {
            this._lastFocusedEditableElement = null
            return
          }
          const o = Array.from(t.ui.getEditableElementsNames()).map((e) => t.ui.getEditableElement(e))
          if (o.includes(n)) {
            this._lastFocusedEditableElement = n
          } else {
            this._lastFocusedEditableElement = o[0]
          }
        }
      }
      class AE extends Hl {
        constructor(t, e) {
          super(t)
          const n = new Cd()
          const o = this.bindTemplate
          n.set({ content: hE, isColorInherited: false })
          n.extendTemplate({ attributes: { style: { width: gE + 'px', height: fE + 'px' } } })
          this.setTemplate({
            tag: 'div',
            attributes: { class: ['ck', 'ck-powered-by'], 'aria-hidden': true },
            children: [
              {
                tag: 'a',
                attributes: {
                  href:
                    'https://ckeditor.com/?utm_source=ckeditor&' +
                    'utm_medium=referral&utm_campaign=701Dn000000hVgmIAE_powered_by_ckeditor_logo',
                  target: '_blank',
                  tabindex: '-1',
                },
                children: [
                  ...(e ? [{ tag: 'span', attributes: { class: ['ck', 'ck-powered-by__label'] }, children: [e] }] : []),
                  n,
                ],
                on: { dragstart: o.to((t) => t.preventDefault()) },
              },
            ],
          })
        }
      }
      function _E(t, e) {
        const n = xE(t)
        const o = n.side === 'right' ? CE(e, n) : vE(e, n)
        return { target: e, positions: [o] }
      }
      function CE(t, e) {
        return yE(t, e, (t, n) => t.left + t.width - n.width - e.horizontalOffset)
      }
      function vE(t, e) {
        return yE(t, e, (t) => t.left + e.horizontalOffset)
      }
      function yE(t, e, n) {
        return (o, i) => {
          const r = o.getVisible()
          if (!r) {
            return kE
          }
          if (o.width < pE || o.height < mE) {
            return kE
          }
          let s
          if (e.position === 'inside') {
            s = o.bottom - i.height
          } else {
            s = o.bottom - i.height / 2
          }
          s -= e.verticalOffset
          const a = n(o, i)
          if (e.position === 'inside') {
            const t = i.clone().moveTo(a, s)
            if (t.getIntersectionArea(r) < t.getArea()) {
              return kE
            }
          } else {
            const n = ic(t)
            if (n) {
              const t = new dc(n)
              const s = r.bottom + i.height / 2 > t.bottom
              const a = e.side === 'left' ? o.left < t.left : o.right > t.right
              if (s || a) {
                return kE
              }
            }
          }
          return { top: s, left: a, name: `position_${e.position}-side_${e.side}`, config: { withArrow: false } }
        }
      }
      function xE(t) {
        const e = t.config.get('ui.poweredBy')
        const n = (e && e.position) || 'border'
        return {
          position: n,
          label: bE,
          verticalOffset: n === 'inside' ? 5 : 0,
          horizontalOffset: 5,
          side: t.locale.contentLanguageDirection === 'ltr' ? 'right' : 'left',
          ...e,
        }
      }
      class EE extends ft() {
        constructor(t) {
          super()
          this.isReady = false
          this._editableElementsMap = new Map()
          this._focusableToolbarDefinitions = []
          const e = t.editing.view
          this.editor = t
          this.componentFactory = new Wx(t)
          this.focusTracker = new kl()
          this.tooltipManager = new sE(t)
          this.poweredBy = new wE(t)
          this.set('viewportOffset', this._readViewportOffsetFromConfig())
          this.once('ready', () => {
            this.isReady = true
          })
          this.listenTo(e.document, 'layoutChanged', this.update.bind(this))
          this.listenTo(e, 'scrollToTheSelection', this._handleScrollToTheSelection.bind(this))
          this._initFocusTracking()
        }
        get element() {
          return null
        }
        update() {
          this.fire('update')
        }
        destroy() {
          this.stopListening()
          this.focusTracker.destroy()
          this.tooltipManager.destroy(this.editor)
          this.poweredBy.destroy()
          for (const t of this._editableElementsMap.values()) {
            t.ckeditorInstance = null
            this.editor.keystrokes.stopListening(t)
          }
          this._editableElementsMap = new Map()
          this._focusableToolbarDefinitions = []
        }
        setEditableElement(t, e) {
          this._editableElementsMap.set(t, e)
          if (!e.ckeditorInstance) {
            e.ckeditorInstance = this.editor
          }
          this.focusTracker.add(e)
          const n = () => {
            if (this.editor.editing.view.getDomRoot(t)) {
              return
            }
            this.editor.keystrokes.listenTo(e)
          }
          if (this.isReady) {
            n()
          } else {
            this.once('ready', n)
          }
        }
        removeEditableElement(t) {
          const e = this._editableElementsMap.get(t)
          if (!e) {
            return
          }
          this._editableElementsMap.delete(t)
          this.editor.keystrokes.stopListening(e)
          this.focusTracker.remove(e)
          e.ckeditorInstance = null
        }
        getEditableElement(t = 'main') {
          return this._editableElementsMap.get(t)
        }
        getEditableElementsNames() {
          return this._editableElementsMap.keys()
        }
        addToolbar(t, e = {}) {
          if (t.isRendered) {
            this.focusTracker.add(t.element)
            this.editor.keystrokes.listenTo(t.element)
          } else {
            t.once('render', () => {
              this.focusTracker.add(t.element)
              this.editor.keystrokes.listenTo(t.element)
            })
          }
          this._focusableToolbarDefinitions.push({ toolbarView: t, options: e })
        }
        get _editableElements() {
          console.warn(
            'editor-ui-deprecated-editable-elements: ' +
              'The EditorUI#_editableElements property has been deprecated and will be removed in the near future.',
            { editorUI: this },
          )
          return this._editableElementsMap
        }
        _readViewportOffsetFromConfig() {
          const t = this.editor
          const e = t.config.get('ui.viewportOffset')
          if (e) {
            return e
          }
          const n = t.config.get('toolbar.viewportTopOffset')
          if (n) {
            console.warn(
              'editor-ui-deprecated-viewport-offset-config: ' +
                'The `toolbar.vieportTopOffset` configuration option is deprecated. ' +
                'It will be removed from future CKEditor versions. Use `ui.viewportOffset.top` instead.',
            )
            return { top: n }
          }
          return { top: 0 }
        }
        _initFocusTracking() {
          const t = this.editor
          const e = t.editing.view
          let n
          let o
          t.keystrokes.set('Alt+F10', (t, i) => {
            const r = this.focusTracker.focusedElement
            if (
              Array.from(this._editableElementsMap.values()).includes(r) &&
              !Array.from(e.domRoots.values()).includes(r)
            ) {
              n = r
            }
            const s = this._getCurrentFocusedToolbarDefinition()
            if (!s || !o) {
              o = this._getFocusableCandidateToolbarDefinitions()
            }
            for (let t = 0; t < o.length; t++) {
              const t = o.shift()
              o.push(t)
              if (t !== s && this._focusFocusableCandidateToolbar(t)) {
                if (s && s.options.afterBlur) {
                  s.options.afterBlur()
                }
                break
              }
            }
            i()
          })
          t.keystrokes.set('Esc', (e, o) => {
            const i = this._getCurrentFocusedToolbarDefinition()
            if (!i) {
              return
            }
            if (n) {
              n.focus()
              n = null
            } else {
              t.editing.view.focus()
            }
            if (i.options.afterBlur) {
              i.options.afterBlur()
            }
            o()
          })
        }
        _getFocusableCandidateToolbarDefinitions() {
          const t = []
          for (const e of this._focusableToolbarDefinitions) {
            const { toolbarView: n, options: o } = e
            if (Ec(n.element) || o.beforeFocus) {
              t.push(e)
            }
          }
          t.sort((t, e) => DE(t) - DE(e))
          return t
        }
        _getCurrentFocusedToolbarDefinition() {
          for (const t of this._focusableToolbarDefinitions) {
            if (t.toolbarView.element && t.toolbarView.element.contains(this.focusTracker.focusedElement)) {
              return t
            }
          }
          return null
        }
        _focusFocusableCandidateToolbar(t) {
          const {
            toolbarView: e,
            options: { beforeFocus: n },
          } = t
          if (n) {
            n()
          }
          if (!Ec(e.element)) {
            return false
          }
          e.focus()
          return true
        }
        _handleScrollToTheSelection(t, e) {
          const n = { top: 0, bottom: 0, left: 0, right: 0, ...this.viewportOffset }
          e.viewportOffset.top += n.top
          e.viewportOffset.bottom += n.bottom
          e.viewportOffset.left += n.left
          e.viewportOffset.right += n.right
        }
      }
      function DE(t) {
        const { toolbarView: e, options: n } = t
        let o = 10
        if (Ec(e.element)) {
          o--
        }
        if (n.isContextual) {
          o--
        }
        return o
      }
      var TE = n(9847)
      var IE = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      IE.insert = 'head'
      IE.singleton = true
      var SE = Rl()(TE.Z, IE)
      const ME = TE.Z.locals || {}
      class BE extends Hl {
        constructor(t) {
          super(t)
          this.body = new bd(t)
        }
        render() {
          super.render()
          this.body.attachToDom()
        }
        destroy() {
          this.body.detachFromDom()
          return super.destroy()
        }
      }
      class NE extends BE {
        constructor(t) {
          super(t)
          this.top = this.createCollection()
          this.main = this.createCollection()
          this._voiceLabelView = this._createVoiceLabel()
          this.setTemplate({
            tag: 'div',
            attributes: {
              class: ['ck', 'ck-reset', 'ck-editor', 'ck-rounded-corners'],
              role: 'application',
              dir: t.uiLanguageDirection,
              lang: t.uiLanguage,
              'aria-labelledby': this._voiceLabelView.id,
            },
            children: [
              this._voiceLabelView,
              {
                tag: 'div',
                attributes: { class: ['ck', 'ck-editor__top', 'ck-reset_all'], role: 'presentation' },
                children: this.top,
              },
              {
                tag: 'div',
                attributes: { class: ['ck', 'ck-editor__main'], role: 'presentation' },
                children: this.main,
              },
            ],
          })
        }
        _createVoiceLabel() {
          const t = this.t
          const e = new Xd()
          e.text = t('Rich Text Editor')
          e.extendTemplate({ attributes: { class: 'ck-voice-label' } })
          return e
        }
      }
      class PE extends Hl {
        constructor(t, e, n) {
          super(t)
          this.name = null
          this.setTemplate({
            tag: 'div',
            attributes: {
              class: ['ck', 'ck-content', 'ck-editor__editable', 'ck-rounded-corners'],
              lang: t.contentLanguage,
              dir: t.contentLanguageDirection,
            },
          })
          this.set('isFocused', false)
          this._editableElement = n
          this._hasExternalElement = !!this._editableElement
          this._editingView = e
        }
        render() {
          super.render()
          if (this._hasExternalElement) {
            this.template.apply((this.element = this._editableElement))
          } else {
            this._editableElement = this.element
          }
          this.on('change:isFocused', () => this._updateIsFocusedClasses())
          this._updateIsFocusedClasses()
        }
        destroy() {
          if (this._hasExternalElement) {
            this.template.revert(this._editableElement)
          }
          super.destroy()
        }
        get hasExternalElement() {
          return this._hasExternalElement
        }
        _updateIsFocusedClasses() {
          const t = this._editingView
          if (t.isRenderingInProgress) {
            n(this)
          } else {
            e(this)
          }
          function e(e) {
            t.change((n) => {
              const o = t.document.getRoot(e.name)
              n.addClass(e.isFocused ? 'ck-focused' : 'ck-blurred', o)
              n.removeClass(e.isFocused ? 'ck-blurred' : 'ck-focused', o)
            })
          }
          function n(o) {
            t.once('change:isRenderingInProgress', (t, i, r) => {
              if (!r) {
                e(o)
              } else {
                n(o)
              }
            })
          }
        }
      }
      class LE extends PE {
        constructor(t, e, n, o = {}) {
          super(t, e, n)
          const i = t.t
          this.extendTemplate({ attributes: { role: 'textbox', class: 'ck-editor__editable_inline' } })
          this._generateLabel = o.label || (() => i('Editor editing area: %0', this.name))
        }
        render() {
          super.render()
          const t = this._editingView
          t.change((e) => {
            const n = t.document.getRoot(this.name)
            e.setAttribute('aria-label', this._generateLabel(this), n)
          })
        }
      }
      var zE = n(1874)
      var RE = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      RE.insert = 'head'
      RE.singleton = true
      var OE = Rl()(zE.Z, RE)
      const VE = zE.Z.locals || {}
      class FE extends (null && View) {
        constructor(t, e = {}) {
          super(t)
          const n = this.bindTemplate
          this.set('label', e.label || '')
          this.set('class', e.class || null)
          this.children = this.createCollection()
          this.setTemplate({
            tag: 'div',
            attributes: { class: ['ck', 'ck-form__header', n.to('class')] },
            children: this.children,
          })
          const o = new View(t)
          o.setTemplate({
            tag: 'h2',
            attributes: { class: ['ck', 'ck-form__header__label'] },
            children: [{ text: n.to('label') }],
          })
          this.children.add(o)
        }
      }
      class jE extends (null && View) {
        constructor(t) {
          super(t)
          const e = this.bindTemplate
          this.setTemplate({
            tag: 'iframe',
            attributes: { class: ['ck', 'ck-reset_all'], sandbox: 'allow-same-origin allow-scripts' },
            on: { load: e.to('loaded') },
          })
        }
        render() {
          return new Promise((t) => {
            this.on('loaded', t)
            return super.render()
          })
        }
      }
      class HE extends Pu {
        static get pluginName() {
          return 'Notification'
        }
        init() {
          this.on(
            'show:warning',
            (t, e) => {
              window.alert(e.message)
            },
            { priority: 'lowest' },
          )
        }
        showSuccess(t, e = {}) {
          this._showNotification({ message: t, type: 'success', namespace: e.namespace, title: e.title })
        }
        showInfo(t, e = {}) {
          this._showNotification({ message: t, type: 'info', namespace: e.namespace, title: e.title })
        }
        showWarning(t, e = {}) {
          this._showNotification({ message: t, type: 'warning', namespace: e.namespace, title: e.title })
        }
        _showNotification(t) {
          const e = t.namespace ? `show:${t.type}:${t.namespace}` : `show:${t.type}`
          this.fire(e, { message: t.message, type: t.type, title: t.title || '' })
        }
      }
      class UE extends ft() {
        constructor(t, e) {
          super()
          if (e) {
            Nm(this, e)
          }
          if (t) {
            this.set(t)
          }
        }
      }
      const WE =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.463 5.187a.888.888 0 1 1 1.254 1.255L9.16 10l3.557 3.557a.888.888 0 1 1-1.254 1.255L7.26 10.61a.888.888 0 0 1 .16-1.382l4.043-4.042z"/></svg>'
      const GE =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8.537 14.813a.888.888 0 1 1-1.254-1.255L10.84 10 7.283 6.442a.888.888 0 1 1 1.254-1.255L12.74 9.39a.888.888 0 0 1-.16 1.382l-4.043 4.042z"/></svg>'
      var qE = n(7592)
      var $E = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      $E.insert = 'head'
      $E.singleton = true
      var KE = Rl()(qE.Z, $E)
      const YE = qE.Z.locals || {}
      var ZE = n(6356)
      var QE = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      QE.insert = 'head'
      QE.singleton = true
      var JE = Rl()(ZE.Z, QE)
      const XE = ZE.Z.locals || {}
      const tD = _c('px')
      class eD extends Du {
        static get pluginName() {
          return 'ContextualBalloon'
        }
        constructor(t) {
          super(t)
          this._viewToStack = new Map()
          this._idToStack = new Map()
          this._view = null
          this._rotatorView = null
          this._fakePanelsView = null
          this.positionLimiter = () => {
            const t = this.editor.editing.view
            const e = t.document
            const n = e.selection.editableElement
            if (n) {
              return t.domConverter.mapViewToDom(n.root)
            }
            return null
          }
          this.set('visibleView', null)
          this.set('_numberOfStacks', 0)
          this.set('_singleViewMode', false)
        }
        destroy() {
          super.destroy()
          if (this._view) {
            this._view.destroy()
          }
          if (this._rotatorView) {
            this._rotatorView.destroy()
          }
          if (this._fakePanelsView) {
            this._fakePanelsView.destroy()
          }
        }
        get view() {
          if (!this._view) {
            this._createPanelView()
          }
          return this._view
        }
        hasView(t) {
          return Array.from(this._viewToStack.keys()).includes(t)
        }
        add(t) {
          if (!this._view) {
            this._createPanelView()
          }
          if (this.hasView(t.view)) {
            throw new P('contextualballoon-add-view-exist', [this, t])
          }
          const e = t.stackId || 'main'
          if (!this._idToStack.has(e)) {
            this._idToStack.set(e, new Map([[t.view, t]]))
            this._viewToStack.set(t.view, this._idToStack.get(e))
            this._numberOfStacks = this._idToStack.size
            if (!this._visibleStack || t.singleViewMode) {
              this.showStack(e)
            }
            return
          }
          const n = this._idToStack.get(e)
          if (t.singleViewMode) {
            this.showStack(e)
          }
          n.set(t.view, t)
          this._viewToStack.set(t.view, n)
          if (n === this._visibleStack) {
            this._showView(t)
          }
        }
        remove(t) {
          if (!this.hasView(t)) {
            throw new P('contextualballoon-remove-view-not-exist', [this, t])
          }
          const e = this._viewToStack.get(t)
          if (this._singleViewMode && this.visibleView === t) {
            this._singleViewMode = false
          }
          if (this.visibleView === t) {
            if (e.size === 1) {
              if (this._idToStack.size > 1) {
                this._showNextStack()
              } else {
                this.view.hide()
                this.visibleView = null
                this._rotatorView.hideView()
              }
            } else {
              this._showView(Array.from(e.values())[e.size - 2])
            }
          }
          if (e.size === 1) {
            this._idToStack.delete(this._getStackId(e))
            this._numberOfStacks = this._idToStack.size
          } else {
            e.delete(t)
          }
          this._viewToStack.delete(t)
        }
        updatePosition(t) {
          if (t) {
            this._visibleStack.get(this.visibleView).position = t
          }
          this.view.pin(this._getBalloonPosition())
          this._fakePanelsView.updatePosition()
        }
        showStack(t) {
          this.visibleStack = t
          const e = this._idToStack.get(t)
          if (!e) {
            throw new P('contextualballoon-showstack-stack-not-exist', this)
          }
          if (this._visibleStack === e) {
            return
          }
          this._showView(Array.from(e.values()).pop())
        }
        _createPanelView() {
          this._view = new Jx(this.editor.locale)
          this.editor.ui.view.body.add(this._view)
          this.editor.ui.focusTracker.add(this._view.element)
          this._rotatorView = this._createRotatorView()
          this._fakePanelsView = this._createFakePanelsView()
        }
        get _visibleStack() {
          return this._viewToStack.get(this.visibleView)
        }
        _getStackId(t) {
          const e = Array.from(this._idToStack.entries()).find((e) => e[1] === t)
          return e[0]
        }
        _showNextStack() {
          const t = Array.from(this._idToStack.values())
          let e = t.indexOf(this._visibleStack) + 1
          if (!t[e]) {
            e = 0
          }
          this.showStack(this._getStackId(t[e]))
        }
        _showPrevStack() {
          const t = Array.from(this._idToStack.values())
          let e = t.indexOf(this._visibleStack) - 1
          if (!t[e]) {
            e = t.length - 1
          }
          this.showStack(this._getStackId(t[e]))
        }
        _createRotatorView() {
          const t = new nD(this.editor.locale)
          const e = this.editor.locale.t
          this.view.content.add(t)
          t.bind('isNavigationVisible').to(this, '_numberOfStacks', this, '_singleViewMode', (t, e) => !e && t > 1)
          t.on('change:isNavigationVisible', () => this.updatePosition(), { priority: 'low' })
          t.bind('counter').to(this, 'visibleView', this, '_numberOfStacks', (t, n) => {
            if (n < 2) {
              return ''
            }
            const o = Array.from(this._idToStack.values()).indexOf(this._visibleStack) + 1
            return e('%0 of %1', [o, n])
          })
          t.buttonNextView.on('execute', () => {
            if (t.focusTracker.isFocused) {
              this.editor.editing.view.focus()
            }
            this._showNextStack()
          })
          t.buttonPrevView.on('execute', () => {
            if (t.focusTracker.isFocused) {
              this.editor.editing.view.focus()
            }
            this._showPrevStack()
          })
          return t
        }
        _createFakePanelsView() {
          const t = new oD(this.editor.locale, this.view)
          t.bind('numberOfPanels').to(this, '_numberOfStacks', this, '_singleViewMode', (t, e) => {
            const n = !e && t >= 2
            return n ? Math.min(t - 1, 2) : 0
          })
          t.listenTo(this.view, 'change:top', () => t.updatePosition())
          t.listenTo(this.view, 'change:left', () => t.updatePosition())
          this.editor.ui.view.body.add(t)
          return t
        }
        _showView({ view: t, balloonClassName: e = '', withArrow: n = true, singleViewMode: o = false }) {
          this.view.class = e
          this.view.withArrow = n
          this._rotatorView.showView(t)
          this.visibleView = t
          this.view.pin(this._getBalloonPosition())
          this._fakePanelsView.updatePosition()
          if (o) {
            this._singleViewMode = true
          }
        }
        _getBalloonPosition() {
          let t = Array.from(this._visibleStack.values()).pop().position
          if (t) {
            if (!t.limiter) {
              t = Object.assign({}, t, { limiter: this.positionLimiter })
            }
            t = Object.assign({}, t, { viewportOffsetConfig: this.editor.ui.viewportOffset })
          }
          return t
        }
      }
      class nD extends Hl {
        constructor(t) {
          super(t)
          const e = t.t
          const n = this.bindTemplate
          this.set('isNavigationVisible', true)
          this.focusTracker = new kl()
          this.buttonPrevView = this._createButtonView(e('Previous'), WE)
          this.buttonNextView = this._createButtonView(e('Next'), GE)
          this.content = this.createCollection()
          this.setTemplate({
            tag: 'div',
            attributes: { class: ['ck', 'ck-balloon-rotator'], 'z-index': '-1' },
            children: [
              {
                tag: 'div',
                attributes: {
                  class: ['ck-balloon-rotator__navigation', n.to('isNavigationVisible', (t) => (t ? '' : 'ck-hidden'))],
                },
                children: [
                  this.buttonPrevView,
                  {
                    tag: 'span',
                    attributes: { class: ['ck-balloon-rotator__counter'] },
                    children: [{ text: n.to('counter') }],
                  },
                  this.buttonNextView,
                ],
              },
              { tag: 'div', attributes: { class: 'ck-balloon-rotator__content' }, children: this.content },
            ],
          })
        }
        render() {
          super.render()
          this.focusTracker.add(this.element)
        }
        destroy() {
          super.destroy()
          this.focusTracker.destroy()
        }
        showView(t) {
          this.hideView()
          this.content.add(t)
        }
        hideView() {
          this.content.clear()
        }
        _createButtonView(t, e) {
          const n = new Dd(this.locale)
          n.set({ label: t, icon: e, tooltip: true })
          return n
        }
      }
      class oD extends Hl {
        constructor(t, e) {
          super(t)
          const n = this.bindTemplate
          this.set('top', 0)
          this.set('left', 0)
          this.set('height', 0)
          this.set('width', 0)
          this.set('numberOfPanels', 0)
          this.content = this.createCollection()
          this._balloonPanelView = e
          this.setTemplate({
            tag: 'div',
            attributes: {
              class: ['ck-fake-panel', n.to('numberOfPanels', (t) => (t ? '' : 'ck-hidden'))],
              style: {
                top: n.to('top', tD),
                left: n.to('left', tD),
                width: n.to('width', tD),
                height: n.to('height', tD),
              },
            },
            children: this.content,
          })
          this.on('change:numberOfPanels', (t, e, n, o) => {
            if (n > o) {
              this._addPanels(n - o)
            } else {
              this._removePanels(o - n)
            }
            this.updatePosition()
          })
        }
        _addPanels(t) {
          while (t--) {
            const t = new Hl()
            t.setTemplate({ tag: 'div' })
            this.content.add(t)
            this.registerChild(t)
          }
        }
        _removePanels(t) {
          while (t--) {
            const t = this.content.last
            this.content.remove(t)
            this.deregisterChild(t)
            t.destroy()
          }
        }
        updatePosition() {
          if (this.numberOfPanels) {
            const { top: t, left: e } = this._balloonPanelView
            const { width: n, height: o } = new dc(this._balloonPanelView.element)
            Object.assign(this, { top: t, left: e, width: n, height: o })
          }
        }
      }
      var iD = n(3707)
      var rD = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      rD.insert = 'head'
      rD.singleton = true
      var sD = Rl()(iD.Z, rD)
      const aD = iD.Z.locals || {}
      const cD = _c('px')
      class lD extends Hl {
        constructor(t) {
          super(t)
          const e = this.bindTemplate
          this.set('isActive', false)
          this.set('isSticky', false)
          this.set('limiterElement', null)
          this.set('limiterBottomOffset', 50)
          this.set('viewportTopOffset', 0)
          this.set('_marginLeft', null)
          this.set('_isStickyToTheBottomOfLimiter', false)
          this.set('_stickyTopOffset', null)
          this.set('_stickyBottomOffset', null)
          this.content = this.createCollection()
          this._contentPanelPlaceholder = new Wl({
            tag: 'div',
            attributes: {
              class: ['ck', 'ck-sticky-panel__placeholder'],
              style: {
                display: e.to('isSticky', (t) => (t ? 'block' : 'none')),
                height: e.to('isSticky', (t) => (t ? cD(this._contentPanelRect.height) : null)),
              },
            },
          }).render()
          this._contentPanel = new Wl({
            tag: 'div',
            attributes: {
              class: [
                'ck',
                'ck-sticky-panel__content',
                e.if('isSticky', 'ck-sticky-panel__content_sticky'),
                e.if('_isStickyToTheBottomOfLimiter', 'ck-sticky-panel__content_sticky_bottom-limit'),
              ],
              style: {
                width: e.to('isSticky', (t) =>
                  t ? cD(this._contentPanelPlaceholder.getBoundingClientRect().width) : null,
                ),
                top: e.to('_stickyTopOffset', (t) => (t ? cD(t) : t)),
                bottom: e.to('_stickyBottomOffset', (t) => (t ? cD(t) : t)),
                marginLeft: e.to('_marginLeft'),
              },
            },
            children: this.content,
          }).render()
          this.setTemplate({
            tag: 'div',
            attributes: { class: ['ck', 'ck-sticky-panel'] },
            children: [this._contentPanelPlaceholder, this._contentPanel],
          })
        }
        render() {
          super.render()
          this.checkIfShouldBeSticky()
          this.listenTo(
            oc.document,
            'scroll',
            (t, e) => {
              this.checkIfShouldBeSticky(e.target)
            },
            { useCapture: true },
          )
          this.listenTo(this, 'change:isActive', () => {
            this.checkIfShouldBeSticky()
          })
        }
        checkIfShouldBeSticky(t) {
          if (!this.limiterElement || !this.isActive) {
            this._unstick()
            return
          }
          const e = bc(this.limiterElement)
          if (t && !e.includes(t)) {
            return
          }
          const n = pc(e, this.viewportTopOffset)
          const o = new dc(this.limiterElement)
          if (n && o.top < n.top) {
            const t = o.getIntersection(n)
            if (t) {
              const e = n.top
              if (e + this._contentPanelRect.height + this.limiterBottomOffset > t.bottom) {
                const t = Math.max(o.bottom - n.bottom, 0) + this.limiterBottomOffset
                if (o.bottom - t > o.top + this._contentPanelRect.height) {
                  this._stickToBottomOfLimiter(t)
                } else {
                  this._unstick()
                }
              } else {
                if (this._contentPanelRect.height + this.limiterBottomOffset < o.height) {
                  this._stickToTopOfAncestors(e)
                } else {
                  this._unstick()
                }
              }
            } else {
              this._unstick()
            }
          } else {
            this._unstick()
          }
        }
        _stickToTopOfAncestors(t) {
          this.isSticky = true
          this._isStickyToTheBottomOfLimiter = false
          this._stickyTopOffset = t
          this._stickyBottomOffset = null
          this._marginLeft = cD(-oc.window.scrollX)
        }
        _stickToBottomOfLimiter(t) {
          this.isSticky = true
          this._isStickyToTheBottomOfLimiter = true
          this._stickyTopOffset = null
          this._stickyBottomOffset = t
          this._marginLeft = cD(-oc.window.scrollX)
        }
        _unstick() {
          this.isSticky = false
          this._isStickyToTheBottomOfLimiter = false
          this._stickyTopOffset = null
          this._stickyBottomOffset = null
          this._marginLeft = null
        }
        get _contentPanelRect() {
          return new dc(this._contentPanel)
        }
      }
      const dD = _c('px')
      class uD extends (null && Plugin) {
        static get pluginName() {
          return 'BalloonToolbar'
        }
        static get requires() {
          return [ContextualBalloon]
        }
        constructor(t) {
          super(t)
          this._resizeObserver = null
          this._balloonConfig = normalizeToolbarConfig(t.config.get('balloonToolbar'))
          this.toolbarView = this._createToolbarView()
          this.focusTracker = new FocusTracker()
          t.ui.once('ready', () => {
            this.focusTracker.add(t.ui.getEditableElement())
            this.focusTracker.add(this.toolbarView.element)
          })
          t.ui.addToolbar(this.toolbarView, {
            beforeFocus: () => this.show(true),
            afterBlur: () => this.hide(),
            isContextual: true,
          })
          this._balloon = t.plugins.get(ContextualBalloon)
          this._fireSelectionChangeDebounced = debounce(() => this.fire('_selectionChangeDebounced'), 200)
          this.decorate('show')
        }
        init() {
          const t = this.editor
          const e = t.model.document.selection
          this.listenTo(this.focusTracker, 'change:isFocused', (t, e, n) => {
            const o = this._balloon.visibleView === this.toolbarView
            if (!n && o) {
              this.hide()
            } else if (n) {
              this.show()
            }
          })
          this.listenTo(e, 'change:range', (t, n) => {
            if (n.directChange || e.isCollapsed) {
              this.hide()
            }
            this._fireSelectionChangeDebounced()
          })
          this.listenTo(this, '_selectionChangeDebounced', () => {
            if (this.editor.editing.view.document.isFocused) {
              this.show()
            }
          })
          if (!this._balloonConfig.shouldNotGroupWhenFull) {
            this.listenTo(t, 'ready', () => {
              const e = t.ui.view.editable.element
              this._resizeObserver = new ResizeObserver(e, (t) => {
                this.toolbarView.maxWidth = dD(t.contentRect.width * 0.9)
              })
            })
          }
          this.listenTo(this.toolbarView, 'groupedItemsUpdate', () => {
            this._updatePosition()
          })
        }
        afterInit() {
          const t = this.editor.ui.componentFactory
          this.toolbarView.fillFromConfig(this._balloonConfig, t)
        }
        _createToolbarView() {
          const t = this.editor.locale.t
          const e = !this._balloonConfig.shouldNotGroupWhenFull
          const n = new ToolbarView(this.editor.locale, { shouldGroupWhenFull: e, isFloating: true })
          n.ariaLabel = t('Editor contextual toolbar')
          n.render()
          return n
        }
        show(t = false) {
          const e = this.editor
          const n = e.model.document.selection
          const o = e.model.schema
          if (this._balloon.hasView(this.toolbarView)) {
            return
          }
          if (n.isCollapsed && !t) {
            return
          }
          if (hD(n, o)) {
            return
          }
          if (Array.from(this.toolbarView.items).every((t) => t.isEnabled !== undefined && !t.isEnabled)) {
            return
          }
          this.listenTo(this.editor.ui, 'update', () => {
            this._updatePosition()
          })
          this._balloon.add({
            view: this.toolbarView,
            position: this._getBalloonPositionData(),
            balloonClassName: 'ck-toolbar-container',
          })
        }
        hide() {
          if (this._balloon.hasView(this.toolbarView)) {
            this.stopListening(this.editor.ui, 'update')
            this._balloon.remove(this.toolbarView)
          }
        }
        _getBalloonPositionData() {
          const t = this.editor
          const e = t.editing.view
          const n = e.document
          const o = n.selection
          const i = n.selection.isBackward
          return {
            target: () => {
              const t = i ? o.getFirstRange() : o.getLastRange()
              const n = Rect.getDomRangeRects(e.domConverter.viewRangeToDom(t))
              if (i) {
                return n[0]
              } else {
                if (n.length > 1 && n[n.length - 1].width === 0) {
                  n.pop()
                }
                return n[n.length - 1]
              }
            },
            positions: this._getBalloonPositions(i),
          }
        }
        _updatePosition() {
          this._balloon.updatePosition(this._getBalloonPositionData())
        }
        destroy() {
          super.destroy()
          this.stopListening()
          this._fireSelectionChangeDebounced.cancel()
          this.toolbarView.destroy()
          this.focusTracker.destroy()
          if (this._resizeObserver) {
            this._resizeObserver.destroy()
          }
        }
        _getBalloonPositions(t) {
          const e = env.isSafari && env.isiOS
          const n = e
            ? generatePositions({
                heightOffset: Math.max(
                  BalloonPanelView.arrowHeightOffset,
                  Math.round(20 / global.window.visualViewport.scale),
                ),
              })
            : BalloonPanelView.defaultPositions
          return t
            ? [
                n.northWestArrowSouth,
                n.northWestArrowSouthWest,
                n.northWestArrowSouthEast,
                n.northWestArrowSouthMiddleEast,
                n.northWestArrowSouthMiddleWest,
                n.southWestArrowNorth,
                n.southWestArrowNorthWest,
                n.southWestArrowNorthEast,
                n.southWestArrowNorthMiddleWest,
                n.southWestArrowNorthMiddleEast,
              ]
            : [
                n.southEastArrowNorth,
                n.southEastArrowNorthEast,
                n.southEastArrowNorthWest,
                n.southEastArrowNorthMiddleEast,
                n.southEastArrowNorthMiddleWest,
                n.northEastArrowSouth,
                n.northEastArrowSouthEast,
                n.northEastArrowSouthWest,
                n.northEastArrowSouthMiddleEast,
                n.northEastArrowSouthMiddleWest,
              ]
        }
      }
      function hD(t, e) {
        if (t.rangeCount === 1) {
          return false
        }
        return [...t.getRanges()].every((t) => {
          const n = t.getContainedElement()
          return n && e.isSelectable(n)
        })
      }
      var gD = n(4176)
      var fD = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      fD.insert = 'head'
      fD.singleton = true
      var mD = Rl()(gD.Z, fD)
      const pD = gD.Z.locals || {}
      const bD = _c('px')
      class kD extends (null && ButtonView) {
        constructor(t) {
          super(t)
          const e = this.bindTemplate
          this.isVisible = false
          this.isToggleable = true
          this.set('top', 0)
          this.set('left', 0)
          this.extendTemplate({
            attributes: {
              class: 'ck-block-toolbar-button',
              style: { top: e.to('top', (t) => bD(t)), left: e.to('left', (t) => bD(t)) },
            },
          })
        }
      }
      const wD = _c('px')
      const { pilcrow: AD } = Sv
      class _D extends (null && Plugin) {
        static get pluginName() {
          return 'BlockToolbar'
        }
        constructor(t) {
          super(t)
          this._resizeObserver = null
          this._blockToolbarConfig = normalizeToolbarConfig(this.editor.config.get('blockToolbar'))
          this.toolbarView = this._createToolbarView()
          this.panelView = this._createPanelView()
          this.buttonView = this._createButtonView()
          clickOutsideHandler({
            emitter: this.panelView,
            contextElements: [this.panelView.element, this.buttonView.element],
            activator: () => this.panelView.isVisible,
            callback: () => this._hidePanel(),
          })
        }
        init() {
          const t = this.editor
          this.listenTo(t.model.document.selection, 'change:range', (t, e) => {
            if (e.directChange) {
              this._hidePanel()
            }
          })
          this.listenTo(t.ui, 'update', () => this._updateButton())
          this.listenTo(t, 'change:isReadOnly', () => this._updateButton(), { priority: 'low' })
          this.listenTo(t.ui.focusTracker, 'change:isFocused', () => this._updateButton())
          this.listenTo(this.buttonView, 'change:isVisible', (t, e, n) => {
            if (n) {
              this.buttonView.listenTo(window, 'resize', () => this._updateButton())
            } else {
              this.buttonView.stopListening(window, 'resize')
              this._hidePanel()
            }
          })
          t.ui.addToolbar(this.toolbarView, {
            beforeFocus: () => this._showPanel(),
            afterBlur: () => this._hidePanel(),
          })
        }
        afterInit() {
          this.toolbarView.fillFromConfig(this._blockToolbarConfig, this.editor.ui.componentFactory)
          for (const t of this.toolbarView.items) {
            t.on('execute', () => this._hidePanel(true), { priority: 'high' })
          }
        }
        destroy() {
          super.destroy()
          this.panelView.destroy()
          this.buttonView.destroy()
          this.toolbarView.destroy()
          if (this._resizeObserver) {
            this._resizeObserver.destroy()
          }
        }
        _createToolbarView() {
          const t = this.editor.locale.t
          const e = !this._blockToolbarConfig.shouldNotGroupWhenFull
          const n = new ToolbarView(this.editor.locale, { shouldGroupWhenFull: e, isFloating: true })
          n.ariaLabel = t('Editor block content toolbar')
          return n
        }
        _createPanelView() {
          const t = this.editor
          const e = new BalloonPanelView(t.locale)
          e.content.add(this.toolbarView)
          e.class = 'ck-toolbar-container'
          t.ui.view.body.add(e)
          t.ui.focusTracker.add(e.element)
          this.toolbarView.keystrokes.set('Esc', (t, e) => {
            this._hidePanel(true)
            e()
          })
          return e
        }
        _createButtonView() {
          const t = this.editor
          const e = t.t
          const n = new BlockButtonView(t.locale)
          n.set({ label: e('Edit block'), icon: AD, withText: false })
          n.bind('isOn').to(this.panelView, 'isVisible')
          n.bind('tooltip').to(this.panelView, 'isVisible', (t) => !t)
          this.listenTo(n, 'execute', () => {
            if (!this.panelView.isVisible) {
              this._showPanel()
            } else {
              this._hidePanel(true)
            }
          })
          t.ui.view.body.add(n)
          t.ui.focusTracker.add(n.element)
          return n
        }
        _updateButton() {
          const t = this.editor
          const e = t.model
          const n = t.editing.view
          if (!t.ui.focusTracker.isFocused) {
            this._hideButton()
            return
          }
          if (!t.model.canEditAt(t.model.document.selection)) {
            this._hideButton()
            return
          }
          const o = Array.from(e.document.selection.getSelectedBlocks())[0]
          if (!o || Array.from(this.toolbarView.items).every((t) => !t.isEnabled)) {
            this._hideButton()
            return
          }
          const i = n.domConverter.mapViewToDom(t.editing.mapper.toViewElement(o))
          this.buttonView.isVisible = true
          this._setupToolbarResize()
          this._attachButtonToElement(i)
          if (this.panelView.isVisible) {
            this._showPanel()
          }
        }
        _hideButton() {
          this.buttonView.isVisible = false
        }
        _showPanel() {
          if (!this.buttonView.isVisible) {
            return
          }
          const t = this.panelView.isVisible
          this.panelView.show()
          const e = this._getSelectedEditableElement()
          this.toolbarView.maxWidth = this._getToolbarMaxWidth(e)
          this.panelView.pin({ target: this.buttonView.element, limiter: e })
          if (!t) {
            this.toolbarView.items.get(0).focus()
          }
        }
        _getSelectedEditableElement() {
          const t = this.editor.model.document.selection.getFirstRange().root.rootName
          return this.editor.ui.getEditableElement(t)
        }
        _hidePanel(t) {
          this.panelView.isVisible = false
          if (t) {
            this.editor.editing.view.focus()
          }
        }
        _attachButtonToElement(t) {
          const e = window.getComputedStyle(t)
          const n = new Rect(this._getSelectedEditableElement())
          const o = parseInt(e.paddingTop, 10)
          const i = parseInt(e.lineHeight, 10) || parseInt(e.fontSize, 10) * 1.2
          const r = getOptimalPosition({
            element: this.buttonView.element,
            target: t,
            positions: [
              (t, e) => {
                let r
                if (this.editor.locale.uiLanguageDirection === 'ltr') {
                  r = n.left - e.width
                } else {
                  r = n.right
                }
                return { top: t.top + o + (i - e.height) / 2, left: r }
              },
            ],
          })
          this.buttonView.top = r.top
          this.buttonView.left = r.left
        }
        _setupToolbarResize() {
          const t = this._getSelectedEditableElement()
          if (!this._blockToolbarConfig.shouldNotGroupWhenFull) {
            if (this._resizeObserver && this._resizeObserver.element !== t) {
              this._resizeObserver.destroy()
              this._resizeObserver = null
            }
            if (!this._resizeObserver) {
              this._resizeObserver = new ResizeObserver(t, () => {
                this.toolbarView.maxWidth = this._getToolbarMaxWidth(t)
              })
            }
          }
        }
        _getToolbarMaxWidth(t) {
          const e = new Rect(t)
          const n = new Rect(this.buttonView.element)
          const o = this.editor.locale.uiLanguageDirection === 'rtl'
          const i = o ? n.left - e.right + n.width : e.left - n.left
          return wD(e.width + i)
        }
      }
      const CD =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.209 18.717A8.5 8.5 0 1 1 18.686 9.6h-.008l.002.12a3 3 0 0 1-2.866 2.997h-.268l-.046-.002v.002h-4.791a2 2 0 1 0 0 4 1 1 0 1 1-.128 1.992 8.665 8.665 0 0 1-.372.008Zm-3.918-7.01a1.25 1.25 0 1 0-2.415-.648 1.25 1.25 0 0 0 2.415.647ZM5.723 8.18a1.25 1.25 0 1 0 .647-2.414 1.25 1.25 0 0 0-.647 2.414ZM9.76 6.155a1.25 1.25 0 1 0 .647-2.415 1.25 1.25 0 0 0-.647 2.415Zm4.028 1.759a1.25 1.25 0 1 0 .647-2.415 1.25 1.25 0 0 0-.647 2.415Z"/></svg>'
      const vD = { colorPaletteIcon: CD }
      class yD extends EE {
        constructor(t, e) {
          super(t)
          this.view = e
          this._toolbarConfig = Eu(t.config.get('toolbar'))
          this._elementReplacer = new xt()
          this.listenTo(
            t.editing.view,
            'scrollToTheSelection',
            this._handleScrollToTheSelectionWithStickyPanel.bind(this),
          )
        }
        get element() {
          return this.view.element
        }
        init(t) {
          const e = this.editor
          const n = this.view
          const o = e.editing.view
          const i = n.editable
          const r = o.document.getRoot()
          i.name = r.rootName
          n.render()
          const s = i.element
          this.setEditableElement(i.name, s)
          n.editable.bind('isFocused').to(this.focusTracker)
          o.attachDomRoot(s)
          if (t) {
            this._elementReplacer.replace(t, this.element)
          }
          this._initPlaceholder()
          this._initToolbar()
          this.fire('ready')
        }
        destroy() {
          super.destroy()
          const t = this.view
          const e = this.editor.editing.view
          this._elementReplacer.restore()
          e.detachDomRoot(t.editable.name)
          t.destroy()
        }
        _initToolbar() {
          const t = this.view
          t.stickyPanel.bind('isActive').to(this.focusTracker, 'isFocused')
          t.stickyPanel.limiterElement = t.element
          t.stickyPanel.bind('viewportTopOffset').to(this, 'viewportOffset', ({ top: t }) => t || 0)
          t.toolbar.fillFromConfig(this._toolbarConfig, this.componentFactory)
          this.addToolbar(t.toolbar)
        }
        _initPlaceholder() {
          const t = this.editor
          const e = t.editing.view
          const n = e.document.getRoot()
          const o = t.sourceElement
          let i
          const r = t.config.get('placeholder')
          if (r) {
            i = typeof r === 'string' ? r : r[this.view.editable.name]
          }
          if (!i && o && o.tagName.toLowerCase() === 'textarea') {
            i = o.getAttribute('placeholder')
          }
          if (i) {
            n.placeholder = i
          }
          Fu({ view: e, element: n, isDirectHost: false, keepOnFocus: true })
        }
        _handleScrollToTheSelectionWithStickyPanel(t, e, n) {
          const o = this.view.stickyPanel
          if (o.isSticky) {
            const t = new dc(o.element).height
            e.viewportOffset.top += t
          } else {
            const t = () => {
              this.editor.editing.view.scrollToTheSelection(n)
            }
            this.listenTo(o, 'change:isSticky', t)
            setTimeout(() => {
              this.stopListening(o, 'change:isSticky', t)
            }, 20)
          }
        }
      }
      var xD = n(3624)
      var ED = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      ED.insert = 'head'
      ED.singleton = true
      var DD = Rl()(xD.Z, ED)
      const TD = xD.Z.locals || {}
      class ID extends NE {
        constructor(t, e, n = {}) {
          super(t)
          this.stickyPanel = new lD(t)
          this.toolbar = new Rv(t, { shouldGroupWhenFull: n.shouldToolbarGroupWhenFull })
          this.editable = new LE(t, e)
        }
        render() {
          super.render()
          this.stickyPanel.content.add(this.toolbar)
          this.top.add(this.stickyPanel)
          this.main.add(this.editable)
        }
      }
      class SD {
        constructor(t) {
          this.crashes = []
          this.state = 'initializing'
          this._now = Date.now
          this.crashes = []
          this._crashNumberLimit = typeof t.crashNumberLimit === 'number' ? t.crashNumberLimit : 3
          this._minimumNonErrorTimePeriod =
            typeof t.minimumNonErrorTimePeriod === 'number' ? t.minimumNonErrorTimePeriod : 5e3
          this._boundErrorHandler = (t) => {
            const e = 'error' in t ? t.error : t.reason
            if (e instanceof Error) {
              this._handleError(e, t)
            }
          }
          this._listeners = {}
          if (!this._restart) {
            throw new Error(
              'The Watchdog class was split into the abstract `Watchdog` class and the `EditorWatchdog` class. ' +
                'Please, use `EditorWatchdog` if you have used the `Watchdog` class previously.',
            )
          }
        }
        destroy() {
          this._stopErrorHandling()
          this._listeners = {}
        }
        on(t, e) {
          if (!this._listeners[t]) {
            this._listeners[t] = []
          }
          this._listeners[t].push(e)
        }
        off(t, e) {
          this._listeners[t] = this._listeners[t].filter((t) => t !== e)
        }
        _fire(t, ...e) {
          const n = this._listeners[t] || []
          for (const t of n) {
            t.apply(this, [null, ...e])
          }
        }
        _startErrorHandling() {
          window.addEventListener('error', this._boundErrorHandler)
          window.addEventListener('unhandledrejection', this._boundErrorHandler)
        }
        _stopErrorHandling() {
          window.removeEventListener('error', this._boundErrorHandler)
          window.removeEventListener('unhandledrejection', this._boundErrorHandler)
        }
        _handleError(t, e) {
          if (this._shouldReactToError(t)) {
            this.crashes.push({
              message: t.message,
              stack: t.stack,
              filename: e instanceof ErrorEvent ? e.filename : undefined,
              lineno: e instanceof ErrorEvent ? e.lineno : undefined,
              colno: e instanceof ErrorEvent ? e.colno : undefined,
              date: this._now(),
            })
            const n = this._shouldRestart()
            this.state = 'crashed'
            this._fire('stateChange')
            this._fire('error', { error: t, causesRestart: n })
            if (n) {
              this._restart()
            } else {
              this.state = 'crashedPermanently'
              this._fire('stateChange')
            }
          }
        }
        _shouldReactToError(t) {
          return (
            t.is &&
            t.is('CKEditorError') &&
            t.context !== undefined &&
            t.context !== null &&
            this.state === 'ready' &&
            this._isErrorComingFromThisItem(t)
          )
        }
        _shouldRestart() {
          if (this.crashes.length <= this._crashNumberLimit) {
            return true
          }
          const t = this.crashes[this.crashes.length - 1].date
          const e = this.crashes[this.crashes.length - 1 - this._crashNumberLimit].date
          const n = (t - e) / this._crashNumberLimit
          return n > this._minimumNonErrorTimePeriod
        }
      }
      function MD(t, e = new Set()) {
        const n = [t]
        const o = new Set()
        let i = 0
        while (n.length > i) {
          const t = n[i++]
          if (o.has(t) || !BD(t) || e.has(t)) {
            continue
          }
          o.add(t)
          if (Symbol.iterator in t) {
            try {
              for (const e of t) {
                n.push(e)
              }
            } catch (t) {}
          } else {
            for (const e in t) {
              if (e === 'defaultValue') {
                continue
              }
              n.push(t[e])
            }
          }
        }
        return o
      }
      function BD(t) {
        const e = Object.prototype.toString.call(t)
        const n = typeof t
        return !(
          n === 'number' ||
          n === 'boolean' ||
          n === 'string' ||
          n === 'symbol' ||
          n === 'function' ||
          e === '[object Date]' ||
          e === '[object RegExp]' ||
          e === '[object Module]' ||
          t === undefined ||
          t === null ||
          t._watchdogExcluded ||
          t instanceof EventTarget ||
          t instanceof Event
        )
      }
      function ND(t, e, n = new Set()) {
        if (t === e && LD(t)) {
          return true
        }
        const o = MD(t, n)
        const i = MD(e, n)
        for (const t of o) {
          if (i.has(t)) {
            return true
          }
        }
        return false
      }
      function PD(t, e, n) {
        const { subNodes: o, prevNodeMap: i } = getSubNodes(t, n.subNodes)
        const { subNodes: r, prevNodeMap: s } = getSubNodes(e, n.subNodes)
        for (const n of o) {
          if (r.has(n)) {
            const o = []
            o.push(n)
            let r = i.get(n)
            while (r && r !== t) {
              o.push(r)
              r = i.get(r)
            }
            r = s.get(n)
            while (r && r !== e) {
              o.unshift(r)
              r = s.get(r)
            }
            console.log('--------')
            console.log({ target1: t })
            console.log({ sharedNode: n })
            console.log({ target2: e })
            console.log({ connection: o })
            return true
          }
        }
        return false
      }
      function LD(t) {
        return typeof t === 'object' && t !== null
      }
      class zD extends SD {
        constructor(t, e = {}) {
          super(e)
          this._editor = null
          this._initUsingData = true
          this._editables = {}
          this._throttledSave = uE(this._save.bind(this), typeof e.saveInterval === 'number' ? e.saveInterval : 5e3)
          if (t) {
            this._creator = (e, n) => t.create(e, n)
          }
          this._destructor = (t) => t.destroy()
        }
        get editor() {
          return this._editor
        }
        get _item() {
          return this._editor
        }
        setCreator(t) {
          this._creator = t
        }
        setDestructor(t) {
          this._destructor = t
        }
        _restart() {
          return Promise.resolve()
            .then(() => {
              this.state = 'initializing'
              this._fire('stateChange')
              return this._destroy()
            })
            .catch((t) => {
              console.error('An error happened during the editor destroying.', t)
            })
            .then(() => {
              const t = {}
              const e = []
              const n = this._config.rootsAttributes || {}
              const o = {}
              for (const [i, r] of Object.entries(this._data.roots)) {
                if (r.isLoaded) {
                  t[i] = ''
                  o[i] = n[i] || {}
                } else {
                  e.push(i)
                }
              }
              const i = {
                ...this._config,
                extraPlugins: this._config.extraPlugins || [],
                lazyRoots: e,
                rootsAttributes: o,
                _watchdogInitialData: this._data,
              }
              delete i.initialData
              i.extraPlugins.push(RD)
              if (this._initUsingData) {
                return this.create(t, i, i.context)
              } else {
                if (Ga(this._elementOrData)) {
                  return this.create(this._elementOrData, i, i.context)
                } else {
                  return this.create(this._editables, i, i.context)
                }
              }
            })
            .then(() => {
              this._fire('restart')
            })
        }
        create(t = this._elementOrData, e = this._config, n) {
          return Promise.resolve()
            .then(() => {
              super._startErrorHandling()
              this._elementOrData = t
              this._initUsingData =
                typeof t == 'string' || (Object.keys(t).length > 0 && typeof Object.values(t)[0] == 'string')
              this._config = this._cloneEditorConfiguration(e) || {}
              this._config.context = n
              return this._creator(t, this._config)
            })
            .then((t) => {
              this._editor = t
              t.model.document.on('change:data', this._throttledSave)
              this._lastDocumentVersion = t.model.document.version
              this._data = this._getData()
              if (!this._initUsingData) {
                this._editables = this._getEditables()
              }
              this.state = 'ready'
              this._fire('stateChange')
            })
        }
        destroy() {
          return Promise.resolve().then(() => {
            this.state = 'destroyed'
            this._fire('stateChange')
            super.destroy()
            return this._destroy()
          })
        }
        _destroy() {
          return Promise.resolve().then(() => {
            this._stopErrorHandling()
            this._throttledSave.cancel()
            const t = this._editor
            this._editor = null
            t.model.document.off('change:data', this._throttledSave)
            return this._destructor(t)
          })
        }
        _save() {
          const t = this._editor.model.document.version
          try {
            this._data = this._getData()
            if (!this._initUsingData) {
              this._editables = this._getEditables()
            }
            this._lastDocumentVersion = t
          } catch (t) {
            console.error(
              t,
              'An error happened during restoring editor data. ' +
                'Editor will be restored from the previously saved data.',
            )
          }
        }
        _setExcludedProperties(t) {
          this._excludedProps = t
        }
        _getData() {
          const t = this._editor
          const e = t.model.document.roots.filter((t) => t.isAttached() && t.rootName != '$graveyard')
          const { plugins: n } = t
          const o = n.has('CommentsRepository') && n.get('CommentsRepository')
          const i = n.has('TrackChanges') && n.get('TrackChanges')
          const r = { roots: {}, markers: {}, commentThreads: JSON.stringify([]), suggestions: JSON.stringify([]) }
          e.forEach((t) => {
            r.roots[t.rootName] = {
              content: JSON.stringify(Array.from(t.getChildren())),
              attributes: JSON.stringify(Array.from(t.getAttributes())),
              isLoaded: t._isLoaded,
            }
          })
          for (const e of t.model.markers) {
            if (!e._affectsData) {
              continue
            }
            r.markers[e.name] = {
              rangeJSON: e.getRange().toJSON(),
              usingOperation: e._managedUsingOperations,
              affectsData: e._affectsData,
            }
          }
          if (o) {
            r.commentThreads = JSON.stringify(o.getCommentThreads({ toJSON: true, skipNotAttached: true }))
          }
          if (i) {
            r.suggestions = JSON.stringify(i.getSuggestions({ toJSON: true, skipNotAttached: true }))
          }
          return r
        }
        _getEditables() {
          const t = {}
          for (const e of this.editor.model.document.getRootNames()) {
            const n = this.editor.ui.getEditableElement(e)
            if (n) {
              t[e] = n
            }
          }
          return t
        }
        _isErrorComingFromThisItem(t) {
          return ND(this._editor, t.context, this._excludedProps)
        }
        _cloneEditorConfiguration(t) {
          return Ua(t, (t, e) => {
            if (Ga(t)) {
              return t
            }
            if (e === 'context') {
              return t
            }
          })
        }
      }
      class RD {
        constructor(t) {
          this.editor = t
          this._data = t.config.get('_watchdogInitialData')
        }
        init() {
          this.editor.data.on(
            'init',
            (t) => {
              t.stop()
              this.editor.model.enqueueChange({ isUndoable: false }, (t) => {
                this._restoreCollaborationData()
                this._restoreEditorData(t)
              })
              this.editor.data.fire('ready')
            },
            { priority: 1e3 - 1 },
          )
        }
        _createNode(t, e) {
          if ('name' in e) {
            const n = t.createElement(e.name, e.attributes)
            if (e.children) {
              for (const o of e.children) {
                n._appendChild(this._createNode(t, o))
              }
            }
            return n
          } else {
            return t.createText(e.data, e.attributes)
          }
        }
        _restoreEditorData(t) {
          const e = this.editor
          Object.entries(this._data.roots).forEach(([n, { content: o, attributes: i }]) => {
            const r = JSON.parse(o)
            const s = JSON.parse(i)
            const a = e.model.document.getRoot(n)
            for (const [e, n] of s) {
              t.setAttribute(e, n, a)
            }
            for (const e of r) {
              const n = this._createNode(t, e)
              t.insert(n, a, 'end')
            }
          })
          Object.entries(this._data.markers).forEach(([n, o]) => {
            const { document: i } = e.model
            const {
              rangeJSON: { start: r, end: s },
              ...a
            } = o
            const c = i.getRoot(r.root)
            const l = t.createPositionFromPath(c, r.path, r.stickiness)
            const d = t.createPositionFromPath(c, s.path, s.stickiness)
            const u = t.createRange(l, d)
            t.addMarker(n, { range: u, ...a })
          })
        }
        _restoreCollaborationData() {
          const t = JSON.parse(this._data.commentThreads)
          const e = JSON.parse(this._data.suggestions)
          t.forEach((t) => {
            const e = this.editor.config.get('collaboration.channelId')
            const n = this.editor.plugins.get('CommentsRepository')
            if (n.hasCommentThread(t.threadId)) {
              const e = n.getCommentThread(t.threadId)
              e.remove()
            }
            n.addCommentThread({ channelId: e, ...t })
          })
          e.forEach((t) => {
            const e = this.editor.plugins.get('TrackChangesEditing')
            if (e.hasSuggestion(t.id)) {
              const n = e.getSuggestion(t.id)
              n.attributes = t.attributes
            } else {
              e.addSuggestionData(t)
            }
          })
        }
      }
      const OD = Symbol('MainQueueId')
      class VD extends SD {
        constructor(t, e = {}) {
          super(e)
          this._watchdogs = new Map()
          this._context = null
          this._contextProps = new Set()
          this._actionQueues = new FD()
          this._watchdogConfig = e
          this._creator = (e) => t.create(e)
          this._destructor = (t) => t.destroy()
          this._actionQueues.onEmpty(() => {
            if (this.state === 'initializing') {
              this.state = 'ready'
              this._fire('stateChange')
            }
          })
        }
        setCreator(t) {
          this._creator = t
        }
        setDestructor(t) {
          this._destructor = t
        }
        get context() {
          return this._context
        }
        create(t = {}) {
          return this._actionQueues.enqueue(OD, () => {
            this._contextConfig = t
            return this._create()
          })
        }
        getItem(t) {
          const e = this._getWatchdog(t)
          return e._item
        }
        getItemState(t) {
          const e = this._getWatchdog(t)
          return e.state
        }
        add(t) {
          const e = jD(t)
          return Promise.all(
            e.map((t) =>
              this._actionQueues.enqueue(t.id, () => {
                if (this.state === 'destroyed') {
                  throw new Error('Cannot add items to destroyed watchdog.')
                }
                if (!this._context) {
                  throw new Error(
                    'Context was not created yet. You should call the `ContextWatchdog#create()` method first.',
                  )
                }
                let e
                if (this._watchdogs.has(t.id)) {
                  throw new Error(`Item with the given id is already added: '${t.id}'.`)
                }
                if (t.type === 'editor') {
                  e = new zD(null, this._watchdogConfig)
                  e.setCreator(t.creator)
                  e._setExcludedProperties(this._contextProps)
                  if (t.destructor) {
                    e.setDestructor(t.destructor)
                  }
                  this._watchdogs.set(t.id, e)
                  e.on('error', (n, { error: o, causesRestart: i }) => {
                    this._fire('itemError', { itemId: t.id, error: o })
                    if (!i) {
                      return
                    }
                    this._actionQueues.enqueue(
                      t.id,
                      () =>
                        new Promise((n) => {
                          const o = () => {
                            e.off('restart', o)
                            this._fire('itemRestart', { itemId: t.id })
                            n()
                          }
                          e.on('restart', o)
                        }),
                    )
                  })
                  return e.create(t.sourceElementOrData, t.config, this._context)
                } else {
                  throw new Error(`Not supported item type: '${t.type}'.`)
                }
              }),
            ),
          )
        }
        remove(t) {
          const e = jD(t)
          return Promise.all(
            e.map((t) =>
              this._actionQueues.enqueue(t, () => {
                const e = this._getWatchdog(t)
                this._watchdogs.delete(t)
                return e.destroy()
              }),
            ),
          )
        }
        destroy() {
          return this._actionQueues.enqueue(OD, () => {
            this.state = 'destroyed'
            this._fire('stateChange')
            super.destroy()
            return this._destroy()
          })
        }
        _restart() {
          return this._actionQueues.enqueue(OD, () => {
            this.state = 'initializing'
            this._fire('stateChange')
            return this._destroy()
              .catch((t) => {
                console.error('An error happened during destroying the context or items.', t)
              })
              .then(() => this._create())
              .then(() => this._fire('restart'))
          })
        }
        _create() {
          return Promise.resolve()
            .then(() => {
              this._startErrorHandling()
              return this._creator(this._contextConfig)
            })
            .then((t) => {
              this._context = t
              this._contextProps = MD(this._context)
              return Promise.all(
                Array.from(this._watchdogs.values()).map((t) => {
                  t._setExcludedProperties(this._contextProps)
                  return t.create(undefined, undefined, this._context)
                }),
              )
            })
        }
        _destroy() {
          return Promise.resolve().then(() => {
            this._stopErrorHandling()
            const t = this._context
            this._context = null
            this._contextProps = new Set()
            return Promise.all(Array.from(this._watchdogs.values()).map((t) => t.destroy())).then(() =>
              this._destructor(t),
            )
          })
        }
        _getWatchdog(t) {
          const e = this._watchdogs.get(t)
          if (!e) {
            throw new Error(`Item with the given id was not registered: ${t}.`)
          }
          return e
        }
        _isErrorComingFromThisItem(t) {
          for (const e of this._watchdogs.values()) {
            if (e._isErrorComingFromThisItem(t)) {
              return false
            }
          }
          return ND(this._context, t.context)
        }
      }
      class FD {
        constructor() {
          this._onEmptyCallbacks = []
          this._queues = new Map()
          this._activeActions = 0
        }
        onEmpty(t) {
          this._onEmptyCallbacks.push(t)
        }
        enqueue(t, e) {
          const n = t === OD
          this._activeActions++
          if (!this._queues.get(t)) {
            this._queues.set(t, Promise.resolve())
          }
          const o = n ? Promise.all(this._queues.values()) : Promise.all([this._queues.get(OD), this._queues.get(t)])
          const i = o.then(e)
          const r = i.catch(() => {})
          this._queues.set(t, r)
          return i.finally(() => {
            this._activeActions--
            if (this._queues.get(t) === r && this._activeActions === 0) {
              this._onEmptyCallbacks.forEach((t) => t())
            }
          })
        }
      }
      function jD(t) {
        return Array.isArray(t) ? t : [t]
      }
      class HD extends qC($C(UC)) {
        constructor(t, e = {}) {
          if (!WD(t) && e.initialData !== undefined) {
            throw new P('editor-create-initial-data', null)
          }
          super(e)
          if (this.config.get('initialData') === undefined) {
            this.config.set('initialData', UD(t))
          }
          if (WD(t)) {
            this.sourceElement = t
          }
          this.model.document.createRoot()
          const n = !this.config.get('toolbar.shouldNotGroupWhenFull')
          const o = new ID(this.locale, this.editing.view, { shouldToolbarGroupWhenFull: n })
          this.ui = new yD(this, o)
          WC(this)
        }
        destroy() {
          if (this.sourceElement) {
            this.updateSourceElement()
          }
          this.ui.destroy()
          return super.destroy()
        }
        static create(t, e = {}) {
          return new Promise((n) => {
            const o = new this(t, e)
            n(
              o
                .initPlugins()
                .then(() => o.ui.init(WD(t) ? t : null))
                .then(() => o.data.init(o.config.get('initialData')))
                .then(() => o.fire('ready'))
                .then(() => o),
            )
          })
        }
      }
      HD.Context = Nu
      HD.EditorWatchdog = zD
      HD.ContextWatchdog = VD
      function UD(t) {
        return WD(t) ? kc(t) : t
      }
      function WD(t) {
        return Ga(t)
      }
      class GD {
        constructor(t, e = 20) {
          this._batch = null
          this.model = t
          this._size = 0
          this.limit = e
          this._isLocked = false
          this._changeCallback = (t, e) => {
            if (e.isLocal && e.isUndoable && e !== this._batch) {
              this._reset(true)
            }
          }
          this._selectionChangeCallback = () => {
            this._reset()
          }
          this.model.document.on('change', this._changeCallback)
          this.model.document.selection.on('change:range', this._selectionChangeCallback)
          this.model.document.selection.on('change:attribute', this._selectionChangeCallback)
        }
        get batch() {
          if (!this._batch) {
            this._batch = this.model.createBatch({ isTyping: true })
          }
          return this._batch
        }
        get size() {
          return this._size
        }
        input(t) {
          this._size += t
          if (this._size >= this.limit) {
            this._reset(true)
          }
        }
        get isLocked() {
          return this._isLocked
        }
        lock() {
          this._isLocked = true
        }
        unlock() {
          this._isLocked = false
        }
        destroy() {
          this.model.document.off('change', this._changeCallback)
          this.model.document.selection.off('change:range', this._selectionChangeCallback)
          this.model.document.selection.off('change:attribute', this._selectionChangeCallback)
        }
        _reset(t = false) {
          if (!this.isLocked || t) {
            this._batch = null
            this._size = 0
          }
        }
      }
      class qD extends Iu {
        constructor(t, e) {
          super(t)
          this._buffer = new GD(t.model, e)
          this._isEnabledBasedOnSelection = false
        }
        get buffer() {
          return this._buffer
        }
        destroy() {
          super.destroy()
          this._buffer.destroy()
        }
        execute(t = {}) {
          const e = this.editor.model
          const n = e.document
          const o = t.text || ''
          const i = o.length
          let r = n.selection
          if (t.selection) {
            r = t.selection
          } else if (t.range) {
            r = e.createSelection(t.range)
          }
          if (!e.canEditAt(r)) {
            return
          }
          const s = t.resultRange
          e.enqueueChange(this._buffer.batch, (t) => {
            this._buffer.lock()
            e.deleteContent(r)
            if (o) {
              e.insertContent(t.createText(o, n.selection.getAttributes()), r)
            }
            if (s) {
              t.setSelection(s)
            } else if (!r.is('documentSelection')) {
              t.setSelection(r)
            }
            this._buffer.unlock()
            this._buffer.input(i)
          })
        }
      }
      const $D = ['insertText', 'insertReplacementText']
      class KD extends Mm {
        constructor(t) {
          super(t)
          this.focusObserver = t.getObserver(rb)
          if (l.isAndroid) {
            $D.push('insertCompositionText')
          }
          const e = t.document
          e.on('beforeinput', (n, o) => {
            if (!this.isEnabled) {
              return
            }
            const { data: i, targetRanges: r, inputType: s, domEvent: a } = o
            if (!$D.includes(s)) {
              return
            }
            this.focusObserver.flush()
            const c = new D(e, 'insertText')
            e.fire(c, new Pm(t, a, { text: i, selection: t.createSelection(r) }))
            if (c.stop.called) {
              n.stop()
            }
          })
          e.on(
            'compositionend',
            (n, { data: o, domEvent: i }) => {
              if (!this.isEnabled || l.isAndroid) {
                return
              }
              if (!o) {
                return
              }
              e.fire('insertText', new Pm(t, i, { text: o, selection: e.selection }))
            },
            { priority: 'lowest' },
          )
        }
        observe() {}
        stopObserving() {}
      }
      class YD extends Du {
        static get pluginName() {
          return 'Input'
        }
        init() {
          const t = this.editor
          const e = t.model
          const n = t.editing.view
          const o = e.document.selection
          n.addObserver(KD)
          const i = new qD(t, t.config.get('typing.undoStep') || 20)
          t.commands.add('insertText', i)
          t.commands.add('input', i)
          this.listenTo(n.document, 'insertText', (o, i) => {
            if (!n.document.isComposing) {
              i.preventDefault()
            }
            const { text: r, selection: s, resultRange: a } = i
            const c = Array.from(s.getRanges()).map((e) => t.editing.mapper.toModelRange(e))
            let d = r
            if (l.isAndroid) {
              const t = Array.from(c[0].getItems()).reduce((t, e) => t + (e.is('$textProxy') ? e.data : ''), '')
              if (t) {
                if (t.length <= d.length) {
                  if (d.startsWith(t)) {
                    d = d.substring(t.length)
                    c[0].start = c[0].start.getShiftedBy(t.length)
                  }
                } else {
                  if (t.startsWith(d)) {
                    c[0].start = c[0].start.getShiftedBy(d.length)
                    d = ''
                  }
                }
              }
            }
            const u = { text: d, selection: e.createSelection(c) }
            if (a) {
              u.resultRange = t.editing.mapper.toModelRange(a)
            }
            t.execute('insertText', u)
            n.scrollToTheSelection()
          })
          if (l.isAndroid) {
            this.listenTo(n.document, 'keydown', (t, r) => {
              if (o.isCollapsed || r.keyCode != 229 || !n.document.isComposing) {
                return
              }
              ZD(e, i)
            })
          } else {
            this.listenTo(n.document, 'compositionstart', () => {
              if (o.isCollapsed) {
                return
              }
              ZD(e, i)
            })
          }
        }
      }
      function ZD(t, e) {
        if (!e.isEnabled) {
          return
        }
        const n = e.buffer
        n.lock()
        t.enqueueChange(n.batch, () => {
          t.deleteContent(t.document.selection)
        })
        n.unlock()
      }
      class QD extends Iu {
        constructor(t, e) {
          super(t)
          this.direction = e
          this._buffer = new GD(t.model, t.config.get('typing.undoStep'))
          this._isEnabledBasedOnSelection = false
        }
        get buffer() {
          return this._buffer
        }
        execute(t = {}) {
          const e = this.editor.model
          const n = e.document
          e.enqueueChange(this._buffer.batch, (o) => {
            this._buffer.lock()
            const i = o.createSelection(t.selection || n.selection)
            if (!e.canEditAt(i)) {
              return
            }
            const r = t.sequence || 1
            const s = i.isCollapsed
            if (i.isCollapsed) {
              e.modifySelection(i, { direction: this.direction, unit: t.unit, treatEmojiAsSingleUnit: true })
            }
            if (this._shouldEntireContentBeReplacedWithParagraph(r)) {
              this._replaceEntireContentWithParagraph(o)
              return
            }
            if (this._shouldReplaceFirstBlockWithParagraph(i, r)) {
              this.editor.execute('paragraph', { selection: i })
              return
            }
            if (i.isCollapsed) {
              return
            }
            let a = 0
            i.getFirstRange()
              .getMinimalFlatRanges()
              .forEach((t) => {
                a += Et(t.getWalker({ singleCharacters: true, ignoreElementEnd: true, shallow: true }))
              })
            e.deleteContent(i, { doNotResetEntireContent: s, direction: this.direction })
            this._buffer.input(a)
            o.setSelection(i)
            this._buffer.unlock()
          })
        }
        _shouldEntireContentBeReplacedWithParagraph(t) {
          if (t > 1) {
            return false
          }
          const e = this.editor.model
          const n = e.document
          const o = n.selection
          const i = e.schema.getLimitElement(o)
          const r = o.isCollapsed && o.containsEntireContent(i)
          if (!r) {
            return false
          }
          if (!e.schema.checkChild(i, 'paragraph')) {
            return false
          }
          const s = i.getChild(0)
          if (s && s.is('element', 'paragraph')) {
            return false
          }
          return true
        }
        _replaceEntireContentWithParagraph(t) {
          const e = this.editor.model
          const n = e.document
          const o = n.selection
          const i = e.schema.getLimitElement(o)
          const r = t.createElement('paragraph')
          t.remove(t.createRangeIn(i))
          t.insert(r, i)
          t.setSelection(r, 0)
        }
        _shouldReplaceFirstBlockWithParagraph(t, e) {
          const n = this.editor.model
          if (e > 1 || this.direction != 'backward') {
            return false
          }
          if (!t.isCollapsed) {
            return false
          }
          const o = t.getFirstPosition()
          const i = n.schema.getLimitElement(o)
          const r = i.getChild(0)
          if (o.parent != r) {
            return false
          }
          if (!t.containsEntireContent(r)) {
            return false
          }
          if (!n.schema.checkChild(i, 'paragraph')) {
            return false
          }
          if (r.name == 'paragraph') {
            return false
          }
          return true
        }
      }
      const JD = 'character'
      const XD = 'word'
      const tT = 'codePoint'
      const eT = 'selection'
      const nT = 'backward'
      const oT = 'forward'
      const iT = {
        deleteContent: { unit: eT, direction: nT },
        deleteContentBackward: { unit: tT, direction: nT },
        deleteWordBackward: { unit: XD, direction: nT },
        deleteHardLineBackward: { unit: eT, direction: nT },
        deleteSoftLineBackward: { unit: eT, direction: nT },
        deleteContentForward: { unit: JD, direction: oT },
        deleteWordForward: { unit: XD, direction: oT },
        deleteHardLineForward: { unit: eT, direction: oT },
        deleteSoftLineForward: { unit: eT, direction: oT },
      }
      class rT extends Mm {
        constructor(t) {
          super(t)
          const e = t.document
          let n = 0
          e.on('keydown', () => {
            n++
          })
          e.on('keyup', () => {
            n = 0
          })
          e.on('beforeinput', (o, i) => {
            if (!this.isEnabled) {
              return
            }
            const { targetRanges: r, domEvent: s, inputType: a } = i
            const c = iT[a]
            if (!c) {
              return
            }
            const d = { direction: c.direction, unit: c.unit, sequence: n }
            if (d.unit == eT) {
              d.selectionToRemove = t.createSelection(r[0])
            }
            if (a === 'deleteContentBackward') {
              if (l.isAndroid) {
                d.sequence = 1
              }
              if (aT(r)) {
                d.unit = eT
                d.selectionToRemove = t.createSelection(r)
              }
            }
            const u = new mf(e, 'delete', r[0])
            e.fire(u, new Pm(t, s, d))
            if (u.stop.called) {
              o.stop()
            }
          })
          if (l.isBlink) {
            sT(this)
          }
        }
        observe() {}
        stopObserving() {}
      }
      function sT(t) {
        const e = t.view
        const n = e.document
        let o = null
        let i = false
        n.on('keydown', (t, { keyCode: e }) => {
          o = e
          i = false
        })
        n.on('keyup', (a, { keyCode: c, domEvent: l }) => {
          const d = n.selection
          const u = t.isEnabled && c == o && r(c) && !d.isCollapsed && !i
          o = null
          if (u) {
            const t = d.getFirstRange()
            const o = new mf(n, 'delete', t)
            const i = { unit: eT, direction: s(c), selectionToRemove: d }
            n.fire(o, new Pm(e, l, i))
          }
        })
        n.on(
          'beforeinput',
          (t, { inputType: e }) => {
            const n = iT[e]
            const a = r(o) && n && n.direction == s(o)
            if (a) {
              i = true
            }
          },
          { priority: 'high' },
        )
        n.on(
          'beforeinput',
          (t, { inputType: e, data: n }) => {
            const i = o == Yc.delete && e == 'insertText' && n == ''
            if (i) {
              t.stop()
            }
          },
          { priority: 'high' },
        )
        function r(t) {
          return t == Yc.backspace || t == Yc.delete
        }
        function s(t) {
          return t == Yc.backspace ? nT : oT
        }
      }
      function aT(t) {
        if (t.length != 1 || t[0].isCollapsed) {
          return false
        }
        const e = t[0].getWalker({ direction: 'backward', singleCharacters: true, ignoreElementEnd: true })
        let n = 0
        for (const { nextPosition: t } of e) {
          if (!t.parent.is('$text')) {
            n++
          } else {
            const e = t.parent.data
            const o = t.offset
            if (Il(e, o) || Sl(e, o) || Bl(e, o)) {
              continue
            }
            n++
          }
          if (n > 1) {
            return true
          }
        }
        return false
      }
      class cT extends Du {
        static get pluginName() {
          return 'Delete'
        }
        init() {
          const t = this.editor
          const e = t.editing.view
          const n = e.document
          const o = t.model.document
          e.addObserver(rT)
          this._undoOnBackspace = false
          const i = new QD(t, 'forward')
          t.commands.add('deleteForward', i)
          t.commands.add('forwardDelete', i)
          t.commands.add('delete', new QD(t, 'backward'))
          this.listenTo(
            n,
            'delete',
            (o, i) => {
              if (!n.isComposing) {
                i.preventDefault()
              }
              const { direction: r, sequence: s, selectionToRemove: a, unit: c } = i
              const l = r === 'forward' ? 'deleteForward' : 'delete'
              const d = { sequence: s }
              if (c == 'selection') {
                const e = Array.from(a.getRanges()).map((e) => t.editing.mapper.toModelRange(e))
                d.selection = t.model.createSelection(e)
              } else {
                d.unit = c
              }
              t.execute(l, d)
              e.scrollToTheSelection()
            },
            { priority: 'low' },
          )
          if (this.editor.plugins.has('UndoEditing')) {
            this.listenTo(
              n,
              'delete',
              (e, n) => {
                if (this._undoOnBackspace && n.direction == 'backward' && n.sequence == 1 && n.unit == 'codePoint') {
                  this._undoOnBackspace = false
                  t.execute('undo')
                  n.preventDefault()
                  e.stop()
                }
              },
              { context: '$capture' },
            )
            this.listenTo(o, 'change', () => {
              this._undoOnBackspace = false
            })
          }
        }
        requestUndoOnBackspace() {
          if (this.editor.plugins.has('UndoEditing')) {
            this._undoOnBackspace = true
          }
        }
      }
      class lT extends Du {
        static get requires() {
          return [YD, cT]
        }
        static get pluginName() {
          return 'Typing'
        }
      }
      function dT(t, e) {
        let n = t.start
        const o = Array.from(t.getWalker({ ignoreElementEnd: false })).reduce((t, { item: o }) => {
          if (!(o.is('$text') || o.is('$textProxy'))) {
            n = e.createPositionAfter(o)
            return ''
          }
          return t + o.data
        }, '')
        return { text: o, range: e.createRange(n, t.end) }
      }
      class uT extends ft() {
        constructor(t, e) {
          super()
          this.model = t
          this.testCallback = e
          this._hasMatch = false
          this.set('isEnabled', true)
          this.on('change:isEnabled', () => {
            if (this.isEnabled) {
              this._startListening()
            } else {
              this.stopListening(t.document.selection)
              this.stopListening(t.document)
            }
          })
          this._startListening()
        }
        get hasMatch() {
          return this._hasMatch
        }
        _startListening() {
          const t = this.model
          const e = t.document
          this.listenTo(e.selection, 'change:range', (t, { directChange: n }) => {
            if (!n) {
              return
            }
            if (!e.selection.isCollapsed) {
              if (this.hasMatch) {
                this.fire('unmatched')
                this._hasMatch = false
              }
              return
            }
            this._evaluateTextBeforeSelection('selection')
          })
          this.listenTo(e, 'change:data', (t, e) => {
            if (e.isUndo || !e.isLocal) {
              return
            }
            this._evaluateTextBeforeSelection('data', { batch: e })
          })
        }
        _evaluateTextBeforeSelection(t, e = {}) {
          const n = this.model
          const o = n.document
          const i = o.selection
          const r = n.createRange(n.createPositionAt(i.focus.parent, 0), i.focus)
          const { text: s, range: a } = dT(r, n)
          const c = this.testCallback(s)
          if (!c && this.hasMatch) {
            this.fire('unmatched')
          }
          this._hasMatch = !!c
          if (c) {
            const n = Object.assign(e, { text: s, range: a })
            if (typeof c == 'object') {
              Object.assign(n, c)
            }
            this.fire(`matched:${t}`, n)
          }
        }
      }
      class hT extends Du {
        static get pluginName() {
          return 'TwoStepCaretMovement'
        }
        constructor(t) {
          super(t)
          this.attributes = new Set()
          this._overrideUid = null
        }
        init() {
          const t = this.editor
          const e = t.model
          const n = t.editing.view
          const o = t.locale
          const i = e.document.selection
          this.listenTo(
            n.document,
            'arrowKey',
            (t, e) => {
              if (!i.isCollapsed) {
                return
              }
              if (e.shiftKey || e.altKey || e.ctrlKey) {
                return
              }
              const n = e.keyCode == Yc.arrowright
              const r = e.keyCode == Yc.arrowleft
              if (!n && !r) {
                return
              }
              const s = o.contentLanguageDirection
              let a = false
              if ((s === 'ltr' && n) || (s === 'rtl' && r)) {
                a = this._handleForwardMovement(e)
              } else {
                a = this._handleBackwardMovement(e)
              }
              if (a === true) {
                t.stop()
              }
            },
            { context: '$text', priority: 'highest' },
          )
          this._isNextGravityRestorationSkipped = false
          this.listenTo(i, 'change:range', (t, e) => {
            if (this._isNextGravityRestorationSkipped) {
              this._isNextGravityRestorationSkipped = false
              return
            }
            if (!this._isGravityOverridden) {
              return
            }
            if (!e.directChange && bT(i.getFirstPosition(), this.attributes)) {
              return
            }
            this._restoreGravity()
          })
        }
        registerAttribute(t) {
          this.attributes.add(t)
        }
        _handleForwardMovement(t) {
          const e = this.attributes
          const n = this.editor.model
          const o = n.document.selection
          const i = o.getFirstPosition()
          if (this._isGravityOverridden) {
            return false
          }
          if (i.isAtStart && gT(o, e)) {
            return false
          }
          if (bT(i, e)) {
            mT(t)
            this._overrideGravity()
            return true
          }
          return false
        }
        _handleBackwardMovement(t) {
          const e = this.attributes
          const n = this.editor.model
          const o = n.document.selection
          const i = o.getFirstPosition()
          if (this._isGravityOverridden) {
            mT(t)
            this._restoreGravity()
            fT(n, e, i)
            return true
          } else {
            if (i.isAtStart) {
              if (gT(o, e)) {
                mT(t)
                fT(n, e, i)
                return true
              }
              return false
            }
            if (pT(i, e)) {
              if (i.isAtEnd && !gT(o, e) && bT(i, e)) {
                mT(t)
                fT(n, e, i)
                return true
              }
              this._isNextGravityRestorationSkipped = true
              this._overrideGravity()
              return false
            }
          }
          return false
        }
        get _isGravityOverridden() {
          return !!this._overrideUid
        }
        _overrideGravity() {
          this._overrideUid = this.editor.model.change((t) => t.overrideSelectionGravity())
        }
        _restoreGravity() {
          this.editor.model.change((t) => {
            t.restoreSelectionGravity(this._overrideUid)
            this._overrideUid = null
          })
        }
      }
      function gT(t, e) {
        for (const n of e) {
          if (t.hasAttribute(n)) {
            return true
          }
        }
        return false
      }
      function fT(t, e, n) {
        const o = n.nodeBefore
        t.change((n) => {
          if (o) {
            const e = []
            const i = t.schema.isObject(o) && t.schema.isInline(o)
            for (const [n, r] of o.getAttributes()) {
              if (
                t.schema.checkAttribute('$text', n) &&
                (!i || t.schema.getAttributeProperties(n).copyFromObject !== false)
              ) {
                e.push([n, r])
              }
            }
            n.setSelectionAttribute(e)
          } else {
            n.removeSelectionAttribute(e)
          }
        })
      }
      function mT(t) {
        t.preventDefault()
      }
      function pT(t, e) {
        const n = t.getShiftedBy(-1)
        return bT(n, e)
      }
      function bT(t, e) {
        const { nodeBefore: n, nodeAfter: o } = t
        for (const t of e) {
          const e = n ? n.getAttribute(t) : undefined
          const i = o ? o.getAttribute(t) : undefined
          if (i !== e) {
            return true
          }
        }
        return false
      }
      var kT = /[\\^$.*+?()[\]{}|]/g,
        wT = RegExp(kT.source)
      function AT(t) {
        t = zh(t)
        return t && wT.test(t) ? t.replace(kT, '\\$&') : t
      }
      const _T = AT
      const CT = {
        copyright: { from: '(c)', to: '©' },
        registeredTrademark: { from: '(r)', to: '®' },
        trademark: { from: '(tm)', to: '™' },
        oneHalf: { from: /(^|[^/a-z0-9])(1\/2)([^/a-z0-9])$/i, to: [null, '½', null] },
        oneThird: { from: /(^|[^/a-z0-9])(1\/3)([^/a-z0-9])$/i, to: [null, '⅓', null] },
        twoThirds: { from: /(^|[^/a-z0-9])(2\/3)([^/a-z0-9])$/i, to: [null, '⅔', null] },
        oneForth: { from: /(^|[^/a-z0-9])(1\/4)([^/a-z0-9])$/i, to: [null, '¼', null] },
        threeQuarters: { from: /(^|[^/a-z0-9])(3\/4)([^/a-z0-9])$/i, to: [null, '¾', null] },
        lessThanOrEqual: { from: '<=', to: '≤' },
        greaterThanOrEqual: { from: '>=', to: '≥' },
        notEqual: { from: '!=', to: '≠' },
        arrowLeft: { from: '<-', to: '←' },
        arrowRight: { from: '->', to: '→' },
        horizontalEllipsis: { from: '...', to: '…' },
        enDash: { from: /(^| )(--)( )$/, to: [null, '–', null] },
        emDash: { from: /(^| )(---)( )$/, to: [null, '—', null] },
        quotesPrimary: { from: IT('"'), to: [null, '“', null, '”'] },
        quotesSecondary: { from: IT("'"), to: [null, '‘', null, '’'] },
        quotesPrimaryEnGb: { from: IT("'"), to: [null, '‘', null, '’'] },
        quotesSecondaryEnGb: { from: IT('"'), to: [null, '“', null, '”'] },
        quotesPrimaryPl: { from: IT('"'), to: [null, '„', null, '”'] },
        quotesSecondaryPl: { from: IT("'"), to: [null, '‚', null, '’'] },
      }
      const vT = {
        symbols: ['copyright', 'registeredTrademark', 'trademark'],
        mathematical: [
          'oneHalf',
          'oneThird',
          'twoThirds',
          'oneForth',
          'threeQuarters',
          'lessThanOrEqual',
          'greaterThanOrEqual',
          'notEqual',
          'arrowLeft',
          'arrowRight',
        ],
        typography: ['horizontalEllipsis', 'enDash', 'emDash'],
        quotes: ['quotesPrimary', 'quotesSecondary'],
      }
      const yT = ['symbols', 'mathematical', 'typography', 'quotes']
      class xT extends Du {
        static get requires() {
          return ['Delete', 'Input']
        }
        static get pluginName() {
          return 'TextTransformation'
        }
        constructor(t) {
          super(t)
          t.config.define('typing', { transformations: { include: yT } })
        }
        init() {
          const t = this.editor.model
          const e = t.document.selection
          e.on('change:range', () => {
            this.isEnabled = !e.anchor.parent.is('element', 'codeBlock')
          })
          this._enableTransformationWatchers()
        }
        _enableTransformationWatchers() {
          const t = this.editor
          const e = t.model
          const n = t.plugins.get('Delete')
          const o = ST(t.config.get('typing.transformations'))
          const i = (t) => {
            for (const e of o) {
              const n = e.from
              const o = n.test(t)
              if (o) {
                return { normalizedTransformation: e }
              }
            }
          }
          const r = new uT(t.model, i)
          r.on('matched:data', (t, o) => {
            if (!o.batch.isTyping) {
              return
            }
            const { from: i, to: r } = o.normalizedTransformation
            const s = i.exec(o.text)
            const a = r(s.slice(1))
            const c = o.range
            let l = s.index
            e.enqueueChange((t) => {
              for (let n = 1; n < s.length; n++) {
                const o = s[n]
                const i = a[n - 1]
                if (i == null) {
                  l += o.length
                  continue
                }
                const r = c.start.getShiftedBy(l)
                const d = e.createRange(r, r.getShiftedBy(o.length))
                const u = TT(r)
                e.insertContent(t.createText(i, u), d)
                l += i.length
              }
              e.enqueueChange(() => {
                n.requestUndoOnBackspace()
              })
            })
          })
          r.bind('isEnabled').to(this)
        }
      }
      function ET(t) {
        if (typeof t == 'string') {
          return new RegExp(`(${_T(t)})$`)
        }
        return t
      }
      function DT(t) {
        if (typeof t == 'string') {
          return () => [t]
        } else if (t instanceof Array) {
          return () => t
        }
        return t
      }
      function TT(t) {
        const e = t.textNode ? t.textNode : t.nodeAfter
        return e.getAttributes()
      }
      function IT(t) {
        return new RegExp(`(^|\\s)(${t})([^${t}]*)(${t})$`)
      }
      function ST(t) {
        const e = t.extra || []
        const n = t.remove || []
        const o = (t) => !n.includes(t)
        const i = t.include.concat(e).filter(o)
        return MT(i)
          .filter(o)
          .map((t) => (typeof t == 'string' && CT[t] ? CT[t] : t))
          .filter((t) => typeof t === 'object')
          .map((t) => ({ from: ET(t.from), to: DT(t.to) }))
      }
      function MT(t) {
        const e = new Set()
        for (const n of t) {
          if (typeof n == 'string' && vT[n]) {
            for (const t of vT[n]) {
              e.add(t)
            }
          } else {
            e.add(n)
          }
        }
        return Array.from(e)
      }
      function BT(t, e, n, o) {
        return o.createRange(NT(t, e, n, true, o), NT(t, e, n, false, o))
      }
      function NT(t, e, n, o, i) {
        let r = t.textNode || (o ? t.nodeBefore : t.nodeAfter)
        let s = null
        while (r && r.getAttribute(e) == n) {
          s = r
          r = o ? r.previousSibling : r.nextSibling
        }
        return s ? i.createPositionAt(s, o ? 'before' : 'after') : t
      }
      function PT(t, e, n, o) {
        const i = t.editing.view
        const r = new Set()
        i.document.registerPostFixer((i) => {
          const s = t.model.document.selection
          let a = false
          if (s.hasAttribute(e)) {
            const c = BT(s.getFirstPosition(), e, s.getAttribute(e), t.model)
            const l = t.editing.mapper.toViewRange(c)
            for (const t of l.getItems()) {
              if (t.is('element', n) && !t.hasClass(o)) {
                i.addClass(o, t)
                r.add(t)
                a = true
              }
            }
          }
          return a
        })
        t.conversion.for('editingDowncast').add((t) => {
          t.on('insert', e, { priority: 'highest' })
          t.on('remove', e, { priority: 'highest' })
          t.on('attribute', e, { priority: 'highest' })
          t.on('selection', e, { priority: 'highest' })
          function e() {
            i.change((t) => {
              for (const e of r.values()) {
                t.removeClass(o, e)
                r.delete(e)
              }
            })
          }
        })
      }
      function LT(t, e, n, o) {
        let i
        let r = null
        if (typeof o == 'function') {
          i = o
        } else {
          r = t.commands.get(o)
          i = () => {
            t.execute(o)
          }
        }
        t.model.document.on('change:data', (s, a) => {
          if ((r && !r.isEnabled) || !e.isEnabled) {
            return
          }
          const c = bl(t.model.document.selection.getRanges())
          if (!c.isCollapsed) {
            return
          }
          if (a.isUndo || !a.isLocal) {
            return
          }
          const l = Array.from(t.model.document.differ.getChanges())
          const d = l[0]
          if (l.length != 1 || d.type !== 'insert' || d.name != '$text' || d.length != 1) {
            return
          }
          const u = d.position.parent
          if (u.is('element', 'codeBlock')) {
            return
          }
          if (
            u.is('element', 'listItem') &&
            typeof o !== 'function' &&
            !['numberedList', 'bulletedList', 'todoList'].includes(o)
          ) {
            return
          }
          if (r && r.value === true) {
            return
          }
          const h = u.getChild(0)
          const g = t.model.createRangeOn(h)
          if (!g.containsRange(c) && !c.end.isEqual(g.end)) {
            return
          }
          const f = n.exec(h.data.substr(0, c.end.offset))
          if (!f) {
            return
          }
          t.model.enqueueChange((e) => {
            const n = e.createPositionAt(u, 0)
            const o = e.createPositionAt(u, f[0].length)
            const r = new Zb(n, o)
            const s = i({ match: f })
            if (s !== false) {
              e.remove(r)
              const n = t.model.document.selection.getFirstRange()
              const o = e.createRangeIn(u)
              if (u.isEmpty && !o.isEqual(n) && !o.containsRange(n, true)) {
                e.remove(u)
              }
            }
            r.detach()
            t.model.enqueueChange(() => {
              const e = t.plugins.get('Delete')
              e.requestUndoOnBackspace()
            })
          })
        })
      }
      function zT(t, e, n, o) {
        let i
        let r
        if (n instanceof RegExp) {
          i = n
        } else {
          r = n
        }
        r =
          r ||
          ((t) => {
            let e
            const n = []
            const o = []
            while ((e = i.exec(t)) !== null) {
              if (e && e.length < 4) {
                break
              }
              let { index: t, 1: i, 2: r, 3: s } = e
              const a = i + r + s
              t += e[0].length - a.length
              const c = [t, t + i.length]
              const l = [t + i.length + r.length, t + i.length + r.length + s.length]
              n.push(c)
              n.push(l)
              o.push([t + i.length, t + i.length + r.length])
            }
            return { remove: n, format: o }
          })
        t.model.document.on('change:data', (n, i) => {
          if (i.isUndo || !i.isLocal || !e.isEnabled) {
            return
          }
          const s = t.model
          const a = s.document.selection
          if (!a.isCollapsed) {
            return
          }
          const c = Array.from(s.document.differ.getChanges())
          const l = c[0]
          if (c.length != 1 || l.type !== 'insert' || l.name != '$text' || l.length != 1) {
            return
          }
          const d = a.focus
          const u = d.parent
          const { text: h, range: g } = OT(s.createRange(s.createPositionAt(u, 0), d), s)
          const f = r(h)
          const m = RT(g.start, f.format, s)
          const p = RT(g.start, f.remove, s)
          if (!(m.length && p.length)) {
            return
          }
          s.enqueueChange((e) => {
            const n = o(e, m)
            if (n === false) {
              return
            }
            for (const t of p.reverse()) {
              e.remove(t)
            }
            s.enqueueChange(() => {
              const e = t.plugins.get('Delete')
              e.requestUndoOnBackspace()
            })
          })
        })
      }
      function RT(t, e, n) {
        return e
          .filter((t) => t[0] !== undefined && t[1] !== undefined)
          .map((e) => n.createRange(t.getShiftedBy(e[0]), t.getShiftedBy(e[1])))
      }
      function OT(t, e) {
        let n = t.start
        const o = Array.from(t.getItems()).reduce((t, o) => {
          if (!(o.is('$text') || o.is('$textProxy')) || o.getAttribute('code')) {
            n = e.createPositionAfter(o)
            return ''
          }
          return t + o.data
        }, '')
        return { text: o, range: e.createRange(n, t.end) }
      }
      class VT extends Du {
        static get requires() {
          return [cT]
        }
        static get pluginName() {
          return 'Autoformat'
        }
        afterInit() {
          this._addListAutoformats()
          this._addBasicStylesAutoformats()
          this._addHeadingAutoformats()
          this._addBlockQuoteAutoformats()
          this._addCodeBlockAutoformats()
          this._addHorizontalLineAutoformats()
        }
        _addListAutoformats() {
          const t = this.editor.commands
          if (t.get('bulletedList')) {
            LT(this.editor, this, /^[*-]\s$/, 'bulletedList')
          }
          if (t.get('numberedList')) {
            LT(this.editor, this, /^1[.|)]\s$/, 'numberedList')
          }
          if (t.get('todoList')) {
            LT(this.editor, this, /^\[\s?\]\s$/, 'todoList')
          }
          if (t.get('checkTodoList')) {
            LT(this.editor, this, /^\[\s?x\s?\]\s$/, () => {
              this.editor.execute('todoList')
              this.editor.execute('checkTodoList')
            })
          }
        }
        _addBasicStylesAutoformats() {
          const t = this.editor.commands
          if (t.get('bold')) {
            const t = FT(this.editor, 'bold')
            zT(this.editor, this, /(?:^|\s)(\*\*)([^*]+)(\*\*)$/g, t)
            zT(this.editor, this, /(?:^|\s)(__)([^_]+)(__)$/g, t)
          }
          if (t.get('italic')) {
            const t = FT(this.editor, 'italic')
            zT(this.editor, this, /(?:^|\s)(\*)([^*_]+)(\*)$/g, t)
            zT(this.editor, this, /(?:^|\s)(_)([^_]+)(_)$/g, t)
          }
          if (t.get('code')) {
            const t = FT(this.editor, 'code')
            zT(this.editor, this, /(`)([^`]+)(`)$/g, t)
          }
          if (t.get('strikethrough')) {
            const t = FT(this.editor, 'strikethrough')
            zT(this.editor, this, /(~~)([^~]+)(~~)$/g, t)
          }
        }
        _addHeadingAutoformats() {
          const t = this.editor.commands.get('heading')
          if (t) {
            t.modelElements
              .filter((t) => t.match(/^heading[1-6]$/))
              .forEach((e) => {
                const n = e[7]
                const o = new RegExp(`^(#{${n}})\\s$`)
                LT(this.editor, this, o, () => {
                  if (!t.isEnabled || t.value === e) {
                    return false
                  }
                  this.editor.execute('heading', { value: e })
                })
              })
          }
        }
        _addBlockQuoteAutoformats() {
          if (this.editor.commands.get('blockQuote')) {
            LT(this.editor, this, /^>\s$/, 'blockQuote')
          }
        }
        _addCodeBlockAutoformats() {
          const t = this.editor
          const e = t.model.document.selection
          if (t.commands.get('codeBlock')) {
            LT(t, this, /^```$/, () => {
              if (e.getFirstPosition().parent.is('element', 'listItem')) {
                return false
              }
              this.editor.execute('codeBlock', { usePreviousLanguageChoice: true })
            })
          }
        }
        _addHorizontalLineAutoformats() {
          if (this.editor.commands.get('horizontalLine')) {
            LT(this.editor, this, /^---$/, 'horizontalLine')
          }
        }
      }
      function FT(t, e) {
        return (n, o) => {
          const i = t.commands.get(e)
          if (!i.isEnabled) {
            return false
          }
          const r = t.model.schema.getValidRanges(o, e)
          for (const t of r) {
            n.setAttribute(e, true, t)
          }
          n.removeSelectionAttribute(e)
        }
      }
      class jT extends Iu {
        constructor(t, e) {
          super(t)
          this.attributeKey = e
        }
        refresh() {
          const t = this.editor.model
          const e = t.document
          this.value = this._getValueFromFirstAllowedNode()
          this.isEnabled = t.schema.checkAttributeInSelection(e.selection, this.attributeKey)
        }
        execute(t = {}) {
          const e = this.editor.model
          const n = e.document
          const o = n.selection
          const i = t.forceValue === undefined ? !this.value : t.forceValue
          e.change((t) => {
            if (o.isCollapsed) {
              if (i) {
                t.setSelectionAttribute(this.attributeKey, true)
              } else {
                t.removeSelectionAttribute(this.attributeKey)
              }
            } else {
              const n = e.schema.getValidRanges(o.getRanges(), this.attributeKey)
              for (const e of n) {
                if (i) {
                  t.setAttribute(this.attributeKey, i, e)
                } else {
                  t.removeAttribute(this.attributeKey, e)
                }
              }
            }
          })
        }
        _getValueFromFirstAllowedNode() {
          const t = this.editor.model
          const e = t.schema
          const n = t.document.selection
          if (n.isCollapsed) {
            return n.hasAttribute(this.attributeKey)
          }
          for (const t of n.getRanges()) {
            for (const n of t.getItems()) {
              if (e.checkAttribute(n, this.attributeKey)) {
                return n.hasAttribute(this.attributeKey)
              }
            }
          }
          return false
        }
      }
      const HT = 'bold'
      class UT extends Du {
        static get pluginName() {
          return 'BoldEditing'
        }
        init() {
          const t = this.editor
          t.model.schema.extend('$text', { allowAttributes: HT })
          t.model.schema.setAttributeProperties(HT, { isFormatting: true, copyOnEnter: true })
          t.conversion.attributeToElement({
            model: HT,
            view: 'strong',
            upcastAlso: [
              'b',
              (t) => {
                const e = t.getStyle('font-weight')
                if (!e) {
                  return null
                }
                if (e == 'bold' || Number(e) >= 600) {
                  return { name: true, styles: ['font-weight'] }
                }
                return null
              },
            ],
          })
          t.commands.add(HT, new jT(t, HT))
          t.keystrokes.set('CTRL+B', HT)
        }
      }
      const WT = 'bold'
      class GT extends Du {
        static get pluginName() {
          return 'BoldUI'
        }
        init() {
          const t = this.editor
          const e = t.t
          t.ui.componentFactory.add(WT, (n) => {
            const o = t.commands.get(WT)
            const i = new Dd(n)
            i.set({ label: e('Bold'), icon: Sv.bold, keystroke: 'CTRL+B', tooltip: true, isToggleable: true })
            i.bind('isOn', 'isEnabled').to(o, 'value', 'isEnabled')
            this.listenTo(i, 'execute', () => {
              t.execute(WT)
              t.editing.view.focus()
            })
            return i
          })
        }
      }
      class qT extends Du {
        static get requires() {
          return [UT, GT]
        }
        static get pluginName() {
          return 'Bold'
        }
      }
      const $T = 'code'
      const KT = 'ck-code_selected'
      class YT extends (null && Plugin) {
        static get pluginName() {
          return 'CodeEditing'
        }
        static get requires() {
          return [TwoStepCaretMovement]
        }
        init() {
          const t = this.editor
          t.model.schema.extend('$text', { allowAttributes: $T })
          t.model.schema.setAttributeProperties($T, { isFormatting: true, copyOnEnter: false })
          t.conversion.attributeToElement({
            model: $T,
            view: 'code',
            upcastAlso: { styles: { 'word-wrap': 'break-word' } },
          })
          t.commands.add($T, new AttributeCommand(t, $T))
          t.plugins.get(TwoStepCaretMovement).registerAttribute($T)
          inlineHighlight(t, $T, 'code', KT)
        }
      }
      var ZT = n(5363)
      var QT = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      QT.insert = 'head'
      QT.singleton = true
      var JT = Rl()(ZT.Z, QT)
      const XT = ZT.Z.locals || {}
      const tI = 'code'
      class eI extends (null && Plugin) {
        static get pluginName() {
          return 'CodeUI'
        }
        init() {
          const t = this.editor
          const e = t.t
          t.ui.componentFactory.add(tI, (n) => {
            const o = t.commands.get(tI)
            const i = new ButtonView(n)
            i.set({ label: e('Code'), icon: codeIcon, tooltip: true, isToggleable: true })
            i.bind('isOn', 'isEnabled').to(o, 'value', 'isEnabled')
            this.listenTo(i, 'execute', () => {
              t.execute(tI)
              t.editing.view.focus()
            })
            return i
          })
        }
      }
      class nI extends (null && Plugin) {
        static get requires() {
          return [CodeEditing, CodeUI]
        }
        static get pluginName() {
          return 'Code'
        }
      }
      const oI = 'italic'
      class iI extends Du {
        static get pluginName() {
          return 'ItalicEditing'
        }
        init() {
          const t = this.editor
          t.model.schema.extend('$text', { allowAttributes: oI })
          t.model.schema.setAttributeProperties(oI, { isFormatting: true, copyOnEnter: true })
          t.conversion.attributeToElement({
            model: oI,
            view: 'i',
            upcastAlso: ['em', { styles: { 'font-style': 'italic' } }],
          })
          t.commands.add(oI, new jT(t, oI))
          t.keystrokes.set('CTRL+I', oI)
        }
      }
      const rI =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m9.586 14.633.021.004c-.036.335.095.655.393.962.082.083.173.15.274.201h1.474a.6.6 0 1 1 0 1.2H5.304a.6.6 0 0 1 0-1.2h1.15c.474-.07.809-.182 1.005-.334.157-.122.291-.32.404-.597l2.416-9.55a1.053 1.053 0 0 0-.281-.823 1.12 1.12 0 0 0-.442-.296H8.15a.6.6 0 0 1 0-1.2h6.443a.6.6 0 1 1 0 1.2h-1.195c-.376.056-.65.155-.823.296-.215.175-.423.439-.623.79l-2.366 9.347z"/></svg>'
      const sI = 'italic'
      class aI extends Du {
        static get pluginName() {
          return 'ItalicUI'
        }
        init() {
          const t = this.editor
          const e = t.t
          t.ui.componentFactory.add(sI, (n) => {
            const o = t.commands.get(sI)
            const i = new Dd(n)
            i.set({ label: e('Italic'), icon: rI, keystroke: 'CTRL+I', tooltip: true, isToggleable: true })
            i.bind('isOn', 'isEnabled').to(o, 'value', 'isEnabled')
            this.listenTo(i, 'execute', () => {
              t.execute(sI)
              t.editing.view.focus()
            })
            return i
          })
        }
      }
      class cI extends Du {
        static get requires() {
          return [iI, aI]
        }
        static get pluginName() {
          return 'Italic'
        }
      }
      const lI = 'strikethrough'
      class dI extends Du {
        static get pluginName() {
          return 'StrikethroughEditing'
        }
        init() {
          const t = this.editor
          t.model.schema.extend('$text', { allowAttributes: lI })
          t.model.schema.setAttributeProperties(lI, { isFormatting: true, copyOnEnter: true })
          t.conversion.attributeToElement({
            model: lI,
            view: 's',
            upcastAlso: ['del', 'strike', { styles: { 'text-decoration': 'line-through' } }],
          })
          t.commands.add(lI, new jT(t, lI))
          t.keystrokes.set('CTRL+SHIFT+X', 'strikethrough')
        }
      }
      const uI =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 16.4c-.8-.4-1.5-.9-2.2-1.5a.6.6 0 0 1-.2-.5l.3-.6h1c1 1.2 2.1 1.7 3.7 1.7 1 0 1.8-.3 2.3-.6.6-.4.6-1.2.6-1.3.2-1.2-.9-2.1-.9-2.1h2.1c.3.7.4 1.2.4 1.7v.8l-.6 1.2c-.6.8-1.1 1-1.6 1.2a6 6 0 0 1-2.4.6c-1 0-1.8-.3-2.5-.6zM6.8 9 6 8.3c-.4-.5-.5-.8-.5-1.6 0-.7.1-1.3.5-1.8.4-.6 1-1 1.6-1.3a6.3 6.3 0 0 1 4.7 0 4 4 0 0 1 1.7 1l.3.7c0 .1.2.4-.2.7-.4.2-.9.1-1 0a3 3 0 0 0-1.2-1c-.4-.2-1-.3-2-.4-.7 0-1.4.2-2 .6-.8.6-1 .8-1 1.5 0 .8.5 1 1.2 1.5.6.4 1.1.7 1.9 1H6.8z"/><path d="M3 10.5V9h14v1.5z"/></svg>'
      const hI = 'strikethrough'
      class gI extends Du {
        static get pluginName() {
          return 'StrikethroughUI'
        }
        init() {
          const t = this.editor
          const e = t.t
          t.ui.componentFactory.add(hI, (n) => {
            const o = t.commands.get(hI)
            const i = new Dd(n)
            i.set({ label: e('Strikethrough'), icon: uI, keystroke: 'CTRL+SHIFT+X', tooltip: true, isToggleable: true })
            i.bind('isOn', 'isEnabled').to(o, 'value', 'isEnabled')
            this.listenTo(i, 'execute', () => {
              t.execute(hI)
              t.editing.view.focus()
            })
            return i
          })
        }
      }
      class fI extends Du {
        static get requires() {
          return [dI, gI]
        }
        static get pluginName() {
          return 'Strikethrough'
        }
      }
      const mI = 'subscript'
      class pI extends (null && Plugin) {
        static get pluginName() {
          return 'SubscriptEditing'
        }
        init() {
          const t = this.editor
          t.model.schema.extend('$text', { allowAttributes: mI })
          t.model.schema.setAttributeProperties(mI, { isFormatting: true, copyOnEnter: true })
          t.conversion.attributeToElement({
            model: mI,
            view: 'sub',
            upcastAlso: [{ styles: { 'vertical-align': 'sub' } }],
          })
          t.commands.add(mI, new AttributeCommand(t, mI))
        }
      }
      const bI = 'subscript'
      class kI extends (null && Plugin) {
        static get pluginName() {
          return 'SubscriptUI'
        }
        init() {
          const t = this.editor
          const e = t.t
          t.ui.componentFactory.add(bI, (n) => {
            const o = t.commands.get(bI)
            const i = new ButtonView(n)
            i.set({ label: e('Subscript'), icon: subscriptIcon, tooltip: true, isToggleable: true })
            i.bind('isOn', 'isEnabled').to(o, 'value', 'isEnabled')
            this.listenTo(i, 'execute', () => {
              t.execute(bI)
              t.editing.view.focus()
            })
            return i
          })
        }
      }
      class wI extends (null && Plugin) {
        static get requires() {
          return [SubscriptEditing, SubscriptUI]
        }
        static get pluginName() {
          return 'Subscript'
        }
      }
      const AI = 'superscript'
      class _I extends (null && Plugin) {
        static get pluginName() {
          return 'SuperscriptEditing'
        }
        init() {
          const t = this.editor
          t.model.schema.extend('$text', { allowAttributes: AI })
          t.model.schema.setAttributeProperties(AI, { isFormatting: true, copyOnEnter: true })
          t.conversion.attributeToElement({
            model: AI,
            view: 'sup',
            upcastAlso: [{ styles: { 'vertical-align': 'super' } }],
          })
          t.commands.add(AI, new AttributeCommand(t, AI))
        }
      }
      const CI = 'superscript'
      class vI extends (null && Plugin) {
        static get pluginName() {
          return 'SuperscriptUI'
        }
        init() {
          const t = this.editor
          const e = t.t
          t.ui.componentFactory.add(CI, (n) => {
            const o = t.commands.get(CI)
            const i = new ButtonView(n)
            i.set({ label: e('Superscript'), icon: superscriptIcon, tooltip: true, isToggleable: true })
            i.bind('isOn', 'isEnabled').to(o, 'value', 'isEnabled')
            this.listenTo(i, 'execute', () => {
              t.execute(CI)
              t.editing.view.focus()
            })
            return i
          })
        }
      }
      class yI extends (null && Plugin) {
        static get requires() {
          return [SuperscriptEditing, SuperscriptUI]
        }
        static get pluginName() {
          return 'Superscript'
        }
      }
      const xI = 'underline'
      class EI extends Du {
        static get pluginName() {
          return 'UnderlineEditing'
        }
        init() {
          const t = this.editor
          t.model.schema.extend('$text', { allowAttributes: xI })
          t.model.schema.setAttributeProperties(xI, { isFormatting: true, copyOnEnter: true })
          t.conversion.attributeToElement({
            model: xI,
            view: 'u',
            upcastAlso: { styles: { 'text-decoration': 'underline' } },
          })
          t.commands.add(xI, new jT(t, xI))
          t.keystrokes.set('CTRL+U', 'underline')
        }
      }
      const DI =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 18v-1.5h14V18zm2.2-8V3.6c0-.4.4-.6.8-.6.3 0 .7.2.7.6v6.2c0 2 1.3 2.8 3.2 2.8 1.9 0 3.4-.9 3.4-2.9V3.6c0-.3.4-.5.8-.5.3 0 .7.2.7.5V10c0 2.7-2.2 4-4.9 4-2.6 0-4.7-1.2-4.7-4z"/></svg>'
      const TI = 'underline'
      class II extends Du {
        static get pluginName() {
          return 'UnderlineUI'
        }
        init() {
          const t = this.editor
          const e = t.t
          t.ui.componentFactory.add(TI, (n) => {
            const o = t.commands.get(TI)
            const i = new Dd(n)
            i.set({ label: e('Underline'), icon: DI, keystroke: 'CTRL+U', tooltip: true, isToggleable: true })
            i.bind('isOn', 'isEnabled').to(o, 'value', 'isEnabled')
            this.listenTo(i, 'execute', () => {
              t.execute(TI)
              t.editing.view.focus()
            })
            return i
          })
        }
      }
      class SI extends Du {
        static get requires() {
          return [EI, II]
        }
        static get pluginName() {
          return 'Underline'
        }
      }
      function* MI(t, e) {
        for (const n of e) {
          if (n && t.getAttributeProperties(n[0]).copyOnEnter) {
            yield n
          }
        }
      }
      class BI extends Iu {
        execute() {
          this.editor.model.change((t) => {
            this.enterBlock(t)
            this.fire('afterExecute', { writer: t })
          })
        }
        enterBlock(t) {
          const e = this.editor.model
          const n = e.document.selection
          const o = e.schema
          const i = n.isCollapsed
          const r = n.getFirstRange()
          const s = r.start.parent
          const a = r.end.parent
          if (o.isLimit(s) || o.isLimit(a)) {
            if (!i && s == a) {
              e.deleteContent(n)
            }
            return false
          }
          if (i) {
            const e = MI(t.model.schema, n.getAttributes())
            NI(t, r.start)
            t.setSelectionAttribute(e)
            return true
          } else {
            const o = !(r.start.isAtStart && r.end.isAtEnd)
            const i = s == a
            e.deleteContent(n, { leaveUnmerged: o })
            if (o) {
              if (i) {
                NI(t, n.focus)
                return true
              } else {
                t.setSelection(a, 0)
              }
            }
          }
          return false
        }
      }
      function NI(t, e) {
        t.split(e)
        t.setSelection(e.parent.nextSibling, 0)
      }
      const PI = { insertParagraph: { isSoft: false }, insertLineBreak: { isSoft: true } }
      class LI extends Mm {
        constructor(t) {
          super(t)
          const e = this.document
          let n = false
          e.on('keydown', (t, e) => {
            n = e.shiftKey
          })
          e.on('beforeinput', (o, i) => {
            if (!this.isEnabled) {
              return
            }
            let r = i.inputType
            if (l.isSafari && n && r == 'insertParagraph') {
              r = 'insertLineBreak'
            }
            const s = i.domEvent
            const a = PI[r]
            if (!a) {
              return
            }
            const c = new mf(e, 'enter', i.targetRanges[0])
            e.fire(c, new Pm(t, s, { isSoft: a.isSoft }))
            if (c.stop.called) {
              o.stop()
            }
          })
        }
        observe() {}
        stopObserving() {}
      }
      class zI extends Du {
        static get pluginName() {
          return 'Enter'
        }
        init() {
          const t = this.editor
          const e = t.editing.view
          const n = e.document
          e.addObserver(LI)
          t.commands.add('enter', new BI(t))
          this.listenTo(
            n,
            'enter',
            (o, i) => {
              if (!n.isComposing) {
                i.preventDefault()
              }
              if (i.isSoft) {
                return
              }
              t.execute('enter')
              e.scrollToTheSelection()
            },
            { priority: 'low' },
          )
        }
      }
      class RI extends Iu {
        execute() {
          const t = this.editor.model
          const e = t.document
          t.change((n) => {
            VI(t, n, e.selection)
            this.fire('afterExecute', { writer: n })
          })
        }
        refresh() {
          const t = this.editor.model
          const e = t.document
          this.isEnabled = OI(t.schema, e.selection)
        }
      }
      function OI(t, e) {
        if (e.rangeCount > 1) {
          return false
        }
        const n = e.anchor
        if (!n || !t.checkChild(n, 'softBreak')) {
          return false
        }
        const o = e.getFirstRange()
        const i = o.start.parent
        const r = o.end.parent
        if ((jI(i, t) || jI(r, t)) && i !== r) {
          return false
        }
        return true
      }
      function VI(t, e, n) {
        const o = n.isCollapsed
        const i = n.getFirstRange()
        const r = i.start.parent
        const s = i.end.parent
        const a = r == s
        if (o) {
          const o = MI(t.schema, n.getAttributes())
          FI(t, e, i.end)
          e.removeSelectionAttribute(n.getAttributeKeys())
          e.setSelectionAttribute(o)
        } else {
          const o = !(i.start.isAtStart && i.end.isAtEnd)
          t.deleteContent(n, { leaveUnmerged: o })
          if (a) {
            FI(t, e, n.focus)
          } else {
            if (o) {
              e.setSelection(s, 0)
            }
          }
        }
      }
      function FI(t, e, n) {
        const o = e.createElement('softBreak')
        t.insertContent(o, n)
        e.setSelection(o, 'after')
      }
      function jI(t, e) {
        if (t.is('rootElement')) {
          return false
        }
        return e.isLimit(t) || jI(t.parent, e)
      }
      class HI extends Du {
        static get pluginName() {
          return 'ShiftEnter'
        }
        init() {
          const t = this.editor
          const e = t.model.schema
          const n = t.conversion
          const o = t.editing.view
          const i = o.document
          e.register('softBreak', { allowWhere: '$text', isInline: true })
          n.for('upcast').elementToElement({ model: 'softBreak', view: 'br' })
          n.for('downcast').elementToElement({
            model: 'softBreak',
            view: (t, { writer: e }) => e.createEmptyElement('br'),
          })
          o.addObserver(LI)
          t.commands.add('shiftEnter', new RI(t))
          this.listenTo(
            i,
            'enter',
            (e, n) => {
              if (!i.isComposing) {
                n.preventDefault()
              }
              if (!n.isSoft) {
                return
              }
              t.execute('shiftEnter')
              o.scrollToTheSelection()
            },
            { priority: 'low' },
          )
        }
      }
      class UI extends Iu {
        refresh() {
          this.value = this._getValue()
          this.isEnabled = this._checkEnabled()
        }
        execute(t = {}) {
          const e = this.editor.model
          const n = e.schema
          const o = e.document.selection
          const i = Array.from(o.getSelectedBlocks())
          const r = t.forceValue === undefined ? !this.value : t.forceValue
          e.change((t) => {
            if (!r) {
              this._removeQuote(t, i.filter(WI))
            } else {
              const e = i.filter((t) => WI(t) || qI(n, t))
              this._applyQuote(t, e)
            }
          })
        }
        _getValue() {
          const t = this.editor.model.document.selection
          const e = bl(t.getSelectedBlocks())
          return !!(e && WI(e))
        }
        _checkEnabled() {
          if (this.value) {
            return true
          }
          const t = this.editor.model.document.selection
          const e = this.editor.model.schema
          const n = bl(t.getSelectedBlocks())
          if (!n) {
            return false
          }
          return qI(e, n)
        }
        _removeQuote(t, e) {
          GI(t, e)
            .reverse()
            .forEach((e) => {
              if (e.start.isAtStart && e.end.isAtEnd) {
                t.unwrap(e.start.parent)
                return
              }
              if (e.start.isAtStart) {
                const n = t.createPositionBefore(e.start.parent)
                t.move(e, n)
                return
              }
              if (!e.end.isAtEnd) {
                t.split(e.end)
              }
              const n = t.createPositionAfter(e.end.parent)
              t.move(e, n)
            })
        }
        _applyQuote(t, e) {
          const n = []
          GI(t, e)
            .reverse()
            .forEach((e) => {
              let o = WI(e.start)
              if (!o) {
                o = t.createElement('blockQuote')
                t.wrap(e, o)
              }
              n.push(o)
            })
          n.reverse().reduce((e, n) => {
            if (e.nextSibling == n) {
              t.merge(t.createPositionAfter(e))
              return e
            }
            return n
          })
        }
      }
      function WI(t) {
        return t.parent.name == 'blockQuote' ? t.parent : null
      }
      function GI(t, e) {
        let n
        let o = 0
        const i = []
        while (o < e.length) {
          const r = e[o]
          const s = e[o + 1]
          if (!n) {
            n = t.createPositionBefore(r)
          }
          if (!s || r.nextSibling != s) {
            i.push(t.createRange(n, t.createPositionAfter(r)))
            n = null
          }
          o++
        }
        return i
      }
      function qI(t, e) {
        const n = t.checkChild(e.parent, 'blockQuote')
        const o = t.checkChild(['$root', 'blockQuote'], e)
        return n && o
      }
      class $I extends Du {
        static get pluginName() {
          return 'BlockQuoteEditing'
        }
        static get requires() {
          return [zI, cT]
        }
        init() {
          const t = this.editor
          const e = t.model.schema
          t.commands.add('blockQuote', new UI(t))
          e.register('blockQuote', { inheritAllFrom: '$container' })
          t.conversion.elementToElement({ model: 'blockQuote', view: 'blockquote' })
          t.model.document.registerPostFixer((n) => {
            const o = t.model.document.differ.getChanges()
            for (const t of o) {
              if (t.type == 'insert') {
                const o = t.position.nodeAfter
                if (!o) {
                  continue
                }
                if (o.is('element', 'blockQuote') && o.isEmpty) {
                  n.remove(o)
                  return true
                } else if (o.is('element', 'blockQuote') && !e.checkChild(t.position, o)) {
                  n.unwrap(o)
                  return true
                } else if (o.is('element')) {
                  const t = n.createRangeIn(o)
                  for (const o of t.getItems()) {
                    if (o.is('element', 'blockQuote') && !e.checkChild(n.createPositionBefore(o), o)) {
                      n.unwrap(o)
                      return true
                    }
                  }
                }
              } else if (t.type == 'remove') {
                const e = t.position.parent
                if (e.is('element', 'blockQuote') && e.isEmpty) {
                  n.remove(e)
                  return true
                }
              }
            }
            return false
          })
          const n = this.editor.editing.view.document
          const o = t.model.document.selection
          const i = t.commands.get('blockQuote')
          this.listenTo(
            n,
            'enter',
            (e, n) => {
              if (!o.isCollapsed || !i.value) {
                return
              }
              const r = o.getLastPosition().parent
              if (r.isEmpty) {
                t.execute('blockQuote')
                t.editing.view.scrollToTheSelection()
                n.preventDefault()
                e.stop()
              }
            },
            { context: 'blockquote' },
          )
          this.listenTo(
            n,
            'delete',
            (e, n) => {
              if (n.direction != 'backward' || !o.isCollapsed || !i.value) {
                return
              }
              const r = o.getLastPosition().parent
              if (r.isEmpty && !r.previousSibling) {
                t.execute('blockQuote')
                t.editing.view.scrollToTheSelection()
                n.preventDefault()
                e.stop()
              }
            },
            { context: 'blockquote' },
          )
        }
      }
      var KI = n(3789)
      var YI = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      YI.insert = 'head'
      YI.singleton = true
      var ZI = Rl()(KI.Z, YI)
      const QI = KI.Z.locals || {}
      class JI extends Du {
        static get pluginName() {
          return 'BlockQuoteUI'
        }
        init() {
          const t = this.editor
          const e = t.t
          t.ui.componentFactory.add('blockQuote', (n) => {
            const o = t.commands.get('blockQuote')
            const i = new Dd(n)
            i.set({ label: e('Block quote'), icon: Sv.quote, tooltip: true, isToggleable: true })
            i.bind('isOn', 'isEnabled').to(o, 'value', 'isEnabled')
            this.listenTo(i, 'execute', () => {
              t.execute('blockQuote')
              t.editing.view.focus()
            })
            return i
          })
        }
      }
      class XI extends Du {
        static get requires() {
          return [$I, JI]
        }
        static get pluginName() {
          return 'BlockQuote'
        }
      }
      const tS = { autoRefresh: true }
      const eS = 36e5
      class nS extends ft() {
        constructor(t, e = {}) {
          super()
          if (!t) {
            throw new P('token-missing-token-url', this)
          }
          if (e.initValue) {
            this._validateTokenValue(e.initValue)
          }
          this.set('value', e.initValue)
          if (typeof t === 'function') {
            this._refresh = t
          } else {
            this._refresh = () => oS(t)
          }
          this._options = { ...tS, ...e }
        }
        init() {
          return new Promise((t, e) => {
            if (!this.value) {
              this.refreshToken().then(t).catch(e)
              return
            }
            if (this._options.autoRefresh) {
              this._registerRefreshTokenTimeout()
            }
            t(this)
          })
        }
        refreshToken() {
          return this._refresh().then((t) => {
            this._validateTokenValue(t)
            this.set('value', t)
            if (this._options.autoRefresh) {
              this._registerRefreshTokenTimeout()
            }
            return this
          })
        }
        destroy() {
          clearTimeout(this._tokenRefreshTimeout)
        }
        _validateTokenValue(t) {
          const e = typeof t === 'string'
          const n = !/^".*"$/.test(t)
          const o = e && t.split('.').length === 3
          if (!(n && o)) {
            throw new P('token-not-in-jwt-format', this)
          }
        }
        _registerRefreshTokenTimeout() {
          const t = this._getTokenRefreshTimeoutTime()
          clearTimeout(this._tokenRefreshTimeout)
          this._tokenRefreshTimeout = setTimeout(() => {
            this.refreshToken()
          }, t)
        }
        _getTokenRefreshTimeoutTime() {
          try {
            const [, t] = this.value.split('.')
            const { exp: e } = JSON.parse(atob(t))
            if (!e) {
              return eS
            }
            const n = Math.floor((e * 1e3 - Date.now()) / 2)
            return n
          } catch (t) {
            return eS
          }
        }
        static create(t, e = {}) {
          const n = new nS(t, e)
          return n.init()
        }
      }
      function oS(t) {
        return new Promise((e, n) => {
          const o = new XMLHttpRequest()
          o.open('GET', t)
          o.addEventListener('load', () => {
            const t = o.status
            const i = o.response
            if (t < 200 || t > 299) {
              return n(new P('token-cannot-download-new-token', null))
            }
            return e(i)
          })
          o.addEventListener('error', () => n(new Error('Network Error')))
          o.addEventListener('abort', () => n(new Error('Abort')))
          o.send()
        })
      }
      const iS = /^data:(\S*?);base64,/
      class rS extends K() {
        constructor(t, e, n) {
          super()
          if (!t) {
            throw new P('fileuploader-missing-file', null)
          }
          if (!e) {
            throw new P('fileuploader-missing-token', null)
          }
          if (!n) {
            throw new P('fileuploader-missing-api-address', null)
          }
          this.file = aS(t) ? sS(t) : t
          this._token = e
          this._apiAddress = n
        }
        onProgress(t) {
          this.on('progress', (e, n) => t(n))
          return this
        }
        onError(t) {
          this.once('error', (e, n) => t(n))
          return this
        }
        abort() {
          this.xhr.abort()
        }
        send() {
          this._prepareRequest()
          this._attachXHRListeners()
          return this._sendRequest()
        }
        _prepareRequest() {
          const t = new XMLHttpRequest()
          t.open('POST', this._apiAddress)
          t.setRequestHeader('Authorization', this._token.value)
          t.responseType = 'json'
          this.xhr = t
        }
        _attachXHRListeners() {
          const t = this.xhr
          const e = (t) => () => this.fire('error', t)
          t.addEventListener('error', e('Network Error'))
          t.addEventListener('abort', e('Abort'))
          if (t.upload) {
            t.upload.addEventListener('progress', (t) => {
              if (t.lengthComputable) {
                this.fire('progress', { total: t.total, uploaded: t.loaded })
              }
            })
          }
          t.addEventListener('load', () => {
            const e = t.status
            const n = t.response
            if (e < 200 || e > 299) {
              return this.fire('error', n.message || n.error)
            }
          })
        }
        _sendRequest() {
          const t = new FormData()
          const e = this.xhr
          t.append('file', this.file)
          return new Promise((n, o) => {
            e.addEventListener('load', () => {
              const t = e.status
              const i = e.response
              if (t < 200 || t > 299) {
                if (i.message) {
                  return o(new P('fileuploader-uploading-data-failed', this, { message: i.message }))
                }
                return o(i.error)
              }
              return n(i)
            })
            e.addEventListener('error', () => o(new Error('Network Error')))
            e.addEventListener('abort', () => o(new Error('Abort')))
            e.send(t)
          })
        }
      }
      function sS(t, e = 512) {
        try {
          const n = t.match(iS)[1]
          const o = atob(t.replace(iS, ''))
          const i = []
          for (let t = 0; t < o.length; t += e) {
            const n = o.slice(t, t + e)
            const r = new Array(n.length)
            for (let t = 0; t < n.length; t++) {
              r[t] = n.charCodeAt(t)
            }
            i.push(new Uint8Array(r))
          }
          return new Blob(i, { type: n })
        } catch (t) {
          throw new P('fileuploader-decoding-image-data-error', null)
        }
      }
      function aS(t) {
        if (typeof t !== 'string') {
          return false
        }
        const e = t.match(iS)
        return !!(e && e.length)
      }
      class cS {
        constructor(t, e) {
          if (!t) {
            throw new P('uploadgateway-missing-token', null)
          }
          if (!e) {
            throw new P('uploadgateway-missing-api-address', null)
          }
          this._token = t
          this._apiAddress = e
        }
        upload(t) {
          return new rS(t, this._token, this._apiAddress)
        }
      }
      class lS extends Pu {
        static get pluginName() {
          return 'CloudServicesCore'
        }
        createToken(t, e) {
          return new nS(t, e)
        }
        createUploadGateway(t, e) {
          return new cS(t, e)
        }
      }
      class dS extends Pu {
        constructor() {
          super(...arguments)
          this.token = null
          this._tokens = new Map()
        }
        static get pluginName() {
          return 'CloudServices'
        }
        static get requires() {
          return [lS]
        }
        async init() {
          const t = this.context.config
          const e = t.get('cloudServices') || {}
          for (const [t, n] of Object.entries(e)) {
            this[t] = n
          }
          if (!this.tokenUrl) {
            this.token = null
            return
          }
          const n = this.context.plugins.get('CloudServicesCore')
          this.token = await n.createToken(this.tokenUrl).init()
          this._tokens.set(this.tokenUrl, this.token)
        }
        async registerTokenUrl(t) {
          if (this._tokens.has(t)) {
            return this.getTokenFor(t)
          }
          const e = this.context.plugins.get('CloudServicesCore')
          const n = await e.createToken(t).init()
          this._tokens.set(t, n)
          return n
        }
        getTokenFor(t) {
          const e = this._tokens.get(t)
          if (!e) {
            throw new P('cloudservices-token-not-registered', this)
          }
          return e
        }
        destroy() {
          super.destroy()
          for (const t of this._tokens.values()) {
            t.destroy()
          }
        }
      }
      class uS extends Lm {
        constructor(t) {
          super(t)
          this.domEventType = [
            'paste',
            'copy',
            'cut',
            'drop',
            'dragover',
            'dragstart',
            'dragend',
            'dragenter',
            'dragleave',
          ]
          const e = this.document
          this.listenTo(e, 'paste', n('clipboardInput'), { priority: 'low' })
          this.listenTo(e, 'drop', n('clipboardInput'), { priority: 'low' })
          this.listenTo(e, 'dragover', n('dragging'), { priority: 'low' })
          function n(t) {
            return (n, o) => {
              o.preventDefault()
              const i = o.dropRange ? [o.dropRange] : null
              const r = new D(e, t)
              e.fire(r, {
                dataTransfer: o.dataTransfer,
                method: n.name,
                targetRanges: i,
                target: o.target,
                domEvent: o.domEvent,
              })
              if (r.stop.called) {
                o.stopPropagation()
              }
            }
          }
        }
        onDomEvent(t) {
          const e = 'clipboardData' in t ? t.clipboardData : t.dataTransfer
          const n = t.type == 'drop' || t.type == 'paste'
          const o = { dataTransfer: new cb(e, { cacheFiles: n }) }
          if (t.type == 'drop' || t.type == 'dragover') {
            o.dropRange = hS(this.view, t)
          }
          this.fire(t.type, t, o)
        }
      }
      function hS(t, e) {
        const n = e.target.ownerDocument
        const o = e.clientX
        const i = e.clientY
        let r
        if (n.caretRangeFromPoint && n.caretRangeFromPoint(o, i)) {
          r = n.caretRangeFromPoint(o, i)
        } else if (e.rangeParent) {
          r = n.createRange()
          r.setStart(e.rangeParent, e.rangeOffset)
          r.collapse(true)
        }
        if (r) {
          return t.domConverter.domRangeToView(r)
        }
        return null
      }
      function gS(t) {
        t = t
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/\r?\n\r?\n/g, '</p><p>')
          .replace(/\r?\n/g, '<br>')
          .replace(/\t/g, '&nbsp;&nbsp;&nbsp;&nbsp;')
          .replace(/^\s/, '&nbsp;')
          .replace(/\s$/, '&nbsp;')
          .replace(/\s\s/g, ' &nbsp;')
        if (t.includes('</p><p>') || t.includes('<br>')) {
          t = `<p>${t}</p>`
        }
        return t
      }
      function fS(t) {
        return t
          .replace(/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g, (t, e) => {
            if (e.length == 1) {
              return ' '
            }
            return e
          })
          .replace(/<!--[\s\S]*?-->/g, '')
      }
      const mS = ['figcaption', 'li']
      function pS(t) {
        let e = ''
        if (t.is('$text') || t.is('$textProxy')) {
          e = t.data
        } else if (t.is('element', 'img') && t.hasAttribute('alt')) {
          e = t.getAttribute('alt')
        } else if (t.is('element', 'br')) {
          e = '\n'
        } else {
          let n = null
          for (const o of t.getChildren()) {
            const t = pS(o)
            if (n && (n.is('containerElement') || o.is('containerElement'))) {
              if (mS.includes(n.name) || mS.includes(o.name)) {
                e += '\n'
              } else {
                e += '\n\n'
              }
            }
            e += t
            n = o
          }
        }
        return e
      }
      class bS extends Du {
        static get pluginName() {
          return 'ClipboardPipeline'
        }
        init() {
          const t = this.editor
          const e = t.editing.view
          e.addObserver(uS)
          this._setupPasteDrop()
          this._setupCopyCut()
        }
        _setupPasteDrop() {
          const t = this.editor
          const e = t.model
          const n = t.editing.view
          const o = n.document
          this.listenTo(
            o,
            'clipboardInput',
            (e, n) => {
              if (n.method == 'paste' && !t.model.canEditAt(t.model.document.selection)) {
                e.stop()
              }
            },
            { priority: 'highest' },
          )
          this.listenTo(
            o,
            'clipboardInput',
            (t, e) => {
              const o = e.dataTransfer
              let i
              if (e.content) {
                i = e.content
              } else {
                let t = ''
                if (o.getData('text/html')) {
                  t = fS(o.getData('text/html'))
                } else if (o.getData('text/plain')) {
                  t = gS(o.getData('text/plain'))
                }
                i = this.editor.data.htmlProcessor.toView(t)
              }
              const r = new D(this, 'inputTransformation')
              this.fire(r, { content: i, dataTransfer: o, targetRanges: e.targetRanges, method: e.method })
              if (r.stop.called) {
                t.stop()
              }
              n.scrollToTheSelection()
            },
            { priority: 'low' },
          )
          this.listenTo(
            this,
            'inputTransformation',
            (t, n) => {
              if (n.content.isEmpty) {
                return
              }
              const o = this.editor.data
              const i = o.toModel(n.content, '$clipboardHolder')
              if (i.childCount == 0) {
                return
              }
              t.stop()
              e.change(() => {
                this.fire('contentInsertion', {
                  content: i,
                  method: n.method,
                  dataTransfer: n.dataTransfer,
                  targetRanges: n.targetRanges,
                })
              })
            },
            { priority: 'low' },
          )
          this.listenTo(
            this,
            'contentInsertion',
            (t, n) => {
              n.resultRange = e.insertContent(n.content)
            },
            { priority: 'low' },
          )
        }
        _setupCopyCut() {
          const t = this.editor
          const e = t.model.document
          const n = t.editing.view
          const o = n.document
          const i = (n, i) => {
            const r = i.dataTransfer
            i.preventDefault()
            const s = t.data.toView(t.model.getSelectedContent(e.selection))
            o.fire('clipboardOutput', { dataTransfer: r, content: s, method: n.name })
          }
          this.listenTo(o, 'copy', i, { priority: 'low' })
          this.listenTo(
            o,
            'cut',
            (e, n) => {
              if (!t.model.canEditAt(t.model.document.selection)) {
                n.preventDefault()
              } else {
                i(e, n)
              }
            },
            { priority: 'low' },
          )
          this.listenTo(
            o,
            'clipboardOutput',
            (n, o) => {
              if (!o.content.isEmpty) {
                o.dataTransfer.setData('text/html', this.editor.data.htmlProcessor.toData(o.content))
                o.dataTransfer.setData('text/plain', pS(o.content))
              }
              if (o.method == 'cut') {
                t.model.deleteContent(e.selection)
              }
            },
            { priority: 'low' },
          )
        }
      }
      class kS extends K() {
        constructor() {
          super(...arguments)
          this._stack = []
        }
        add(t, e) {
          const n = this._stack
          const o = n[0]
          this._insertDescriptor(t)
          const i = n[0]
          if (o !== i && !wS(o, i)) {
            this.fire('change:top', { oldDescriptor: o, newDescriptor: i, writer: e })
          }
        }
        remove(t, e) {
          const n = this._stack
          const o = n[0]
          this._removeDescriptor(t)
          const i = n[0]
          if (o !== i && !wS(o, i)) {
            this.fire('change:top', { oldDescriptor: o, newDescriptor: i, writer: e })
          }
        }
        _insertDescriptor(t) {
          const e = this._stack
          const n = e.findIndex((e) => e.id === t.id)
          if (wS(t, e[n])) {
            return
          }
          if (n > -1) {
            e.splice(n, 1)
          }
          let o = 0
          while (e[o] && AS(e[o], t)) {
            o++
          }
          e.splice(o, 0, t)
        }
        _removeDescriptor(t) {
          const e = this._stack
          const n = e.findIndex((e) => e.id === t)
          if (n > -1) {
            e.splice(n, 1)
          }
        }
      }
      function wS(t, e) {
        return t && e && t.priority == e.priority && _S(t.classes) == _S(e.classes)
      }
      function AS(t, e) {
        if (t.priority > e.priority) {
          return true
        } else if (t.priority < e.priority) {
          return false
        }
        return _S(t.classes) > _S(e.classes)
      }
      function _S(t) {
        return Array.isArray(t) ? t.sort().join(',') : t
      }
      const CS =
        '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M4 0v1H1v3H0V.5A.5.5 0 0 1 .5 0H4zm8 0h3.5a.5.5 0 0 1 .5.5V4h-1V1h-3V0zM4 16H.5a.5.5 0 0 1-.5-.5V12h1v3h3v1zm8 0v-1h3v-3h1v3.5a.5.5 0 0 1-.5.5H12z"/><path fill-opacity=".256" d="M1 1h14v14H1z"/><g class="ck-icon__selected-indicator"><path d="M7 0h2v1H7V0zM0 7h1v2H0V7zm15 0h1v2h-1V7zm-8 8h2v1H7v-1z"/><path fill-opacity=".254" d="M1 1h14v14H1z"/></g></svg>'
      const vS = 'ck-widget'
      const yS = 'ck-widget_selected'
      function xS(t) {
        if (!t.is('element')) {
          return false
        }
        return !!t.getCustomProperty('widget')
      }
      function ES(t, e, n = {}) {
        if (!t.is('containerElement')) {
          throw new P('widget-to-widget-wrong-element-type', null, { element: t })
        }
        e.setAttribute('contenteditable', 'false', t)
        e.addClass(vS, t)
        e.setCustomProperty('widget', true, t)
        t.getFillerOffset = LS
        e.setCustomProperty('widgetLabel', [], t)
        if (n.label) {
          SS(t, n.label)
        }
        if (n.hasSelectionHandle) {
          zS(t, e)
        }
        IS(t, e)
        return t
      }
      function DS(t, e, n) {
        if (e.classes) {
          n.addClass(sl(e.classes), t)
        }
        if (e.attributes) {
          for (const o in e.attributes) {
            n.setAttribute(o, e.attributes[o], t)
          }
        }
      }
      function TS(t, e, n) {
        if (e.classes) {
          n.removeClass(sl(e.classes), t)
        }
        if (e.attributes) {
          for (const o in e.attributes) {
            n.removeAttribute(o, t)
          }
        }
      }
      function IS(t, e, n = DS, o = TS) {
        const i = new kS()
        i.on('change:top', (e, i) => {
          if (i.oldDescriptor) {
            o(t, i.oldDescriptor, i.writer)
          }
          if (i.newDescriptor) {
            n(t, i.newDescriptor, i.writer)
          }
        })
        const r = (t, e, n) => i.add(e, n)
        const s = (t, e, n) => i.remove(e, n)
        e.setCustomProperty('addHighlight', r, t)
        e.setCustomProperty('removeHighlight', s, t)
      }
      function SS(t, e) {
        const n = t.getCustomProperty('widgetLabel')
        n.push(e)
      }
      function MS(t) {
        const e = t.getCustomProperty('widgetLabel')
        return e.reduce((t, e) => {
          if (typeof e === 'function') {
            return t ? t + '. ' + e() : e()
          } else {
            return t ? t + '. ' + e : e
          }
        }, '')
      }
      function BS(t, e, n = {}) {
        e.addClass(['ck-editor__editable', 'ck-editor__nested-editable'], t)
        e.setAttribute('role', 'textbox', t)
        if (n.label) {
          e.setAttribute('aria-label', n.label, t)
        }
        e.setAttribute('contenteditable', t.isReadOnly ? 'false' : 'true', t)
        t.on('change:isReadOnly', (n, o, i) => {
          e.setAttribute('contenteditable', i ? 'false' : 'true', t)
        })
        t.on('change:isFocused', (n, o, i) => {
          if (i) {
            e.addClass('ck-editor__nested-editable_focused', t)
          } else {
            e.removeClass('ck-editor__nested-editable_focused', t)
          }
        })
        IS(t, e)
        return t
      }
      function NS(t, e) {
        const n = t.getSelectedElement()
        if (n) {
          const o = HS(t)
          if (o) {
            return e.createRange(e.createPositionAt(n, o))
          }
        }
        return P_(t, e)
      }
      function PS(t, e) {
        return (n, o) => {
          const { mapper: i, viewPosition: r } = o
          const s = i.findMappedViewAncestor(r)
          if (!e(s)) {
            return
          }
          const a = i.toModelElement(s)
          o.modelPosition = t.createPositionAt(a, r.isAtStart ? 'before' : 'after')
        }
      }
      function LS() {
        return null
      }
      function zS(t, e) {
        const n = e.createUIElement('div', { class: 'ck ck-widget__selection-handle' }, function (t) {
          const e = this.toDomElement(t)
          const n = new Cd()
          n.set('content', CS)
          n.render()
          e.appendChild(n.element)
          return e
        })
        e.insert(e.createPositionAt(t, 0), n)
        e.addClass(['ck-widget_with-selection-handle'], t)
      }
      const RS = 'widget-type-around'
      function OS(t, e, n) {
        return !!t && xS(t) && !n.isInline(e)
      }
      function VS(t) {
        return t.closest('.ck-widget__type-around__button')
      }
      function FS(t) {
        return t.classList.contains('ck-widget__type-around__button_before') ? 'before' : 'after'
      }
      function jS(t, e) {
        const n = t.closest('.ck-widget')
        return e.mapDomToView(n)
      }
      function HS(t) {
        return t.getAttribute(RS)
      }
      const US =
        '<svg viewBox="0 0 10 8" xmlns="http://www.w3.org/2000/svg"><path d="M9.055.263v3.972h-6.77M1 4.216l2-2.038m-2 2 2 2.038"/></svg>'
      var WS = n(2347)
      var GS = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      GS.insert = 'head'
      GS.singleton = true
      var qS = Rl()(WS.Z, GS)
      const $S = WS.Z.locals || {}
      const KS = ['before', 'after']
      const YS = new DOMParser().parseFromString(US, 'image/svg+xml').firstChild
      const ZS = 'ck-widget__type-around_disabled'
      class QS extends Du {
        constructor() {
          super(...arguments)
          this._currentFakeCaretModelElement = null
        }
        static get pluginName() {
          return 'WidgetTypeAround'
        }
        static get requires() {
          return [zI, cT]
        }
        init() {
          const t = this.editor
          const e = t.editing.view
          this.on('change:isEnabled', (n, o, i) => {
            e.change((t) => {
              for (const n of e.document.roots) {
                if (i) {
                  t.removeClass(ZS, n)
                } else {
                  t.addClass(ZS, n)
                }
              }
            })
            if (!i) {
              t.model.change((t) => {
                t.removeSelectionAttribute(RS)
              })
            }
          })
          this._enableTypeAroundUIInjection()
          this._enableInsertingParagraphsOnButtonClick()
          this._enableInsertingParagraphsOnEnterKeypress()
          this._enableInsertingParagraphsOnTypingKeystroke()
          this._enableTypeAroundFakeCaretActivationUsingKeyboardArrows()
          this._enableDeleteIntegration()
          this._enableInsertContentIntegration()
          this._enableInsertObjectIntegration()
          this._enableDeleteContentIntegration()
        }
        destroy() {
          super.destroy()
          this._currentFakeCaretModelElement = null
        }
        _insertParagraph(t, e) {
          const n = this.editor
          const o = n.editing.view
          const i = n.model.schema.getAttributesWithProperty(t, 'copyOnReplace', true)
          n.execute('insertParagraph', { position: n.model.createPositionAt(t, e), attributes: i })
          o.focus()
          o.scrollToTheSelection()
        }
        _listenToIfEnabled(t, e, n, o) {
          this.listenTo(
            t,
            e,
            (...t) => {
              if (this.isEnabled) {
                n(...t)
              }
            },
            o,
          )
        }
        _insertParagraphAccordingToFakeCaretPosition() {
          const t = this.editor
          const e = t.model
          const n = e.document.selection
          const o = HS(n)
          if (!o) {
            return false
          }
          const i = n.getSelectedElement()
          this._insertParagraph(i, o)
          return true
        }
        _enableTypeAroundUIInjection() {
          const t = this.editor
          const e = t.model.schema
          const n = t.locale.t
          const o = { before: n('Insert paragraph before block'), after: n('Insert paragraph after block') }
          t.editing.downcastDispatcher.on(
            'insert',
            (t, i, r) => {
              const s = r.mapper.toViewElement(i.item)
              if (!s) {
                return
              }
              if (OS(s, i.item, e)) {
                JS(r.writer, o, s)
                const t = s.getCustomProperty('widgetLabel')
                t.push(() =>
                  this.isEnabled ? n('Press Enter to type after or press Shift + Enter to type before the widget') : '',
                )
              }
            },
            { priority: 'low' },
          )
        }
        _enableTypeAroundFakeCaretActivationUsingKeyboardArrows() {
          const t = this.editor
          const e = t.model
          const n = e.document.selection
          const o = e.schema
          const i = t.editing.view
          this._listenToIfEnabled(
            i.document,
            'arrowKey',
            (t, e) => {
              this._handleArrowKeyPress(t, e)
            },
            { context: [xS, '$text'], priority: 'high' },
          )
          this._listenToIfEnabled(n, 'change:range', (e, n) => {
            if (!n.directChange) {
              return
            }
            t.model.change((t) => {
              t.removeSelectionAttribute(RS)
            })
          })
          this._listenToIfEnabled(e.document, 'change:data', () => {
            const e = n.getSelectedElement()
            if (e) {
              const n = t.editing.mapper.toViewElement(e)
              if (OS(n, e, o)) {
                return
              }
            }
            t.model.change((t) => {
              t.removeSelectionAttribute(RS)
            })
          })
          this._listenToIfEnabled(t.editing.downcastDispatcher, 'selection', (t, e, n) => {
            const i = n.writer
            if (this._currentFakeCaretModelElement) {
              const t = n.mapper.toViewElement(this._currentFakeCaretModelElement)
              if (t) {
                i.removeClass(KS.map(r), t)
                this._currentFakeCaretModelElement = null
              }
            }
            const s = e.selection.getSelectedElement()
            if (!s) {
              return
            }
            const a = n.mapper.toViewElement(s)
            if (!OS(a, s, o)) {
              return
            }
            const c = HS(e.selection)
            if (!c) {
              return
            }
            i.addClass(r(c), a)
            this._currentFakeCaretModelElement = s
          })
          this._listenToIfEnabled(t.ui.focusTracker, 'change:isFocused', (e, n, o) => {
            if (!o) {
              t.model.change((t) => {
                t.removeSelectionAttribute(RS)
              })
            }
          })
          function r(t) {
            return `ck-widget_type-around_show-fake-caret_${t}`
          }
        }
        _handleArrowKeyPress(t, e) {
          const n = this.editor
          const o = n.model
          const i = o.document.selection
          const r = o.schema
          const s = n.editing.view
          const a = e.keyCode
          const c = ol(a, n.locale.contentLanguageDirection)
          const l = s.document.selection.getSelectedElement()
          const d = n.editing.mapper.toModelElement(l)
          let u
          if (OS(l, d, r)) {
            u = this._handleArrowKeyPressOnSelectedWidget(c)
          } else if (i.isCollapsed) {
            u = this._handleArrowKeyPressWhenSelectionNextToAWidget(c)
          } else if (!e.shiftKey) {
            u = this._handleArrowKeyPressWhenNonCollapsedSelection(c)
          }
          if (u) {
            e.preventDefault()
            t.stop()
          }
        }
        _handleArrowKeyPressOnSelectedWidget(t) {
          const e = this.editor
          const n = e.model
          const o = n.document.selection
          const i = HS(o)
          return n.change((e) => {
            if (i) {
              const n = i === (t ? 'after' : 'before')
              if (!n) {
                e.removeSelectionAttribute(RS)
                return true
              }
            } else {
              e.setSelectionAttribute(RS, t ? 'after' : 'before')
              return true
            }
            return false
          })
        }
        _handleArrowKeyPressWhenSelectionNextToAWidget(t) {
          const e = this.editor
          const n = e.model
          const o = n.schema
          const i = e.plugins.get('Widget')
          const r = i._getObjectElementNextToSelection(t)
          const s = e.editing.mapper.toViewElement(r)
          if (OS(s, r, o)) {
            n.change((e) => {
              i._setSelectionOverElement(r)
              e.setSelectionAttribute(RS, t ? 'before' : 'after')
            })
            return true
          }
          return false
        }
        _handleArrowKeyPressWhenNonCollapsedSelection(t) {
          const e = this.editor
          const n = e.model
          const o = n.schema
          const i = e.editing.mapper
          const r = n.document.selection
          const s = t ? r.getLastPosition().nodeBefore : r.getFirstPosition().nodeAfter
          const a = i.toViewElement(s)
          if (OS(a, s, o)) {
            n.change((e) => {
              e.setSelection(s, 'on')
              e.setSelectionAttribute(RS, t ? 'after' : 'before')
            })
            return true
          }
          return false
        }
        _enableInsertingParagraphsOnButtonClick() {
          const t = this.editor
          const e = t.editing.view
          this._listenToIfEnabled(e.document, 'mousedown', (n, o) => {
            const i = VS(o.domTarget)
            if (!i) {
              return
            }
            const r = FS(i)
            const s = jS(i, e.domConverter)
            const a = t.editing.mapper.toModelElement(s)
            this._insertParagraph(a, r)
            o.preventDefault()
            n.stop()
          })
        }
        _enableInsertingParagraphsOnEnterKeypress() {
          const t = this.editor
          const e = t.model.document.selection
          const n = t.editing.view
          this._listenToIfEnabled(
            n.document,
            'enter',
            (n, o) => {
              if (n.eventPhase != 'atTarget') {
                return
              }
              const i = e.getSelectedElement()
              const r = t.editing.mapper.toViewElement(i)
              const s = t.model.schema
              let a
              if (this._insertParagraphAccordingToFakeCaretPosition()) {
                a = true
              } else if (OS(r, i, s)) {
                this._insertParagraph(i, o.isSoft ? 'before' : 'after')
                a = true
              }
              if (a) {
                o.preventDefault()
                n.stop()
              }
            },
            { context: xS },
          )
        }
        _enableInsertingParagraphsOnTypingKeystroke() {
          const t = this.editor
          const e = t.editing.view.document
          this._listenToIfEnabled(
            e,
            'insertText',
            (t, n) => {
              if (this._insertParagraphAccordingToFakeCaretPosition()) {
                n.selection = e.selection
              }
            },
            { priority: 'high' },
          )
          if (l.isAndroid) {
            this._listenToIfEnabled(e, 'keydown', (t, e) => {
              if (e.keyCode == 229) {
                this._insertParagraphAccordingToFakeCaretPosition()
              }
            })
          } else {
            this._listenToIfEnabled(
              e,
              'compositionstart',
              () => {
                this._insertParagraphAccordingToFakeCaretPosition()
              },
              { priority: 'high' },
            )
          }
        }
        _enableDeleteIntegration() {
          const t = this.editor
          const e = t.editing.view
          const n = t.model
          const o = n.schema
          this._listenToIfEnabled(
            e.document,
            'delete',
            (e, i) => {
              if (e.eventPhase != 'atTarget') {
                return
              }
              const r = HS(n.document.selection)
              if (!r) {
                return
              }
              const s = i.direction
              const a = n.document.selection.getSelectedElement()
              const c = r === 'before'
              const l = s == 'forward'
              const d = c === l
              if (d) {
                t.execute('delete', { selection: n.createSelection(a, 'on') })
              } else {
                const e = o.getNearestSelectionRange(n.createPositionAt(a, r), s)
                if (e) {
                  if (!e.isCollapsed) {
                    n.change((n) => {
                      n.setSelection(e)
                      t.execute(l ? 'deleteForward' : 'delete')
                    })
                  } else {
                    const i = n.createSelection(e.start)
                    n.modifySelection(i, { direction: s })
                    if (!i.focus.isEqual(e.start)) {
                      n.change((n) => {
                        n.setSelection(e)
                        t.execute(l ? 'deleteForward' : 'delete')
                      })
                    } else {
                      const t = eM(o, e.start.parent)
                      n.deleteContent(n.createSelection(t, 'on'), { doNotAutoparagraph: true })
                    }
                  }
                }
              }
              i.preventDefault()
              e.stop()
            },
            { context: xS },
          )
        }
        _enableInsertContentIntegration() {
          const t = this.editor
          const e = this.editor.model
          const n = e.document.selection
          this._listenToIfEnabled(
            t.model,
            'insertContent',
            (t, [o, i]) => {
              if (i && !i.is('documentSelection')) {
                return
              }
              const r = HS(n)
              if (!r) {
                return
              }
              t.stop()
              return e.change((t) => {
                const i = n.getSelectedElement()
                const s = e.createPositionAt(i, r)
                const a = t.createSelection(s)
                const c = e.insertContent(o, a)
                t.setSelection(a)
                return c
              })
            },
            { priority: 'high' },
          )
        }
        _enableInsertObjectIntegration() {
          const t = this.editor
          const e = this.editor.model
          const n = e.document.selection
          this._listenToIfEnabled(
            t.model,
            'insertObject',
            (t, e) => {
              const [, o, i = {}] = e
              if (o && !o.is('documentSelection')) {
                return
              }
              const r = HS(n)
              if (!r) {
                return
              }
              i.findOptimalPosition = r
              e[3] = i
            },
            { priority: 'high' },
          )
        }
        _enableDeleteContentIntegration() {
          const t = this.editor
          const e = this.editor.model
          const n = e.document.selection
          this._listenToIfEnabled(
            t.model,
            'deleteContent',
            (t, [e]) => {
              if (e && !e.is('documentSelection')) {
                return
              }
              const o = HS(n)
              if (o) {
                t.stop()
              }
            },
            { priority: 'high' },
          )
        }
      }
      function JS(t, e, n) {
        const o = t.createUIElement('div', { class: 'ck ck-reset_all ck-widget__type-around' }, function (t) {
          const n = this.toDomElement(t)
          XS(n, e)
          tM(n)
          return n
        })
        t.insert(t.createPositionAt(n, 'end'), o)
      }
      function XS(t, e) {
        for (const n of KS) {
          const o = new Wl({
            tag: 'div',
            attributes: {
              class: ['ck', 'ck-widget__type-around__button', `ck-widget__type-around__button_${n}`],
              title: e[n],
              'aria-hidden': 'true',
            },
            children: [t.ownerDocument.importNode(YS, true)],
          })
          t.appendChild(o.render())
        }
      }
      function tM(t) {
        const e = new Wl({ tag: 'div', attributes: { class: ['ck', 'ck-widget__type-around__fake-caret'] } })
        t.appendChild(e.render())
      }
      function eM(t, e) {
        let n = e
        for (const o of e.getAncestors({ parentFirst: true })) {
          if (o.childCount > 1 || t.isLimit(o)) {
            break
          }
          n = o
        }
        return n
      }
      function nM(t) {
        const e = t.model
        return (n, o) => {
          const i = o.keyCode == Yc.arrowup
          const r = o.keyCode == Yc.arrowdown
          const s = o.shiftKey
          const a = e.document.selection
          if (!i && !r) {
            return
          }
          const c = r
          if (s && aM(a, c)) {
            return
          }
          const l = oM(t, a, c)
          if (!l) {
            return
          }
          if (l.isCollapsed) {
            if (a.isCollapsed) {
              return
            } else if (s) {
              return
            }
          }
          if (l.isCollapsed || sM(t, l, c)) {
            e.change((t) => {
              const n = c ? l.end : l.start
              if (s) {
                const o = e.createSelection(a.anchor)
                o.setFocus(n)
                t.setSelection(o)
              } else {
                t.setSelection(n)
              }
            })
            n.stop()
            o.preventDefault()
            o.stopPropagation()
          }
        }
      }
      function oM(t, e, n) {
        const o = t.model
        if (n) {
          const t = e.isCollapsed ? e.focus : e.getLastPosition()
          const n = iM(o, t, 'forward')
          if (!n) {
            return null
          }
          const i = o.createRange(t, n)
          const r = rM(o.schema, i, 'backward')
          if (r) {
            return o.createRange(t, r)
          }
          return null
        } else {
          const t = e.isCollapsed ? e.focus : e.getFirstPosition()
          const n = iM(o, t, 'backward')
          if (!n) {
            return null
          }
          const i = o.createRange(n, t)
          const r = rM(o.schema, i, 'forward')
          if (r) {
            return o.createRange(r, t)
          }
          return null
        }
      }
      function iM(t, e, n) {
        const o = t.schema
        const i = t.createRangeIn(e.root)
        const r = n == 'forward' ? 'elementStart' : 'elementEnd'
        for (const { previousPosition: t, item: s, type: a } of i.getWalker({ startPosition: e, direction: n })) {
          if (o.isLimit(s) && !o.isInline(s)) {
            return t
          }
          if (a == r && o.isBlock(s)) {
            return null
          }
        }
        return null
      }
      function rM(t, e, n) {
        const o = n == 'backward' ? e.end : e.start
        if (t.checkChild(o, '$text')) {
          return o
        }
        for (const { nextPosition: o } of e.getWalker({ direction: n })) {
          if (t.checkChild(o, '$text')) {
            return o
          }
        }
        return null
      }
      function sM(t, e, n) {
        const o = t.model
        const i = t.view.domConverter
        if (n) {
          const t = o.createSelection(e.start)
          o.modifySelection(t)
          if (!t.focus.isAtEnd && !e.start.isEqual(t.focus)) {
            e = o.createRange(t.focus, e.end)
          }
        }
        const r = t.mapper.toViewRange(e)
        const s = i.viewRangeToDom(r)
        const a = dc.getDomRangeRects(s)
        let c
        for (const t of a) {
          if (c === undefined) {
            c = Math.round(t.bottom)
            continue
          }
          if (Math.round(t.top) >= c) {
            return false
          }
          c = Math.max(c, Math.round(t.bottom))
        }
        return true
      }
      function aM(t, e) {
        return !t.isCollapsed && t.isBackward == e
      }
      var cM = n(7153)
      var lM = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      lM.insert = 'head'
      lM.singleton = true
      var dM = Rl()(cM.Z, lM)
      const uM = cM.Z.locals || {}
      class hM extends Du {
        constructor() {
          super(...arguments)
          this._previouslySelected = new Set()
        }
        static get pluginName() {
          return 'Widget'
        }
        static get requires() {
          return [QS, cT]
        }
        init() {
          const t = this.editor
          const e = t.editing.view
          const n = e.document
          this.editor.editing.downcastDispatcher.on('selection', (e, n, o) => {
            const i = o.writer
            const r = n.selection
            if (r.isCollapsed) {
              return
            }
            const s = r.getSelectedElement()
            if (!s) {
              return
            }
            const a = t.editing.mapper.toViewElement(s)
            if (!xS(a)) {
              return
            }
            if (!o.consumable.consume(r, 'selection')) {
              return
            }
            i.setSelection(i.createRangeOn(a), { fake: true, label: MS(a) })
          })
          this.editor.editing.downcastDispatcher.on(
            'selection',
            (t, e, n) => {
              this._clearPreviouslySelectedWidgets(n.writer)
              const o = n.writer
              const i = o.document.selection
              let r = null
              for (const t of i.getRanges()) {
                for (const e of t) {
                  const t = e.item
                  if (xS(t) && !fM(t, r)) {
                    o.addClass(yS, t)
                    this._previouslySelected.add(t)
                    r = t
                  }
                }
              }
            },
            { priority: 'low' },
          )
          e.addObserver(K_)
          this.listenTo(n, 'mousedown', (...t) => this._onMousedown(...t))
          this.listenTo(
            n,
            'arrowKey',
            (...t) => {
              this._handleSelectionChangeOnArrowKeyPress(...t)
            },
            { context: [xS, '$text'] },
          )
          this.listenTo(
            n,
            'arrowKey',
            (...t) => {
              this._preventDefaultOnArrowKeyPress(...t)
            },
            { context: '$root' },
          )
          this.listenTo(n, 'arrowKey', nM(this.editor.editing), { context: '$text' })
          this.listenTo(
            n,
            'delete',
            (t, e) => {
              if (this._handleDelete(e.direction == 'forward')) {
                e.preventDefault()
                t.stop()
              }
            },
            { context: '$root' },
          )
        }
        _onMousedown(t, e) {
          const n = this.editor
          const o = n.editing.view
          const i = o.document
          let r = e.target
          if (gM(r)) {
            if ((l.isSafari || l.isGecko) && e.domEvent.detail >= 3) {
              const t = n.editing.mapper
              const o = r.is('attributeElement') ? r.findAncestor((t) => !t.is('attributeElement')) : r
              const i = t.toModelElement(o)
              e.preventDefault()
              this.editor.model.change((t) => {
                t.setSelection(i, 'in')
              })
            }
            return
          }
          if (!xS(r)) {
            r = r.findAncestor(xS)
            if (!r) {
              return
            }
          }
          if (l.isAndroid) {
            e.preventDefault()
          }
          if (!i.isFocused) {
            o.focus()
          }
          const s = n.editing.mapper.toModelElement(r)
          this._setSelectionOverElement(s)
        }
        _handleSelectionChangeOnArrowKeyPress(t, e) {
          const n = e.keyCode
          const o = this.editor.model
          const i = o.schema
          const r = o.document.selection
          const s = r.getSelectedElement()
          const a = el(n, this.editor.locale.contentLanguageDirection)
          const c = a == 'down' || a == 'right'
          const l = a == 'up' || a == 'down'
          if (s && i.isObject(s)) {
            const n = c ? r.getLastPosition() : r.getFirstPosition()
            const s = i.getNearestSelectionRange(n, c ? 'forward' : 'backward')
            if (s) {
              o.change((t) => {
                t.setSelection(s)
              })
              e.preventDefault()
              t.stop()
            }
            return
          }
          if (!r.isCollapsed && !e.shiftKey) {
            const n = r.getFirstPosition()
            const s = r.getLastPosition()
            const a = n.nodeAfter
            const l = s.nodeBefore
            if ((a && i.isObject(a)) || (l && i.isObject(l))) {
              o.change((t) => {
                t.setSelection(c ? s : n)
              })
              e.preventDefault()
              t.stop()
            }
            return
          }
          if (!r.isCollapsed) {
            return
          }
          const d = this._getObjectElementNextToSelection(c)
          if (d && i.isObject(d)) {
            if (i.isInline(d) && l) {
              return
            }
            this._setSelectionOverElement(d)
            e.preventDefault()
            t.stop()
          }
        }
        _preventDefaultOnArrowKeyPress(t, e) {
          const n = this.editor.model
          const o = n.schema
          const i = n.document.selection.getSelectedElement()
          if (i && o.isObject(i)) {
            e.preventDefault()
            t.stop()
          }
        }
        _handleDelete(t) {
          const e = this.editor.model.document
          const n = e.selection
          if (!this.editor.model.canEditAt(n)) {
            return
          }
          if (!n.isCollapsed) {
            return
          }
          const o = this._getObjectElementNextToSelection(t)
          if (o) {
            this.editor.model.change((t) => {
              let e = n.anchor.parent
              while (e.isEmpty) {
                const n = e
                e = n.parent
                t.remove(n)
              }
              this._setSelectionOverElement(o)
            })
            return true
          }
        }
        _setSelectionOverElement(t) {
          this.editor.model.change((e) => {
            e.setSelection(e.createRangeOn(t))
          })
        }
        _getObjectElementNextToSelection(t) {
          const e = this.editor.model
          const n = e.schema
          const o = e.document.selection
          const i = e.createSelection(o)
          e.modifySelection(i, { direction: t ? 'forward' : 'backward' })
          if (i.isEqual(o)) {
            return null
          }
          const r = t ? i.focus.nodeBefore : i.focus.nodeAfter
          if (!!r && n.isObject(r)) {
            return r
          }
          return null
        }
        _clearPreviouslySelectedWidgets(t) {
          for (const e of this._previouslySelected) {
            t.removeClass(yS, e)
          }
          this._previouslySelected.clear()
        }
      }
      function gM(t) {
        let e = t
        while (e) {
          if (e.is('editableElement') && !e.is('rootElement')) {
            return true
          }
          if (xS(e)) {
            return false
          }
          e = e.parent
        }
        return false
      }
      function fM(t, e) {
        if (!e) {
          return false
        }
        return Array.from(t.getAncestors()).includes(e)
      }
      class mM extends Du {
        constructor() {
          super(...arguments)
          this._toolbarDefinitions = new Map()
        }
        static get requires() {
          return [eD]
        }
        static get pluginName() {
          return 'WidgetToolbarRepository'
        }
        init() {
          const t = this.editor
          if (t.plugins.has('BalloonToolbar')) {
            const e = t.plugins.get('BalloonToolbar')
            this.listenTo(
              e,
              'show',
              (e) => {
                if (kM(t.editing.view.document.selection)) {
                  e.stop()
                }
              },
              { priority: 'high' },
            )
          }
          this._balloon = this.editor.plugins.get('ContextualBalloon')
          this.on('change:isEnabled', () => {
            this._updateToolbarsVisibility()
          })
          this.listenTo(t.ui, 'update', () => {
            this._updateToolbarsVisibility()
          })
          this.listenTo(
            t.ui.focusTracker,
            'change:isFocused',
            () => {
              this._updateToolbarsVisibility()
            },
            { priority: 'low' },
          )
        }
        destroy() {
          super.destroy()
          for (const t of this._toolbarDefinitions.values()) {
            t.view.destroy()
          }
        }
        register(t, { ariaLabel: e, items: n, getRelatedElement: o, balloonClassName: i = 'ck-toolbar-container' }) {
          if (!n.length) {
            L('widget-toolbar-no-items', { toolbarId: t })
            return
          }
          const r = this.editor
          const s = r.t
          const a = new Rv(r.locale)
          a.ariaLabel = e || s('Widget toolbar')
          if (this._toolbarDefinitions.has(t)) {
            throw new P('widget-toolbar-duplicated', this, { toolbarId: t })
          }
          const c = { view: a, getRelatedElement: o, balloonClassName: i, itemsConfig: n, initialized: false }
          r.ui.addToolbar(a, {
            isContextual: true,
            beforeFocus: () => {
              const t = o(r.editing.view.document.selection)
              if (t) {
                this._showToolbar(c, t)
              }
            },
            afterBlur: () => {
              this._hideToolbar(c)
            },
          })
          this._toolbarDefinitions.set(t, c)
        }
        _updateToolbarsVisibility() {
          let t = 0
          let e = null
          let n = null
          for (const o of this._toolbarDefinitions.values()) {
            const i = o.getRelatedElement(this.editor.editing.view.document.selection)
            if (!this.isEnabled || !i) {
              if (this._isToolbarInBalloon(o)) {
                this._hideToolbar(o)
              }
            } else if (!this.editor.ui.focusTracker.isFocused) {
              if (this._isToolbarVisible(o)) {
                this._hideToolbar(o)
              }
            } else {
              const r = i.getAncestors().length
              if (r > t) {
                t = r
                e = i
                n = o
              }
            }
          }
          if (n) {
            this._showToolbar(n, e)
          }
        }
        _hideToolbar(t) {
          this._balloon.remove(t.view)
          this.stopListening(this._balloon, 'change:visibleView')
        }
        _showToolbar(t, e) {
          if (this._isToolbarVisible(t)) {
            pM(this.editor, e)
          } else if (!this._isToolbarInBalloon(t)) {
            if (!t.initialized) {
              t.initialized = true
              t.view.fillFromConfig(t.itemsConfig, this.editor.ui.componentFactory)
            }
            this._balloon.add({ view: t.view, position: bM(this.editor, e), balloonClassName: t.balloonClassName })
            this.listenTo(this._balloon, 'change:visibleView', () => {
              for (const t of this._toolbarDefinitions.values()) {
                if (this._isToolbarVisible(t)) {
                  const e = t.getRelatedElement(this.editor.editing.view.document.selection)
                  pM(this.editor, e)
                }
              }
            })
          }
        }
        _isToolbarVisible(t) {
          return this._balloon.visibleView === t.view
        }
        _isToolbarInBalloon(t) {
          return this._balloon.hasView(t.view)
        }
      }
      function pM(t, e) {
        const n = t.plugins.get('ContextualBalloon')
        const o = bM(t, e)
        n.updatePosition(o)
      }
      function bM(t, e) {
        const n = t.editing.view
        const o = Jx.defaultPositions
        return {
          target: n.domConverter.mapViewToDom(e),
          positions: [
            o.northArrowSouth,
            o.northArrowSouthWest,
            o.northArrowSouthEast,
            o.southArrowNorth,
            o.southArrowNorthWest,
            o.southArrowNorthEast,
            o.viewportStickyNorth,
          ],
        }
      }
      function kM(t) {
        const e = t.getSelectedElement()
        return !!(e && xS(e))
      }
      class wM extends ft() {
        constructor(t) {
          super()
          this.set('activeHandlePosition', null)
          this.set('proposedWidthPercents', null)
          this.set('proposedWidth', null)
          this.set('proposedHeight', null)
          this.set('proposedHandleHostWidth', null)
          this.set('proposedHandleHostHeight', null)
          this._options = t
          this._referenceCoordinates = null
        }
        get originalWidth() {
          return this._originalWidth
        }
        get originalHeight() {
          return this._originalHeight
        }
        get originalWidthPercents() {
          return this._originalWidthPercents
        }
        get aspectRatio() {
          return this._aspectRatio
        }
        begin(t, e, n) {
          const o = new dc(e)
          this.activeHandlePosition = vM(t)
          this._referenceCoordinates = _M(e, yM(this.activeHandlePosition))
          this._originalWidth = o.width
          this._originalHeight = o.height
          this._aspectRatio = o.width / o.height
          const i = n.style.width
          if (i && i.match(/^\d+(\.\d*)?%$/)) {
            this._originalWidthPercents = parseFloat(i)
          } else {
            this._originalWidthPercents = AM(n, o)
          }
        }
        update(t) {
          this.proposedWidth = t.width
          this.proposedHeight = t.height
          this.proposedWidthPercents = t.widthPercents
          this.proposedHandleHostWidth = t.handleHostWidth
          this.proposedHandleHostHeight = t.handleHostHeight
        }
      }
      function AM(t, e) {
        const n = t.parentElement
        let o = parseFloat(n.ownerDocument.defaultView.getComputedStyle(n).width)
        const i = 5
        let r = 0
        let s = n
        while (isNaN(o)) {
          s = s.parentElement
          if (++r > i) {
            return 0
          }
          o = parseFloat(n.ownerDocument.defaultView.getComputedStyle(s).width)
        }
        return (e.width / o) * 100
      }
      function _M(t, e) {
        const n = new dc(t)
        const o = e.split('-')
        const i = { x: o[1] == 'right' ? n.right : n.left, y: o[0] == 'bottom' ? n.bottom : n.top }
        i.x += t.ownerDocument.defaultView.scrollX
        i.y += t.ownerDocument.defaultView.scrollY
        return i
      }
      function CM(t) {
        return `ck-widget__resizer__handle-${t}`
      }
      function vM(t) {
        const e = ['top-left', 'top-right', 'bottom-right', 'bottom-left']
        for (const n of e) {
          if (t.classList.contains(CM(n))) {
            return n
          }
        }
      }
      function yM(t) {
        const e = t.split('-')
        const n = { top: 'bottom', bottom: 'top', left: 'right', right: 'left' }
        return `${n[e[0]]}-${n[e[1]]}`
      }
      class xM extends Hl {
        constructor() {
          super()
          const t = this.bindTemplate
          this.setTemplate({
            tag: 'div',
            attributes: {
              class: ['ck', 'ck-size-view', t.to('_viewPosition', (t) => (t ? `ck-orientation-${t}` : ''))],
              style: { display: t.if('_isVisible', 'none', (t) => !t) },
            },
            children: [{ text: t.to('_label') }],
          })
        }
        _bindToState(t, e) {
          this.bind('_isVisible').to(e, 'proposedWidth', e, 'proposedHeight', (t, e) => t !== null && e !== null)
          this.bind('_label').to(
            e,
            'proposedHandleHostWidth',
            e,
            'proposedHandleHostHeight',
            e,
            'proposedWidthPercents',
            (e, n, o) => {
              if (t.unit === 'px') {
                return `${e}×${n}`
              } else {
                return `${o}%`
              }
            },
          )
          this.bind('_viewPosition').to(
            e,
            'activeHandlePosition',
            e,
            'proposedHandleHostWidth',
            e,
            'proposedHandleHostHeight',
            (t, e, n) => (e < 50 || n < 50 ? 'above-center' : t),
          )
        }
        _dismiss() {
          this.unbind()
          this._isVisible = false
        }
      }
      class EM extends ft() {
        constructor(t) {
          super()
          this._viewResizerWrapper = null
          this._options = t
          this.set('isEnabled', true)
          this.set('isSelected', false)
          this.bind('isVisible').to(this, 'isEnabled', this, 'isSelected', (t, e) => t && e)
          this.decorate('begin')
          this.decorate('cancel')
          this.decorate('commit')
          this.decorate('updateSize')
          this.on(
            'commit',
            (t) => {
              if (!this.state.proposedWidth && !this.state.proposedWidthPercents) {
                this._cleanup()
                t.stop()
              }
            },
            { priority: 'high' },
          )
        }
        get state() {
          return this._state
        }
        show() {
          const t = this._options.editor.editing.view
          t.change((t) => {
            t.removeClass('ck-hidden', this._viewResizerWrapper)
          })
        }
        hide() {
          const t = this._options.editor.editing.view
          t.change((t) => {
            t.addClass('ck-hidden', this._viewResizerWrapper)
          })
        }
        attach() {
          const t = this
          const e = this._options.viewElement
          const n = this._options.editor.editing.view
          n.change((n) => {
            const o = n.createUIElement('div', { class: 'ck ck-reset_all ck-widget__resizer' }, function (e) {
              const n = this.toDomElement(e)
              t._appendHandles(n)
              t._appendSizeUI(n)
              return n
            })
            n.insert(n.createPositionAt(e, 'end'), o)
            n.addClass('ck-widget_with-resizer', e)
            this._viewResizerWrapper = o
            if (!this.isVisible) {
              this.hide()
            }
          })
          this.on('change:isVisible', () => {
            if (this.isVisible) {
              this.show()
              this.redraw()
            } else {
              this.hide()
            }
          })
        }
        begin(t) {
          this._state = new wM(this._options)
          this._sizeView._bindToState(this._options, this.state)
          this._initialViewWidth = this._options.viewElement.getStyle('width')
          this.state.begin(t, this._getHandleHost(), this._getResizeHost())
        }
        updateSize(t) {
          const e = this._proposeNewSize(t)
          const n = this._options.editor.editing.view
          n.change((t) => {
            const n = this._options.unit || '%'
            const o = (n === '%' ? e.widthPercents : e.width) + n
            t.setStyle('width', o, this._options.viewElement)
          })
          const o = this._getHandleHost()
          const i = new dc(o)
          const r = Math.round(i.width)
          const s = Math.round(i.height)
          const a = new dc(o)
          e.width = Math.round(a.width)
          e.height = Math.round(a.height)
          this.redraw(i)
          this.state.update({ ...e, handleHostWidth: r, handleHostHeight: s })
        }
        commit() {
          const t = this._options.unit || '%'
          const e = (t === '%' ? this.state.proposedWidthPercents : this.state.proposedWidth) + t
          this._options.editor.editing.view.change(() => {
            this._cleanup()
            this._options.onCommit(e)
          })
        }
        cancel() {
          this._cleanup()
        }
        destroy() {
          this.cancel()
        }
        redraw(t) {
          const e = this._domResizerWrapper
          if (!IM(e)) {
            return
          }
          const n = e.parentElement
          const o = this._getHandleHost()
          const i = this._viewResizerWrapper
          const r = [i.getStyle('width'), i.getStyle('height'), i.getStyle('left'), i.getStyle('top')]
          let s
          if (n.isSameNode(o)) {
            const e = t || new dc(o)
            s = [e.width + 'px', e.height + 'px', undefined, undefined]
          } else {
            s = [o.offsetWidth + 'px', o.offsetHeight + 'px', o.offsetLeft + 'px', o.offsetTop + 'px']
          }
          if (Dt(r, s) !== 'same') {
            this._options.editor.editing.view.change((t) => {
              t.setStyle({ width: s[0], height: s[1], left: s[2], top: s[3] }, i)
            })
          }
        }
        containsHandle(t) {
          return this._domResizerWrapper.contains(t)
        }
        static isResizeHandle(t) {
          return t.classList.contains('ck-widget__resizer__handle')
        }
        _cleanup() {
          this._sizeView._dismiss()
          const t = this._options.editor.editing.view
          t.change((t) => {
            t.setStyle('width', this._initialViewWidth, this._options.viewElement)
          })
        }
        _proposeNewSize(t) {
          const e = this.state
          const n = TM(t)
          const o = this._options.isCentered ? this._options.isCentered(this) : true
          const i = {
            x: e._referenceCoordinates.x - (n.x + e.originalWidth),
            y: n.y - e.originalHeight - e._referenceCoordinates.y,
          }
          if (o && e.activeHandlePosition.endsWith('-right')) {
            i.x = n.x - (e._referenceCoordinates.x + e.originalWidth)
          }
          if (o) {
            i.x *= 2
          }
          let r = Math.abs(e.originalWidth + i.x)
          let s = Math.abs(e.originalHeight + i.y)
          const a = r / e.aspectRatio > s ? 'width' : 'height'
          if (a == 'width') {
            s = r / e.aspectRatio
          } else {
            r = s * e.aspectRatio
          }
          return {
            width: Math.round(r),
            height: Math.round(s),
            widthPercents: Math.min(Math.round((e.originalWidthPercents / e.originalWidth) * r * 100) / 100, 100),
          }
        }
        _getResizeHost() {
          const t = this._domResizerWrapper.parentElement
          return this._options.getResizeHost(t)
        }
        _getHandleHost() {
          const t = this._domResizerWrapper.parentElement
          return this._options.getHandleHost(t)
        }
        get _domResizerWrapper() {
          return this._options.editor.editing.view.domConverter.mapViewToDom(this._viewResizerWrapper)
        }
        _appendHandles(t) {
          const e = ['top-left', 'top-right', 'bottom-right', 'bottom-left']
          for (const n of e) {
            t.appendChild(new Wl({ tag: 'div', attributes: { class: `ck-widget__resizer__handle ${DM(n)}` } }).render())
          }
        }
        _appendSizeUI(t) {
          this._sizeView = new xM()
          this._sizeView.render()
          t.appendChild(this._sizeView.element)
        }
      }
      function DM(t) {
        return `ck-widget__resizer__handle-${t}`
      }
      function TM(t) {
        return { x: t.pageX, y: t.pageY }
      }
      function IM(t) {
        return t && t.ownerDocument && t.ownerDocument.contains(t)
      }
      var SM = n(4875)
      var MM = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      MM.insert = 'head'
      MM.singleton = true
      var BM = Rl()(SM.Z, MM)
      const NM = SM.Z.locals || {}
      class PM extends (null && Plugin) {
        constructor() {
          super(...arguments)
          this._resizers = new Map()
        }
        static get pluginName() {
          return 'WidgetResize'
        }
        init() {
          const t = this.editor.editing
          const e = global.window.document
          this.set('selectedResizer', null)
          this.set('_activeResizer', null)
          t.view.addObserver(MouseObserver)
          this._observer = new (DomEmitterMixin())()
          this.listenTo(t.view.document, 'mousedown', this._mouseDownListener.bind(this), { priority: 'high' })
          this._observer.listenTo(e, 'mousemove', this._mouseMoveListener.bind(this))
          this._observer.listenTo(e, 'mouseup', this._mouseUpListener.bind(this))
          this._redrawSelectedResizerThrottled = throttle(() => this.redrawSelectedResizer(), 200)
          this.editor.ui.on('update', this._redrawSelectedResizerThrottled)
          this.editor.model.document.on(
            'change',
            () => {
              for (const [t, e] of this._resizers) {
                if (!t.isAttached()) {
                  this._resizers.delete(t)
                  e.destroy()
                }
              }
            },
            { priority: 'lowest' },
          )
          this._observer.listenTo(global.window, 'resize', this._redrawSelectedResizerThrottled)
          const n = this.editor.editing.view.document.selection
          n.on('change', () => {
            const t = n.getSelectedElement()
            const e = this.getResizerByViewElement(t) || null
            if (e) {
              this.select(e)
            } else {
              this.deselect()
            }
          })
        }
        redrawSelectedResizer() {
          if (this.selectedResizer && this.selectedResizer.isVisible) {
            this.selectedResizer.redraw()
          }
        }
        destroy() {
          super.destroy()
          this._observer.stopListening()
          for (const t of this._resizers.values()) {
            t.destroy()
          }
          this._redrawSelectedResizerThrottled.cancel()
        }
        select(t) {
          this.deselect()
          this.selectedResizer = t
          this.selectedResizer.isSelected = true
        }
        deselect() {
          if (this.selectedResizer) {
            this.selectedResizer.isSelected = false
          }
          this.selectedResizer = null
        }
        attachTo(t) {
          const e = new Resizer(t)
          const n = this.editor.plugins
          e.attach()
          if (n.has('WidgetToolbarRepository')) {
            const t = n.get('WidgetToolbarRepository')
            e.on(
              'begin',
              () => {
                t.forceDisabled('resize')
              },
              { priority: 'lowest' },
            )
            e.on(
              'cancel',
              () => {
                t.clearForceDisabled('resize')
              },
              { priority: 'highest' },
            )
            e.on(
              'commit',
              () => {
                t.clearForceDisabled('resize')
              },
              { priority: 'highest' },
            )
          }
          this._resizers.set(t.viewElement, e)
          const o = this.editor.editing.view.document.selection
          const i = o.getSelectedElement()
          if (this.getResizerByViewElement(i) == e) {
            this.select(e)
          }
          return e
        }
        getResizerByViewElement(t) {
          return this._resizers.get(t)
        }
        _getResizerByHandle(t) {
          for (const e of this._resizers.values()) {
            if (e.containsHandle(t)) {
              return e
            }
          }
        }
        _mouseDownListener(t, e) {
          const n = e.domTarget
          if (!Resizer.isResizeHandle(n)) {
            return
          }
          this._activeResizer = this._getResizerByHandle(n) || null
          if (this._activeResizer) {
            this._activeResizer.begin(n)
            t.stop()
            e.preventDefault()
          }
        }
        _mouseMoveListener(t, e) {
          if (this._activeResizer) {
            this._activeResizer.updateSize(e)
          }
        }
        _mouseUpListener() {
          if (this._activeResizer) {
            this._activeResizer.commit()
            this._activeResizer = null
          }
        }
      }
      var LM = n(799)
      var zM = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      zM.insert = 'head'
      zM.singleton = true
      var RM = Rl()(LM.Z, zM)
      const OM = LM.Z.locals || {}
      class VM extends Du {
        static get pluginName() {
          return 'DragDrop'
        }
        static get requires() {
          return [bS, hM]
        }
        init() {
          const t = this.editor
          const e = t.editing.view
          this._draggedRange = null
          this._draggingUid = ''
          this._draggableElement = null
          this._updateDropMarkerThrottled = uE((t) => this._updateDropMarker(t), 40)
          this._removeDropMarkerDelayed = yl(() => this._removeDropMarker(), 40)
          this._clearDraggableAttributesDelayed = yl(() => this._clearDraggableAttributes(), 40)
          if (t.plugins.has('DragDropExperimental')) {
            this.forceDisabled('DragDropExperimental')
            return
          }
          e.addObserver(uS)
          e.addObserver(K_)
          this._setupDragging()
          this._setupContentInsertionIntegration()
          this._setupClipboardInputIntegration()
          this._setupDropMarker()
          this._setupDraggableAttributeHandling()
          this.listenTo(t, 'change:isReadOnly', (t, e, n) => {
            if (n) {
              this.forceDisabled('readOnlyMode')
            } else {
              this.clearForceDisabled('readOnlyMode')
            }
          })
          this.on('change:isEnabled', (t, e, n) => {
            if (!n) {
              this._finalizeDragging(false)
            }
          })
          if (l.isAndroid) {
            this.forceDisabled('noAndroidSupport')
          }
        }
        destroy() {
          if (this._draggedRange) {
            this._draggedRange.detach()
            this._draggedRange = null
          }
          this._updateDropMarkerThrottled.cancel()
          this._removeDropMarkerDelayed.cancel()
          this._clearDraggableAttributesDelayed.cancel()
          return super.destroy()
        }
        _setupDragging() {
          const t = this.editor
          const e = t.model
          const n = e.document
          const o = t.editing.view
          const i = o.document
          this.listenTo(
            i,
            'dragstart',
            (o, r) => {
              const s = n.selection
              if (r.target && r.target.is('editableElement')) {
                r.preventDefault()
                return
              }
              const a = r.target ? $M(r.target) : null
              if (a) {
                const n = t.editing.mapper.toModelElement(a)
                this._draggedRange = Zb.fromRange(e.createRangeOn(n))
                if (t.plugins.has('WidgetToolbarRepository')) {
                  const e = t.plugins.get('WidgetToolbarRepository')
                  e.forceDisabled('dragDrop')
                }
              } else if (!i.selection.isCollapsed) {
                const t = i.selection.getSelectedElement()
                if (!t || !xS(t)) {
                  this._draggedRange = Zb.fromRange(s.getFirstRange())
                }
              }
              if (!this._draggedRange) {
                r.preventDefault()
                return
              }
              this._draggingUid = I()
              const c = this.isEnabled && t.model.canEditAt(this._draggedRange)
              r.dataTransfer.effectAllowed = c ? 'copyMove' : 'copy'
              r.dataTransfer.setData('application/ckeditor5-dragging-uid', this._draggingUid)
              const l = e.createSelection(this._draggedRange.toRange())
              const d = t.data.toView(e.getSelectedContent(l))
              i.fire('clipboardOutput', { dataTransfer: r.dataTransfer, content: d, method: 'dragstart' })
              if (!c) {
                this._draggedRange.detach()
                this._draggedRange = null
                this._draggingUid = ''
              }
            },
            { priority: 'low' },
          )
          this.listenTo(
            i,
            'dragend',
            (t, e) => {
              this._finalizeDragging(!e.dataTransfer.isCanceled && e.dataTransfer.dropEffect == 'move')
            },
            { priority: 'low' },
          )
          this.listenTo(i, 'dragenter', () => {
            if (!this.isEnabled) {
              return
            }
            o.focus()
          })
          this.listenTo(i, 'dragleave', () => {
            this._removeDropMarkerDelayed()
          })
          this.listenTo(
            i,
            'dragging',
            (e, n) => {
              if (!this.isEnabled) {
                n.dataTransfer.dropEffect = 'none'
                return
              }
              this._removeDropMarkerDelayed.cancel()
              const o = FM(t, n.targetRanges, n.target)
              if (!t.model.canEditAt(o)) {
                n.dataTransfer.dropEffect = 'none'
                return
              }
              if (!this._draggedRange) {
                n.dataTransfer.dropEffect = 'copy'
              }
              if (!l.isGecko) {
                if (n.dataTransfer.effectAllowed == 'copy') {
                  n.dataTransfer.dropEffect = 'copy'
                } else if (['all', 'copyMove'].includes(n.dataTransfer.effectAllowed)) {
                  n.dataTransfer.dropEffect = 'move'
                }
              }
              if (o) {
                this._updateDropMarkerThrottled(o)
              }
            },
            { priority: 'low' },
          )
        }
        _setupClipboardInputIntegration() {
          const t = this.editor
          const e = t.editing.view
          const n = e.document
          this.listenTo(
            n,
            'clipboardInput',
            (e, n) => {
              if (n.method != 'drop') {
                return
              }
              const o = FM(t, n.targetRanges, n.target)
              this._removeDropMarker()
              if (!o || !t.model.canEditAt(o)) {
                this._finalizeDragging(false)
                e.stop()
                return
              }
              if (
                this._draggedRange &&
                this._draggingUid != n.dataTransfer.getData('application/ckeditor5-dragging-uid')
              ) {
                this._draggedRange.detach()
                this._draggedRange = null
                this._draggingUid = ''
              }
              const i = qM(n.dataTransfer) == 'move'
              if (i && this._draggedRange && this._draggedRange.containsRange(o, true)) {
                this._finalizeDragging(false)
                e.stop()
                return
              }
              n.targetRanges = [t.editing.mapper.toViewRange(o)]
            },
            { priority: 'high' },
          )
        }
        _setupContentInsertionIntegration() {
          const t = this.editor.plugins.get(bS)
          t.on(
            'contentInsertion',
            (t, e) => {
              if (!this.isEnabled || e.method !== 'drop') {
                return
              }
              const n = e.targetRanges.map((t) => this.editor.editing.mapper.toModelRange(t))
              this.editor.model.change((t) => t.setSelection(n))
            },
            { priority: 'high' },
          )
          t.on(
            'contentInsertion',
            (t, e) => {
              if (!this.isEnabled || e.method !== 'drop') {
                return
              }
              const n = qM(e.dataTransfer) == 'move'
              const o = !e.resultRange || !e.resultRange.isCollapsed
              this._finalizeDragging(o && n)
            },
            { priority: 'lowest' },
          )
        }
        _setupDraggableAttributeHandling() {
          const t = this.editor
          const e = t.editing.view
          const n = e.document
          this.listenTo(n, 'mousedown', (o, i) => {
            if (l.isAndroid || !i) {
              return
            }
            this._clearDraggableAttributesDelayed.cancel()
            let r = $M(i.target)
            if (l.isBlink && !r && !n.selection.isCollapsed) {
              const t = n.selection.getSelectedElement()
              if (!t || !xS(t)) {
                const t = n.selection.editableElement
                if (t && !t.isReadOnly) {
                  r = t
                }
              }
            }
            if (r) {
              e.change((t) => {
                t.setAttribute('draggable', 'true', r)
              })
              this._draggableElement = t.editing.mapper.toModelElement(r)
            }
          })
          this.listenTo(n, 'mouseup', () => {
            if (!l.isAndroid) {
              this._clearDraggableAttributesDelayed()
            }
          })
        }
        _clearDraggableAttributes() {
          const t = this.editor.editing
          t.view.change((e) => {
            if (this._draggableElement && this._draggableElement.root.rootName != '$graveyard') {
              e.removeAttribute('draggable', t.mapper.toViewElement(this._draggableElement))
            }
            this._draggableElement = null
          })
        }
        _setupDropMarker() {
          const t = this.editor
          t.conversion
            .for('editingDowncast')
            .markerToHighlight({ model: 'drop-target', view: { classes: ['ck-clipboard-drop-target-range'] } })
          t.conversion.for('editingDowncast').markerToElement({
            model: 'drop-target',
            view: (e, { writer: n }) => {
              const o = t.model.schema.checkChild(e.markerRange.start, '$text')
              if (!o) {
                return
              }
              return n.createUIElement('span', { class: 'ck ck-clipboard-drop-target-position' }, function (t) {
                const e = this.toDomElement(t)
                e.append('⁠', t.createElement('span'), '⁠')
                return e
              })
            },
          })
        }
        _updateDropMarker(t) {
          const e = this.editor
          const n = e.model.markers
          e.model.change((e) => {
            if (n.has('drop-target')) {
              if (!n.get('drop-target').getRange().isEqual(t)) {
                e.updateMarker('drop-target', { range: t })
              }
            } else {
              e.addMarker('drop-target', { range: t, usingOperation: false, affectsData: false })
            }
          })
        }
        _removeDropMarker() {
          const t = this.editor.model
          this._removeDropMarkerDelayed.cancel()
          this._updateDropMarkerThrottled.cancel()
          if (t.markers.has('drop-target')) {
            t.change((t) => {
              t.removeMarker('drop-target')
            })
          }
        }
        _finalizeDragging(t) {
          const e = this.editor
          const n = e.model
          this._removeDropMarker()
          this._clearDraggableAttributes()
          if (e.plugins.has('WidgetToolbarRepository')) {
            const t = e.plugins.get('WidgetToolbarRepository')
            t.clearForceDisabled('dragDrop')
          }
          this._draggingUid = ''
          if (!this._draggedRange) {
            return
          }
          if (t && this.isEnabled) {
            n.deleteContent(n.createSelection(this._draggedRange), { doNotAutoparagraph: true })
          }
          this._draggedRange.detach()
          this._draggedRange = null
        }
      }
      function FM(t, e, n) {
        const o = t.model
        const i = t.editing.mapper
        let r = null
        const s = e ? e[0].start : null
        if (n.is('uiElement')) {
          n = n.parent
        }
        r = jM(t, n)
        if (r) {
          return r
        }
        const a = GM(t, n)
        const c = s ? i.toModelPosition(s) : null
        if (!c) {
          return HM(t, a)
        }
        r = UM(t, c, a)
        if (r) {
          return r
        }
        r = o.schema.getNearestSelectionRange(c, l.isGecko ? 'forward' : 'backward')
        if (r) {
          return r
        }
        return WM(t, c.parent)
      }
      function jM(t, e) {
        const n = t.model
        const o = t.editing.mapper
        if (xS(e)) {
          return n.createRangeOn(o.toModelElement(e))
        }
        if (!e.is('editableElement')) {
          const t = e.findAncestor((t) => xS(t) || t.is('editableElement'))
          if (xS(t)) {
            return n.createRangeOn(o.toModelElement(t))
          }
        }
        return null
      }
      function HM(t, e) {
        const n = t.model
        const o = n.schema
        const i = n.createPositionAt(e, 0)
        return o.getNearestSelectionRange(i, 'forward')
      }
      function UM(t, e, n) {
        const o = t.model
        if (!o.schema.checkChild(n, '$block')) {
          return null
        }
        const i = o.createPositionAt(n, 0)
        const r = e.path.slice(0, i.path.length)
        const s = o.createPositionFromPath(e.root, r)
        const a = s.nodeAfter
        if (a && o.schema.isObject(a)) {
          return o.createRangeOn(a)
        }
        return null
      }
      function WM(t, e) {
        const n = t.model
        let o = e
        while (o) {
          if (n.schema.isObject(o)) {
            return n.createRangeOn(o)
          }
          o = o.parent
        }
        return null
      }
      function GM(t, e) {
        const n = t.editing.mapper
        const o = t.editing.view
        const i = n.toModelElement(e)
        if (i) {
          return i
        }
        const r = o.createPositionBefore(e)
        const s = n.findMappedViewAncestor(r)
        return n.toModelElement(s)
      }
      function qM(t) {
        if (l.isGecko) {
          return t.dropEffect
        }
        return ['all', 'copyMove'].includes(t.effectAllowed) ? 'move' : 'copy'
      }
      function $M(t) {
        if (t.is('editableElement')) {
          return null
        }
        if (t.hasClass('ck-widget__selection-handle')) {
          return t.findAncestor(xS)
        }
        if (xS(t)) {
          return t
        }
        const e = t.findAncestor((t) => xS(t) || t.is('editableElement'))
        if (xS(e)) {
          return e
        }
        return null
      }
      class KM extends Du {
        static get pluginName() {
          return 'PastePlainText'
        }
        static get requires() {
          return [bS]
        }
        init() {
          const t = this.editor
          const e = t.model
          const n = t.editing.view
          const o = n.document
          const i = e.document.selection
          let r = false
          n.addObserver(uS)
          this.listenTo(o, 'keydown', (t, e) => {
            r = e.shiftKey
          })
          t.plugins.get(bS).on('contentInsertion', (t, n) => {
            if (!r && !YM(n.content, e.schema)) {
              return
            }
            e.change((t) => {
              const o = Array.from(i.getAttributes()).filter(([t]) => e.schema.getAttributeProperties(t).isFormatting)
              if (!i.isCollapsed) {
                e.deleteContent(i, { doNotAutoparagraph: true })
              }
              o.push(...i.getAttributes())
              const r = t.createRangeIn(n.content)
              for (const e of r.getItems()) {
                if (e.is('$textProxy')) {
                  t.setAttributes(o, e)
                }
              }
            })
          })
        }
      }
      function YM(t, e) {
        if (t.childCount > 1) {
          return false
        }
        const n = t.getChild(0)
        if (e.isObject(n)) {
          return false
        }
        return Array.from(n.getAttributeKeys()).length == 0
      }
      class ZM extends Du {
        static get pluginName() {
          return 'Clipboard'
        }
        static get requires() {
          return [bS, VM, KM]
        }
      }
      const QM = _c('px')
      class JM extends (null && View) {
        constructor() {
          super()
          const t = this.bindTemplate
          this.set({ isVisible: false, left: null, top: null, width: null })
          this.setTemplate({
            tag: 'div',
            attributes: {
              class: ['ck', 'ck-clipboard-drop-target-line', t.if('isVisible', 'ck-hidden', (t) => !t)],
              style: {
                left: t.to('left', (t) => QM(t)),
                top: t.to('top', (t) => QM(t)),
                width: t.to('width', (t) => QM(t)),
              },
            },
          })
        }
      }
      class XM extends (null && Plugin) {
        constructor() {
          super(...arguments)
          this.removeDropMarkerDelayed = delay(() => this.removeDropMarker(), 40)
          this._updateDropMarkerThrottled = throttle((t) => this._updateDropMarker(t), 40)
          this._reconvertMarkerThrottled = throttle(() => {
            if (this.editor.model.markers.has('drop-target')) {
              this.editor.editing.reconvertMarker('drop-target')
            }
          }, 0)
          this._dropTargetLineView = new LineView()
          this._domEmitter = new (DomEmitterMixin())()
          this._scrollables = new Map()
        }
        static get pluginName() {
          return 'DragDropTarget'
        }
        init() {
          this._setupDropMarker()
        }
        destroy() {
          this._domEmitter.stopListening()
          for (const { resizeObserver: t } of this._scrollables.values()) {
            t.destroy()
          }
          this._updateDropMarkerThrottled.cancel()
          this.removeDropMarkerDelayed.cancel()
          this._reconvertMarkerThrottled.cancel()
          return super.destroy()
        }
        updateDropMarker(t, e, n, o, i) {
          this.removeDropMarkerDelayed.cancel()
          const r = tB(this.editor, t, e, n, o, i)
          if (r) {
            this._updateDropMarkerThrottled(r)
          }
        }
        getFinalDropRange(t, e, n, o, i) {
          const r = tB(this.editor, t, e, n, o, i)
          this.removeDropMarker()
          return r
        }
        removeDropMarker() {
          const t = this.editor.model
          this.removeDropMarkerDelayed.cancel()
          this._updateDropMarkerThrottled.cancel()
          this._dropTargetLineView.isVisible = false
          if (t.markers.has('drop-target')) {
            t.change((t) => {
              t.removeMarker('drop-target')
            })
          }
        }
        _setupDropMarker() {
          const t = this.editor
          t.ui.view.body.add(this._dropTargetLineView)
          t.conversion
            .for('editingDowncast')
            .markerToHighlight({ model: 'drop-target', view: { classes: ['ck-clipboard-drop-target-range'] } })
          t.conversion.for('editingDowncast').markerToElement({
            model: 'drop-target',
            view: (e, { writer: n }) => {
              if (t.model.schema.checkChild(e.markerRange.start, '$text')) {
                this._dropTargetLineView.isVisible = false
                return this._createDropTargetPosition(n)
              } else {
                if (e.markerRange.isCollapsed) {
                  this._updateDropTargetLine(e.markerRange)
                } else {
                  this._dropTargetLineView.isVisible = false
                }
              }
            },
          })
        }
        _updateDropMarker(t) {
          const e = this.editor
          const n = e.model.markers
          e.model.change((e) => {
            if (n.has('drop-target')) {
              if (!n.get('drop-target').getRange().isEqual(t)) {
                e.updateMarker('drop-target', { range: t })
              }
            } else {
              e.addMarker('drop-target', { range: t, usingOperation: false, affectsData: false })
            }
          })
        }
        _createDropTargetPosition(t) {
          return t.createUIElement('span', { class: 'ck ck-clipboard-drop-target-position' }, function (t) {
            const e = this.toDomElement(t)
            e.append('⁠', t.createElement('span'), '⁠')
            return e
          })
        }
        _updateDropTargetLine(t) {
          const e = this.editor.editing
          const n = t.start.nodeBefore
          const o = t.start.nodeAfter
          const i = t.start.parent
          const r = n ? e.mapper.toViewElement(n) : null
          const s = r ? e.view.domConverter.mapViewToDom(r) : null
          const a = o ? e.mapper.toViewElement(o) : null
          const c = a ? e.view.domConverter.mapViewToDom(a) : null
          const l = e.mapper.toViewElement(i)
          const d = e.view.domConverter.mapViewToDom(l)
          const u = this._getScrollableRect(l)
          const { scrollX: h, scrollY: g } = global.window
          const f = s ? new Rect(s) : null
          const m = c ? new Rect(c) : null
          const p = new Rect(d).excludeScrollbarsAndBorders()
          const b = f ? f.bottom : p.top
          const k = m ? m.top : p.bottom
          const w = global.window.getComputedStyle(d)
          const A = b <= k ? (b + k) / 2 : k
          if (u.top < A && A < u.bottom) {
            const t = p.left + parseFloat(w.paddingLeft)
            const e = p.right - parseFloat(w.paddingRight)
            const n = Math.max(t + h, u.left)
            const o = Math.min(e + h, u.right)
            this._dropTargetLineView.set({ isVisible: true, left: n, top: A + g, width: o - n })
          } else {
            this._dropTargetLineView.isVisible = false
          }
        }
        _getScrollableRect(t) {
          const e = t.root.rootName
          let n
          if (this._scrollables.has(e)) {
            n = this._scrollables.get(e).domElement
          } else {
            const o = this.editor.editing.view.domConverter.mapViewToDom(t)
            n = rB(o)
            this._domEmitter.listenTo(n, 'scroll', this._reconvertMarkerThrottled, { usePassive: true })
            const i = new ResizeObserver(n, this._reconvertMarkerThrottled)
            this._scrollables.set(e, { domElement: n, resizeObserver: i })
          }
          return new Rect(n).excludeScrollbarsAndBorders()
        }
      }
      function tB(t, e, n, o, i, r) {
        const s = t.model
        const a = t.editing.mapper
        const c = iB(t, e)
        let l = c
        while (l) {
          if (!r) {
            if (s.schema.checkChild(l, '$text')) {
              const e = n ? n[0].start : null
              const r = e ? a.toModelPosition(e) : null
              if (r) {
                if (s.schema.checkChild(r, '$text')) {
                  return s.createRange(r)
                } else if (e) {
                  return nB(t, iB(t, e.parent), o, i)
                }
              }
            } else if (s.schema.isInline(l)) {
              return nB(t, l, o, i)
            }
          }
          if (s.schema.isBlock(l)) {
            return nB(t, l, o, i)
          } else if (s.schema.checkChild(l, '$block')) {
            const e = Array.from(l.getChildren()).filter((e) => e.is('element') && !eB(t, e))
            let n = 0
            let r = e.length
            while (n < r - 1) {
              const s = Math.floor((n + r) / 2)
              const a = oB(t, e[s], o, i)
              if (a == 'before') {
                r = s
              } else {
                n = s
              }
            }
            return nB(t, e[n], o, i)
          }
          l = l.parent
        }
        console.warn('none:', c.name)
        return null
      }
      function eB(t, e) {
        const n = t.editing.mapper
        const o = t.editing.view.domConverter
        const i = n.toViewElement(e)
        const r = o.mapViewToDom(i)
        return global.window.getComputedStyle(r).float != 'none'
      }
      function nB(t, e, n, o) {
        const i = t.model
        return i.createRange(i.createPositionAt(e, oB(t, e, n, o)))
      }
      function oB(t, e, n, o) {
        const i = t.editing.mapper
        const r = t.editing.view.domConverter
        const s = i.toViewElement(e)
        const a = r.mapViewToDom(s)
        const c = new Rect(a)
        if (t.model.schema.isInline(e)) {
          return n < (c.left + c.right) / 2 ? 'before' : 'after'
        } else {
          return o < (c.top + c.bottom) / 2 ? 'before' : 'after'
        }
      }
      function iB(t, e) {
        const n = t.editing.mapper
        const o = t.editing.view
        const i = n.toModelElement(e)
        if (i) {
          return i
        }
        const r = o.createPositionBefore(e)
        const s = n.findMappedViewAncestor(r)
        return n.toModelElement(s)
      }
      function rB(t) {
        let e = t
        do {
          e = e.parentElement
          const t = global.window.getComputedStyle(e).overflowY
          if (t == 'auto' || t == 'scroll') {
            break
          }
        } while (e.tagName != 'BODY')
        return e
      }
      class sB extends (null && Plugin) {
        constructor() {
          super(...arguments)
          this._clearDraggableAttributesDelayed = delay(() => this._clearDraggableAttributes(), 40)
          this._blockMode = false
          this._domEmitter = new (DomEmitterMixin())()
        }
        static get pluginName() {
          return 'DragDropExperimental'
        }
        static get requires() {
          return [ClipboardPipeline, Widget, DragDropTarget]
        }
        init() {
          const t = this.editor
          const e = t.editing.view
          this._draggedRange = null
          this._draggingUid = ''
          this._draggableElement = null
          e.addObserver(ClipboardObserver)
          e.addObserver(MouseObserver)
          this._setupDragging()
          this._setupContentInsertionIntegration()
          this._setupClipboardInputIntegration()
          this._setupDraggableAttributeHandling()
          this.listenTo(t, 'change:isReadOnly', (t, e, n) => {
            if (n) {
              this.forceDisabled('readOnlyMode')
            } else {
              this.clearForceDisabled('readOnlyMode')
            }
          })
          this.on('change:isEnabled', (t, e, n) => {
            if (!n) {
              this._finalizeDragging(false)
            }
          })
          if (env.isAndroid) {
            this.forceDisabled('noAndroidSupport')
          }
        }
        destroy() {
          if (this._draggedRange) {
            this._draggedRange.detach()
            this._draggedRange = null
          }
          if (this._previewContainer) {
            this._previewContainer.remove()
          }
          this._domEmitter.stopListening()
          this._clearDraggableAttributesDelayed.cancel()
          return super.destroy()
        }
        _setupDragging() {
          const t = this.editor
          const e = t.model
          const n = t.editing.view
          const o = n.document
          const i = t.plugins.get(DragDropTarget)
          this.listenTo(
            o,
            'dragstart',
            (n, i) => {
              if (i.target && i.target.is('editableElement')) {
                i.preventDefault()
                return
              }
              this._prepareDraggedRange(i.target)
              if (!this._draggedRange) {
                i.preventDefault()
                return
              }
              this._draggingUid = uid()
              i.dataTransfer.effectAllowed = this.isEnabled ? 'copyMove' : 'copy'
              i.dataTransfer.setData('application/ckeditor5-dragging-uid', this._draggingUid)
              const r = e.createSelection(this._draggedRange.toRange())
              const s = t.data.toView(e.getSelectedContent(r))
              o.fire('clipboardOutput', { dataTransfer: i.dataTransfer, content: s, method: 'dragstart' })
              this._updatePreview(i.dataTransfer)
              i.stopPropagation()
              if (!this.isEnabled) {
                this._draggedRange.detach()
                this._draggedRange = null
                this._draggingUid = ''
              }
            },
            { priority: 'low' },
          )
          this.listenTo(
            o,
            'dragend',
            (t, e) => {
              this._finalizeDragging(!e.dataTransfer.isCanceled && e.dataTransfer.dropEffect == 'move')
            },
            { priority: 'low' },
          )
          this._domEmitter.listenTo(
            global.document,
            'dragend',
            () => {
              this._blockMode = false
            },
            { useCapture: true },
          )
          this.listenTo(o, 'dragenter', () => {
            if (!this.isEnabled) {
              return
            }
            n.focus()
          })
          this.listenTo(o, 'dragleave', () => {
            i.removeDropMarkerDelayed()
          })
          this.listenTo(
            o,
            'dragging',
            (t, e) => {
              if (!this.isEnabled) {
                e.dataTransfer.dropEffect = 'none'
                return
              }
              const { clientX: n, clientY: o } = e.domEvent
              i.updateDropMarker(e.target, e.targetRanges, n, o, this._blockMode)
              if (!this._draggedRange) {
                e.dataTransfer.dropEffect = 'copy'
              }
              if (!env.isGecko) {
                if (e.dataTransfer.effectAllowed == 'copy') {
                  e.dataTransfer.dropEffect = 'copy'
                } else if (['all', 'copyMove'].includes(e.dataTransfer.effectAllowed)) {
                  e.dataTransfer.dropEffect = 'move'
                }
              }
              t.stop()
            },
            { priority: 'low' },
          )
        }
        _setupClipboardInputIntegration() {
          const t = this.editor
          const e = t.editing.view
          const n = e.document
          const o = t.plugins.get(DragDropTarget)
          this.listenTo(
            n,
            'clipboardInput',
            (e, n) => {
              if (n.method != 'drop') {
                return
              }
              const { clientX: i, clientY: r } = n.domEvent
              const s = o.getFinalDropRange(n.target, n.targetRanges, i, r, this._blockMode)
              if (!s) {
                this._finalizeDragging(false)
                e.stop()
                return
              }
              if (
                this._draggedRange &&
                this._draggingUid != n.dataTransfer.getData('application/ckeditor5-dragging-uid')
              ) {
                this._draggedRange.detach()
                this._draggedRange = null
                this._draggingUid = ''
              }
              const a = aB(n.dataTransfer) == 'move'
              if (a && this._draggedRange && this._draggedRange.containsRange(s, true)) {
                this._finalizeDragging(false)
                e.stop()
                return
              }
              n.targetRanges = [t.editing.mapper.toViewRange(s)]
            },
            { priority: 'high' },
          )
        }
        _setupContentInsertionIntegration() {
          const t = this.editor.plugins.get(ClipboardPipeline)
          t.on(
            'contentInsertion',
            (t, e) => {
              if (!this.isEnabled || e.method !== 'drop') {
                return
              }
              const n = e.targetRanges.map((t) => this.editor.editing.mapper.toModelRange(t))
              this.editor.model.change((t) => t.setSelection(n))
            },
            { priority: 'high' },
          )
          t.on(
            'contentInsertion',
            (t, e) => {
              if (!this.isEnabled || e.method !== 'drop') {
                return
              }
              const n = aB(e.dataTransfer) == 'move'
              const o = !e.resultRange || !e.resultRange.isCollapsed
              this._finalizeDragging(o && n)
            },
            { priority: 'lowest' },
          )
        }
        _setupDraggableAttributeHandling() {
          const t = this.editor
          const e = t.editing.view
          const n = e.document
          this.listenTo(n, 'mousedown', (o, i) => {
            if (env.isAndroid || !i) {
              return
            }
            this._clearDraggableAttributesDelayed.cancel()
            let r = cB(i.target)
            if (env.isBlink && !t.isReadOnly && !r && !n.selection.isCollapsed) {
              const t = n.selection.getSelectedElement()
              if (!t || !isWidget(t)) {
                r = n.selection.editableElement
              }
            }
            if (r) {
              e.change((t) => {
                t.setAttribute('draggable', 'true', r)
              })
              this._draggableElement = t.editing.mapper.toModelElement(r)
            }
          })
          this.listenTo(n, 'mouseup', () => {
            if (!env.isAndroid) {
              this._clearDraggableAttributesDelayed()
            }
          })
        }
        _clearDraggableAttributes() {
          const t = this.editor.editing
          t.view.change((e) => {
            if (this._draggableElement && this._draggableElement.root.rootName != '$graveyard') {
              e.removeAttribute('draggable', t.mapper.toViewElement(this._draggableElement))
            }
            this._draggableElement = null
          })
        }
        _finalizeDragging(t) {
          const e = this.editor
          const n = e.model
          const o = e.plugins.get(DragDropTarget)
          o.removeDropMarker()
          this._clearDraggableAttributes()
          if (e.plugins.has('WidgetToolbarRepository')) {
            const t = e.plugins.get('WidgetToolbarRepository')
            t.clearForceDisabled('dragDrop')
          }
          this._draggingUid = ''
          if (this._previewContainer) {
            this._previewContainer.remove()
            this._previewContainer = undefined
          }
          if (!this._draggedRange) {
            return
          }
          if (t && this.isEnabled) {
            n.deleteContent(n.createSelection(this._draggedRange), { doNotAutoparagraph: true })
          }
          this._draggedRange.detach()
          this._draggedRange = null
        }
        _prepareDraggedRange(t) {
          const e = this.editor
          const n = e.model
          const o = n.document.selection
          const i = t ? cB(t) : null
          if (i) {
            const t = e.editing.mapper.toModelElement(i)
            this._draggedRange = LiveRange.fromRange(n.createRangeOn(t))
            this._blockMode = n.schema.isBlock(t)
            if (e.plugins.has('WidgetToolbarRepository')) {
              const t = e.plugins.get('WidgetToolbarRepository')
              t.forceDisabled('dragDrop')
            }
          } else if (!o.isCollapsed || o.getFirstPosition().parent.isEmpty) {
            const t = Array.from(o.getSelectedBlocks())
            if (t.length > 1) {
              this._draggedRange = LiveRange.fromRange(
                n.createRange(n.createPositionBefore(t[0]), n.createPositionAfter(t[t.length - 1])),
              )
              n.change((t) => t.setSelection(this._draggedRange.toRange()))
              this._blockMode = true
            } else if (t.length == 1) {
              const e = o.getFirstRange()
              const i = n.createRange(n.createPositionBefore(t[0]), n.createPositionAfter(t[0]))
              if (e.start.isTouching(i.start) && e.end.isTouching(i.end)) {
                this._draggedRange = LiveRange.fromRange(i)
                this._blockMode = true
              } else {
                this._draggedRange = LiveRange.fromRange(o.getFirstRange())
                this._blockMode = false
              }
            }
          }
        }
        _updatePreview(t) {
          const e = this.editor.editing.view
          const n = e.document.selection.editableElement
          const o = e.domConverter.mapViewToDom(n)
          const i = global.window.getComputedStyle(o)
          if (!this._previewContainer) {
            this._previewContainer = createElement(global.document, 'div', {
              style: 'position: fixed; left: -999999px;',
            })
            global.document.body.appendChild(this._previewContainer)
          } else {
            this._previewContainer.removeChild(this._previewContainer.firstElementChild)
          }
          const r = createElement(global.document, 'div')
          r.className = 'ck ck-content'
          r.style.width = i.width
          r.innerHTML = t.getData('text/html')
          t.setDragImage(r, 0, 0)
          this._previewContainer.appendChild(r)
        }
      }
      function aB(t) {
        if (env.isGecko) {
          return t.dropEffect
        }
        return ['all', 'copyMove'].includes(t.effectAllowed) ? 'move' : 'copy'
      }
      function cB(t) {
        if (t.is('editableElement')) {
          return null
        }
        if (t.hasClass('ck-widget__selection-handle')) {
          return t.findAncestor(isWidget)
        }
        if (isWidget(t)) {
          return t
        }
        const e = t.findAncestor((t) => isWidget(t) || t.is('editableElement'))
        if (isWidget(e)) {
          return e
        }
        return null
      }
      class lB extends (null && Plugin) {
        constructor() {
          super(...arguments)
          this._isBlockDragging = false
          this._domEmitter = new (DomEmitterMixin())()
        }
        static get pluginName() {
          return 'DragDropBlockToolbar'
        }
        init() {
          const t = this.editor
          this.listenTo(t, 'change:isReadOnly', (t, e, n) => {
            if (n) {
              this.forceDisabled('readOnlyMode')
              this._isBlockDragging = false
            } else {
              this.clearForceDisabled('readOnlyMode')
            }
          })
          if (env.isAndroid) {
            this.forceDisabled('noAndroidSupport')
          }
          if (t.plugins.has('BlockToolbar')) {
            const e = t.plugins.get('BlockToolbar')
            const n = e.buttonView.element
            n.setAttribute('draggable', 'true')
            this._domEmitter.listenTo(n, 'dragstart', (t, e) => this._handleBlockDragStart(e))
            this._domEmitter.listenTo(global.document, 'dragover', (t, e) => this._handleBlockDragging(e))
            this._domEmitter.listenTo(global.document, 'drop', (t, e) => this._handleBlockDragging(e))
            this._domEmitter.listenTo(global.document, 'dragend', () => this._handleBlockDragEnd(), {
              useCapture: true,
            })
          }
        }
        destroy() {
          this._domEmitter.stopListening()
          return super.destroy()
        }
        _handleBlockDragStart(t) {
          if (!this.isEnabled) {
            return
          }
          const e = this.editor.model
          const n = e.document.selection
          const o = Array.from(n.getSelectedBlocks())
          const i = e.createRange(e.createPositionBefore(o[0]), e.createPositionAfter(o[o.length - 1]))
          e.change((t) => t.setSelection(i))
          this._isBlockDragging = true
          this.editor.editing.view.getObserver(ClipboardObserver).onDomEvent(t)
        }
        _handleBlockDragging(t) {
          if (!this.isEnabled || !this._isBlockDragging) {
            return
          }
          const e = t.clientX + 100
          const n = t.clientY
          const o = document.elementFromPoint(e, n)
          if (!o || !o.closest('.ck-editor__editable')) {
            return
          }
          this.editor.editing.view
            .getObserver(ClipboardObserver)
            .onDomEvent({
              ...t,
              type: t.type,
              dataTransfer: t.dataTransfer,
              target: o,
              clientX: e,
              clientY: n,
              preventDefault: () => t.preventDefault(),
              stopPropagation: () => t.stopPropagation(),
            })
        }
        _handleBlockDragEnd() {
          this._isBlockDragging = false
        }
      }
      class dB extends Iu {
        constructor(t) {
          super(t)
          this.affectsData = false
        }
        execute() {
          const t = this.editor.model
          const e = t.document.selection
          let n = t.schema.getLimitElement(e)
          if (e.containsEntireContent(n) || !uB(t.schema, n)) {
            do {
              n = n.parent
              if (!n) {
                return
              }
            } while (!uB(t.schema, n))
          }
          t.change((t) => {
            t.setSelection(n, 'in')
          })
        }
      }
      function uB(t, e) {
        return t.isLimit(e) && (t.checkChild(e, '$text') || t.checkChild(e, 'paragraph'))
      }
      const hB = Jc('Ctrl+A')
      class gB extends Du {
        static get pluginName() {
          return 'SelectAllEditing'
        }
        init() {
          const t = this.editor
          const e = t.editing.view
          const n = e.document
          t.commands.add('selectAll', new dB(t))
          this.listenTo(n, 'keydown', (e, n) => {
            if (Qc(n) === hB) {
              t.execute('selectAll')
              n.preventDefault()
            }
          })
        }
      }
      const fB =
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M.75 15.5a.75.75 0 0 1 .75.75V18l.008.09A.5.5 0 0 0 2 18.5h1.75a.75.75 0 1 1 0 1.5H1.5l-.144-.007a1.5 1.5 0 0 1-1.35-1.349L0 18.5v-2.25a.75.75 0 0 1 .75-.75zm18.5 0a.75.75 0 0 1 .75.75v2.25l-.007.144a1.5 1.5 0 0 1-1.349 1.35L18.5 20h-2.25a.75.75 0 1 1 0-1.5H18a.5.5 0 0 0 .492-.41L18.5 18v-1.75a.75.75 0 0 1 .75-.75zm-10.45 3c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm.45-5.5a.75.75 0 1 1 0 1.5h-8.5a.75.75 0 1 1 0-1.5h8.5zM1.3 11c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM1.3 7c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5h-2.5a.75.75 0 1 1 0-1.5h2.5zm-5 0a.75.75 0 1 1 0 1.5h-5.5a.75.75 0 0 1 0-1.5h5.5zm-6.5-5a.75.75 0 0 1 0 1.5H2a.5.5 0 0 0-.492.41L1.5 2v1.75a.75.75 0 0 1-1.5 0V1.5l.007-.144A1.5 1.5 0 0 1 1.356.006L1.5 0h2.25zM18.5 0l.144.007a1.5 1.5 0 0 1 1.35 1.349L20 1.5v2.25a.75.75 0 1 1-1.5 0V2l-.008-.09A.5.5 0 0 0 18 1.5h-1.75a.75.75 0 1 1 0-1.5h2.25zM8.8 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6z"/></svg>'
      class mB extends Du {
        static get pluginName() {
          return 'SelectAllUI'
        }
        init() {
          const t = this.editor
          t.ui.componentFactory.add('selectAll', (e) => {
            const n = t.commands.get('selectAll')
            const o = new Dd(e)
            const i = e.t
            o.set({ label: i('Select all'), icon: fB, keystroke: 'Ctrl+A', tooltip: true })
            o.bind('isEnabled').to(n, 'isEnabled')
            this.listenTo(o, 'execute', () => {
              t.execute('selectAll')
              t.editing.view.focus()
            })
            return o
          })
        }
      }
      class pB extends Du {
        static get requires() {
          return [gB, mB]
        }
        static get pluginName() {
          return 'SelectAll'
        }
      }
      class bB extends Iu {
        constructor(t) {
          super(t)
          this._stack = []
          this._createdBatches = new WeakSet()
          this.refresh()
          this._isEnabledBasedOnSelection = false
          this.listenTo(
            t.data,
            'set',
            (t, e) => {
              e[1] = { ...e[1] }
              const n = e[1]
              if (!n.batchType) {
                n.batchType = { isUndoable: false }
              }
            },
            { priority: 'high' },
          )
          this.listenTo(t.data, 'set', (t, e) => {
            const n = e[1]
            if (!n.batchType.isUndoable) {
              this.clearStack()
            }
          })
        }
        refresh() {
          this.isEnabled = this._stack.length > 0
        }
        get createdBatches() {
          return this._createdBatches
        }
        addBatch(t) {
          const e = this.editor.model.document.selection
          const n = { ranges: e.hasOwnRange ? Array.from(e.getRanges()) : [], isBackward: e.isBackward }
          this._stack.push({ batch: t, selection: n })
          this.refresh()
        }
        clearStack() {
          this._stack = []
          this.refresh()
        }
        _restoreSelection(t, e, n) {
          const o = this.editor.model
          const i = o.document
          const r = []
          const s = t.map((t) => t.getTransformedByOperations(n))
          const a = s.flat()
          for (const t of s) {
            const e = t.filter((t) => t.root != i.graveyard).filter((t) => !wB(t, a))
            if (!e.length) {
              continue
            }
            kB(e)
            r.push(e[0])
          }
          if (r.length) {
            o.change((t) => {
              t.setSelection(r, { backward: e })
            })
          }
        }
        _undo(t, e) {
          const n = this.editor.model
          const o = n.document
          this._createdBatches.add(e)
          const i = t.operations.slice().filter((t) => t.isDocumentOperation)
          i.reverse()
          for (const t of i) {
            const i = t.baseVersion + 1
            const r = Array.from(o.history.getOperations(i))
            const s = RA([t.getReversed()], r, {
              useRelations: true,
              document: this.editor.model.document,
              padWithNoOps: false,
              forceWeakRemove: true,
            })
            const a = s.operationsA
            for (let i of a) {
              const r = i.affectedSelectable
              if (r && !n.canEditAt(r)) {
                i = new EA(i.baseVersion)
              }
              e.addOperation(i)
              n.applyOperation(i)
              o.history.setOperationAsUndone(t, i)
            }
          }
        }
      }
      function kB(t) {
        t.sort((t, e) => (t.start.isBefore(e.start) ? -1 : 1))
        for (let e = 1; e < t.length; e++) {
          const n = t[e - 1]
          const o = n.getJoined(t[e], true)
          if (o) {
            e--
            t.splice(e, 2, o)
          }
        }
      }
      function wB(t, e) {
        return e.some((e) => e !== t && e.containsRange(t, true))
      }
      class AB extends bB {
        execute(t = null) {
          const e = t ? this._stack.findIndex((e) => e.batch == t) : this._stack.length - 1
          const n = this._stack.splice(e, 1)[0]
          const o = this.editor.model.createBatch({ isUndo: true })
          this.editor.model.enqueueChange(o, () => {
            this._undo(n.batch, o)
            const t = this.editor.model.document.history.getOperations(n.batch.baseVersion)
            this._restoreSelection(n.selection.ranges, n.selection.isBackward, t)
          })
          this.fire('revert', n.batch, o)
          this.refresh()
        }
      }
      class _B extends bB {
        execute() {
          const t = this._stack.pop()
          const e = this.editor.model.createBatch({ isUndo: true })
          this.editor.model.enqueueChange(e, () => {
            const n = t.batch.operations[t.batch.operations.length - 1]
            const o = n.baseVersion + 1
            const i = this.editor.model.document.history.getOperations(o)
            this._restoreSelection(t.selection.ranges, t.selection.isBackward, i)
            this._undo(t.batch, e)
          })
          this.refresh()
        }
      }
      class CB extends Du {
        constructor() {
          super(...arguments)
          this._batchRegistry = new WeakSet()
        }
        static get pluginName() {
          return 'UndoEditing'
        }
        init() {
          const t = this.editor
          this._undoCommand = new AB(t)
          this._redoCommand = new _B(t)
          t.commands.add('undo', this._undoCommand)
          t.commands.add('redo', this._redoCommand)
          this.listenTo(
            t.model,
            'applyOperation',
            (t, e) => {
              const n = e[0]
              if (!n.isDocumentOperation) {
                return
              }
              const o = n.batch
              const i = this._redoCommand.createdBatches.has(o)
              const r = this._undoCommand.createdBatches.has(o)
              const s = this._batchRegistry.has(o)
              if (s) {
                return
              }
              this._batchRegistry.add(o)
              if (!o.isUndoable) {
                return
              }
              if (i) {
                this._undoCommand.addBatch(o)
              } else if (!r) {
                this._undoCommand.addBatch(o)
                this._redoCommand.clearStack()
              }
            },
            { priority: 'highest' },
          )
          this.listenTo(this._undoCommand, 'revert', (t, e, n) => {
            this._redoCommand.addBatch(n)
          })
          t.keystrokes.set('CTRL+Z', 'undo')
          t.keystrokes.set('CTRL+Y', 'redo')
          t.keystrokes.set('CTRL+SHIFT+Z', 'redo')
        }
      }
      const vB =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m5.042 9.367 2.189 1.837a.75.75 0 0 1-.965 1.149l-3.788-3.18a.747.747 0 0 1-.21-.284.75.75 0 0 1 .17-.945L6.23 4.762a.75.75 0 1 1 .964 1.15L4.863 7.866h8.917A.75.75 0 0 1 14 7.9a4 4 0 1 1-1.477 7.718l.344-1.489a2.5 2.5 0 1 0 1.094-4.73l.008-.032H5.042z"/></svg>'
      const yB =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m14.958 9.367-2.189 1.837a.75.75 0 0 0 .965 1.149l3.788-3.18a.747.747 0 0 0 .21-.284.75.75 0 0 0-.17-.945L13.77 4.762a.75.75 0 1 0-.964 1.15l2.331 1.955H6.22A.75.75 0 0 0 6 7.9a4 4 0 1 0 1.477 7.718l-.344-1.489A2.5 2.5 0 1 1 6.039 9.4l-.008-.032h8.927z"/></svg>'
      class xB extends Du {
        static get pluginName() {
          return 'UndoUI'
        }
        init() {
          const t = this.editor
          const e = t.locale
          const n = t.t
          const o = e.uiLanguageDirection == 'ltr' ? vB : yB
          const i = e.uiLanguageDirection == 'ltr' ? yB : vB
          this._addButton('undo', n('Undo'), 'CTRL+Z', o)
          this._addButton('redo', n('Redo'), 'CTRL+Y', i)
        }
        _addButton(t, e, n, o) {
          const i = this.editor
          i.ui.componentFactory.add(t, (r) => {
            const s = i.commands.get(t)
            const a = new Dd(r)
            a.set({ label: e, icon: o, keystroke: n, tooltip: true })
            a.bind('isEnabled').to(s, 'isEnabled')
            this.listenTo(a, 'execute', () => {
              i.execute(t)
              i.editing.view.focus()
            })
            return a
          })
        }
      }
      class EB extends Du {
        static get requires() {
          return [CB, xB]
        }
        static get pluginName() {
          return 'Undo'
        }
      }
      class DB extends Du {
        static get requires() {
          return [ZM, zI, pB, HI, lT, EB]
        }
        static get pluginName() {
          return 'Essentials'
        }
      }
      class TB extends Iu {
        constructor(t) {
          super(t)
          this._isEnabledBasedOnSelection = false
        }
        refresh() {
          const t = this.editor.model
          const e = t.document
          const n = bl(e.selection.getSelectedBlocks())
          this.value = !!n && n.is('element', 'paragraph')
          this.isEnabled = !!n && IB(n, t.schema)
        }
        execute(t = {}) {
          const e = this.editor.model
          const n = e.document
          const o = t.selection || n.selection
          if (!e.canEditAt(o)) {
            return
          }
          e.change((t) => {
            const n = o.getSelectedBlocks()
            for (const o of n) {
              if (!o.is('element', 'paragraph') && IB(o, e.schema)) {
                t.rename(o, 'paragraph')
              }
            }
          })
        }
      }
      function IB(t, e) {
        return e.checkChild(t.parent, 'paragraph') && !e.isObject(t)
      }
      class SB extends Iu {
        constructor(t) {
          super(t)
          this._isEnabledBasedOnSelection = false
        }
        execute(t) {
          const e = this.editor.model
          const n = t.attributes
          let o = t.position
          if (!e.canEditAt(o)) {
            return
          }
          e.change((t) => {
            const i = t.createElement('paragraph')
            const r = e.schema.findAllowedParent(o, i)
            if (!r) {
              return
            }
            if (n) {
              e.schema.setAllowedAttributes(i, n, t)
            }
            if (o.path.length < 2) {
              e.insertContent(i, o)
              t.setSelection(i, 'in')
              return
            }
            const s = o.parent
            const a = s.isEmpty
            const c = o.isAtEnd && !s.isEmpty
            const l = o.isAtStart && !s.isEmpty
            const d = e.schema.checkChild(s, i)
            if (a || c) {
              o = t.createPositionAfter(s)
            } else if (l) {
              o = t.createPositionBefore(s)
            } else if (!d) {
              o = t.split(o, r).position
            }
            e.insertContent(i, o)
            t.setSelection(i, 'in')
          })
        }
      }
      class MB extends Du {
        static get pluginName() {
          return 'Paragraph'
        }
        init() {
          const t = this.editor
          const e = t.model
          t.commands.add('paragraph', new TB(t))
          t.commands.add('insertParagraph', new SB(t))
          e.schema.register('paragraph', { inheritAllFrom: '$block' })
          t.conversion.elementToElement({ model: 'paragraph', view: 'p' })
          t.conversion.for('upcast').elementToElement({
            model: (t, { writer: e }) => {
              if (!MB.paragraphLikeElements.has(t.name)) {
                return null
              }
              if (t.isEmpty) {
                return null
              }
              return e.createElement('paragraph')
            },
            view: /.+/,
            converterPriority: 'low',
          })
        }
      }
      MB.paragraphLikeElements = new Set([
        'blockquote',
        'dd',
        'div',
        'dt',
        'h1',
        'h2',
        'h3',
        'h4',
        'h5',
        'h6',
        'li',
        'p',
        'td',
        'th',
      ])
      const BB = Sv.paragraph
      class NB extends (null && Plugin) {
        static get requires() {
          return [Paragraph]
        }
        init() {
          const t = this.editor
          const e = t.t
          t.ui.componentFactory.add('paragraph', (n) => {
            const o = new ButtonView(n)
            const i = t.commands.get('paragraph')
            o.label = e('Paragraph')
            o.icon = BB
            o.tooltip = true
            o.isToggleable = true
            o.bind('isEnabled').to(i)
            o.bind('isOn').to(i, 'value')
            o.on('execute', () => {
              t.execute('paragraph')
            })
            return o
          })
        }
      }
      class PB extends Iu {
        constructor(t, e) {
          super(t)
          this.modelElements = e
        }
        refresh() {
          const t = bl(this.editor.model.document.selection.getSelectedBlocks())
          this.value = !!t && this.modelElements.includes(t.name) && t.name
          this.isEnabled = !!t && this.modelElements.some((e) => LB(t, e, this.editor.model.schema))
        }
        execute(t) {
          const e = this.editor.model
          const n = e.document
          const o = t.value
          e.change((t) => {
            const i = Array.from(n.selection.getSelectedBlocks()).filter((t) => LB(t, o, e.schema))
            for (const e of i) {
              if (!e.is('element', o)) {
                t.rename(e, o)
              }
            }
          })
        }
      }
      function LB(t, e, n) {
        return n.checkChild(t.parent, e) && !n.isObject(t)
      }
      const zB = 'paragraph'
      class RB extends Du {
        static get pluginName() {
          return 'HeadingEditing'
        }
        constructor(t) {
          super(t)
          t.config.define('heading', {
            options: [
              { model: 'paragraph', title: 'Paragraph', class: 'ck-heading_paragraph' },
              { model: 'heading1', view: 'h2', title: 'Heading 1', class: 'ck-heading_heading1' },
              { model: 'heading2', view: 'h3', title: 'Heading 2', class: 'ck-heading_heading2' },
              { model: 'heading3', view: 'h4', title: 'Heading 3', class: 'ck-heading_heading3' },
            ],
          })
        }
        static get requires() {
          return [MB]
        }
        init() {
          const t = this.editor
          const e = t.config.get('heading.options')
          const n = []
          for (const o of e) {
            if (o.model === 'paragraph') {
              continue
            }
            t.model.schema.register(o.model, { inheritAllFrom: '$block' })
            t.conversion.elementToElement(o)
            n.push(o.model)
          }
          this._addDefaultH1Conversion(t)
          t.commands.add('heading', new PB(t, n))
        }
        afterInit() {
          const t = this.editor
          const e = t.commands.get('enter')
          const n = t.config.get('heading.options')
          if (e) {
            this.listenTo(e, 'afterExecute', (e, o) => {
              const i = t.model.document.selection.getFirstPosition().parent
              const r = n.some((t) => i.is('element', t.model))
              if (r && !i.is('element', zB) && i.childCount === 0) {
                o.writer.rename(i, zB)
              }
            })
          }
        }
        _addDefaultH1Conversion(t) {
          t.conversion.for('upcast').elementToElement({ model: 'heading1', view: 'h1', converterPriority: M.low + 1 })
        }
      }
      function OB(t) {
        const e = t.t
        const n = {
          Paragraph: e('Paragraph'),
          'Heading 1': e('Heading 1'),
          'Heading 2': e('Heading 2'),
          'Heading 3': e('Heading 3'),
          'Heading 4': e('Heading 4'),
          'Heading 5': e('Heading 5'),
          'Heading 6': e('Heading 6'),
        }
        return t.config.get('heading.options').map((t) => {
          const e = n[t.title]
          if (e && e != t.title) {
            t.title = e
          }
          return t
        })
      }
      var VB = n(4249)
      var FB = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      FB.insert = 'head'
      FB.singleton = true
      var jB = Rl()(VB.Z, FB)
      const HB = VB.Z.locals || {}
      class UB extends Du {
        static get pluginName() {
          return 'HeadingUI'
        }
        init() {
          const t = this.editor
          const e = t.t
          const n = OB(t)
          const o = e('Choose heading')
          const i = e('Heading')
          t.ui.componentFactory.add('heading', (e) => {
            const r = {}
            const s = new pl()
            const a = t.commands.get('heading')
            const c = t.commands.get('paragraph')
            const l = [a]
            for (const t of n) {
              const e = {
                type: 'button',
                model: new UE({ label: t.title, class: t.class, role: 'menuitemradio', withText: true }),
              }
              if (t.model === 'paragraph') {
                e.model.bind('isOn').to(c, 'value')
                e.model.set('commandName', 'paragraph')
                l.push(c)
              } else {
                e.model.bind('isOn').to(a, 'value', (e) => e === t.model)
                e.model.set({ commandName: 'heading', commandValue: t.model })
              }
              s.add(e)
              r[t.model] = t.title
            }
            const d = ay(e)
            dy(d, s, { ariaLabel: i, role: 'menu' })
            d.buttonView.set({ ariaLabel: i, ariaLabelledBy: undefined, isOn: false, withText: true, tooltip: i })
            d.extendTemplate({ attributes: { class: ['ck-heading-dropdown'] } })
            d.bind('isEnabled').toMany(l, 'isEnabled', (...t) => t.some((t) => t))
            d.buttonView.bind('label').to(a, 'value', c, 'value', (t, e) => {
              const n = t || (e && 'paragraph')
              if (typeof n === 'boolean') {
                return o
              }
              if (!r[n]) {
                return o
              }
              return r[n]
            })
            this.listenTo(d, 'execute', (e) => {
              const { commandName: n, commandValue: o } = e.source
              t.execute(n, o ? { value: o } : undefined)
              t.editing.view.focus()
            })
            return d
          })
        }
      }
      class WB extends Du {
        static get requires() {
          return [RB, UB]
        }
        static get pluginName() {
          return 'Heading'
        }
      }
      const GB =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M19 9v10h-2v-8h-2V9h4zM4 8.5h5V4a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1v11.5a1 1 0 0 1-1 1H10a1 1 0 0 1-1-1V11H4v4.5a1 1 0 0 1-1 1h-.5a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1H3a1 1 0 0 1 1 1v4.5z"/></svg>'
      const qB =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 8.5h5V4a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1v11.5a1 1 0 0 1-1 1H9a1 1 0 0 1-1-1V11H3v4.5a1 1 0 0 1-1 1h-.5a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1H2a1 1 0 0 1 1 1v4.5zm16.076 8.343V18.5h-6.252c.067-.626.27-1.22.61-1.78.338-.561 1.006-1.305 2.005-2.232.804-.749 1.297-1.257 1.479-1.523.245-.368.368-.732.368-1.092 0-.398-.107-.703-.32-.917-.214-.214-.51-.32-.886-.32-.372 0-.669.111-.889.336-.22.224-.347.596-.38 1.117l-1.778-.178c.106-.982.438-1.686.997-2.114.558-.427 1.257-.64 2.095-.64.918 0 1.64.247 2.164.742.525.495.787 1.11.787 1.847 0 .419-.075.818-.225 1.197-.15.378-.388.775-.714 1.19-.216.275-.605.67-1.168 1.187-.563.516-.92.859-1.07 1.028a3.11 3.11 0 0 0-.365.495h3.542z"/></svg>'
      const $B =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 8.5h5V4a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1v11.5a1 1 0 0 1-1 1H9a1 1 0 0 1-1-1V11H3v4.5a1 1 0 0 1-1 1h-.5a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1H2a1 1 0 0 1 1 1v4.5zm9.989 7.53 1.726-.209c.055.44.203.777.445 1.01.24.232.533.349.876.349.368 0 .678-.14.93-.42.251-.279.377-.655.377-1.13 0-.448-.12-.803-.362-1.066a1.153 1.153 0 0 0-.882-.393c-.228 0-.501.044-.819.133l.197-1.453c.482.012.85-.092 1.105-.315.253-.222.38-.517.38-.885 0-.313-.093-.563-.279-.75-.186-.185-.434-.278-.743-.278a1.07 1.07 0 0 0-.78.317c-.216.212-.347.52-.394.927l-1.644-.28c.114-.562.287-1.012.517-1.348.231-.337.553-.601.965-.794a3.24 3.24 0 0 1 1.387-.289c.876 0 1.579.28 2.108.838.436.457.653.973.653 1.549 0 .817-.446 1.468-1.339 1.955.533.114.96.37 1.28.768.319.398.478.878.478 1.441 0 .817-.298 1.513-.895 2.088-.596.576-1.339.864-2.228.864-.842 0-1.54-.243-2.094-.727-.555-.485-.876-1.118-.965-1.901z"/></svg>'
      const KB =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3.5 8.5h5V4a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1v11.5a1 1 0 0 1-1 1h-.5a1 1 0 0 1-1-1V11h-5v4.5a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1v4.5zm13.55 10v-1.873h-3.81v-1.561l4.037-5.91h1.498v5.904h1.156v1.567h-1.156V18.5H17.05zm0-3.44v-3.18l-2.14 3.18h2.14z"/></svg>'
      const YB =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3.5 8.5h5V4a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1v11.5a1 1 0 0 1-1 1h-.5a1 1 0 0 1-1-1V11h-5v4.5a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1v4.5zm9.578 7.607 1.777-.184c.05.402.201.72.45.955a1.223 1.223 0 0 0 1.81-.101c.258-.303.387-.759.387-1.368 0-.572-.128-1-.384-1.286-.256-.285-.59-.428-1-.428-.512 0-.971.226-1.377.679l-1.448-.21.915-4.843h4.716v1.67H15.56l-.28 1.58a2.697 2.697 0 0 1 1.219-.298 2.68 2.68 0 0 1 2.012.863c.55.576.825 1.323.825 2.241a3.36 3.36 0 0 1-.666 2.05c-.605.821-1.445 1.232-2.52 1.232-.86 0-1.56-.23-2.101-.692-.542-.461-.866-1.081-.971-1.86z"/></svg>'
      const ZB =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3.5 8.5h5V4a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1v11.5a1 1 0 0 1-1 1h-.5a1 1 0 0 1-1-1V11h-5v4.5a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1v4.5zm15.595 2.973-1.726.19c-.043-.355-.153-.617-.33-.787-.178-.169-.409-.253-.692-.253-.377 0-.695.169-.956.507-.26.339-.424 1.043-.492 2.114.445-.525.997-.787 1.657-.787.745 0 1.383.284 1.914.85.531.568.797 1.3.797 2.197 0 .952-.28 1.716-.838 2.291-.559.576-1.276.864-2.152.864-.94 0-1.712-.365-2.317-1.095-.605-.73-.908-1.927-.908-3.59 0-1.705.316-2.935.946-3.688.63-.753 1.45-1.13 2.457-1.13.706 0 1.291.198 1.755.594.463.395.758.97.885 1.723zm-4.043 3.891c0 .58.133 1.028.4 1.343.266.315.57.473.914.473.33 0 .605-.13.825-.388.22-.258.33-.68.33-1.27 0-.604-.118-1.047-.355-1.329a1.115 1.115 0 0 0-.89-.422c-.342 0-.632.134-.869.403s-.355.666-.355 1.19z"/></svg>'
      const QB = { heading1: GB, heading2: qB, heading3: $B, heading4: KB, heading5: YB, heading6: ZB }
      class JB extends (null && Plugin) {
        init() {
          const t = getLocalizedOptions(this.editor)
          t.filter((t) => t.model !== 'paragraph').map((t) => this._createButton(t))
        }
        _createButton(t) {
          const e = this.editor
          e.ui.componentFactory.add(t.model, (n) => {
            const o = new ButtonView(n)
            const i = e.commands.get('heading')
            o.label = t.title
            o.icon = t.icon || QB[t.model]
            o.tooltip = true
            o.isToggleable = true
            o.bind('isEnabled').to(i)
            o.bind('isOn').to(i, 'value', (e) => e == t.model)
            o.on('execute', () => {
              e.execute('heading', { value: t.model })
              e.editing.view.focus()
            })
            return o
          })
        }
      }
      const XB = new Set(['paragraph', 'heading1', 'heading2', 'heading3', 'heading4', 'heading5', 'heading6'])
      class tN extends (null && Plugin) {
        constructor() {
          super(...arguments)
          this._bodyPlaceholder = new Map()
        }
        static get pluginName() {
          return 'Title'
        }
        static get requires() {
          return ['Paragraph']
        }
        init() {
          const t = this.editor
          const e = t.model
          e.schema.register('title', { isBlock: true, allowIn: '$root' })
          e.schema.register('title-content', { isBlock: true, allowIn: 'title', allowAttributes: ['alignment'] })
          e.schema.extend('$text', { allowIn: 'title-content' })
          e.schema.addAttributeCheck((t) => {
            if (t.endsWith('title-content $text')) {
              return false
            }
          })
          t.editing.mapper.on('modelToViewPosition', nN(t.editing.view))
          t.data.mapper.on('modelToViewPosition', nN(t.editing.view))
          t.conversion.for('downcast').elementToElement({ model: 'title-content', view: 'h1' })
          t.conversion.for('downcast').add((t) =>
            t.on('insert:title', (t, e, n) => {
              n.consumable.consume(e.item, t.name)
            }),
          )
          t.data.upcastDispatcher.on('element:h1', eN, { priority: 'high' })
          t.data.upcastDispatcher.on('element:h2', eN, { priority: 'high' })
          t.data.upcastDispatcher.on('element:h3', eN, { priority: 'high' })
          e.document.registerPostFixer((t) => this._fixTitleContent(t))
          e.document.registerPostFixer((t) => this._fixTitleElement(t))
          e.document.registerPostFixer((t) => this._fixBodyElement(t))
          e.document.registerPostFixer((t) => this._fixExtraParagraph(t))
          this._attachPlaceholders()
          this._attachTabPressHandling()
        }
        getTitle(t = {}) {
          const e = t.rootName ? t.rootName : undefined
          const n = this._getTitleElement(e)
          const o = n.getChild(0)
          return this.editor.data.stringify(o, t)
        }
        getBody(t = {}) {
          const e = this.editor
          const n = e.data
          const o = e.model
          const i = t.rootName ? t.rootName : undefined
          const r = e.model.document.getRoot(i)
          const s = e.editing.view
          const a = new DowncastWriter(s.document)
          const c = o.createRangeIn(r)
          const l = a.createDocumentFragment()
          const d = o.createPositionAfter(r.getChild(0))
          const u = o.createRange(d, o.createPositionAt(r, 'end'))
          const h = new Map()
          for (const t of o.markers) {
            const e = u.getIntersection(t.getRange())
            if (e) {
              h.set(t.name, e)
            }
          }
          n.mapper.clearBindings()
          n.mapper.bindElements(r, l)
          n.downcastDispatcher.convert(c, h, a, t)
          a.remove(a.createRangeOn(l.getChild(0)))
          return e.data.processor.toData(l)
        }
        _getTitleElement(t) {
          const e = this.editor.model.document.getRoot(t)
          for (const t of e.getChildren()) {
            if (oN(t)) {
              return t
            }
          }
        }
        _fixTitleContent(t) {
          let e = false
          for (const n of this.editor.model.document.getRootNames()) {
            const o = this._getTitleElement(n)
            if (!o || o.maxOffset === 1) {
              continue
            }
            const i = Array.from(o.getChildren())
            i.shift()
            for (const e of i) {
              t.move(t.createRangeOn(e), o, 'after')
              t.rename(e, 'paragraph')
            }
            e = true
          }
          return e
        }
        _fixTitleElement(t) {
          let e = false
          const n = this.editor.model
          for (const o of this.editor.model.document.getRoots()) {
            const i = Array.from(o.getChildren()).filter(oN)
            const r = i[0]
            const s = o.getChild(0)
            if (s.is('element', 'title')) {
              if (i.length > 1) {
                rN(i, t, n)
                e = true
              }
              continue
            }
            if (!r && !XB.has(s.name)) {
              const n = t.createElement('title')
              t.insert(n, o)
              t.insertElement('title-content', n)
              e = true
              continue
            }
            if (XB.has(s.name)) {
              iN(s, t, n)
            } else {
              t.move(t.createRangeOn(r), o, 0)
            }
            rN(i, t, n)
            e = true
          }
          return e
        }
        _fixBodyElement(t) {
          let e = false
          for (const n of this.editor.model.document.getRootNames()) {
            const o = this.editor.model.document.getRoot(n)
            if (o.childCount < 2) {
              const i = t.createElement('paragraph')
              t.insert(i, o, 1)
              this._bodyPlaceholder.set(n, i)
              e = true
            }
          }
          return e
        }
        _fixExtraParagraph(t) {
          let e = false
          for (const n of this.editor.model.document.getRootNames()) {
            const o = this.editor.model.document.getRoot(n)
            const i = this._bodyPlaceholder.get(n)
            if (aN(i, o)) {
              this._bodyPlaceholder.delete(n)
              t.remove(i)
              e = true
            }
          }
          return e
        }
        _attachPlaceholders() {
          const t = this.editor
          const e = t.t
          const n = t.editing.view
          const o = t.sourceElement
          const i = t.config.get('title.placeholder') || e('Type your title')
          const r =
            t.config.get('placeholder') ||
            (o && o.tagName.toLowerCase() === 'textarea' && o.getAttribute('placeholder')) ||
            e('Type or paste your content here.')
          t.editing.downcastDispatcher.on('insert:title-content', (t, e, o) => {
            const r = o.mapper.toViewElement(e.item)
            r.placeholder = i
            enablePlaceholder({ view: n, element: r, keepOnFocus: true })
          })
          const s = new Map()
          n.document.registerPostFixer((t) => {
            let e = false
            for (const o of n.document.roots) {
              if (o.isEmpty) {
                continue
              }
              const n = o.getChild(1)
              const i = s.get(o.rootName)
              if (n !== i) {
                if (i) {
                  hidePlaceholder(t, i)
                  t.removeAttribute('data-placeholder', i)
                }
                t.setAttribute('data-placeholder', r, n)
                s.set(o.rootName, n)
                e = true
              }
              if (needsPlaceholder(n, true) && o.childCount === 2 && n.name === 'p') {
                e = showPlaceholder(t, n) ? true : e
              } else {
                e = hidePlaceholder(t, n) ? true : e
              }
            }
            return e
          })
        }
        _attachTabPressHandling() {
          const t = this.editor
          const e = t.model
          t.keystrokes.set('TAB', (t, n) => {
            e.change((t) => {
              const o = e.document.selection
              const i = Array.from(o.getSelectedBlocks())
              if (i.length === 1 && i[0].is('element', 'title-content')) {
                const e = o.getFirstPosition().root
                const i = e.getChild(1)
                t.setSelection(i, 0)
                n()
              }
            })
          })
          t.keystrokes.set('SHIFT + TAB', (n, o) => {
            e.change((n) => {
              const i = e.document.selection
              if (!i.isCollapsed) {
                return
              }
              const r = first(i.getSelectedBlocks())
              const s = i.getFirstPosition()
              const a = t.model.document.getRoot(s.root.rootName)
              const c = a.getChild(0)
              const l = a.getChild(1)
              if (r === l && s.isAtStart) {
                n.setSelection(c.getChild(0), 0)
                o()
              }
            })
          })
        }
      }
      function eN(t, e, n) {
        const o = e.modelCursor
        const i = e.viewItem
        if (!o.isAtStart || !o.parent.is('element', '$root')) {
          return
        }
        if (!n.consumable.consume(i, { name: true })) {
          return
        }
        const r = n.writer
        const s = r.createElement('title')
        const a = r.createElement('title-content')
        r.append(a, s)
        r.insert(s, o)
        n.convertChildren(i, a)
        n.updateConversionResult(s, e)
      }
      function nN(t) {
        return (e, n) => {
          const o = n.modelPosition.parent
          if (!o.is('element', 'title')) {
            return
          }
          const i = o.parent
          const r = n.mapper.toViewElement(i)
          n.viewPosition = t.createPositionAt(r, 0)
          e.stop()
        }
      }
      function oN(t) {
        return t.is('element', 'title')
      }
      function iN(t, e, n) {
        const o = e.createElement('title')
        e.insert(o, t, 'before')
        e.insert(t, o, 0)
        e.rename(t, 'title-content')
        n.schema.removeDisallowedAttributes([t], e)
      }
      function rN(t, e, n) {
        let o = false
        for (const i of t) {
          if (i.index !== 0) {
            sN(i, e, n)
            o = true
          }
        }
        return o
      }
      function sN(t, e, n) {
        const o = t.getChild(0)
        if (o.isEmpty) {
          e.remove(t)
          return
        }
        e.move(e.createRangeOn(o), t, 'before')
        e.rename(o, 'paragraph')
        e.remove(t)
        n.schema.removeDisallowedAttributes([o], e)
      }
      function aN(t, e) {
        if (!t || !t.is('element', 'paragraph') || t.childCount) {
          return false
        }
        if (e.childCount <= 2 || e.getChild(e.childCount - 1) !== t) {
          return false
        }
        return true
      }
      function cN(t) {
        return t.createContainerElement('span', { class: 'image-inline' }, t.createEmptyElement('img'))
      }
      function lN(t) {
        return t.createContainerElement('figure', { class: 'image' }, [
          t.createEmptyElement('img'),
          t.createSlot('children'),
        ])
      }
      function dN(t, e) {
        const n = t.plugins.get('ImageUtils')
        const o = t.plugins.has('ImageInlineEditing') && t.plugins.has('ImageBlockEditing')
        return (t) => {
          if (!n.isInlineImageView(t)) {
            return null
          }
          if (!o) {
            return i(t)
          }
          const r =
            t.getStyle('display') == 'block' || t.findAncestor(n.isBlockImageView) ? 'imageBlock' : 'imageInline'
          if (r !== e) {
            return null
          }
          return i(t)
        }
        function i(t) {
          const e = { name: true }
          if (t.hasAttribute('src')) {
            e.attributes = ['src']
          }
          return e
        }
      }
      function uN(t, e) {
        const n = bl(e.getSelectedBlocks())
        if (!n || t.isObject(n)) {
          return 'imageBlock'
        }
        if (n.isEmpty && n.name != 'listItem') {
          return 'imageBlock'
        }
        return 'imageInline'
      }
      class hN extends Du {
        static get pluginName() {
          return 'ImageUtils'
        }
        isImage(t) {
          return this.isInlineImage(t) || this.isBlockImage(t)
        }
        isInlineImageView(t) {
          return !!t && t.is('element', 'img')
        }
        isBlockImageView(t) {
          return !!t && t.is('element', 'figure') && t.hasClass('image')
        }
        insertImage(t = {}, e = null, n = null) {
          const o = this.editor
          const i = o.model
          const r = i.document.selection
          n = pN(o, e || r, n)
          t = { ...Object.fromEntries(r.getAttributes()), ...t }
          for (const e in t) {
            if (!i.schema.checkAttribute(n, e)) {
              delete t[e]
            }
          }
          return i.change((o) => {
            const r = o.createElement(n, t)
            i.insertObject(r, e, null, {
              setSelection: 'on',
              findOptimalPosition: !e && n != 'imageInline' ? 'auto' : undefined,
            })
            if (r.parent) {
              return r
            }
            return null
          })
        }
        getClosestSelectedImageWidget(t) {
          const e = t.getFirstPosition()
          if (!e) {
            return null
          }
          const n = t.getSelectedElement()
          if (n && this.isImageWidget(n)) {
            return n
          }
          let o = e.parent
          while (o) {
            if (o.is('element') && this.isImageWidget(o)) {
              return o
            }
            o = o.parent
          }
          return null
        }
        getClosestSelectedImageElement(t) {
          const e = t.getSelectedElement()
          return this.isImage(e) ? e : t.getFirstPosition().findAncestor('imageBlock')
        }
        isImageAllowed() {
          const t = this.editor.model
          const e = t.document.selection
          return gN(this.editor, e) && fN(e)
        }
        toImageWidget(t, e, n) {
          e.setCustomProperty('image', true, t)
          const o = () => {
            const e = this.findViewImgElement(t)
            const o = e.getAttribute('alt')
            return o ? `${o} ${n}` : n
          }
          return ES(t, e, { label: o })
        }
        isImageWidget(t) {
          return !!t.getCustomProperty('image') && xS(t)
        }
        isBlockImage(t) {
          return !!t && t.is('element', 'imageBlock')
        }
        isInlineImage(t) {
          return !!t && t.is('element', 'imageInline')
        }
        findViewImgElement(t) {
          if (this.isInlineImageView(t)) {
            return t
          }
          const e = this.editor.editing.view
          for (const { item: n } of e.createRangeIn(t)) {
            if (this.isInlineImageView(n)) {
              return n
            }
          }
        }
      }
      function gN(t, e) {
        const n = pN(t, e, null)
        if (n == 'imageBlock') {
          const n = mN(e, t.model)
          if (t.model.schema.checkChild(n, 'imageBlock')) {
            return true
          }
        } else if (t.model.schema.checkChild(e.focus, 'imageInline')) {
          return true
        }
        return false
      }
      function fN(t) {
        return [...t.focus.getAncestors()].every((t) => !t.is('element', 'imageBlock'))
      }
      function mN(t, e) {
        const n = NS(t, e)
        const o = n.start.parent
        if (o.isEmpty && !o.is('element', '$root')) {
          return o.parent
        }
        return o
      }
      function pN(t, e, n) {
        const o = t.model.schema
        const i = t.config.get('image.insert.type')
        if (!t.plugins.has('ImageBlockEditing')) {
          return 'imageInline'
        }
        if (!t.plugins.has('ImageInlineEditing')) {
          return 'imageBlock'
        }
        if (n) {
          return n
        }
        if (i === 'inline') {
          return 'imageInline'
        }
        if (i === 'block') {
          return 'imageBlock'
        }
        if (e.is('selection')) {
          return uN(o, e)
        }
        return o.checkChild(e, 'imageInline') ? 'imageInline' : 'imageBlock'
      }
      const bN = new RegExp(
        String(
          /^(http(s)?:\/\/)?[\w-]+\.[\w.~:/[\]@!$&'()*+,;=%-]+/.source +
            /\.(jpg|jpeg|png|gif|ico|webp|JPG|JPEG|PNG|GIF|ICO|WEBP)/.source +
            /(\?[\w.~:/[\]@!$&'()*+,;=%-]*)?/.source +
            /(#[\w.~:/[\]@!$&'()*+,;=%-]*)?$/.source,
        ),
      )
      class kN extends (null && Plugin) {
        static get requires() {
          return [Clipboard, ImageUtils, Undo, Delete]
        }
        static get pluginName() {
          return 'AutoImage'
        }
        constructor(t) {
          super(t)
          this._timeoutId = null
          this._positionToInsert = null
        }
        init() {
          const t = this.editor
          const e = t.model.document
          const n = t.plugins.get('ClipboardPipeline')
          this.listenTo(n, 'inputTransformation', () => {
            const t = e.selection.getFirstRange()
            const n = LivePosition.fromPosition(t.start)
            n.stickiness = 'toPrevious'
            const o = LivePosition.fromPosition(t.end)
            o.stickiness = 'toNext'
            e.once(
              'change:data',
              () => {
                this._embedImageBetweenPositions(n, o)
                n.detach()
                o.detach()
              },
              { priority: 'high' },
            )
          })
          t.commands.get('undo').on(
            'execute',
            () => {
              if (this._timeoutId) {
                global.window.clearTimeout(this._timeoutId)
                this._positionToInsert.detach()
                this._timeoutId = null
                this._positionToInsert = null
              }
            },
            { priority: 'high' },
          )
        }
        _embedImageBetweenPositions(t, e) {
          const n = this.editor
          const o = new LiveRange(t, e)
          const i = o.getWalker({ ignoreElementEnd: true })
          const r = Object.fromEntries(n.model.document.selection.getAttributes())
          const s = this.editor.plugins.get('ImageUtils')
          let a = ''
          for (const t of i) {
            if (t.item.is('$textProxy')) {
              a += t.item.data
            }
          }
          a = a.trim()
          if (!a.match(bN)) {
            o.detach()
            return
          }
          this._positionToInsert = LivePosition.fromPosition(t)
          this._timeoutId = setTimeout(() => {
            const t = n.commands.get('insertImage')
            if (!t.isEnabled) {
              o.detach()
              return
            }
            n.model.change((t) => {
              this._timeoutId = null
              t.remove(o)
              o.detach()
              let e
              if (this._positionToInsert.root.rootName !== '$graveyard') {
                e = this._positionToInsert.toPosition()
              }
              s.insertImage({ ...r, src: a }, e)
              this._positionToInsert.detach()
              this._positionToInsert = null
            })
            const e = n.plugins.get('Delete')
            e.requestUndoOnBackspace()
          }, 100)
        }
      }
      class wN extends Iu {
        refresh() {
          const t = this.editor
          const e = t.plugins.get('ImageUtils')
          const n = e.getClosestSelectedImageElement(this.editor.model.document.selection)
          this.isEnabled = !!n
          if (this.isEnabled && n.hasAttribute('alt')) {
            this.value = n.getAttribute('alt')
          } else {
            this.value = false
          }
        }
        execute(t) {
          const e = this.editor
          const n = e.plugins.get('ImageUtils')
          const o = e.model
          const i = n.getClosestSelectedImageElement(o.document.selection)
          o.change((e) => {
            e.setAttribute('alt', t.newValue, i)
          })
        }
      }
      class AN extends Du {
        static get requires() {
          return [hN]
        }
        static get pluginName() {
          return 'ImageTextAlternativeEditing'
        }
        init() {
          this.editor.commands.add('imageTextAlternative', new wN(this.editor))
        }
      }
      var _N = n(5269)
      var CN = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      CN.insert = 'head'
      CN.singleton = true
      var vN = Rl()(_N.Z, CN)
      const yN = _N.Z.locals || {}
      var xN = n(6603)
      var EN = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      EN.insert = 'head'
      EN.singleton = true
      var DN = Rl()(xN.Z, EN)
      const TN = xN.Z.locals || {}
      class IN extends Hl {
        constructor(t) {
          super(t)
          const e = this.locale.t
          this.focusTracker = new kl()
          this.keystrokes = new wl()
          this.labeledInput = this._createLabeledInputView()
          this.saveButtonView = this._createButton(e('Save'), Sv.check, 'ck-button-save')
          this.saveButtonView.type = 'submit'
          this.cancelButtonView = this._createButton(e('Cancel'), Sv.cancel, 'ck-button-cancel', 'cancel')
          this._focusables = new Pl()
          this._focusCycler = new _u({
            focusables: this._focusables,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: { focusPrevious: 'shift + tab', focusNext: 'tab' },
          })
          this.setTemplate({
            tag: 'form',
            attributes: { class: ['ck', 'ck-text-alternative-form', 'ck-responsive-form'], tabindex: '-1' },
            children: [this.labeledInput, this.saveButtonView, this.cancelButtonView],
          })
        }
        render() {
          super.render()
          this.keystrokes.listenTo(this.element)
          i({ view: this })
          ;[this.labeledInput, this.saveButtonView, this.cancelButtonView].forEach((t) => {
            this._focusables.add(t)
            this.focusTracker.add(t.element)
          })
        }
        destroy() {
          super.destroy()
          this.focusTracker.destroy()
          this.keystrokes.destroy()
        }
        _createButton(t, e, n, o) {
          const i = new Dd(this.locale)
          i.set({ label: t, icon: e, tooltip: true })
          i.extendTemplate({ attributes: { class: n } })
          if (o) {
            i.delegate('execute').to(this, o)
          }
          return i
        }
        _createLabeledInputView() {
          const t = this.locale.t
          const e = new iu(this.locale, Ay)
          e.label = t('Text alternative')
          return e
        }
      }
      function SN(t) {
        const e = t.plugins.get('ContextualBalloon')
        const n = t.plugins.get('ImageUtils')
        if (n.getClosestSelectedImageWidget(t.editing.view.document.selection)) {
          const n = MN(t)
          e.updatePosition(n)
        }
      }
      function MN(t) {
        const e = t.editing.view
        const n = Jx.defaultPositions
        const o = t.plugins.get('ImageUtils')
        return {
          target: e.domConverter.mapViewToDom(o.getClosestSelectedImageWidget(e.document.selection)),
          positions: [
            n.northArrowSouth,
            n.northArrowSouthWest,
            n.northArrowSouthEast,
            n.southArrowNorth,
            n.southArrowNorthWest,
            n.southArrowNorthEast,
            n.viewportStickyNorth,
          ],
        }
      }
      class BN extends Du {
        static get requires() {
          return [eD]
        }
        static get pluginName() {
          return 'ImageTextAlternativeUI'
        }
        init() {
          this._createButton()
        }
        destroy() {
          super.destroy()
          if (this._form) {
            this._form.destroy()
          }
        }
        _createButton() {
          const t = this.editor
          const e = t.t
          t.ui.componentFactory.add('imageTextAlternative', (n) => {
            const o = t.commands.get('imageTextAlternative')
            const i = new Dd(n)
            i.set({ label: e('Change image text alternative'), icon: Sv.lowVision, tooltip: true })
            i.bind('isEnabled').to(o, 'isEnabled')
            i.bind('isOn').to(o, 'value', (t) => !!t)
            this.listenTo(i, 'execute', () => {
              this._showForm()
            })
            return i
          })
        }
        _createForm() {
          const n = this.editor
          const o = n.editing.view
          const i = o.document
          const r = n.plugins.get('ImageUtils')
          this._balloon = this.editor.plugins.get('ContextualBalloon')
          this._form = new (e(IN))(n.locale)
          this._form.render()
          this.listenTo(this._form, 'submit', () => {
            n.execute('imageTextAlternative', { newValue: this._form.labeledInput.fieldView.element.value })
            this._hideForm(true)
          })
          this.listenTo(this._form, 'cancel', () => {
            this._hideForm(true)
          })
          this._form.keystrokes.set('Esc', (t, e) => {
            this._hideForm(true)
            e()
          })
          this.listenTo(n.ui, 'update', () => {
            if (!r.getClosestSelectedImageWidget(i.selection)) {
              this._hideForm(true)
            } else if (this._isVisible) {
              SN(n)
            }
          })
          t({
            emitter: this._form,
            activator: () => this._isVisible,
            contextElements: () => [this._balloon.view.element],
            callback: () => this._hideForm(),
          })
        }
        _showForm() {
          if (this._isVisible) {
            return
          }
          if (!this._form) {
            this._createForm()
          }
          const t = this.editor
          const e = t.commands.get('imageTextAlternative')
          const n = this._form.labeledInput
          this._form.disableCssTransitions()
          if (!this._isInBalloon) {
            this._balloon.add({ view: this._form, position: MN(t) })
          }
          n.fieldView.value = n.fieldView.element.value = e.value || ''
          this._form.labeledInput.fieldView.select()
          this._form.enableCssTransitions()
        }
        _hideForm(t = false) {
          if (!this._isInBalloon) {
            return
          }
          if (this._form.focusTracker.isFocused) {
            this._form.saveButtonView.focus()
          }
          this._balloon.remove(this._form)
          if (t) {
            this.editor.editing.view.focus()
          }
        }
        get _isVisible() {
          return !!this._balloon && this._balloon.visibleView === this._form
        }
        get _isInBalloon() {
          return !!this._balloon && this._balloon.hasView(this._form)
        }
      }
      class NN extends Du {
        static get requires() {
          return [AN, BN]
        }
        static get pluginName() {
          return 'ImageTextAlternative'
        }
      }
      function PN(t) {
        const e = (e, n, o) => {
          if (!o.consumable.test(n.viewItem, { name: true, classes: 'image' })) {
            return
          }
          const i = t.findViewImgElement(n.viewItem)
          if (!i || !o.consumable.test(i, { name: true })) {
            return
          }
          o.consumable.consume(n.viewItem, { name: true, classes: 'image' })
          const r = o.convertItem(i, n.modelCursor)
          const s = bl(r.modelRange.getItems())
          if (!s) {
            o.consumable.revert(n.viewItem, { name: true, classes: 'image' })
            return
          }
          o.convertChildren(n.viewItem, s)
          o.updateConversionResult(s, n)
        }
        return (t) => {
          t.on('element:figure', e)
        }
      }
      function LN(t) {
        const e = ['srcset', 'media', 'type', 'sizes']
        const n = (n, o, i) => {
          const r = o.viewItem
          if (!i.consumable.test(r, { name: true })) {
            return
          }
          const s = new Map()
          for (const t of r.getChildren()) {
            if (t.is('element', 'source')) {
              const n = {}
              for (const o of e) {
                if (t.hasAttribute(o)) {
                  if (i.consumable.test(t, { attributes: o })) {
                    n[o] = t.getAttribute(o)
                  }
                }
              }
              if (Object.keys(n).length) {
                s.set(t, n)
              }
            }
          }
          const a = t.findViewImgElement(r)
          if (!a) {
            return
          }
          let c = o.modelCursor.parent
          if (!c.is('element', 'imageBlock')) {
            const t = i.convertItem(a, o.modelCursor)
            o.modelRange = t.modelRange
            o.modelCursor = t.modelCursor
            c = first(t.modelRange.getItems())
          }
          i.consumable.consume(r, { name: true })
          for (const [t, e] of s) {
            i.consumable.consume(t, { attributes: Object.keys(e) })
          }
          if (s.size) {
            i.writer.setAttribute('sources', Array.from(s.values()), c)
          }
          i.convertChildren(r, c)
        }
        return (t) => {
          t.on('element:picture', n)
        }
      }
      function zN(t, e) {
        const n = (e, n, o) => {
          if (!o.consumable.consume(n.item, e.name)) {
            return
          }
          const i = o.writer
          const r = o.mapper.toViewElement(n.item)
          const s = t.findViewImgElement(r)
          if (n.attributeNewValue === null) {
            const t = n.attributeOldValue
            if (t && t.data) {
              i.removeAttribute('srcset', s)
              i.removeAttribute('sizes', s)
              if (t.width) {
                i.removeAttribute('width', s)
              }
            }
          } else {
            const t = n.attributeNewValue
            if (t && t.data) {
              i.setAttribute('srcset', t.data, s)
              i.setAttribute('sizes', '100vw', s)
              if (t.width) {
                i.setAttribute('width', t.width, s)
              }
            }
          }
        }
        return (t) => {
          t.on(`attribute:srcset:${e}`, n)
        }
      }
      function RN(t) {
        const e = (e, n, o) => {
          if (!o.consumable.consume(n.item, e.name)) {
            return
          }
          const i = o.writer
          const r = o.mapper.toViewElement(n.item)
          const s = t.findViewImgElement(r)
          const a = n.attributeNewValue
          if (a && a.length) {
            const t = i.createContainerElement(
              'picture',
              null,
              a.map((t) => i.createEmptyElement('source', t)),
            )
            const e = []
            let n = s.parent
            while (n && n.is('attributeElement')) {
              const t = n.parent
              i.unwrap(i.createRangeOn(s), n)
              e.unshift(n)
              n = t
            }
            i.insert(i.createPositionBefore(s), t)
            i.move(i.createRangeOn(s), i.createPositionAt(t, 'end'))
            for (const n of e) {
              i.wrap(i.createRangeOn(t), n)
            }
          } else if (s.parent.is('element', 'picture')) {
            const t = s.parent
            i.move(i.createRangeOn(s), i.createPositionBefore(t))
            i.remove(t)
          }
        }
        return (t) => {
          t.on('attribute:sources:imageBlock', e)
          t.on('attribute:sources:imageInline', e)
        }
      }
      function ON(t, e, n) {
        const o = (e, n, o) => {
          if (!o.consumable.consume(n.item, e.name)) {
            return
          }
          const i = o.writer
          const r = o.mapper.toViewElement(n.item)
          const s = t.findViewImgElement(r)
          i.setAttribute(n.attributeKey, n.attributeNewValue || '', s)
        }
        return (t) => {
          t.on(`attribute:${n}:${e}`, o)
        }
      }
      class VN extends Mm {
        observe(t) {
          this.listenTo(
            t,
            'load',
            (t, e) => {
              const n = e.target
              if (this.checkShouldIgnoreEventFromTarget(n)) {
                return
              }
              if (n.tagName == 'IMG') {
                this._fireEvents(e)
              }
            },
            { useCapture: true },
          )
        }
        stopObserving(t) {
          this.stopListening(t)
        }
        _fireEvents(t) {
          if (this.isEnabled) {
            this.document.fire('layoutChanged')
            this.document.fire('imageLoaded', t)
          }
        }
      }
      class FN extends Iu {
        constructor(t) {
          super(t)
          const e = t.config.get('image.insert.type')
          if (!t.plugins.has('ImageBlockEditing')) {
            if (e === 'block') {
              L('image-block-plugin-required')
            }
          }
          if (!t.plugins.has('ImageInlineEditing')) {
            if (e === 'inline') {
              L('image-inline-plugin-required')
            }
          }
        }
        refresh() {
          const t = this.editor.plugins.get('ImageUtils')
          this.isEnabled = t.isImageAllowed()
        }
        execute(t) {
          const e = sl(t.source)
          const n = this.editor.model.document.selection
          const o = this.editor.plugins.get('ImageUtils')
          const i = Object.fromEntries(n.getAttributes())
          e.forEach((t, e) => {
            const r = n.getSelectedElement()
            if (typeof t === 'string') {
              t = { src: t }
            }
            if (e && r && o.isImage(r)) {
              const e = this.editor.model.createPositionAfter(r)
              o.insertImage({ ...t, ...i }, e)
            } else {
              o.insertImage({ ...t, ...i })
            }
          })
        }
      }
      class jN extends Iu {
        refresh() {
          const t = this.editor
          const e = t.plugins.get('ImageUtils')
          const n = this.editor.model.document.selection.getSelectedElement()
          this.isEnabled = e.isImage(n)
          this.value = this.isEnabled ? n.getAttribute('src') : null
        }
        execute(t) {
          const e = this.editor.model.document.selection.getSelectedElement()
          this.editor.model.change((n) => {
            n.setAttribute('src', t.source, e)
            n.removeAttribute('srcset', e)
            n.removeAttribute('sizes', e)
          })
        }
      }
      class HN extends Du {
        static get requires() {
          return [hN]
        }
        static get pluginName() {
          return 'ImageEditing'
        }
        init() {
          const t = this.editor
          const e = t.conversion
          t.editing.view.addObserver(VN)
          e.for('upcast')
            .attributeToAttribute({ view: { name: 'img', key: 'alt' }, model: 'alt' })
            .attributeToAttribute({
              view: { name: 'img', key: 'srcset' },
              model: {
                key: 'srcset',
                value: (t) => {
                  const e = { data: t.getAttribute('srcset') }
                  if (t.hasAttribute('width')) {
                    e.width = t.getAttribute('width')
                  }
                  return e
                },
              },
            })
          const n = new FN(t)
          const o = new jN(t)
          t.commands.add('insertImage', n)
          t.commands.add('replaceImageSource', o)
          t.commands.add('imageInsert', n)
        }
      }
      class UN extends Iu {
        constructor(t, e) {
          super(t)
          this._modelElementName = e
        }
        refresh() {
          const t = this.editor
          const e = t.plugins.get('ImageUtils')
          const n = e.getClosestSelectedImageElement(this.editor.model.document.selection)
          if (this._modelElementName === 'imageBlock') {
            this.isEnabled = e.isInlineImage(n)
          } else {
            this.isEnabled = e.isBlockImage(n)
          }
        }
        execute() {
          const t = this.editor
          const e = this.editor.model
          const n = t.plugins.get('ImageUtils')
          const o = n.getClosestSelectedImageElement(e.document.selection)
          const i = Object.fromEntries(o.getAttributes())
          if (!i.src && !i.uploadId) {
            return null
          }
          return e.change((t) => {
            const r = Array.from(e.markers).filter((t) => t.getRange().containsItem(o))
            const s = n.insertImage(i, e.createSelection(o, 'on'), this._modelElementName)
            if (!s) {
              return null
            }
            const a = t.createRangeOn(s)
            for (const e of r) {
              const n = e.getRange()
              const o = n.root.rootName != '$graveyard' ? n.getJoined(a, true) : a
              t.updateMarker(e, { range: o })
            }
            return { oldElement: o, newElement: s }
          })
        }
      }
      class WN extends Du {
        static get requires() {
          return [HN, hN, bS]
        }
        static get pluginName() {
          return 'ImageBlockEditing'
        }
        init() {
          const t = this.editor
          const e = t.model.schema
          e.register('imageBlock', { inheritAllFrom: '$blockObject', allowAttributes: ['alt', 'src', 'srcset'] })
          this._setupConversion()
          if (t.plugins.has('ImageInlineEditing')) {
            t.commands.add('imageTypeBlock', new UN(this.editor, 'imageBlock'))
            this._setupClipboardIntegration()
          }
        }
        _setupConversion() {
          const t = this.editor
          const e = t.t
          const n = t.conversion
          const o = t.plugins.get('ImageUtils')
          n.for('dataDowncast').elementToStructure({ model: 'imageBlock', view: (t, { writer: e }) => lN(e) })
          n.for('editingDowncast').elementToStructure({
            model: 'imageBlock',
            view: (t, { writer: n }) => o.toImageWidget(lN(n), n, e('image widget')),
          })
          n.for('downcast').add(ON(o, 'imageBlock', 'src')).add(ON(o, 'imageBlock', 'alt')).add(zN(o, 'imageBlock'))
          n.for('upcast')
            .elementToElement({
              view: dN(t, 'imageBlock'),
              model: (t, { writer: e }) =>
                e.createElement('imageBlock', t.hasAttribute('src') ? { src: t.getAttribute('src') } : undefined),
            })
            .add(PN(o))
        }
        _setupClipboardIntegration() {
          const t = this.editor
          const e = t.model
          const n = t.editing.view
          const o = t.plugins.get('ImageUtils')
          const i = t.plugins.get('ClipboardPipeline')
          this.listenTo(i, 'inputTransformation', (i, r) => {
            const s = Array.from(r.content.getChildren())
            let a
            if (!s.every(o.isInlineImageView)) {
              return
            }
            if (r.targetRanges) {
              a = t.editing.mapper.toModelRange(r.targetRanges[0])
            } else {
              a = e.document.selection.getFirstRange()
            }
            const c = e.createSelection(a)
            if (uN(e.schema, c) === 'imageBlock') {
              const t = new Y_(n.document)
              const e = s.map((e) => t.createElement('figure', { class: 'image' }, e))
              r.content = t.createDocumentFragment(e)
            }
          })
        }
      }
      var GN = n(2430)
      var qN = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      qN.insert = 'head'
      qN.singleton = true
      var $N = Rl()(GN.Z, qN)
      const KN = GN.Z.locals || {}
      class YN extends Du {
        static get requires() {
          return [WN, hM, NN]
        }
        static get pluginName() {
          return 'ImageBlock'
        }
      }
      class ZN extends Du {
        static get requires() {
          return [HN, hN, bS]
        }
        static get pluginName() {
          return 'ImageInlineEditing'
        }
        init() {
          const t = this.editor
          const e = t.model.schema
          e.register('imageInline', { inheritAllFrom: '$inlineObject', allowAttributes: ['alt', 'src', 'srcset'] })
          e.addChildCheck((t, e) => {
            if (t.endsWith('caption') && e.name === 'imageInline') {
              return false
            }
          })
          this._setupConversion()
          if (t.plugins.has('ImageBlockEditing')) {
            t.commands.add('imageTypeInline', new UN(this.editor, 'imageInline'))
            this._setupClipboardIntegration()
          }
        }
        _setupConversion() {
          const t = this.editor
          const e = t.t
          const n = t.conversion
          const o = t.plugins.get('ImageUtils')
          n.for('dataDowncast').elementToElement({
            model: 'imageInline',
            view: (t, { writer: e }) => e.createEmptyElement('img'),
          })
          n.for('editingDowncast').elementToStructure({
            model: 'imageInline',
            view: (t, { writer: n }) => o.toImageWidget(cN(n), n, e('image widget')),
          })
          n.for('downcast').add(ON(o, 'imageInline', 'src')).add(ON(o, 'imageInline', 'alt')).add(zN(o, 'imageInline'))
          n.for('upcast').elementToElement({
            view: dN(t, 'imageInline'),
            model: (t, { writer: e }) =>
              e.createElement('imageInline', t.hasAttribute('src') ? { src: t.getAttribute('src') } : undefined),
          })
        }
        _setupClipboardIntegration() {
          const t = this.editor
          const e = t.model
          const n = t.editing.view
          const o = t.plugins.get('ImageUtils')
          const i = t.plugins.get('ClipboardPipeline')
          this.listenTo(i, 'inputTransformation', (i, r) => {
            const s = Array.from(r.content.getChildren())
            let a
            if (!s.every(o.isBlockImageView)) {
              return
            }
            if (r.targetRanges) {
              a = t.editing.mapper.toModelRange(r.targetRanges[0])
            } else {
              a = e.document.selection.getFirstRange()
            }
            const c = e.createSelection(a)
            if (uN(e.schema, c) === 'imageInline') {
              const t = new Y_(n.document)
              const e = s.map((e) => {
                if (e.childCount === 1) {
                  Array.from(e.getAttributes()).forEach((n) => t.setAttribute(...n, o.findViewImgElement(e)))
                  return e.getChild(0)
                } else {
                  return e
                }
              })
              r.content = t.createDocumentFragment(e)
            }
          })
        }
      }
      class QN extends Du {
        static get requires() {
          return [ZN, hM, NN]
        }
        static get pluginName() {
          return 'ImageInline'
        }
      }
      class JN extends Du {
        static get requires() {
          return [YN, QN]
        }
        static get pluginName() {
          return 'Image'
        }
      }
      class XN extends Du {
        static get pluginName() {
          return 'ImageCaptionUtils'
        }
        static get requires() {
          return [hN]
        }
        getCaptionFromImageModelElement(t) {
          for (const e of t.getChildren()) {
            if (!!e && e.is('element', 'caption')) {
              return e
            }
          }
          return null
        }
        getCaptionFromModelSelection(t) {
          const e = this.editor.plugins.get('ImageUtils')
          const n = t.getFirstPosition().findAncestor('caption')
          if (!n) {
            return null
          }
          if (e.isBlockImage(n.parent)) {
            return n
          }
          return null
        }
        matchImageCaptionViewElement(t) {
          const e = this.editor.plugins.get('ImageUtils')
          if (t.name == 'figcaption' && e.isBlockImageView(t.parent)) {
            return { name: true }
          }
          return null
        }
      }
      class tP extends Iu {
        refresh() {
          const t = this.editor
          const e = t.plugins.get('ImageCaptionUtils')
          const n = t.plugins.get('ImageUtils')
          if (!t.plugins.has(WN)) {
            this.isEnabled = false
            this.value = false
            return
          }
          const o = t.model.document.selection
          const i = o.getSelectedElement()
          if (!i) {
            const t = e.getCaptionFromModelSelection(o)
            this.isEnabled = !!t
            this.value = !!t
            return
          }
          this.isEnabled = n.isImage(i)
          if (!this.isEnabled) {
            this.value = false
          } else {
            this.value = !!e.getCaptionFromImageModelElement(i)
          }
        }
        execute(t = {}) {
          const { focusCaptionOnShow: e } = t
          this.editor.model.change((t) => {
            if (this.value) {
              this._hideImageCaption(t)
            } else {
              this._showImageCaption(t, e)
            }
          })
        }
        _showImageCaption(t, e) {
          const n = this.editor.model
          const o = n.document.selection
          const i = this.editor.plugins.get('ImageCaptionEditing')
          const r = this.editor.plugins.get('ImageUtils')
          let s = o.getSelectedElement()
          const a = i._getSavedCaption(s)
          if (r.isInlineImage(s)) {
            this.editor.execute('imageTypeBlock')
            s = o.getSelectedElement()
          }
          const c = a || t.createElement('caption')
          t.append(c, s)
          if (e) {
            t.setSelection(c, 'in')
          }
        }
        _hideImageCaption(t) {
          const e = this.editor
          const n = e.model.document.selection
          const o = e.plugins.get('ImageCaptionEditing')
          const i = e.plugins.get('ImageCaptionUtils')
          let r = n.getSelectedElement()
          let s
          if (r) {
            s = i.getCaptionFromImageModelElement(r)
          } else {
            s = i.getCaptionFromModelSelection(n)
            r = s.parent
          }
          o._saveCaption(r, s)
          t.setSelection(r, 'on')
          t.remove(s)
        }
      }
      class eP extends Du {
        static get requires() {
          return [hN, XN]
        }
        static get pluginName() {
          return 'ImageCaptionEditing'
        }
        constructor(t) {
          super(t)
          this._savedCaptionsMap = new WeakMap()
        }
        init() {
          const t = this.editor
          const e = t.model.schema
          if (!e.isRegistered('caption')) {
            e.register('caption', { allowIn: 'imageBlock', allowContentOf: '$block', isLimit: true })
          } else {
            e.extend('caption', { allowIn: 'imageBlock' })
          }
          t.commands.add('toggleImageCaption', new tP(this.editor))
          this._setupConversion()
          this._setupImageTypeCommandsIntegration()
          this._registerCaptionReconversion()
        }
        _setupConversion() {
          const t = this.editor
          const e = t.editing.view
          const n = t.plugins.get('ImageUtils')
          const o = t.plugins.get('ImageCaptionUtils')
          const i = t.t
          t.conversion
            .for('upcast')
            .elementToElement({ view: (t) => o.matchImageCaptionViewElement(t), model: 'caption' })
          t.conversion.for('dataDowncast').elementToElement({
            model: 'caption',
            view: (t, { writer: e }) => {
              if (!n.isBlockImage(t.parent)) {
                return null
              }
              return e.createContainerElement('figcaption')
            },
          })
          t.conversion.for('editingDowncast').elementToElement({
            model: 'caption',
            view: (t, { writer: o }) => {
              if (!n.isBlockImage(t.parent)) {
                return null
              }
              const r = o.createEditableElement('figcaption')
              o.setCustomProperty('imageCaption', true, r)
              r.placeholder = i('Enter image caption')
              Fu({ view: e, element: r, keepOnFocus: true })
              const s = t.parent.getAttribute('alt')
              const a = s ? i('Caption for image: %0', [s]) : i('Caption for the image')
              return BS(r, o, { label: a })
            },
          })
        }
        _setupImageTypeCommandsIntegration() {
          const t = this.editor
          const e = t.plugins.get('ImageUtils')
          const n = t.plugins.get('ImageCaptionUtils')
          const o = t.commands.get('imageTypeInline')
          const i = t.commands.get('imageTypeBlock')
          const r = (t) => {
            if (!t.return) {
              return
            }
            const { oldElement: o, newElement: i } = t.return
            if (!o) {
              return
            }
            if (e.isBlockImage(o)) {
              const t = n.getCaptionFromImageModelElement(o)
              if (t) {
                this._saveCaption(i, t)
                return
              }
            }
            const r = this._getSavedCaption(o)
            if (r) {
              this._saveCaption(i, r)
            }
          }
          if (o) {
            this.listenTo(o, 'execute', r, { priority: 'low' })
          }
          if (i) {
            this.listenTo(i, 'execute', r, { priority: 'low' })
          }
        }
        _getSavedCaption(t) {
          const e = this._savedCaptionsMap.get(t)
          return e ? vb.fromJSON(e) : null
        }
        _saveCaption(t, e) {
          this._savedCaptionsMap.set(t, e.toJSON())
        }
        _registerCaptionReconversion() {
          const t = this.editor
          const e = t.model
          const n = t.plugins.get('ImageUtils')
          const o = t.plugins.get('ImageCaptionUtils')
          e.document.on('change:data', () => {
            const i = e.document.differ.getChanges()
            for (const e of i) {
              if (e.attributeKey !== 'alt') {
                continue
              }
              const i = e.range.start.nodeAfter
              if (n.isBlockImage(i)) {
                const e = o.getCaptionFromImageModelElement(i)
                if (!e) {
                  return
                }
                t.editing.reconvertItem(e)
              }
            }
          })
        }
      }
      class nP extends Du {
        static get requires() {
          return [XN]
        }
        static get pluginName() {
          return 'ImageCaptionUI'
        }
        init() {
          const t = this.editor
          const e = t.editing.view
          const n = t.plugins.get('ImageCaptionUtils')
          const o = t.t
          t.ui.componentFactory.add('toggleImageCaption', (i) => {
            const r = t.commands.get('toggleImageCaption')
            const s = new Dd(i)
            s.set({ icon: Sv.caption, tooltip: true, isToggleable: true })
            s.bind('isOn', 'isEnabled').to(r, 'value', 'isEnabled')
            s.bind('label').to(r, 'value', (t) => (t ? o('Toggle caption off') : o('Toggle caption on')))
            this.listenTo(s, 'execute', () => {
              t.execute('toggleImageCaption', { focusCaptionOnShow: true })
              const o = n.getCaptionFromModelSelection(t.model.document.selection)
              if (o) {
                const n = t.editing.mapper.toViewElement(o)
                e.scrollToTheSelection()
                e.change((t) => {
                  t.addClass('image__caption_highlighted', n)
                })
              }
              t.editing.view.focus()
            })
            return s
          })
        }
      }
      var oP = n(2423)
      var iP = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      iP.insert = 'head'
      iP.singleton = true
      var rP = Rl()(oP.Z, iP)
      const sP = oP.Z.locals || {}
      class aP extends Du {
        static get requires() {
          return [eP, nP]
        }
        static get pluginName() {
          return 'ImageCaption'
        }
      }
      class cP extends ft() {
        constructor() {
          super()
          const t = new window.FileReader()
          this._reader = t
          this._data = undefined
          this.set('loaded', 0)
          t.onprogress = (t) => {
            this.loaded = t.loaded
          }
        }
        get error() {
          return this._reader.error
        }
        get data() {
          return this._data
        }
        read(t) {
          const e = this._reader
          this.total = t.size
          return new Promise((n, o) => {
            e.onload = () => {
              const t = e.result
              this._data = t
              n(t)
            }
            e.onerror = () => {
              o('error')
            }
            e.onabort = () => {
              o('aborted')
            }
            this._reader.readAsDataURL(t)
          })
        }
        abort() {
          this._reader.abort()
        }
      }
      class lP extends Du {
        constructor() {
          super(...arguments)
          this.loaders = new pl()
          this._loadersMap = new Map()
          this._pendingAction = null
        }
        static get pluginName() {
          return 'FileRepository'
        }
        static get requires() {
          return [YC]
        }
        init() {
          this.loaders.on('change', () => this._updatePendingAction())
          this.set('uploaded', 0)
          this.set('uploadTotal', null)
          this.bind('uploadedPercent').to(this, 'uploaded', this, 'uploadTotal', (t, e) => (e ? (t / e) * 100 : 0))
        }
        getLoader(t) {
          return this._loadersMap.get(t) || null
        }
        createLoader(t) {
          if (!this.createUploadAdapter) {
            L('filerepository-no-upload-adapter')
            return null
          }
          const e = new dP(Promise.resolve(t), this.createUploadAdapter)
          this.loaders.add(e)
          this._loadersMap.set(t, e)
          if (t instanceof Promise) {
            e.file
              .then((t) => {
                this._loadersMap.set(t, e)
              })
              .catch(() => {})
          }
          e.on('change:uploaded', () => {
            let t = 0
            for (const e of this.loaders) {
              t += e.uploaded
            }
            this.uploaded = t
          })
          e.on('change:uploadTotal', () => {
            let t = 0
            for (const e of this.loaders) {
              if (e.uploadTotal) {
                t += e.uploadTotal
              }
            }
            this.uploadTotal = t
          })
          return e
        }
        destroyLoader(t) {
          const e = t instanceof dP ? t : this.getLoader(t)
          e._destroy()
          this.loaders.remove(e)
          this._loadersMap.forEach((t, n) => {
            if (t === e) {
              this._loadersMap.delete(n)
            }
          })
        }
        _updatePendingAction() {
          const t = this.editor.plugins.get(YC)
          if (this.loaders.length) {
            if (!this._pendingAction) {
              const e = this.editor.t
              const n = (t) => `${e('Upload in progress')} ${parseInt(t)}%.`
              this._pendingAction = t.add(n(this.uploadedPercent))
              this._pendingAction.bind('message').to(this, 'uploadedPercent', n)
            }
          } else {
            t.remove(this._pendingAction)
            this._pendingAction = null
          }
        }
      }
      class dP extends ft() {
        constructor(t, e) {
          super()
          this.id = I()
          this._filePromiseWrapper = this._createFilePromiseWrapper(t)
          this._adapter = e(this)
          this._reader = new cP()
          this.set('status', 'idle')
          this.set('uploaded', 0)
          this.set('uploadTotal', null)
          this.bind('uploadedPercent').to(this, 'uploaded', this, 'uploadTotal', (t, e) => (e ? (t / e) * 100 : 0))
          this.set('uploadResponse', null)
        }
        get file() {
          if (!this._filePromiseWrapper) {
            return Promise.resolve(null)
          } else {
            return this._filePromiseWrapper.promise.then((t) => (this._filePromiseWrapper ? t : null))
          }
        }
        get data() {
          return this._reader.data
        }
        read() {
          if (this.status != 'idle') {
            throw new P('filerepository-read-wrong-status', this)
          }
          this.status = 'reading'
          return this.file
            .then((t) => this._reader.read(t))
            .then((t) => {
              if (this.status !== 'reading') {
                throw this.status
              }
              this.status = 'idle'
              return t
            })
            .catch((t) => {
              if (t === 'aborted') {
                this.status = 'aborted'
                throw 'aborted'
              }
              this.status = 'error'
              throw this._reader.error ? this._reader.error : t
            })
        }
        upload() {
          if (this.status != 'idle') {
            throw new P('filerepository-upload-wrong-status', this)
          }
          this.status = 'uploading'
          return this.file
            .then(() => this._adapter.upload())
            .then((t) => {
              this.uploadResponse = t
              this.status = 'idle'
              return t
            })
            .catch((t) => {
              if (this.status === 'aborted') {
                throw 'aborted'
              }
              this.status = 'error'
              throw t
            })
        }
        abort() {
          const t = this.status
          this.status = 'aborted'
          if (!this._filePromiseWrapper.isFulfilled) {
            this._filePromiseWrapper.promise.catch(() => {})
            this._filePromiseWrapper.rejecter('aborted')
          } else if (t == 'reading') {
            this._reader.abort()
          } else if (t == 'uploading' && this._adapter.abort) {
            this._adapter.abort()
          }
          this._destroy()
        }
        _destroy() {
          this._filePromiseWrapper = undefined
          this._reader = undefined
          this._adapter = undefined
          this.uploadResponse = undefined
        }
        _createFilePromiseWrapper(t) {
          const e = {}
          e.promise = new Promise((n, o) => {
            e.rejecter = o
            e.isFulfilled = false
            t.then((t) => {
              e.isFulfilled = true
              n(t)
            }).catch((t) => {
              e.isFulfilled = true
              o(t)
            })
          })
          return e
        }
      }
      class uP extends Hl {
        constructor(t) {
          super(t)
          this.buttonView = new Dd(t)
          this._fileInputView = new hP(t)
          this._fileInputView.bind('acceptedType').to(this)
          this._fileInputView.bind('allowMultipleFiles').to(this)
          this._fileInputView.delegate('done').to(this)
          this.setTemplate({
            tag: 'span',
            attributes: { class: 'ck-file-dialog-button' },
            children: [this.buttonView, this._fileInputView],
          })
          this.buttonView.on('execute', () => {
            this._fileInputView.open()
          })
        }
        focus() {
          this.buttonView.focus()
        }
      }
      class hP extends Hl {
        constructor(t) {
          super(t)
          this.set('acceptedType', undefined)
          this.set('allowMultipleFiles', false)
          const e = this.bindTemplate
          this.setTemplate({
            tag: 'input',
            attributes: {
              class: ['ck-hidden'],
              type: 'file',
              tabindex: '-1',
              accept: e.to('acceptedType'),
              multiple: e.to('allowMultipleFiles'),
            },
            on: {
              change: e.to(() => {
                if (this.element && this.element.files && this.element.files.length) {
                  this.fire('done', this.element.files)
                }
                this.element.value = ''
              }),
            },
          })
        }
        open() {
          this.element.click()
        }
      }
      class gP extends (null && Plugin) {
        static get requires() {
          return [FileRepository]
        }
        static get pluginName() {
          return 'Base64UploadAdapter'
        }
        init() {
          this.editor.plugins.get(FileRepository).createUploadAdapter = (t) => new fP(t)
        }
      }
      class fP {
        constructor(t) {
          this.loader = t
        }
        upload() {
          return new Promise((t, e) => {
            const n = (this.reader = new window.FileReader())
            n.addEventListener('load', () => {
              t({ default: n.result })
            })
            n.addEventListener('error', (t) => {
              e(t)
            })
            n.addEventListener('abort', () => {
              e()
            })
            this.loader.file.then((t) => {
              n.readAsDataURL(t)
            })
          })
        }
        abort() {
          this.reader.abort()
        }
      }
      class mP extends (null && Plugin) {
        static get requires() {
          return [FileRepository]
        }
        static get pluginName() {
          return 'SimpleUploadAdapter'
        }
        init() {
          const t = this.editor.config.get('simpleUpload')
          if (!t) {
            return
          }
          if (!t.uploadUrl) {
            logWarning('simple-upload-adapter-missing-uploadurl')
            return
          }
          this.editor.plugins.get(FileRepository).createUploadAdapter = (e) => new pP(e, t)
        }
      }
      class pP {
        constructor(t, e) {
          this.loader = t
          this.options = e
        }
        upload() {
          return this.loader.file.then(
            (t) =>
              new Promise((e, n) => {
                this._initRequest()
                this._initListeners(e, n, t)
                this._sendRequest(t)
              }),
          )
        }
        abort() {
          if (this.xhr) {
            this.xhr.abort()
          }
        }
        _initRequest() {
          const t = (this.xhr = new XMLHttpRequest())
          t.open('POST', this.options.uploadUrl, true)
          t.responseType = 'json'
        }
        _initListeners(t, e, n) {
          const o = this.xhr
          const i = this.loader
          const r = `Couldn't upload file: ${n.name}.`
          o.addEventListener('error', () => e(r))
          o.addEventListener('abort', () => e())
          o.addEventListener('load', () => {
            const n = o.response
            if (!n || n.error) {
              return e(n && n.error && n.error.message ? n.error.message : r)
            }
            const i = n.url ? { default: n.url } : n.urls
            t({ ...n, urls: i })
          })
          if (o.upload) {
            o.upload.addEventListener('progress', (t) => {
              if (t.lengthComputable) {
                i.uploadTotal = t.total
                i.uploaded = t.loaded
              }
            })
          }
        }
        _sendRequest(t) {
          const e = this.options.headers || {}
          const n = this.options.withCredentials || false
          for (const t of Object.keys(e)) {
            this.xhr.setRequestHeader(t, e[t])
          }
          this.xhr.withCredentials = n
          const o = new FormData()
          o.append('upload', t)
          this.xhr.send(o)
        }
      }
      function bP(t) {
        const e = t.map((t) => t.replace('+', '\\+'))
        return new RegExp(`^image\\/(${e.join('|')})$`)
      }
      function kP(t) {
        return new Promise((e, n) => {
          const o = t.getAttribute('src')
          fetch(o)
            .then((t) => t.blob())
            .then((t) => {
              const n = AP(t, o)
              const i = n.replace('image/', '')
              const r = `image.${i}`
              const s = new File([t], r, { type: n })
              e(s)
            })
            .catch((t) => (t && t.name === 'TypeError' ? _P(o).then(e).catch(n) : n(t)))
        })
      }
      function wP(t, e) {
        if (!t.isInlineImageView(e) || !e.getAttribute('src')) {
          return false
        }
        return !!e.getAttribute('src').match(/^data:image\/\w+;base64,/g) || !!e.getAttribute('src').match(/^blob:/g)
      }
      function AP(t, e) {
        if (t.type) {
          return t.type
        } else if (e.match(/data:(image\/\w+);base64/)) {
          return e.match(/data:(image\/\w+);base64/)[1].toLowerCase()
        } else {
          return 'image/jpeg'
        }
      }
      function _P(t) {
        return CP(t).then((e) => {
          const n = AP(e, t)
          const o = n.replace('image/', '')
          const i = `image.${o}`
          return new File([e], i, { type: n })
        })
      }
      function CP(t) {
        return new Promise((e, n) => {
          const o = oc.document.createElement('img')
          o.addEventListener('load', () => {
            const t = oc.document.createElement('canvas')
            t.width = o.width
            t.height = o.height
            const i = t.getContext('2d')
            i.drawImage(o, 0, 0)
            t.toBlob((t) => (t ? e(t) : n()))
          })
          o.addEventListener('error', () => n())
          o.src = t
        })
      }
      class vP extends Du {
        static get pluginName() {
          return 'ImageUploadUI'
        }
        init() {
          const t = this.editor
          const e = t.t
          const n = (n) => {
            const o = new uP(n)
            const i = t.commands.get('uploadImage')
            const r = t.config.get('image.upload.types')
            const s = bP(r)
            o.set({ acceptedType: r.map((t) => `image/${t}`).join(','), allowMultipleFiles: true })
            o.buttonView.set({ label: e('Insert image'), icon: Sv.image, tooltip: true })
            o.buttonView.bind('isEnabled').to(i)
            o.on('done', (e, n) => {
              const o = Array.from(n).filter((t) => s.test(t.type))
              if (o.length) {
                t.execute('uploadImage', { file: o })
                t.editing.view.focus()
              }
            })
            return o
          }
          t.ui.componentFactory.add('uploadImage', n)
          t.ui.componentFactory.add('imageUpload', n)
        }
      }
      var yP = n(2926)
      var xP = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      xP.insert = 'head'
      xP.singleton = true
      var EP = Rl()(yP.Z, xP)
      const DP = yP.Z.locals || {}
      var TP = n(1547)
      var IP = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      IP.insert = 'head'
      IP.singleton = true
      var SP = Rl()(TP.Z, IP)
      const MP = TP.Z.locals || {}
      var BP = n(6618)
      var NP = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      NP.insert = 'head'
      NP.singleton = true
      var PP = Rl()(BP.Z, NP)
      const LP = BP.Z.locals || {}
      class zP extends Du {
        static get pluginName() {
          return 'ImageUploadProgress'
        }
        constructor(t) {
          super(t)
          this.uploadStatusChange = (t, e, n) => {
            const o = this.editor
            const i = e.item
            const r = i.getAttribute('uploadId')
            if (!n.consumable.consume(e.item, t.name)) {
              return
            }
            const s = o.plugins.get('ImageUtils')
            const a = o.plugins.get(lP)
            const c = r ? e.attributeNewValue : null
            const l = this.placeholder
            const d = o.editing.mapper.toViewElement(i)
            const u = n.writer
            if (c == 'reading') {
              RP(d, u)
              VP(s, l, d, u)
              return
            }
            if (c == 'uploading') {
              const t = a.loaders.get(r)
              RP(d, u)
              if (!t) {
                VP(s, l, d, u)
              } else {
                FP(d, u)
                jP(d, u, t, o.editing.view)
                KP(s, d, u, t)
              }
              return
            }
            if (c == 'complete' && a.loaders.get(r)) {
              UP(d, u, o.editing.view)
            }
            HP(d, u)
            FP(d, u)
            OP(d, u)
          }
          this.placeholder = 'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=='
        }
        init() {
          const t = this.editor
          if (t.plugins.has('ImageBlockEditing')) {
            t.editing.downcastDispatcher.on('attribute:uploadStatus:imageBlock', this.uploadStatusChange)
          }
          if (t.plugins.has('ImageInlineEditing')) {
            t.editing.downcastDispatcher.on('attribute:uploadStatus:imageInline', this.uploadStatusChange)
          }
        }
      }
      function RP(t, e) {
        if (!t.hasClass('ck-appear')) {
          e.addClass('ck-appear', t)
        }
      }
      function OP(t, e) {
        e.removeClass('ck-appear', t)
      }
      function VP(t, e, n, o) {
        if (!n.hasClass('ck-image-upload-placeholder')) {
          o.addClass('ck-image-upload-placeholder', n)
        }
        const i = t.findViewImgElement(n)
        if (i.getAttribute('src') !== e) {
          o.setAttribute('src', e, i)
        }
        if (!qP(n, 'placeholder')) {
          o.insert(o.createPositionAfter(i), GP(o))
        }
      }
      function FP(t, e) {
        if (t.hasClass('ck-image-upload-placeholder')) {
          e.removeClass('ck-image-upload-placeholder', t)
        }
        $P(t, e, 'placeholder')
      }
      function jP(t, e, n, o) {
        const i = WP(e)
        e.insert(e.createPositionAt(t, 'end'), i)
        n.on('change:uploadedPercent', (t, e, n) => {
          o.change((t) => {
            t.setStyle('width', n + '%', i)
          })
        })
      }
      function HP(t, e) {
        $P(t, e, 'progressBar')
      }
      function UP(t, e, n) {
        const o = e.createUIElement('div', { class: 'ck-image-upload-complete-icon' })
        e.insert(e.createPositionAt(t, 'end'), o)
        setTimeout(() => {
          n.change((t) => t.remove(t.createRangeOn(o)))
        }, 3e3)
      }
      function WP(t) {
        const e = t.createUIElement('div', { class: 'ck-progress-bar' })
        t.setCustomProperty('progressBar', true, e)
        return e
      }
      function GP(t) {
        const e = t.createUIElement('div', { class: 'ck-upload-placeholder-loader' })
        t.setCustomProperty('placeholder', true, e)
        return e
      }
      function qP(t, e) {
        for (const n of t.getChildren()) {
          if (n.getCustomProperty(e)) {
            return n
          }
        }
      }
      function $P(t, e, n) {
        const o = qP(t, n)
        if (o) {
          e.remove(e.createRangeOn(o))
        }
      }
      function KP(t, e, n, o) {
        if (o.data) {
          const i = t.findViewImgElement(e)
          n.setAttribute('src', o.data, i)
        }
      }
      class YP extends Iu {
        refresh() {
          const t = this.editor
          const e = t.plugins.get('ImageUtils')
          const n = t.model.document.selection.getSelectedElement()
          this.isEnabled = e.isImageAllowed() || e.isImage(n)
        }
        execute(t) {
          const e = sl(t.file)
          const n = this.editor.model.document.selection
          const o = this.editor.plugins.get('ImageUtils')
          const i = Object.fromEntries(n.getAttributes())
          e.forEach((t, e) => {
            const r = n.getSelectedElement()
            if (e && r && o.isImage(r)) {
              const e = this.editor.model.createPositionAfter(r)
              this._uploadImage(t, i, e)
            } else {
              this._uploadImage(t, i)
            }
          })
        }
        _uploadImage(t, e, n) {
          const o = this.editor
          const i = o.plugins.get(lP)
          const r = i.createLoader(t)
          const s = o.plugins.get('ImageUtils')
          if (!r) {
            return
          }
          s.insertImage({ ...e, uploadId: r.id }, n)
        }
      }
      class ZP extends Du {
        static get requires() {
          return [lP, HE, bS, hN]
        }
        static get pluginName() {
          return 'ImageUploadEditing'
        }
        constructor(t) {
          super(t)
          t.config.define('image', { upload: { types: ['jpeg', 'png', 'gif', 'bmp', 'webp', 'tiff'] } })
          this._uploadImageElements = new Map()
        }
        init() {
          const t = this.editor
          const e = t.model.document
          const n = t.conversion
          const o = t.plugins.get(lP)
          const i = t.plugins.get('ImageUtils')
          const r = t.plugins.get('ClipboardPipeline')
          const s = bP(t.config.get('image.upload.types'))
          const a = new YP(t)
          t.commands.add('uploadImage', a)
          t.commands.add('imageUpload', a)
          n.for('upcast').attributeToAttribute({ view: { name: 'img', key: 'uploadId' }, model: 'uploadId' })
          this.listenTo(t.editing.view.document, 'clipboardInput', (e, n) => {
            if (QP(n.dataTransfer)) {
              return
            }
            const o = Array.from(n.dataTransfer.files).filter((t) => {
              if (!t) {
                return false
              }
              return s.test(t.type)
            })
            if (!o.length) {
              return
            }
            e.stop()
            t.model.change((e) => {
              if (n.targetRanges) {
                e.setSelection(n.targetRanges.map((e) => t.editing.mapper.toModelRange(e)))
              }
              t.model.enqueueChange(() => {
                t.execute('uploadImage', { file: o })
              })
            })
          })
          this.listenTo(r, 'inputTransformation', (e, n) => {
            const r = Array.from(t.editing.view.createRangeIn(n.content))
              .map((t) => t.item)
              .filter((t) => wP(i, t) && !t.getAttribute('uploadProcessed'))
              .map((t) => ({ promise: kP(t), imageElement: t }))
            if (!r.length) {
              return
            }
            const s = new Y_(t.editing.view.document)
            for (const t of r) {
              s.setAttribute('uploadProcessed', true, t.imageElement)
              const e = o.createLoader(t.promise)
              if (e) {
                s.setAttribute('src', '', t.imageElement)
                s.setAttribute('uploadId', e.id, t.imageElement)
              }
            }
          })
          t.editing.view.document.on('dragover', (t, e) => {
            e.preventDefault()
          })
          e.on('change', () => {
            const n = e.differ.getChanges({ includeChangesInGraveyard: true }).reverse()
            const i = new Set()
            for (const e of n) {
              if (e.type == 'insert' && e.name != '$text') {
                const n = e.position.nodeAfter
                const r = e.position.root.rootName == '$graveyard'
                for (const e of JP(t, n)) {
                  const t = e.getAttribute('uploadId')
                  if (!t) {
                    continue
                  }
                  const n = o.loaders.get(t)
                  if (!n) {
                    continue
                  }
                  if (r) {
                    if (!i.has(t)) {
                      n.abort()
                    }
                  } else {
                    i.add(t)
                    this._uploadImageElements.set(t, e)
                    if (n.status == 'idle') {
                      this._readAndUpload(n)
                    }
                  }
                }
              }
            }
          })
          this.on(
            'uploadComplete',
            (t, { imageElement: e, data: n }) => {
              const o = n.urls ? n.urls : n
              this.editor.model.change((t) => {
                t.setAttribute('src', o.default, e)
                this._parseAndSetSrcsetAttributeOnImage(o, e, t)
              })
            },
            { priority: 'low' },
          )
        }
        afterInit() {
          const t = this.editor.model.schema
          if (this.editor.plugins.has('ImageBlockEditing')) {
            t.extend('imageBlock', { allowAttributes: ['uploadId', 'uploadStatus'] })
          }
          if (this.editor.plugins.has('ImageInlineEditing')) {
            t.extend('imageInline', { allowAttributes: ['uploadId', 'uploadStatus'] })
          }
        }
        _readAndUpload(t) {
          const e = this.editor
          const n = e.model
          const o = e.locale.t
          const i = e.plugins.get(lP)
          const r = e.plugins.get(HE)
          const s = e.plugins.get('ImageUtils')
          const a = this._uploadImageElements
          n.enqueueChange({ isUndoable: false }, (e) => {
            e.setAttribute('uploadStatus', 'reading', a.get(t.id))
          })
          return t
            .read()
            .then(() => {
              const o = t.upload()
              const i = a.get(t.id)
              if (l.isSafari) {
                const t = e.editing.mapper.toViewElement(i)
                const n = s.findViewImgElement(t)
                e.editing.view.once('render', () => {
                  if (!n.parent) {
                    return
                  }
                  const t = e.editing.view.domConverter.mapViewToDom(n.parent)
                  if (!t) {
                    return
                  }
                  const o = t.style.display
                  t.style.display = 'none'
                  t._ckHack = t.offsetHeight
                  t.style.display = o
                })
              }
              n.enqueueChange({ isUndoable: false }, (t) => {
                t.setAttribute('uploadStatus', 'uploading', i)
              })
              return o
            })
            .then((e) => {
              n.enqueueChange({ isUndoable: false }, (n) => {
                const o = a.get(t.id)
                n.setAttribute('uploadStatus', 'complete', o)
                this.fire('uploadComplete', { data: e, imageElement: o })
              })
              c()
            })
            .catch((e) => {
              if (t.status !== 'error' && t.status !== 'aborted') {
                throw e
              }
              if (t.status == 'error' && e) {
                r.showWarning(e, { title: o('Upload failed'), namespace: 'upload' })
              }
              n.enqueueChange({ isUndoable: false }, (e) => {
                e.remove(a.get(t.id))
              })
              c()
            })
          function c() {
            n.enqueueChange({ isUndoable: false }, (e) => {
              const n = a.get(t.id)
              e.removeAttribute('uploadId', n)
              e.removeAttribute('uploadStatus', n)
              a.delete(t.id)
            })
            i.destroyLoader(t)
          }
        }
        _parseAndSetSrcsetAttributeOnImage(t, e, n) {
          let o = 0
          const i = Object.keys(t)
            .filter((t) => {
              const e = parseInt(t, 10)
              if (!isNaN(e)) {
                o = Math.max(o, e)
                return true
              }
            })
            .map((e) => `${t[e]} ${e}w`)
            .join(', ')
          if (i != '') {
            n.setAttribute('srcset', { data: i, width: o }, e)
          }
        }
      }
      function QP(t) {
        return Array.from(t.types).includes('text/html') && t.getData('text/html') !== ''
      }
      function JP(t, e) {
        const n = t.plugins.get('ImageUtils')
        return Array.from(t.model.createRangeOn(e))
          .filter((t) => n.isImage(t.item))
          .map((t) => t.item)
      }
      class XP extends Du {
        static get pluginName() {
          return 'ImageUpload'
        }
        static get requires() {
          return [ZP, vP, zP]
        }
      }
      var tL = n(8340)
      var eL = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      eL.insert = 'head'
      eL.singleton = true
      var nL = Rl()(tL.Z, eL)
      const oL = tL.Z.locals || {}
      class iL extends (null && View) {
        constructor(t, e = {}) {
          super(t)
          const n = this.bindTemplate
          this.set('class', e.class || null)
          this.children = this.createCollection()
          if (e.children) {
            e.children.forEach((t) => this.children.add(t))
          }
          this.set('_role', null)
          this.set('_ariaLabelledBy', null)
          if (e.labelView) {
            this.set({ _role: 'group', _ariaLabelledBy: e.labelView.id })
          }
          this.setTemplate({
            tag: 'div',
            attributes: {
              class: ['ck', 'ck-form__row', n.to('class')],
              role: n.to('_role'),
              'aria-labelledby': n.to('_ariaLabelledBy'),
            },
            children: this.children,
          })
        }
      }
      var rL = n(8879)
      var sL = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      sL.insert = 'head'
      sL.singleton = true
      var aL = Rl()(rL.Z, sL)
      const cL = rL.Z.locals || {}
      class lL extends (null && View) {
        constructor(t, e = {}) {
          super(t)
          const { insertButtonView: n, cancelButtonView: o } = this._createActionButtons(t)
          this.insertButtonView = n
          this.cancelButtonView = o
          this.set('imageURLInputValue', '')
          this.focusTracker = new FocusTracker()
          this.keystrokes = new KeystrokeHandler()
          this._focusables = new ViewCollection()
          this._focusCycler = new FocusCycler({
            focusables: this._focusables,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: { focusPrevious: 'shift + tab', focusNext: 'tab' },
          })
          this.set('_integrations', new Collection())
          for (const [t, n] of Object.entries(e)) {
            if (t === 'insertImageViaUrl') {
              n.fieldView.bind('value').to(this, 'imageURLInputValue', (t) => t || '')
              n.fieldView.on('input', () => {
                this.imageURLInputValue = n.fieldView.element.value.trim()
              })
            }
            n.name = t
            this._integrations.add(n)
          }
          this.setTemplate({
            tag: 'form',
            attributes: { class: ['ck', 'ck-image-insert-form'], tabindex: '-1' },
            children: [
              ...this._integrations,
              new ImageInsertFormRowView(t, {
                children: [this.insertButtonView, this.cancelButtonView],
                class: 'ck-image-insert-form__action-row',
              }),
            ],
          })
        }
        render() {
          super.render()
          submitHandler({ view: this })
          const t = [...this._integrations, this.insertButtonView, this.cancelButtonView]
          t.forEach((t) => {
            this._focusables.add(t)
            this.focusTracker.add(t.element)
          })
          this.keystrokes.listenTo(this.element)
          const e = (t) => t.stopPropagation()
          this.keystrokes.set('arrowright', e)
          this.keystrokes.set('arrowleft', e)
          this.keystrokes.set('arrowup', e)
          this.keystrokes.set('arrowdown', e)
        }
        destroy() {
          super.destroy()
          this.focusTracker.destroy()
          this.keystrokes.destroy()
        }
        getIntegration(t) {
          return this._integrations.find((e) => e.name === t)
        }
        _createActionButtons(t) {
          const e = t.t
          const n = new ButtonView(t)
          const o = new ButtonView(t)
          n.set({
            label: e('Insert'),
            icon: icons.check,
            class: 'ck-button-save',
            type: 'submit',
            withText: true,
            isEnabled: this.imageURLInputValue,
          })
          o.set({ label: e('Cancel'), icon: icons.cancel, class: 'ck-button-cancel', withText: true })
          n.bind('isEnabled').to(this, 'imageURLInputValue', (t) => !!t)
          n.delegate('execute').to(this, 'submit')
          o.delegate('execute').to(this, 'cancel')
          return { insertButtonView: n, cancelButtonView: o }
        }
        focus() {
          this._focusCycler.focusFirst()
        }
      }
      function dL(t) {
        const e = t.config.get('image.insert.integrations')
        const n = t.plugins.get('ImageInsertUI')
        const o = { insertImageViaUrl: uL(t.locale) }
        if (!e) {
          return o
        }
        if (e.find((t) => t === 'openCKFinder') && t.ui.componentFactory.has('ckfinder')) {
          const e = t.ui.componentFactory.create('ckfinder')
          e.set({ withText: true, class: 'ck-image-insert__ck-finder-button' })
          e.delegate('execute').to(n, 'cancel')
          o.openCKFinder = e
        }
        return e.reduce((e, n) => {
          if (o[n]) {
            e[n] = o[n]
          } else if (t.ui.componentFactory.has(n)) {
            e[n] = t.ui.componentFactory.create(n)
          }
          return e
        }, {})
      }
      function uL(t) {
        const e = t.t
        const n = new LabeledFieldView(t, createLabeledInputText)
        n.set({ label: e('Insert image via URL') })
        n.fieldView.placeholder = 'https://example.com/image.png'
        return n
      }
      class hL extends (null && Plugin) {
        static get pluginName() {
          return 'ImageInsertUI'
        }
        init() {
          const t = this.editor
          const e = (t) => this._createDropdownView(t)
          t.ui.componentFactory.add('insertImage', e)
          t.ui.componentFactory.add('imageInsert', e)
        }
        _createDropdownView(t) {
          const e = this.editor
          const n = t.t
          const o = e.commands.get('uploadImage')
          const i = e.commands.get('insertImage')
          this.dropdownView = createDropdown(t, o ? SplitButtonView : undefined)
          const r = this.dropdownView.buttonView
          const s = this.dropdownView.panelView
          r.set({ label: n('Insert image'), icon: icons.image, tooltip: true })
          s.extendTemplate({ attributes: { class: 'ck-image-insert__panel' } })
          if (o) {
            const t = this.dropdownView.buttonView
            t.actionView = e.ui.componentFactory.create('uploadImage')
            t.actionView.extendTemplate({ attributes: { class: 'ck ck-button ck-splitbutton__action' } })
          }
          return this._setUpDropdown(o || i)
        }
        _setUpDropdown(t) {
          const e = this.editor
          const n = e.t
          const o = this.dropdownView
          const i = o.panelView
          const r = this.editor.plugins.get('ImageUtils')
          const s = e.commands.get('replaceImageSource')
          let a
          o.bind('isEnabled').to(t)
          o.once('change:isOpen', () => {
            a = new ImageInsertPanelView(e.locale, prepareIntegrations(e))
            a.delegate('submit', 'cancel').to(o)
            i.children.add(a)
          })
          o.on(
            'change:isOpen',
            () => {
              const t = e.model.document.selection.getSelectedElement()
              const i = a.insertButtonView
              const c = a.getIntegration('insertImageViaUrl')
              if (o.isOpen) {
                if (r.isImage(t)) {
                  a.imageURLInputValue = s.value
                  i.label = n('Update')
                  c.label = n('Update image URL')
                } else {
                  a.imageURLInputValue = ''
                  i.label = n('Insert')
                  c.label = n('Insert image via URL')
                }
              }
            },
            { priority: 'low' },
          )
          this.delegate('cancel').to(o)
          o.on('submit', () => {
            l()
            c()
          })
          o.on('cancel', () => {
            l()
          })
          function c() {
            const t = e.model.document.selection.getSelectedElement()
            if (r.isImage(t)) {
              e.execute('replaceImageSource', { source: a.imageURLInputValue })
            } else {
              e.execute('insertImage', { source: a.imageURLInputValue })
            }
          }
          function l() {
            e.editing.view.focus()
            o.isOpen = false
          }
          return o
        }
      }
      class gL extends (null && Plugin) {
        static get pluginName() {
          return 'ImageInsertViaUrl'
        }
        static get requires() {
          return [ImageInsertUI]
        }
      }
      class fL extends (null && Plugin) {
        static get pluginName() {
          return 'ImageInsert'
        }
        static get requires() {
          return [ImageUpload, ImageInsertViaUrl, ImageInsertUI]
        }
      }
      class mL extends (null && Command) {
        refresh() {
          const t = this.editor
          const e = t.plugins.get('ImageUtils')
          const n = e.getClosestSelectedImageElement(t.model.document.selection)
          this.isEnabled = !!n
          if (!n || !n.hasAttribute('width')) {
            this.value = null
          } else {
            this.value = { width: n.getAttribute('width'), height: null }
          }
        }
        execute(t) {
          const e = this.editor
          const n = e.model
          const o = e.plugins.get('ImageUtils')
          const i = o.getClosestSelectedImageElement(n.document.selection)
          this.value = { width: t.width, height: null }
          if (i) {
            n.change((e) => {
              e.setAttribute('width', t.width, i)
            })
          }
        }
      }
      class pL extends (null && Plugin) {
        static get requires() {
          return [ImageUtils]
        }
        static get pluginName() {
          return 'ImageResizeEditing'
        }
        constructor(t) {
          super(t)
          t.config.define('image', {
            resizeUnit: '%',
            resizeOptions: [
              { name: 'resizeImage:original', value: null, icon: 'original' },
              { name: 'resizeImage:25', value: '25', icon: 'small' },
              { name: 'resizeImage:50', value: '50', icon: 'medium' },
              { name: 'resizeImage:75', value: '75', icon: 'large' },
            ],
          })
        }
        init() {
          const t = this.editor
          const e = new ResizeImageCommand(t)
          this._registerSchema()
          this._registerConverters('imageBlock')
          this._registerConverters('imageInline')
          t.commands.add('resizeImage', e)
          t.commands.add('imageResize', e)
        }
        _registerSchema() {
          if (this.editor.plugins.has('ImageBlockEditing')) {
            this.editor.model.schema.extend('imageBlock', { allowAttributes: 'width' })
          }
          if (this.editor.plugins.has('ImageInlineEditing')) {
            this.editor.model.schema.extend('imageInline', { allowAttributes: 'width' })
          }
        }
        _registerConverters(t) {
          const e = this.editor
          e.conversion.for('downcast').add((e) =>
            e.on(`attribute:width:${t}`, (t, e, n) => {
              if (!n.consumable.consume(e.item, t.name)) {
                return
              }
              const o = n.writer
              const i = n.mapper.toViewElement(e.item)
              if (e.attributeNewValue !== null) {
                o.setStyle('width', e.attributeNewValue, i)
                o.addClass('image_resized', i)
              } else {
                o.removeStyle('width', i)
                o.removeClass('image_resized', i)
              }
            }),
          )
          e.conversion
            .for('upcast')
            .attributeToAttribute({
              view: { name: t === 'imageBlock' ? 'figure' : 'img', styles: { width: /.+/ } },
              model: { key: 'width', value: (t) => t.getStyle('width') },
            })
        }
      }
      const bL = {
        small: Sv.objectSizeSmall,
        medium: Sv.objectSizeMedium,
        large: Sv.objectSizeLarge,
        original: Sv.objectSizeFull,
      }
      class kL extends (null && Plugin) {
        static get requires() {
          return [ImageResizeEditing]
        }
        static get pluginName() {
          return 'ImageResizeButtons'
        }
        constructor(t) {
          super(t)
          this._resizeUnit = t.config.get('image.resizeUnit')
        }
        init() {
          const t = this.editor
          const e = t.config.get('image.resizeOptions')
          const n = t.commands.get('resizeImage')
          this.bind('isEnabled').to(n)
          for (const t of e) {
            this._registerImageResizeButton(t)
          }
          this._registerImageResizeDropdown(e)
        }
        _registerImageResizeButton(t) {
          const e = this.editor
          const { name: n, value: o, icon: i } = t
          const r = o ? o + this._resizeUnit : null
          e.ui.componentFactory.add(n, (n) => {
            const o = new ButtonView(n)
            const s = e.commands.get('resizeImage')
            const a = this._getOptionLabelValue(t, true)
            if (!bL[i]) {
              throw new CKEditorError('imageresizebuttons-missing-icon', e, t)
            }
            o.set({ label: a, icon: bL[i], tooltip: a, isToggleable: true })
            o.bind('isEnabled').to(this)
            o.bind('isOn').to(s, 'value', wL(r))
            this.listenTo(o, 'execute', () => {
              e.execute('resizeImage', { width: r })
            })
            return o
          })
        }
        _registerImageResizeDropdown(t) {
          const e = this.editor
          const n = e.t
          const o = t.find((t) => !t.value)
          const i = (i) => {
            const r = e.commands.get('resizeImage')
            const s = createDropdown(i, DropdownButtonView)
            const a = s.buttonView
            const c = n('Resize image')
            a.set({
              tooltip: c,
              commandValue: o.value,
              icon: bL.medium,
              isToggleable: true,
              label: this._getOptionLabelValue(o),
              withText: true,
              class: 'ck-resize-image-button',
              ariaLabel: c,
              ariaLabelledBy: undefined,
            })
            a.bind('label').to(r, 'value', (t) => {
              if (t && t.width) {
                return t.width
              } else {
                return this._getOptionLabelValue(o)
              }
            })
            s.bind('isEnabled').to(this)
            addListToDropdown(s, () => this._getResizeDropdownListItemDefinitions(t, r), {
              ariaLabel: n('Image resize list'),
              role: 'menu',
            })
            this.listenTo(s, 'execute', (t) => {
              e.execute(t.source.commandName, { width: t.source.commandValue })
              e.editing.view.focus()
            })
            return s
          }
          e.ui.componentFactory.add('resizeImage', i)
          e.ui.componentFactory.add('imageResize', i)
        }
        _getOptionLabelValue(t, e = false) {
          const n = this.editor.t
          if (t.label) {
            return t.label
          } else if (e) {
            if (t.value) {
              return n('Resize image to %0', t.value + this._resizeUnit)
            } else {
              return n('Resize image to the original size')
            }
          } else {
            if (t.value) {
              return t.value + this._resizeUnit
            } else {
              return n('Original')
            }
          }
        }
        _getResizeDropdownListItemDefinitions(t, e) {
          const n = new Collection()
          t.map((t) => {
            const o = t.value ? t.value + this._resizeUnit : null
            const i = {
              type: 'button',
              model: new Model({
                commandName: 'resizeImage',
                commandValue: o,
                label: this._getOptionLabelValue(t),
                role: 'menuitemradio',
                withText: true,
                icon: null,
              }),
            }
            i.model.bind('isOn').to(e, 'value', wL(o))
            n.add(i)
          })
          return n
        }
      }
      function wL(t) {
        return (e) => {
          const n = e
          if (t === null && n === t) {
            return true
          }
          return n !== null && n.width === t
        }
      }
      const AL =
        null &&
        'figure.image.ck-widget > img,' +
          'figure.image.ck-widget > picture > img,' +
          'figure.image.ck-widget > a > img,' +
          'figure.image.ck-widget > a > picture > img,' +
          'span.image-inline.ck-widget > img,' +
          'span.image-inline.ck-widget > picture > img'
      const _L = /(image|image-inline)/
      const CL = 'image_resized'
      class vL extends (null && Plugin) {
        static get requires() {
          return [WidgetResize]
        }
        static get pluginName() {
          return 'ImageResizeHandles'
        }
        init() {
          const t = this.editor.commands.get('resizeImage')
          this.bind('isEnabled').to(t)
          this._setupResizerCreator()
        }
        _setupResizerCreator() {
          const t = this.editor
          const e = t.editing.view
          e.addObserver(ImageLoadObserver)
          this.listenTo(e.document, 'imageLoaded', (n, o) => {
            if (!o.target.matches(AL)) {
              return
            }
            const i = t.editing.view.domConverter
            const r = i.domToView(o.target)
            const s = r.findAncestor({ classes: _L })
            let a = this.editor.plugins.get(WidgetResize).getResizerByViewElement(s)
            if (a) {
              a.redraw()
              return
            }
            const c = t.editing.mapper
            const l = c.toModelElement(s)
            a = t.plugins.get(WidgetResize).attachTo({
              unit: t.config.get('image.resizeUnit'),
              modelElement: l,
              viewElement: s,
              editor: t,
              getHandleHost(t) {
                return t.querySelector('img')
              },
              getResizeHost() {
                return i.mapViewToDom(c.toViewElement(l.parent))
              },
              isCentered() {
                const t = l.getAttribute('imageStyle')
                return !t || t == 'block' || t == 'alignCenter'
              },
              onCommit(n) {
                e.change((t) => {
                  t.removeClass(CL, s)
                })
                t.execute('resizeImage', { width: n })
              },
            })
            a.on('updateSize', () => {
              if (!s.hasClass(CL)) {
                e.change((t) => {
                  t.addClass(CL, s)
                })
              }
            })
            a.bind('isEnabled').to(this)
          })
        }
      }
      var yL = n(2400)
      var xL = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      xL.insert = 'head'
      xL.singleton = true
      var EL = Rl()(yL.Z, xL)
      const DL = yL.Z.locals || {}
      class TL extends (null && Plugin) {
        static get requires() {
          return [ImageResizeEditing, ImageResizeHandles, ImageResizeButtons]
        }
        static get pluginName() {
          return 'ImageResize'
        }
      }
      class IL extends Iu {
        constructor(t, e) {
          super(t)
          this._defaultStyles = { imageBlock: false, imageInline: false }
          this._styles = new Map(
            e.map((t) => {
              if (t.isDefault) {
                for (const e of t.modelElements) {
                  this._defaultStyles[e] = t.name
                }
              }
              return [t.name, t]
            }),
          )
        }
        refresh() {
          const t = this.editor
          const e = t.plugins.get('ImageUtils')
          const n = e.getClosestSelectedImageElement(this.editor.model.document.selection)
          this.isEnabled = !!n
          if (!this.isEnabled) {
            this.value = false
          } else if (n.hasAttribute('imageStyle')) {
            this.value = n.getAttribute('imageStyle')
          } else {
            this.value = this._defaultStyles[n.name]
          }
        }
        execute(t = {}) {
          const e = this.editor
          const n = e.model
          const o = e.plugins.get('ImageUtils')
          n.change((e) => {
            const i = t.value
            let r = o.getClosestSelectedImageElement(n.document.selection)
            if (i && this.shouldConvertImageType(i, r)) {
              this.editor.execute(o.isBlockImage(r) ? 'imageTypeInline' : 'imageTypeBlock')
              r = o.getClosestSelectedImageElement(n.document.selection)
            }
            if (!i || this._styles.get(i).isDefault) {
              e.removeAttribute('imageStyle', r)
            } else {
              e.setAttribute('imageStyle', i, r)
            }
          })
        }
        shouldConvertImageType(t, e) {
          const n = this._styles.get(t).modelElements
          return !n.includes(e.name)
        }
      }
      const {
        objectFullWidth: SL,
        objectInline: ML,
        objectLeft: BL,
        objectRight: NL,
        objectCenter: PL,
        objectBlockLeft: LL,
        objectBlockRight: zL,
      } = Sv
      const RL = {
        get inline() {
          return { name: 'inline', title: 'In line', icon: ML, modelElements: ['imageInline'], isDefault: true }
        },
        get alignLeft() {
          return {
            name: 'alignLeft',
            title: 'Left aligned image',
            icon: BL,
            modelElements: ['imageBlock', 'imageInline'],
            className: 'image-style-align-left',
          }
        },
        get alignBlockLeft() {
          return {
            name: 'alignBlockLeft',
            title: 'Left aligned image',
            icon: LL,
            modelElements: ['imageBlock'],
            className: 'image-style-block-align-left',
          }
        },
        get alignCenter() {
          return {
            name: 'alignCenter',
            title: 'Centered image',
            icon: PL,
            modelElements: ['imageBlock'],
            className: 'image-style-align-center',
          }
        },
        get alignRight() {
          return {
            name: 'alignRight',
            title: 'Right aligned image',
            icon: NL,
            modelElements: ['imageBlock', 'imageInline'],
            className: 'image-style-align-right',
          }
        },
        get alignBlockRight() {
          return {
            name: 'alignBlockRight',
            title: 'Right aligned image',
            icon: zL,
            modelElements: ['imageBlock'],
            className: 'image-style-block-align-right',
          }
        },
        get block() {
          return { name: 'block', title: 'Centered image', icon: PL, modelElements: ['imageBlock'], isDefault: true }
        },
        get side() {
          return {
            name: 'side',
            title: 'Side image',
            icon: NL,
            modelElements: ['imageBlock'],
            className: 'image-style-side',
          }
        },
      }
      const OL = { full: SL, left: LL, right: zL, center: PL, inlineLeft: BL, inlineRight: NL, inline: ML }
      const VL = [
        {
          name: 'imageStyle:wrapText',
          title: 'Wrap text',
          defaultItem: 'imageStyle:alignLeft',
          items: ['imageStyle:alignLeft', 'imageStyle:alignRight'],
        },
        {
          name: 'imageStyle:breakText',
          title: 'Break text',
          defaultItem: 'imageStyle:block',
          items: ['imageStyle:alignBlockLeft', 'imageStyle:block', 'imageStyle:alignBlockRight'],
        },
      ]
      function FL(t) {
        const e = t.configuredStyles.options || []
        const n = e.map((t) => UL(t)).filter((e) => WL(e, t))
        return n
      }
      function jL(t, e) {
        if (t && e) {
          return {
            options: [
              'inline',
              'alignLeft',
              'alignRight',
              'alignCenter',
              'alignBlockLeft',
              'alignBlockRight',
              'block',
              'side',
            ],
          }
        } else if (t) {
          return { options: ['block', 'side'] }
        } else if (e) {
          return { options: ['inline', 'alignLeft', 'alignRight'] }
        }
        return {}
      }
      function HL(t) {
        if (t.has('ImageBlockEditing') && t.has('ImageInlineEditing')) {
          return [...VL]
        } else {
          return []
        }
      }
      function UL(t) {
        if (typeof t === 'string') {
          if (!RL[t]) {
            t = { name: t }
          } else {
            t = { ...RL[t] }
          }
        } else {
          t = GL(RL[t.name], t)
        }
        if (typeof t.icon === 'string') {
          t.icon = OL[t.icon] || t.icon
        }
        return t
      }
      function WL(t, { isBlockPluginLoaded: e, isInlinePluginLoaded: n }) {
        const { modelElements: o, name: i } = t
        if (!o || !o.length || !i) {
          qL({ style: t })
          return false
        } else {
          const i = [e ? 'imageBlock' : null, n ? 'imageInline' : null]
          if (!o.some((t) => i.includes(t))) {
            L('image-style-missing-dependency', {
              style: t,
              missingPlugins: o.map((t) => (t === 'imageBlock' ? 'ImageBlockEditing' : 'ImageInlineEditing')),
            })
            return false
          }
        }
        return true
      }
      function GL(t, e) {
        const n = { ...e }
        for (const o in t) {
          if (!Object.prototype.hasOwnProperty.call(e, o)) {
            n[o] = t[o]
          }
        }
        return n
      }
      function qL(t) {
        L('image-style-configuration-definition-invalid', t)
      }
      const $L = {
        normalizeStyles: FL,
        getDefaultStylesConfiguration: jL,
        getDefaultDropdownDefinitions: HL,
        warnInvalidStyle: qL,
        DEFAULT_OPTIONS: RL,
        DEFAULT_ICONS: OL,
        DEFAULT_DROPDOWN_DEFINITIONS: VL,
      }
      function KL(t) {
        return (e, n, o) => {
          if (!o.consumable.consume(n.item, e.name)) {
            return
          }
          const i = ZL(n.attributeNewValue, t)
          const r = ZL(n.attributeOldValue, t)
          const s = o.mapper.toViewElement(n.item)
          const a = o.writer
          if (r) {
            a.removeClass(r.className, s)
          }
          if (i) {
            a.addClass(i.className, s)
          }
        }
      }
      function YL(t) {
        const e = {
          imageInline: t.filter((t) => !t.isDefault && t.modelElements.includes('imageInline')),
          imageBlock: t.filter((t) => !t.isDefault && t.modelElements.includes('imageBlock')),
        }
        return (t, n, o) => {
          if (!n.modelRange) {
            return
          }
          const i = n.viewItem
          const r = bl(n.modelRange.getItems())
          if (!r) {
            return
          }
          if (!o.schema.checkAttribute(r, 'imageStyle')) {
            return
          }
          for (const t of e[r.name]) {
            if (o.consumable.consume(i, { classes: t.className })) {
              o.writer.setAttribute('imageStyle', t.name, r)
            }
          }
        }
      }
      function ZL(t, e) {
        for (const n of e) {
          if (n.name === t) {
            return n
          }
        }
      }
      class QL extends Du {
        static get pluginName() {
          return 'ImageStyleEditing'
        }
        static get requires() {
          return [hN]
        }
        init() {
          const { normalizeStyles: t, getDefaultStylesConfiguration: e } = $L
          const n = this.editor
          const o = n.plugins.has('ImageBlockEditing')
          const i = n.plugins.has('ImageInlineEditing')
          n.config.define('image.styles', e(o, i))
          this.normalizedStyles = t({
            configuredStyles: n.config.get('image.styles'),
            isBlockPluginLoaded: o,
            isInlinePluginLoaded: i,
          })
          this._setupConversion(o, i)
          this._setupPostFixer()
          n.commands.add('imageStyle', new IL(n, this.normalizedStyles))
        }
        _setupConversion(t, e) {
          const n = this.editor
          const o = n.model.schema
          const i = KL(this.normalizedStyles)
          const r = YL(this.normalizedStyles)
          n.editing.downcastDispatcher.on('attribute:imageStyle', i)
          n.data.downcastDispatcher.on('attribute:imageStyle', i)
          if (t) {
            o.extend('imageBlock', { allowAttributes: 'imageStyle' })
            n.data.upcastDispatcher.on('element:figure', r, { priority: 'low' })
          }
          if (e) {
            o.extend('imageInline', { allowAttributes: 'imageStyle' })
            n.data.upcastDispatcher.on('element:img', r, { priority: 'low' })
          }
        }
        _setupPostFixer() {
          const t = this.editor
          const e = t.model.document
          const n = t.plugins.get(hN)
          const o = new Map(this.normalizedStyles.map((t) => [t.name, t]))
          e.registerPostFixer((t) => {
            let i = false
            for (const r of e.differ.getChanges()) {
              if (r.type == 'insert' || (r.type == 'attribute' && r.attributeKey == 'imageStyle')) {
                let e = r.type == 'insert' ? r.position.nodeAfter : r.range.start.nodeAfter
                if (e && e.is('element', 'paragraph') && e.childCount > 0) {
                  e = e.getChild(0)
                }
                if (!n.isImage(e)) {
                  continue
                }
                const s = e.getAttribute('imageStyle')
                if (!s) {
                  continue
                }
                const a = o.get(s)
                if (!a || !a.modelElements.includes(e.name)) {
                  t.removeAttribute('imageStyle', e)
                  i = true
                }
              }
            }
            return i
          })
        }
      }
      var JL = n(3534)
      var XL = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      XL.insert = 'head'
      XL.singleton = true
      var tz = Rl()(JL.Z, XL)
      const ez = JL.Z.locals || {}
      class nz extends Du {
        static get requires() {
          return [QL]
        }
        static get pluginName() {
          return 'ImageStyleUI'
        }
        get localizedDefaultStylesTitles() {
          const t = this.editor.t
          return {
            'Wrap text': t('Wrap text'),
            'Break text': t('Break text'),
            'In line': t('In line'),
            'Full size image': t('Full size image'),
            'Side image': t('Side image'),
            'Left aligned image': t('Left aligned image'),
            'Centered image': t('Centered image'),
            'Right aligned image': t('Right aligned image'),
          }
        }
        init() {
          const t = this.editor.plugins
          const e = this.editor.config.get('image.toolbar') || []
          const n = t.get('ImageStyleEditing')
          const o = oz(n.normalizedStyles, this.localizedDefaultStylesTitles)
          for (const t of o) {
            this._createButton(t)
          }
          const i = oz([...e.filter(at), ...$L.getDefaultDropdownDefinitions(t)], this.localizedDefaultStylesTitles)
          for (const t of i) {
            this._createDropdown(t, o)
          }
        }
        _createDropdown(t, e) {
          const n = this.editor.ui.componentFactory
          n.add(t.name, (o) => {
            let i
            const { defaultItem: r, items: s, title: a } = t
            const c = s
              .filter((t) => e.find(({ name: e }) => iz(e) === t))
              .map((t) => {
                const e = n.create(t)
                if (t === r) {
                  i = e
                }
                return e
              })
            if (s.length !== c.length) {
              $L.warnInvalidStyle({ dropdown: t })
            }
            const l = ay(o, Jv)
            const d = l.buttonView
            const u = d.arrowView
            cy(l, c, { enableActiveItemFocusOnDropdownOpen: true })
            d.set({ label: rz(a, i.label), class: null, tooltip: true })
            u.unbind('label')
            u.set({ label: a })
            d.bind('icon').toMany(c, 'isOn', (...t) => {
              const e = t.findIndex(wg)
              return e < 0 ? i.icon : c[e].icon
            })
            d.bind('label').toMany(c, 'isOn', (...t) => {
              const e = t.findIndex(wg)
              return rz(a, e < 0 ? i.label : c[e].label)
            })
            d.bind('isOn').toMany(c, 'isOn', (...t) => t.some(wg))
            d.bind('class').toMany(c, 'isOn', (...t) => (t.some(wg) ? 'ck-splitbutton_flatten' : undefined))
            d.on('execute', () => {
              if (!c.some(({ isOn: t }) => t)) {
                i.fire('execute')
              } else {
                l.isOpen = !l.isOpen
              }
            })
            l.bind('isEnabled').toMany(c, 'isEnabled', (...t) => t.some(wg))
            this.listenTo(l, 'execute', () => {
              this.editor.editing.view.focus()
            })
            return l
          })
        }
        _createButton(t) {
          const e = t.name
          this.editor.ui.componentFactory.add(iz(e), (n) => {
            const o = this.editor.commands.get('imageStyle')
            const i = new Dd(n)
            i.set({ label: t.title, icon: t.icon, tooltip: true, isToggleable: true })
            i.bind('isEnabled').to(o, 'isEnabled')
            i.bind('isOn').to(o, 'value', (t) => t === e)
            i.on('execute', this._executeCommand.bind(this, e))
            return i
          })
        }
        _executeCommand(t) {
          this.editor.execute('imageStyle', { value: t })
          this.editor.editing.view.focus()
        }
      }
      function oz(t, e) {
        for (const n of t) {
          if (e[n.title]) {
            n.title = e[n.title]
          }
        }
        return t
      }
      function iz(t) {
        return `imageStyle:${t}`
      }
      function rz(t, e) {
        return (t ? t + ': ' : '') + e
      }
      class sz extends Du {
        static get requires() {
          return [QL, nz]
        }
        static get pluginName() {
          return 'ImageStyle'
        }
      }
      class az extends Du {
        static get requires() {
          return [mM, hN]
        }
        static get pluginName() {
          return 'ImageToolbar'
        }
        afterInit() {
          const t = this.editor
          const e = t.t
          const n = t.plugins.get(mM)
          const o = t.plugins.get('ImageUtils')
          n.register('image', {
            ariaLabel: e('Image toolbar'),
            items: cz(t.config.get('image.toolbar') || []),
            getRelatedElement: (t) => o.getClosestSelectedImageWidget(t),
          })
        }
      }
      function cz(t) {
        return t.map((t) => (at(t) ? t.name : t))
      }
      class lz extends (null && Plugin) {
        static get requires() {
          return [ImageEditing, ImageUtils]
        }
        static get pluginName() {
          return 'PictureEditing'
        }
        afterInit() {
          const t = this.editor
          if (t.plugins.has('ImageBlockEditing')) {
            t.model.schema.extend('imageBlock', { allowAttributes: ['sources'] })
          }
          if (t.plugins.has('ImageInlineEditing')) {
            t.model.schema.extend('imageInline', { allowAttributes: ['sources'] })
          }
          this._setupConversion()
          this._setupImageUploadEditingIntegration()
        }
        _setupConversion() {
          const t = this.editor
          const e = t.conversion
          const n = t.plugins.get('ImageUtils')
          e.for('upcast').add(upcastPicture(n))
          e.for('downcast').add(downcastSourcesAttribute(n))
        }
        _setupImageUploadEditingIntegration() {
          const t = this.editor
          if (!t.plugins.has('ImageUploadEditing')) {
            return
          }
          const e = t.plugins.get('ImageUploadEditing')
          this.listenTo(e, 'uploadComplete', (e, { imageElement: n, data: o }) => {
            const i = o.sources
            if (!i) {
              return
            }
            t.model.change((t) => {
              t.setAttributes({ sources: i }, n)
            })
          })
        }
      }
      class dz extends Du {
        static get pluginName() {
          return 'IndentEditing'
        }
        init() {
          const t = this.editor
          t.commands.add('indent', new Mu(t))
          t.commands.add('outdent', new Mu(t))
        }
      }
      const uz =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zM1.632 6.95 5.02 9.358a.4.4 0 0 1-.013.661l-3.39 2.207A.4.4 0 0 1 1 11.892V7.275a.4.4 0 0 1 .632-.326z"/></svg>'
      const hz =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zm1.618-9.55L.98 9.358a.4.4 0 0 0 .013.661l3.39 2.207A.4.4 0 0 0 5 11.892V7.275a.4.4 0 0 0-.632-.326z"/></svg>'
      class gz extends Du {
        static get pluginName() {
          return 'IndentUI'
        }
        init() {
          const t = this.editor
          const e = t.locale
          const n = t.t
          const o = e.uiLanguageDirection == 'ltr' ? uz : hz
          const i = e.uiLanguageDirection == 'ltr' ? hz : uz
          this._defineButton('indent', n('Increase indent'), o)
          this._defineButton('outdent', n('Decrease indent'), i)
        }
        _defineButton(t, e, n) {
          const o = this.editor
          o.ui.componentFactory.add(t, (i) => {
            const r = o.commands.get(t)
            const s = new Dd(i)
            s.set({ label: e, icon: n, tooltip: true })
            s.bind('isEnabled').to(r, 'isEnabled')
            this.listenTo(s, 'execute', () => {
              o.execute(t)
              o.editing.view.focus()
            })
            return s
          })
        }
      }
      class fz extends Du {
        static get pluginName() {
          return 'Indent'
        }
        static get requires() {
          return [dz, gz]
        }
      }
      class mz extends (null && Command) {
        constructor(t, e) {
          super(t)
          this._indentBehavior = e
        }
        refresh() {
          const t = this.editor
          const e = t.model
          const n = first(e.document.selection.getSelectedBlocks())
          if (!n || !e.schema.checkAttribute(n, 'blockIndent')) {
            this.isEnabled = false
            return
          }
          this.isEnabled = this._indentBehavior.checkEnabled(n.getAttribute('blockIndent'))
        }
        execute() {
          const t = this.editor.model
          const e = pz(t)
          t.change((t) => {
            for (const n of e) {
              const e = n.getAttribute('blockIndent')
              const o = this._indentBehavior.getNextIndent(e)
              if (o) {
                t.setAttribute('blockIndent', o, n)
              } else {
                t.removeAttribute('blockIndent', n)
              }
            }
          })
        }
      }
      function pz(t) {
        const e = t.document.selection
        const n = t.schema
        const o = Array.from(e.getSelectedBlocks())
        return o.filter((t) => n.checkAttribute(t, 'blockIndent'))
      }
      const bz = null && ['paragraph', 'heading1', 'heading2', 'heading3', 'heading4', 'heading5', 'heading6']
      class kz extends (null && Plugin) {
        constructor(t) {
          super(t)
          t.config.define('indentBlock', { offset: 40, unit: 'px' })
        }
        static get pluginName() {
          return 'IndentBlock'
        }
        init() {
          const t = this.editor
          const e = t.config.get('indentBlock')
          if (e.classes && e.classes.length) {
            this._setupConversionUsingClasses(e.classes)
            t.commands.add(
              'indentBlock',
              new IndentBlockCommand(t, new IndentUsingClasses({ direction: 'forward', classes: e.classes })),
            )
            t.commands.add(
              'outdentBlock',
              new IndentBlockCommand(t, new IndentUsingClasses({ direction: 'backward', classes: e.classes })),
            )
          } else {
            t.data.addStyleProcessorRules(addMarginRules)
            this._setupConversionUsingOffset()
            t.commands.add(
              'indentBlock',
              new IndentBlockCommand(
                t,
                new IndentUsingOffset({ direction: 'forward', offset: e.offset, unit: e.unit }),
              ),
            )
            t.commands.add(
              'outdentBlock',
              new IndentBlockCommand(
                t,
                new IndentUsingOffset({ direction: 'backward', offset: e.offset, unit: e.unit }),
              ),
            )
          }
        }
        afterInit() {
          const t = this.editor
          const e = t.model.schema
          const n = t.commands.get('indent')
          const o = t.commands.get('outdent')
          const i = t.config.get('heading.options')
          const r = i && i.map((t) => t.model)
          const s = r || bz
          s.forEach((t) => {
            if (e.isRegistered(t)) {
              e.extend(t, { allowAttributes: 'blockIndent' })
            }
          })
          e.setAttributeProperties('blockIndent', { isFormatting: true })
          n.registerChildCommand(t.commands.get('indentBlock'))
          o.registerChildCommand(t.commands.get('outdentBlock'))
        }
        _setupConversionUsingOffset() {
          const t = this.editor.conversion
          const e = this.editor.locale
          const n = e.contentLanguageDirection === 'rtl' ? 'margin-right' : 'margin-left'
          t.for('upcast').attributeToAttribute({
            view: { styles: { [n]: /[\s\S]+/ } },
            model: { key: 'blockIndent', value: (t) => t.getStyle(n) },
          })
          t.for('downcast').attributeToAttribute({
            model: 'blockIndent',
            view: (t) => ({ key: 'style', value: { [n]: t } }),
          })
        }
        _setupConversionUsingClasses(t) {
          const e = { model: { key: 'blockIndent', values: [] }, view: {} }
          for (const n of t) {
            e.model.values.push(n)
            e.view[n] = { key: 'class', value: [n] }
          }
          this.editor.conversion.attributeToAttribute(e)
        }
      }
      class wz {
        constructor() {
          this._definitions = new Set()
        }
        get length() {
          return this._definitions.size
        }
        add(t) {
          if (Array.isArray(t)) {
            t.forEach((t) => this._definitions.add(t))
          } else {
            this._definitions.add(t)
          }
        }
        getDispatcher() {
          return (t) => {
            t.on(
              'attribute:linkHref',
              (t, e, n) => {
                if (!n.consumable.test(e.item, 'attribute:linkHref')) {
                  return
                }
                if (!(e.item.is('selection') || n.schema.isInline(e.item))) {
                  return
                }
                const o = n.writer
                const i = o.document.selection
                for (const t of this._definitions) {
                  const r = o.createAttributeElement('a', t.attributes, { priority: 5 })
                  if (t.classes) {
                    o.addClass(t.classes, r)
                  }
                  for (const e in t.styles) {
                    o.setStyle(e, t.styles[e], r)
                  }
                  o.setCustomProperty('link', true, r)
                  if (t.callback(e.attributeNewValue)) {
                    if (e.item.is('selection')) {
                      o.wrap(i.getFirstRange(), r)
                    } else {
                      o.wrap(n.mapper.toViewRange(e.range), r)
                    }
                  } else {
                    o.unwrap(n.mapper.toViewRange(e.range), r)
                  }
                }
              },
              { priority: 'high' },
            )
          }
        }
        getDispatcherForLinkedImage() {
          return (t) => {
            t.on('attribute:linkHref:imageBlock', (t, e, { writer: n, mapper: o }) => {
              const i = o.toViewElement(e.item)
              const r = Array.from(i.getChildren()).find((t) => t.is('element', 'a'))
              for (const t of this._definitions) {
                const o = _l(t.attributes)
                if (t.callback(e.attributeNewValue)) {
                  for (const [t, e] of o) {
                    if (t === 'class') {
                      n.addClass(e, r)
                    } else {
                      n.setAttribute(t, e, r)
                    }
                  }
                  if (t.classes) {
                    n.addClass(t.classes, r)
                  }
                  for (const e in t.styles) {
                    n.setStyle(e, t.styles[e], r)
                  }
                } else {
                  for (const [t, e] of o) {
                    if (t === 'class') {
                      n.removeClass(e, r)
                    } else {
                      n.removeAttribute(t, r)
                    }
                  }
                  if (t.classes) {
                    n.removeClass(t.classes, r)
                  }
                  for (const e in t.styles) {
                    n.removeStyle(e, r)
                  }
                }
              }
            })
          }
        }
      }
      function Az(t, e, n) {
        var o = t.length
        n = n === undefined ? o : n
        return !e && n >= o ? t : $h(t, e, n)
      }
      const _z = Az
      var Cz = '\\ud800-\\udfff',
        vz = '\\u0300-\\u036f',
        yz = '\\ufe20-\\ufe2f',
        xz = '\\u20d0-\\u20ff',
        Ez = vz + yz + xz,
        Dz = '\\ufe0e\\ufe0f'
      var Tz = '\\u200d'
      var Iz = RegExp('[' + Tz + Cz + Ez + Dz + ']')
      function Sz(t) {
        return Iz.test(t)
      }
      const Mz = Sz
      function Bz(t) {
        return t.split('')
      }
      const Nz = Bz
      var Pz = '\\ud800-\\udfff',
        Lz = '\\u0300-\\u036f',
        zz = '\\ufe20-\\ufe2f',
        Rz = '\\u20d0-\\u20ff',
        Oz = Lz + zz + Rz,
        Vz = '\\ufe0e\\ufe0f'
      var Fz = '[' + Pz + ']',
        jz = '[' + Oz + ']',
        Hz = '\\ud83c[\\udffb-\\udfff]',
        Uz = '(?:' + jz + '|' + Hz + ')',
        Wz = '[^' + Pz + ']',
        Gz = '(?:\\ud83c[\\udde6-\\uddff]){2}',
        qz = '[\\ud800-\\udbff][\\udc00-\\udfff]',
        $z = '\\u200d'
      var Kz = Uz + '?',
        Yz = '[' + Vz + ']?',
        Zz = '(?:' + $z + '(?:' + [Wz, Gz, qz].join('|') + ')' + Yz + Kz + ')*',
        Qz = Yz + Kz + Zz,
        Jz = '(?:' + [Wz + jz + '?', jz, Gz, qz, Fz].join('|') + ')'
      var Xz = RegExp(Hz + '(?=' + Hz + ')|' + Jz + Qz, 'g')
      function tR(t) {
        return t.match(Xz) || []
      }
      const eR = tR
      function nR(t) {
        return Mz(t) ? eR(t) : Nz(t)
      }
      const oR = nR
      function iR(t) {
        return function (e) {
          e = zh(e)
          var n = Mz(e) ? oR(e) : undefined
          var o = n ? n[0] : e.charAt(0)
          var i = n ? _z(n, 1).join('') : e.slice(1)
          return o[t]() + i
        }
      }
      const rR = iR
      var sR = rR('toUpperCase')
      const aR = sR
      const cR = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g
      const lR = /^(?:(?:https?|ftps?|mailto):|[^a-z]|[a-z+.-]+(?:[^a-z+.:-]|$))/i
      const dR = /^[\S]+@((?![-_])(?:[-\w\u00a1-\uffff]{0,63}[^-_]\.))+(?:[a-z\u00a1-\uffff]{2,})$/i
      const uR = /^((\w+:(\/{2,})?)|(\W))/i
      const hR = 'Ctrl+K'
      function gR(t) {
        return t.is('attributeElement') && !!t.getCustomProperty('link')
      }
      function fR(t, { writer: e }) {
        const n = e.createAttributeElement('a', { href: t }, { priority: 5 })
        e.setCustomProperty('link', true, n)
        return n
      }
      function mR(t) {
        const e = String(t)
        return pR(e) ? e : '#'
      }
      function pR(t) {
        const e = t.replace(cR, '')
        return !!e.match(lR)
      }
      function bR(t, e) {
        const n = { 'Open in a new tab': t('Open in a new tab'), Downloadable: t('Downloadable') }
        e.forEach((t) => {
          if ('label' in t && n[t.label]) {
            t.label = n[t.label]
          }
          return t
        })
        return e
      }
      function kR(t) {
        const e = []
        if (t) {
          for (const [n, o] of Object.entries(t)) {
            const t = Object.assign({}, o, { id: `link${aR(n)}` })
            e.push(t)
          }
        }
        return e
      }
      function wR(t, e) {
        if (!t) {
          return false
        }
        return e.checkAttribute(t.name, 'linkHref')
      }
      function AR(t) {
        return dR.test(t)
      }
      function _R(t, e) {
        const n = AR(t) ? 'mailto:' : e
        const o = !!n && !CR(t)
        return t && o ? n + t : t
      }
      function CR(t) {
        return uR.test(t)
      }
      function vR(t) {
        window.open(t, '_blank', 'noopener')
      }
      class yR extends Iu {
        constructor() {
          super(...arguments)
          this.manualDecorators = new pl()
          this.automaticDecorators = new wz()
        }
        restoreManualDecoratorStates() {
          for (const t of this.manualDecorators) {
            t.value = this._getDecoratorStateFromModel(t.id)
          }
        }
        refresh() {
          const t = this.editor.model
          const e = t.document.selection
          const n = e.getSelectedElement() || bl(e.getSelectedBlocks())
          if (wR(n, t.schema)) {
            this.value = n.getAttribute('linkHref')
            this.isEnabled = t.schema.checkAttribute(n, 'linkHref')
          } else {
            this.value = e.getAttribute('linkHref')
            this.isEnabled = t.schema.checkAttributeInSelection(e, 'linkHref')
          }
          for (const t of this.manualDecorators) {
            t.value = this._getDecoratorStateFromModel(t.id)
          }
        }
        execute(t, e = {}) {
          const n = this.editor.model
          const o = n.document.selection
          const i = []
          const r = []
          for (const t in e) {
            if (e[t]) {
              i.push(t)
            } else {
              r.push(t)
            }
          }
          n.change((e) => {
            if (o.isCollapsed) {
              const s = o.getFirstPosition()
              if (o.hasAttribute('linkHref')) {
                const a = xR(o)
                let c = BT(s, 'linkHref', o.getAttribute('linkHref'), n)
                if (o.getAttribute('linkHref') === a) {
                  c = this._updateLinkContent(n, e, c, t)
                }
                e.setAttribute('linkHref', t, c)
                i.forEach((t) => {
                  e.setAttribute(t, true, c)
                })
                r.forEach((t) => {
                  e.removeAttribute(t, c)
                })
                e.setSelection(e.createPositionAfter(c.end.nodeBefore))
              } else if (t !== '') {
                const r = _l(o.getAttributes())
                r.set('linkHref', t)
                i.forEach((t) => {
                  r.set(t, true)
                })
                const { end: a } = n.insertContent(e.createText(t, r), s)
                e.setSelection(a)
              }
              ;['linkHref', ...i, ...r].forEach((t) => {
                e.removeSelectionAttribute(t)
              })
            } else {
              const s = n.schema.getValidRanges(o.getRanges(), 'linkHref')
              const a = []
              for (const t of o.getSelectedBlocks()) {
                if (n.schema.checkAttribute(t, 'linkHref')) {
                  a.push(e.createRangeOn(t))
                }
              }
              const c = a.slice()
              for (const t of s) {
                if (this._isRangeToUpdate(t, a)) {
                  c.push(t)
                }
              }
              for (const s of c) {
                let a = s
                if (c.length === 1) {
                  const i = xR(o)
                  if (o.getAttribute('linkHref') === i) {
                    a = this._updateLinkContent(n, e, s, t)
                    e.setSelection(e.createSelection(a))
                  }
                }
                e.setAttribute('linkHref', t, a)
                i.forEach((t) => {
                  e.setAttribute(t, true, a)
                })
                r.forEach((t) => {
                  e.removeAttribute(t, a)
                })
              }
            }
          })
        }
        _getDecoratorStateFromModel(t) {
          const e = this.editor.model
          const n = e.document.selection
          const o = n.getSelectedElement()
          if (wR(o, e.schema)) {
            return o.getAttribute(t)
          }
          return n.getAttribute(t)
        }
        _isRangeToUpdate(t, e) {
          for (const n of e) {
            if (n.containsRange(t)) {
              return false
            }
          }
          return true
        }
        _updateLinkContent(t, e, n, o) {
          const i = e.createText(o, { linkHref: o })
          return t.insertContent(i, n)
        }
      }
      function xR(t) {
        if (t.isCollapsed) {
          const e = t.getFirstPosition()
          return e.textNode && e.textNode.data
        } else {
          const e = Array.from(t.getFirstRange().getItems())
          if (e.length > 1) {
            return null
          }
          const n = e[0]
          if (n.is('$text') || n.is('$textProxy')) {
            return n.data
          }
          return null
        }
      }
      class ER extends Iu {
        refresh() {
          const t = this.editor.model
          const e = t.document.selection
          const n = e.getSelectedElement()
          if (wR(n, t.schema)) {
            this.isEnabled = t.schema.checkAttribute(n, 'linkHref')
          } else {
            this.isEnabled = t.schema.checkAttributeInSelection(e, 'linkHref')
          }
        }
        execute() {
          const t = this.editor
          const e = this.editor.model
          const n = e.document.selection
          const o = t.commands.get('link')
          e.change((t) => {
            const i = n.isCollapsed
              ? [BT(n.getFirstPosition(), 'linkHref', n.getAttribute('linkHref'), e)]
              : e.schema.getValidRanges(n.getRanges(), 'linkHref')
            for (const e of i) {
              t.removeAttribute('linkHref', e)
              if (o) {
                for (const n of o.manualDecorators) {
                  t.removeAttribute(n.id, e)
                }
              }
            }
          })
        }
      }
      class DR extends ft() {
        constructor({ id: t, label: e, attributes: n, classes: o, styles: i, defaultValue: r }) {
          super()
          this.id = t
          this.set('value', undefined)
          this.defaultValue = r
          this.label = e
          this.attributes = n
          this.classes = o
          this.styles = i
        }
        _createPattern() {
          return { attributes: this.attributes, classes: this.classes, styles: this.styles }
        }
      }
      var TR = n(3925)
      var IR = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      IR.insert = 'head'
      IR.singleton = true
      var SR = Rl()(TR.Z, IR)
      const MR = TR.Z.locals || {}
      const BR = 'ck-link_selected'
      const NR = 'automatic'
      const PR = 'manual'
      const LR = /^(https?:)?\/\//
      class zR extends Du {
        static get pluginName() {
          return 'LinkEditing'
        }
        static get requires() {
          return [hT, YD, bS]
        }
        constructor(t) {
          super(t)
          t.config.define('link', { addTargetToExternalLinks: false })
        }
        init() {
          const t = this.editor
          t.model.schema.extend('$text', { allowAttributes: 'linkHref' })
          t.conversion.for('dataDowncast').attributeToElement({ model: 'linkHref', view: fR })
          t.conversion.for('editingDowncast').attributeToElement({ model: 'linkHref', view: (t, e) => fR(mR(t), e) })
          t.conversion
            .for('upcast')
            .elementToAttribute({
              view: { name: 'a', attributes: { href: true } },
              model: { key: 'linkHref', value: (t) => t.getAttribute('href') },
            })
          t.commands.add('link', new yR(t))
          t.commands.add('unlink', new ER(t))
          const e = bR(t.t, kR(t.config.get('link.decorators')))
          this._enableAutomaticDecorators(e.filter((t) => t.mode === NR))
          this._enableManualDecorators(e.filter((t) => t.mode === PR))
          const n = t.plugins.get(hT)
          n.registerAttribute('linkHref')
          PT(t, 'linkHref', 'a', BR)
          this._enableLinkOpen()
          this._enableInsertContentSelectionAttributesFixer()
          this._enableClickingAfterLink()
          this._enableTypingOverLink()
          this._handleDeleteContentAfterLink()
          this._enableClipboardIntegration()
        }
        _enableAutomaticDecorators(t) {
          const e = this.editor
          const n = e.commands.get('link')
          const o = n.automaticDecorators
          if (e.config.get('link.addTargetToExternalLinks')) {
            o.add({
              id: 'linkIsExternal',
              mode: NR,
              callback: (t) => !!t && LR.test(t),
              attributes: { target: '_blank', rel: 'noopener noreferrer' },
            })
          }
          o.add(t)
          if (o.length) {
            e.conversion.for('downcast').add(o.getDispatcher())
          }
        }
        _enableManualDecorators(t) {
          if (!t.length) {
            return
          }
          const e = this.editor
          const n = e.commands.get('link')
          const o = n.manualDecorators
          t.forEach((t) => {
            e.model.schema.extend('$text', { allowAttributes: t.id })
            const n = new DR(t)
            o.add(n)
            e.conversion.for('downcast').attributeToElement({
              model: n.id,
              view: (t, { writer: e, schema: o }, { item: i }) => {
                if (!(i.is('selection') || o.isInline(i))) {
                  return
                }
                if (t) {
                  const t = e.createAttributeElement('a', n.attributes, { priority: 5 })
                  if (n.classes) {
                    e.addClass(n.classes, t)
                  }
                  for (const o in n.styles) {
                    e.setStyle(o, n.styles[o], t)
                  }
                  e.setCustomProperty('link', true, t)
                  return t
                }
              },
            })
            e.conversion
              .for('upcast')
              .elementToAttribute({ view: { name: 'a', ...n._createPattern() }, model: { key: n.id } })
          })
        }
        _enableLinkOpen() {
          const t = this.editor
          const e = t.editing.view
          const n = e.document
          this.listenTo(
            n,
            'click',
            (t, e) => {
              const n = l.isMac ? e.domEvent.metaKey : e.domEvent.ctrlKey
              if (!n) {
                return
              }
              let o = e.domTarget
              if (o.tagName.toLowerCase() != 'a') {
                o = o.closest('a')
              }
              if (!o) {
                return
              }
              const i = o.getAttribute('href')
              if (!i) {
                return
              }
              t.stop()
              e.preventDefault()
              vR(i)
            },
            { context: '$capture' },
          )
          this.listenTo(n, 'keydown', (e, n) => {
            const o = t.commands.get('link')
            const i = o.value
            const r = !!i && n.keyCode === Yc.enter && n.altKey
            if (!r) {
              return
            }
            e.stop()
            vR(i)
          })
        }
        _enableInsertContentSelectionAttributesFixer() {
          const t = this.editor
          const e = t.model
          const n = e.document.selection
          this.listenTo(
            e,
            'insertContent',
            () => {
              const t = n.anchor.nodeBefore
              const o = n.anchor.nodeAfter
              if (!n.hasAttribute('linkHref')) {
                return
              }
              if (!t) {
                return
              }
              if (!t.hasAttribute('linkHref')) {
                return
              }
              if (o && o.hasAttribute('linkHref')) {
                return
              }
              e.change((t) => {
                RR(t, FR(e.schema))
              })
            },
            { priority: 'low' },
          )
        }
        _enableClickingAfterLink() {
          const t = this.editor
          const e = t.model
          t.editing.view.addObserver(K_)
          let n = false
          this.listenTo(t.editing.view.document, 'mousedown', () => {
            n = true
          })
          this.listenTo(t.editing.view.document, 'selectionChange', () => {
            if (!n) {
              return
            }
            n = false
            const t = e.document.selection
            if (!t.isCollapsed) {
              return
            }
            if (!t.hasAttribute('linkHref')) {
              return
            }
            const o = t.getFirstPosition()
            const i = BT(o, 'linkHref', t.getAttribute('linkHref'), e)
            if (o.isTouching(i.start) || o.isTouching(i.end)) {
              e.change((t) => {
                RR(t, FR(e.schema))
              })
            }
          })
        }
        _enableTypingOverLink() {
          const t = this.editor
          const e = t.editing.view
          let n = null
          let o = false
          this.listenTo(
            e.document,
            'delete',
            () => {
              o = true
            },
            { priority: 'high' },
          )
          this.listenTo(
            t.model,
            'deleteContent',
            () => {
              const e = t.model.document.selection
              if (e.isCollapsed) {
                return
              }
              if (o) {
                o = false
                return
              }
              if (!VR(t)) {
                return
              }
              if (OR(t.model)) {
                n = e.getAttributes()
              }
            },
            { priority: 'high' },
          )
          this.listenTo(
            t.model,
            'insertContent',
            (e, [i]) => {
              o = false
              if (!VR(t)) {
                return
              }
              if (!n) {
                return
              }
              t.model.change((t) => {
                for (const [e, o] of n) {
                  t.setAttribute(e, o, i)
                }
              })
              n = null
            },
            { priority: 'high' },
          )
        }
        _handleDeleteContentAfterLink() {
          const t = this.editor
          const e = t.model
          const n = e.document.selection
          const o = t.editing.view
          let i = false
          let r = false
          this.listenTo(
            o.document,
            'delete',
            (t, e) => {
              r = e.direction === 'backward'
            },
            { priority: 'high' },
          )
          this.listenTo(
            e,
            'deleteContent',
            () => {
              i = false
              const t = n.getFirstPosition()
              const o = n.getAttribute('linkHref')
              if (!o) {
                return
              }
              const r = BT(t, 'linkHref', o, e)
              i = r.containsPosition(t) || r.end.isEqual(t)
            },
            { priority: 'high' },
          )
          this.listenTo(
            e,
            'deleteContent',
            () => {
              if (!r) {
                return
              }
              r = false
              if (i) {
                return
              }
              t.model.enqueueChange((t) => {
                RR(t, FR(e.schema))
              })
            },
            { priority: 'low' },
          )
        }
        _enableClipboardIntegration() {
          const t = this.editor
          const e = t.model
          const n = this.editor.config.get('link.defaultProtocol')
          if (!n) {
            return
          }
          this.listenTo(t.plugins.get('ClipboardPipeline'), 'contentInsertion', (t, o) => {
            e.change((t) => {
              const e = t.createRangeIn(o.content)
              for (const o of e.getItems()) {
                if (o.hasAttribute('linkHref')) {
                  const e = _R(o.getAttribute('linkHref'), n)
                  t.setAttribute('linkHref', e, o)
                }
              }
            })
          })
        }
      }
      function RR(t, e) {
        t.removeSelectionAttribute('linkHref')
        for (const n of e) {
          t.removeSelectionAttribute(n)
        }
      }
      function OR(t) {
        const e = t.document.selection
        const n = e.getFirstPosition()
        const o = e.getLastPosition()
        const i = n.nodeAfter
        if (!i) {
          return false
        }
        if (!i.is('$text')) {
          return false
        }
        if (!i.hasAttribute('linkHref')) {
          return false
        }
        const r = o.textNode || o.nodeBefore
        if (i === r) {
          return true
        }
        const s = BT(n, 'linkHref', i.getAttribute('linkHref'), t)
        return s.containsRange(t.createRange(n, o), true)
      }
      function VR(t) {
        const e = t.model.change((t) => t.batch)
        return e.isTyping
      }
      function FR(t) {
        const e = t.getDefinition('$text').allowAttributes
        return e.filter((t) => t.startsWith('link'))
      }
      var jR = n(4874)
      var HR = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      HR.insert = 'head'
      HR.singleton = true
      var UR = Rl()(jR.Z, HR)
      const WR = jR.Z.locals || {}
      class GR extends Hl {
        constructor(t, e) {
          super(t)
          this.focusTracker = new kl()
          this.keystrokes = new wl()
          this._focusables = new Pl()
          const n = t.t
          this.urlInputView = this._createUrlInput()
          this.saveButtonView = this._createButton(n('Save'), Sv.check, 'ck-button-save')
          this.saveButtonView.type = 'submit'
          this.cancelButtonView = this._createButton(n('Cancel'), Sv.cancel, 'ck-button-cancel', 'cancel')
          this._manualDecoratorSwitches = this._createManualDecoratorSwitches(e)
          this.children = this._createFormChildren(e.manualDecorators)
          this._focusCycler = new _u({
            focusables: this._focusables,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: { focusPrevious: 'shift + tab', focusNext: 'tab' },
          })
          const o = ['ck', 'ck-link-form', 'ck-responsive-form']
          if (e.manualDecorators.length) {
            o.push('ck-link-form_layout-vertical', 'ck-vertical-form')
          }
          this.setTemplate({ tag: 'form', attributes: { class: o, tabindex: '-1' }, children: this.children })
        }
        getDecoratorSwitchesState() {
          return Array.from(this._manualDecoratorSwitches).reduce((t, e) => {
            t[e.name] = e.isOn
            return t
          }, {})
        }
        render() {
          super.render()
          i({ view: this })
          const t = [this.urlInputView, ...this._manualDecoratorSwitches, this.saveButtonView, this.cancelButtonView]
          t.forEach((t) => {
            this._focusables.add(t)
            this.focusTracker.add(t.element)
          })
          this.keystrokes.listenTo(this.element)
        }
        destroy() {
          super.destroy()
          this.focusTracker.destroy()
          this.keystrokes.destroy()
        }
        focus() {
          this._focusCycler.focusFirst()
        }
        _createUrlInput() {
          const t = this.locale.t
          const e = new iu(this.locale, Ay)
          e.label = t('Link URL')
          return e
        }
        _createButton(t, e, n, o) {
          const i = new Dd(this.locale)
          i.set({ label: t, icon: e, tooltip: true })
          i.extendTemplate({ attributes: { class: n } })
          if (o) {
            i.delegate('execute').to(this, o)
          }
          return i
        }
        _createManualDecoratorSwitches(t) {
          const e = this.createCollection()
          for (const n of t.manualDecorators) {
            const o = new Bd(this.locale)
            o.set({ name: n.id, label: n.label, withText: true })
            o.bind('isOn').toMany([n, t], 'value', (t, e) =>
              e === undefined && t === undefined ? !!n.defaultValue : !!t,
            )
            o.on('execute', () => {
              n.set('value', !o.isOn)
            })
            e.add(o)
          }
          return e
        }
        _createFormChildren(t) {
          const e = this.createCollection()
          e.add(this.urlInputView)
          if (t.length) {
            const t = new Hl()
            t.setTemplate({
              tag: 'ul',
              children: this._manualDecoratorSwitches.map((t) => ({
                tag: 'li',
                children: [t],
                attributes: { class: ['ck', 'ck-list__item'] },
              })),
              attributes: { class: ['ck', 'ck-reset', 'ck-list'] },
            })
            e.add(t)
          }
          e.add(this.saveButtonView)
          e.add(this.cancelButtonView)
          return e
        }
      }
      var qR = n(7536)
      var $R = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      $R.insert = 'head'
      $R.singleton = true
      var KR = Rl()(qR.Z, $R)
      const YR = qR.Z.locals || {}
      const ZR =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184zm4.919 10.562-1.414 1.414a.75.75 0 1 1-1.06-1.06l1.414-1.415-1.415-1.414a.75.75 0 0 1 1.061-1.06l1.414 1.414 1.414-1.415a.75.75 0 0 1 1.061 1.061l-1.414 1.414 1.414 1.415a.75.75 0 0 1-1.06 1.06l-1.415-1.414z"/></svg>'
      class QR extends Hl {
        constructor(t) {
          super(t)
          this.focusTracker = new kl()
          this.keystrokes = new wl()
          this._focusables = new Pl()
          const e = t.t
          this.previewButtonView = this._createPreviewButton()
          this.unlinkButtonView = this._createButton(e('Unlink'), ZR, 'unlink')
          this.editButtonView = this._createButton(e('Edit link'), Sv.pencil, 'edit')
          this.set('href', undefined)
          this._focusCycler = new _u({
            focusables: this._focusables,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: { focusPrevious: 'shift + tab', focusNext: 'tab' },
          })
          this.setTemplate({
            tag: 'div',
            attributes: { class: ['ck', 'ck-link-actions', 'ck-responsive-form'], tabindex: '-1' },
            children: [this.previewButtonView, this.editButtonView, this.unlinkButtonView],
          })
        }
        render() {
          super.render()
          const t = [this.previewButtonView, this.editButtonView, this.unlinkButtonView]
          t.forEach((t) => {
            this._focusables.add(t)
            this.focusTracker.add(t.element)
          })
          this.keystrokes.listenTo(this.element)
        }
        destroy() {
          super.destroy()
          this.focusTracker.destroy()
          this.keystrokes.destroy()
        }
        focus() {
          this._focusCycler.focusFirst()
        }
        _createButton(t, e, n) {
          const o = new Dd(this.locale)
          o.set({ label: t, icon: e, tooltip: true })
          o.delegate('execute').to(this, n)
          return o
        }
        _createPreviewButton() {
          const t = new Dd(this.locale)
          const e = this.bindTemplate
          const n = this.t
          t.set({ withText: true, tooltip: n('Open link in new tab') })
          t.extendTemplate({
            attributes: {
              class: ['ck', 'ck-link-actions__preview'],
              href: e.to('href', (t) => t && mR(t)),
              target: '_blank',
              rel: 'noopener noreferrer',
            },
          })
          t.bind('label').to(this, 'href', (t) => t || n('This link has no URL'))
          t.bind('isEnabled').to(this, 'href', (t) => !!t)
          t.template.tag = 'a'
          t.template.eventListeners = {}
          return t
        }
      }
      const JR =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184z"/></svg>'
      const XR = 'link-ui'
      class tO extends Du {
        constructor() {
          super(...arguments)
          this.actionsView = null
          this.formView = null
        }
        static get requires() {
          return [eD]
        }
        static get pluginName() {
          return 'LinkUI'
        }
        init() {
          const t = this.editor
          t.editing.view.addObserver($_)
          this._balloon = t.plugins.get(eD)
          this._createToolbarLinkButton()
          this._enableBalloonActivators()
          t.conversion
            .for('editingDowncast')
            .markerToHighlight({ model: XR, view: { classes: ['ck-fake-link-selection'] } })
          t.conversion
            .for('editingDowncast')
            .markerToElement({
              model: XR,
              view: { name: 'span', classes: ['ck-fake-link-selection', 'ck-fake-link-selection_collapsed'] },
            })
        }
        destroy() {
          super.destroy()
          if (this.formView) {
            this.formView.destroy()
          }
          if (this.actionsView) {
            this.actionsView.destroy()
          }
        }
        _createViews() {
          this.actionsView = this._createActionsView()
          this.formView = this._createFormView()
          this._enableUserBalloonInteractions()
        }
        _createActionsView() {
          const t = this.editor
          const e = new QR(t.locale)
          const n = t.commands.get('link')
          const o = t.commands.get('unlink')
          e.bind('href').to(n, 'value')
          e.editButtonView.bind('isEnabled').to(n)
          e.unlinkButtonView.bind('isEnabled').to(o)
          this.listenTo(e, 'edit', () => {
            this._addFormView()
          })
          this.listenTo(e, 'unlink', () => {
            t.execute('unlink')
            this._hideUI()
          })
          e.keystrokes.set('Esc', (t, e) => {
            this._hideUI()
            e()
          })
          e.keystrokes.set(hR, (t, e) => {
            this._addFormView()
            e()
          })
          return e
        }
        _createFormView() {
          const t = this.editor
          const n = t.commands.get('link')
          const o = t.config.get('link.defaultProtocol')
          const i = new (e(GR))(t.locale, n)
          i.urlInputView.fieldView.bind('value').to(n, 'value')
          i.urlInputView.bind('isEnabled').to(n, 'isEnabled')
          i.saveButtonView.bind('isEnabled').to(n)
          this.listenTo(i, 'submit', () => {
            const { value: e } = i.urlInputView.fieldView.element
            const n = _R(e, o)
            t.execute('link', n, i.getDecoratorSwitchesState())
            this._closeFormView()
          })
          this.listenTo(i, 'cancel', () => {
            this._closeFormView()
          })
          i.keystrokes.set('Esc', (t, e) => {
            this._closeFormView()
            e()
          })
          return i
        }
        _createToolbarLinkButton() {
          const t = this.editor
          const e = t.commands.get('link')
          const n = t.t
          t.ui.componentFactory.add('link', (t) => {
            const o = new Dd(t)
            o.isEnabled = true
            o.label = n('Link')
            o.icon = JR
            o.keystroke = hR
            o.tooltip = true
            o.isToggleable = true
            o.bind('isEnabled').to(e, 'isEnabled')
            o.bind('isOn').to(e, 'value', (t) => !!t)
            this.listenTo(o, 'execute', () => this._showUI(true))
            return o
          })
        }
        _enableBalloonActivators() {
          const t = this.editor
          const e = t.editing.view.document
          this.listenTo(e, 'click', () => {
            const t = this._getSelectedLinkElement()
            if (t) {
              this._showUI()
            }
          })
          t.keystrokes.set(hR, (e, n) => {
            n()
            if (t.commands.get('link').isEnabled) {
              this._showUI(true)
            }
          })
        }
        _enableUserBalloonInteractions() {
          this.editor.keystrokes.set(
            'Tab',
            (t, e) => {
              if (this._areActionsVisible && !this.actionsView.focusTracker.isFocused) {
                this.actionsView.focus()
                e()
              }
            },
            { priority: 'high' },
          )
          this.editor.keystrokes.set('Esc', (t, e) => {
            if (this._isUIVisible) {
              this._hideUI()
              e()
            }
          })
          t({
            emitter: this.formView,
            activator: () => this._isUIInPanel,
            contextElements: () => [this._balloon.view.element],
            callback: () => this._hideUI(),
          })
        }
        _addActionsView() {
          if (!this.actionsView) {
            this._createViews()
          }
          if (this._areActionsInPanel) {
            return
          }
          this._balloon.add({ view: this.actionsView, position: this._getBalloonPositionData() })
        }
        _addFormView() {
          if (!this.formView) {
            this._createViews()
          }
          if (this._isFormInPanel) {
            return
          }
          const t = this.editor
          const e = t.commands.get('link')
          this.formView.disableCssTransitions()
          this._balloon.add({ view: this.formView, position: this._getBalloonPositionData() })
          if (this._balloon.visibleView === this.formView) {
            this.formView.urlInputView.fieldView.select()
          }
          this.formView.enableCssTransitions()
          this.formView.urlInputView.fieldView.element.value = e.value || ''
        }
        _closeFormView() {
          const t = this.editor.commands.get('link')
          t.restoreManualDecoratorStates()
          if (t.value !== undefined) {
            this._removeFormView()
          } else {
            this._hideUI()
          }
        }
        _removeFormView() {
          if (this._isFormInPanel) {
            this.formView.saveButtonView.focus()
            this._balloon.remove(this.formView)
            this.editor.editing.view.focus()
            this._hideFakeVisualSelection()
          }
        }
        _showUI(t = false) {
          if (!this.formView) {
            this._createViews()
          }
          if (!this._getSelectedLinkElement()) {
            this._showFakeVisualSelection()
            this._addActionsView()
            if (t) {
              this._balloon.showStack('main')
            }
            this._addFormView()
          } else {
            if (this._areActionsVisible) {
              this._addFormView()
            } else {
              this._addActionsView()
            }
            if (t) {
              this._balloon.showStack('main')
            }
          }
          this._startUpdatingUI()
        }
        _hideUI() {
          if (!this._isUIInPanel) {
            return
          }
          const t = this.editor
          this.stopListening(t.ui, 'update')
          this.stopListening(this._balloon, 'change:visibleView')
          t.editing.view.focus()
          this._removeFormView()
          this._balloon.remove(this.actionsView)
          this._hideFakeVisualSelection()
        }
        _startUpdatingUI() {
          const t = this.editor
          const e = t.editing.view.document
          let n = this._getSelectedLinkElement()
          let o = r()
          const i = () => {
            const t = this._getSelectedLinkElement()
            const e = r()
            if ((n && !t) || (!n && e !== o)) {
              this._hideUI()
            } else if (this._isUIVisible) {
              this._balloon.updatePosition(this._getBalloonPositionData())
            }
            n = t
            o = e
          }
          function r() {
            return e.selection.focus
              .getAncestors()
              .reverse()
              .find((t) => t.is('element'))
          }
          this.listenTo(t.ui, 'update', i)
          this.listenTo(this._balloon, 'change:visibleView', i)
        }
        get _isFormInPanel() {
          return !!this.formView && this._balloon.hasView(this.formView)
        }
        get _areActionsInPanel() {
          return !!this.actionsView && this._balloon.hasView(this.actionsView)
        }
        get _areActionsVisible() {
          return !!this.actionsView && this._balloon.visibleView === this.actionsView
        }
        get _isUIInPanel() {
          return this._isFormInPanel || this._areActionsInPanel
        }
        get _isUIVisible() {
          const t = this._balloon.visibleView
          return (!!this.formView && t == this.formView) || this._areActionsVisible
        }
        _getBalloonPositionData() {
          const t = this.editor.editing.view
          const e = this.editor.model
          const n = t.document
          let o
          if (e.markers.has(XR)) {
            const e = Array.from(this.editor.editing.mapper.markerNameToElements(XR))
            const n = t.createRange(t.createPositionBefore(e[0]), t.createPositionAfter(e[e.length - 1]))
            o = t.domConverter.viewRangeToDom(n)
          } else {
            o = () => {
              const e = this._getSelectedLinkElement()
              return e ? t.domConverter.mapViewToDom(e) : t.domConverter.viewRangeToDom(n.selection.getFirstRange())
            }
          }
          return { target: o }
        }
        _getSelectedLinkElement() {
          const t = this.editor.editing.view
          const e = t.document.selection
          const n = e.getSelectedElement()
          if (e.isCollapsed || (n && xS(n))) {
            return eO(e.getFirstPosition())
          } else {
            const n = e.getFirstRange().getTrimmed()
            const o = eO(n.start)
            const i = eO(n.end)
            if (!o || o != i) {
              return null
            }
            if (t.createRangeIn(o).getTrimmed().isEqual(n)) {
              return o
            } else {
              return null
            }
          }
        }
        _showFakeVisualSelection() {
          const t = this.editor.model
          t.change((e) => {
            const n = t.document.selection.getFirstRange()
            if (t.markers.has(XR)) {
              e.updateMarker(XR, { range: n })
            } else {
              if (n.start.isAtEnd) {
                const o = n.start.getLastMatchingPosition(({ item: e }) => !t.schema.isContent(e), { boundaries: n })
                e.addMarker(XR, { usingOperation: false, affectsData: false, range: e.createRange(o, n.end) })
              } else {
                e.addMarker(XR, { usingOperation: false, affectsData: false, range: n })
              }
            }
          })
        }
        _hideFakeVisualSelection() {
          const t = this.editor.model
          if (t.markers.has(XR)) {
            t.change((t) => {
              t.removeMarker(XR)
            })
          }
        }
      }
      function eO(t) {
        return t.getAncestors().find((t) => gR(t)) || null
      }
      const nO = 4
      const oO = new RegExp(
        '(^|\\s)' +
          '(' +
          '(' +
          '(?:(?:(?:https?|ftp):)?\\/\\/)' +
          '(?:\\S+(?::\\S*)?@)?' +
          '(?:' +
          '(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])' +
          '(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}' +
          '(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))' +
          '|' +
          '(' +
          '((?!www\\.)|(www\\.))' +
          '(?![-_])(?:[-_a-z0-9\\u00a1-\\uffff]{1,63}\\.)+' +
          '(?:[a-z\\u00a1-\\uffff]{2,63})' +
          ')' +
          ')' +
          '(?::\\d{2,5})?' +
          '(?:[/?#]\\S*)?' +
          ')' +
          '|' +
          '(' +
          '(www.|(\\S+@))' +
          '((?![-_])(?:[-_a-z0-9\\u00a1-\\uffff]{1,63}\\.))+' +
          '(?:[a-z\\u00a1-\\uffff]{2,63})' +
          ')' +
          ')$',
        'i',
      )
      const iO = 2
      class rO extends Du {
        static get requires() {
          return [cT]
        }
        static get pluginName() {
          return 'AutoLink'
        }
        init() {
          const t = this.editor
          const e = t.model.document.selection
          e.on('change:range', () => {
            this.isEnabled = !e.anchor.parent.is('element', 'codeBlock')
          })
          this._enableTypingHandling()
        }
        afterInit() {
          this._enableEnterHandling()
          this._enableShiftEnterHandling()
        }
        _enableTypingHandling() {
          const t = this.editor
          const e = new uT(t.model, (t) => {
            if (!sO(t)) {
              return
            }
            const e = aO(t.substr(0, t.length - 1))
            if (e) {
              return { url: e }
            }
          })
          e.on('matched:data', (e, n) => {
            const { batch: o, range: i, url: r } = n
            if (!o.isTyping) {
              return
            }
            const s = i.end.getShiftedBy(-1)
            const a = s.getShiftedBy(-r.length)
            const c = t.model.createRange(a, s)
            this._applyAutoLink(r, c)
          })
          e.bind('isEnabled').to(this)
        }
        _enableEnterHandling() {
          const t = this.editor
          const e = t.model
          const n = t.commands.get('enter')
          if (!n) {
            return
          }
          n.on('execute', () => {
            const t = e.document.selection.getFirstPosition()
            if (!t.parent.previousSibling) {
              return
            }
            const n = e.createRangeIn(t.parent.previousSibling)
            this._checkAndApplyAutoLinkOnRange(n)
          })
        }
        _enableShiftEnterHandling() {
          const t = this.editor
          const e = t.model
          const n = t.commands.get('shiftEnter')
          if (!n) {
            return
          }
          n.on('execute', () => {
            const t = e.document.selection.getFirstPosition()
            const n = e.createRange(e.createPositionAt(t.parent, 0), t.getShiftedBy(-1))
            this._checkAndApplyAutoLinkOnRange(n)
          })
        }
        _checkAndApplyAutoLinkOnRange(t) {
          const e = this.editor.model
          const { text: n, range: o } = dT(t, e)
          const i = aO(n)
          if (i) {
            const t = e.createRange(o.end.getShiftedBy(-i.length), o.end)
            this._applyAutoLink(i, t)
          }
        }
        _applyAutoLink(t, e) {
          const n = this.editor.model
          const o = this.editor.config.get('link.defaultProtocol')
          const i = _R(t, o)
          if (!this.isEnabled || !cO(e, n) || !CR(i) || lO(e)) {
            return
          }
          this._persistAutoLink(i, e)
        }
        _persistAutoLink(t, e) {
          const n = this.editor.model
          const o = this.editor.plugins.get('Delete')
          n.enqueueChange((i) => {
            i.setAttribute('linkHref', t, e)
            n.enqueueChange(() => {
              o.requestUndoOnBackspace()
            })
          })
        }
      }
      function sO(t) {
        return t.length > nO && t[t.length - 1] === ' ' && t[t.length - 2] !== ' '
      }
      function aO(t) {
        const e = oO.exec(t)
        return e ? e[iO] : null
      }
      function cO(t, e) {
        return e.schema.checkAttributeInSelection(e.createSelection(t), 'linkHref')
      }
      function lO(t) {
        const e = t.start.nodeAfter
        return !!e && e.hasAttribute('linkHref')
      }
      class dO extends Du {
        static get requires() {
          return [zR, tO, rO]
        }
        static get pluginName() {
          return 'Link'
        }
      }
      class uO extends (null && Plugin) {
        static get requires() {
          return ['ImageEditing', 'ImageUtils', LinkEditing]
        }
        static get pluginName() {
          return 'LinkImageEditing'
        }
        init() {
          const t = this.editor
          const e = t.model.schema
          if (t.plugins.has('ImageBlockEditing')) {
            e.extend('imageBlock', { allowAttributes: ['linkHref'] })
          }
          t.conversion.for('upcast').add(hO(t))
          t.conversion.for('downcast').add(gO(t))
          this._enableAutomaticDecorators()
          this._enableManualDecorators()
        }
        _enableAutomaticDecorators() {
          const t = this.editor
          const e = t.commands.get('link')
          const n = e.automaticDecorators
          if (n.length) {
            t.conversion.for('downcast').add(n.getDispatcherForLinkedImage())
          }
        }
        _enableManualDecorators() {
          const t = this.editor
          const e = t.commands.get('link')
          for (const n of e.manualDecorators) {
            if (t.plugins.has('ImageBlockEditing')) {
              t.model.schema.extend('imageBlock', { allowAttributes: n.id })
            }
            if (t.plugins.has('ImageInlineEditing')) {
              t.model.schema.extend('imageInline', { allowAttributes: n.id })
            }
            t.conversion.for('downcast').add(fO(n))
            t.conversion.for('upcast').add(mO(t, n))
          }
        }
      }
      function hO(t) {
        const e = t.plugins.has('ImageInlineEditing')
        const n = t.plugins.get('ImageUtils')
        return (t) => {
          t.on(
            'element:a',
            (t, o, i) => {
              const r = o.viewItem
              const s = n.findViewImgElement(r)
              if (!s) {
                return
              }
              const a = s.findAncestor((t) => n.isBlockImageView(t))
              if (e && !a) {
                return
              }
              const c = { attributes: ['href'] }
              if (!i.consumable.consume(r, c)) {
                return
              }
              const l = r.getAttribute('href')
              if (!l) {
                return
              }
              let d = o.modelCursor.parent
              if (!d.is('element', 'imageBlock')) {
                const t = i.convertItem(s, o.modelCursor)
                o.modelRange = t.modelRange
                o.modelCursor = t.modelCursor
                d = o.modelCursor.nodeBefore
              }
              if (d && d.is('element', 'imageBlock')) {
                i.writer.setAttribute('linkHref', l, d)
              }
            },
            { priority: 'high' },
          )
        }
      }
      function gO(t) {
        const e = t.plugins.get('ImageUtils')
        return (t) => {
          t.on(
            'attribute:linkHref:imageBlock',
            (t, n, o) => {
              if (!o.consumable.consume(n.item, t.name)) {
                return
              }
              const i = o.mapper.toViewElement(n.item)
              const r = o.writer
              const s = Array.from(i.getChildren()).find((t) => t.is('element', 'a'))
              const a = e.findViewImgElement(i)
              const c = a.parent.is('element', 'picture') ? a.parent : a
              if (s) {
                if (n.attributeNewValue) {
                  r.setAttribute('href', n.attributeNewValue, s)
                } else {
                  r.move(r.createRangeOn(c), r.createPositionAt(i, 0))
                  r.remove(s)
                }
              } else {
                const t = r.createContainerElement('a', { href: n.attributeNewValue })
                r.insert(r.createPositionAt(i, 0), t)
                r.move(r.createRangeOn(c), r.createPositionAt(t, 0))
              }
            },
            { priority: 'high' },
          )
        }
      }
      function fO(t) {
        return (e) => {
          e.on(`attribute:${t.id}:imageBlock`, (e, n, o) => {
            const i = o.mapper.toViewElement(n.item)
            const r = Array.from(i.getChildren()).find((t) => t.is('element', 'a'))
            if (!r) {
              return
            }
            for (const [e, n] of toMap(t.attributes)) {
              o.writer.setAttribute(e, n, r)
            }
            if (t.classes) {
              o.writer.addClass(t.classes, r)
            }
            for (const e in t.styles) {
              o.writer.setStyle(e, t.styles[e], r)
            }
          })
        }
      }
      function mO(t, e) {
        const n = t.plugins.has('ImageInlineEditing')
        const o = t.plugins.get('ImageUtils')
        return (t) => {
          t.on(
            'element:a',
            (t, i, r) => {
              const s = i.viewItem
              const a = o.findViewImgElement(s)
              if (!a) {
                return
              }
              const c = a.findAncestor((t) => o.isBlockImageView(t))
              if (n && !c) {
                return
              }
              const l = new Matcher(e._createPattern())
              const d = l.match(s)
              if (!d) {
                return
              }
              if (!r.consumable.consume(s, d.match)) {
                return
              }
              const u = i.modelCursor.nodeBefore || i.modelCursor.parent
              r.writer.setAttribute(e.id, true, u)
            },
            { priority: 'high' },
          )
        }
      }
      class pO extends (null && Plugin) {
        static get requires() {
          return [LinkEditing, LinkUI, 'ImageBlockEditing']
        }
        static get pluginName() {
          return 'LinkImageUI'
        }
        init() {
          const t = this.editor
          const e = t.editing.view.document
          this.listenTo(
            e,
            'click',
            (e, n) => {
              if (this._isSelectedLinkedImage(t.model.document.selection)) {
                n.preventDefault()
                e.stop()
              }
            },
            { priority: 'high' },
          )
          this._createToolbarLinkImageButton()
        }
        _createToolbarLinkImageButton() {
          const t = this.editor
          const e = t.t
          t.ui.componentFactory.add('linkImage', (n) => {
            const o = new ButtonView(n)
            const i = t.plugins.get('LinkUI')
            const r = t.commands.get('link')
            o.set({
              isEnabled: true,
              label: e('Link image'),
              icon: linkIcon,
              keystroke: LINK_KEYSTROKE,
              tooltip: true,
              isToggleable: true,
            })
            o.bind('isEnabled').to(r, 'isEnabled')
            o.bind('isOn').to(r, 'value', (t) => !!t)
            this.listenTo(o, 'execute', () => {
              if (this._isSelectedLinkedImage(t.model.document.selection)) {
                i._addActionsView()
              } else {
                i._showUI(true)
              }
            })
            return o
          })
        }
        _isSelectedLinkedImage(t) {
          const e = t.getSelectedElement()
          const n = this.editor.plugins.get('ImageUtils')
          return n.isImage(e) && e.hasAttribute('linkHref')
        }
      }
      var bO = n(4330)
      var kO = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      kO.insert = 'head'
      kO.singleton = true
      var wO = Rl()(bO.Z, kO)
      const AO = bO.Z.locals || {}
      class _O extends (null && Plugin) {
        static get requires() {
          return [LinkImageEditing, LinkImageUI]
        }
        static get pluginName() {
          return 'LinkImage'
        }
      }
      class CO {
        constructor(t, e) {
          this._startElement = t
          this._referenceIndent = t.getAttribute('listIndent')
          this._isForward = e.direction == 'forward'
          this._includeSelf = !!e.includeSelf
          this._sameAttributes = sl(e.sameAttributes || [])
          this._sameIndent = !!e.sameIndent
          this._lowerIndent = !!e.lowerIndent
          this._higherIndent = !!e.higherIndent
        }
        static first(t, e) {
          const n = new this(t, e)
          const o = n[Symbol.iterator]()
          return bl(o)
        }
        *[Symbol.iterator]() {
          const t = []
          for (const { node: e } of vO(this._getStartNode(), this._isForward ? 'forward' : 'backward')) {
            const n = e.getAttribute('listIndent')
            if (n < this._referenceIndent) {
              if (!this._lowerIndent) {
                break
              }
              this._referenceIndent = n
            } else if (n > this._referenceIndent) {
              if (!this._higherIndent) {
                continue
              }
              if (!this._isForward) {
                t.push(e)
                continue
              }
            } else {
              if (!this._sameIndent) {
                if (this._higherIndent) {
                  if (t.length) {
                    yield* t
                    t.length = 0
                  }
                  break
                }
                continue
              }
              if (this._sameAttributes.some((t) => e.getAttribute(t) !== this._startElement.getAttribute(t))) {
                break
              }
            }
            if (t.length) {
              yield* t
              t.length = 0
            }
            yield e
          }
        }
        _getStartNode() {
          if (this._includeSelf) {
            return this._startElement
          }
          return this._isForward ? this._startElement.nextSibling : this._startElement.previousSibling
        }
      }
      function* vO(t, e = 'forward') {
        const n = e == 'forward'
        let o = null
        while (EO(t)) {
          yield { node: t, previous: o }
          o = t
          t = n ? t.nextSibling : t.previousSibling
        }
      }
      class yO {
        constructor(t) {
          this._listHead = t
        }
        [Symbol.iterator]() {
          return vO(this._listHead, 'forward')
        }
      }
      class xO {
        static next() {
          return uid()
        }
      }
      function EO(t) {
        return !!t && t.is('element') && t.hasAttribute('listItemId')
      }
      function DO(t, e = {}) {
        return [...TO(t, { ...e, direction: 'backward' }), ...TO(t, { ...e, direction: 'forward' })]
      }
      function TO(t, e = {}) {
        const n = e.direction == 'forward'
        const o = Array.from(
          new ListWalker(t, { ...e, includeSelf: n, sameIndent: true, sameAttributes: 'listItemId' }),
        )
        return n ? o : o.reverse()
      }
      function IO(t) {
        return Array.from(new ListWalker(t, { direction: 'forward', higherIndent: true }))
      }
      function SO(t) {
        const e = new ListWalker(t, { sameIndent: true, sameAttributes: 'listType' })
        const n = new ListWalker(t, {
          sameIndent: true,
          sameAttributes: 'listType',
          includeSelf: true,
          direction: 'forward',
        })
        return [...Array.from(e).reverse(), ...n]
      }
      function MO(t) {
        const e = ListWalker.first(t, { sameIndent: true, sameAttributes: 'listItemId' })
        if (!e) {
          return true
        }
        return false
      }
      function BO(t) {
        const e = ListWalker.first(t, { direction: 'forward', sameIndent: true, sameAttributes: 'listItemId' })
        if (!e) {
          return true
        }
        return false
      }
      function NO(t, e = {}) {
        t = toArray(t)
        const n = e.withNested !== false
        const o = new Set()
        for (const e of t) {
          for (const t of DO(e, { higherIndent: n })) {
            o.add(t)
          }
        }
        return HO(o)
      }
      function PO(t) {
        t = toArray(t)
        const e = new Set()
        for (const n of t) {
          for (const t of SO(n)) {
            e.add(t)
          }
        }
        return HO(e)
      }
      function LO(t, e) {
        const n = TO(t, { direction: 'forward' })
        const o = xO.next()
        for (const t of n) {
          e.setAttribute('listItemId', o, t)
        }
        return n
      }
      function zO(t, e, n) {
        const o = {}
        for (const [t, n] of e.getAttributes()) {
          if (t.startsWith('list')) {
            o[t] = n
          }
        }
        const i = TO(t, { direction: 'forward' })
        for (const t of i) {
          n.setAttributes(o, t)
        }
        return i
      }
      function RO(t, e, { expand: n, indentBy: o = 1 } = {}) {
        t = toArray(t)
        const i = n ? NO(t) : t
        for (const t of i) {
          const n = t.getAttribute('listIndent') + o
          if (n < 0) {
            VO(t, e)
          } else {
            e.setAttribute('listIndent', n, t)
          }
        }
        return i
      }
      function OO(t, e) {
        t = toArray(t)
        const n = NO(t)
        const o = new Set()
        const i = Math.min(...n.map((t) => t.getAttribute('listIndent')))
        const r = new Map()
        for (const t of n) {
          r.set(t, ListWalker.first(t, { lowerIndent: true }))
        }
        for (const t of n) {
          if (o.has(t)) {
            continue
          }
          o.add(t)
          const n = t.getAttribute('listIndent') - 1
          if (n < 0) {
            VO(t, e)
            continue
          }
          if (t.getAttribute('listIndent') == i) {
            const n = WO(t, r.get(t), e)
            for (const t of n) {
              o.add(t)
            }
            if (n.length) {
              continue
            }
          }
          e.setAttribute('listIndent', n, t)
        }
        return HO(o)
      }
      function VO(t, e) {
        t = toArray(t)
        for (const n of t) {
          for (const t of n.getAttributeKeys()) {
            if (t.startsWith('list')) {
              e.removeAttribute(t, n)
            }
          }
        }
        return t
      }
      function FO(t) {
        if (!t.length) {
          return false
        }
        const e = t[0].getAttribute('listItemId')
        if (!e) {
          return false
        }
        return !t.some((t) => t.getAttribute('listItemId') != e)
      }
      function jO(t, e) {
        const n = []
        let o = Number.POSITIVE_INFINITY
        for (const { node: i } of iterateSiblingListBlocks(t.nextSibling, 'forward')) {
          const t = i.getAttribute('listIndent')
          if (t == 0) {
            break
          }
          if (t < o) {
            o = t
          }
          const r = t - o
          e.setAttribute('listIndent', r, i)
          n.push(i)
        }
        return n
      }
      function HO(t) {
        return Array.from(t)
          .filter((t) => t.root.rootName !== '$graveyard')
          .sort((t, e) => t.index - e.index)
      }
      function UO(t) {
        const e = t.document.selection.getSelectedElement()
        if (!e) {
          return null
        }
        if (t.schema.isObject(e) && t.schema.isBlock(e)) {
          return e
        }
        return null
      }
      function WO(t, e, n) {
        const o = TO(e, { direction: 'forward' })
        if (o.pop().index > t.index) {
          return zO(t, e, n)
        }
        return []
      }
      class GO extends (null && Command) {
        constructor(t, e) {
          super(t)
          this._direction = e
        }
        refresh() {
          this.isEnabled = this._checkEnabled()
        }
        execute() {
          const t = this.editor.model
          const e = qO(t.document.selection)
          t.change((t) => {
            const n = []
            if (isSingleListItem(e) && !isFirstBlockOfListItem(e[0])) {
              if (this._direction == 'forward') {
                n.push(...indentBlocks(e, t))
              }
              n.push(...splitListItemBefore(e[0], t))
            } else {
              if (this._direction == 'forward') {
                n.push(...indentBlocks(e, t, { expand: true }))
              } else {
                n.push(...outdentBlocksWithMerge(e, t))
              }
            }
            for (const e of n) {
              if (!e.hasAttribute('listType')) {
                continue
              }
              const n = ListWalker.first(e, { sameIndent: true })
              if (n) {
                t.setAttribute('listType', n.getAttribute('listType'), e)
              }
            }
            this._fireAfterExecute(n)
          })
        }
        _fireAfterExecute(t) {
          this.fire('afterExecute', sortBlocks(new Set(t)))
        }
        _checkEnabled() {
          let t = qO(this.editor.model.document.selection)
          let e = t[0]
          if (!e) {
            return false
          }
          if (this._direction == 'backward') {
            return true
          }
          if (isSingleListItem(t) && !isFirstBlockOfListItem(t[0])) {
            return true
          }
          t = expandListBlocksToCompleteItems(t)
          e = t[0]
          const n = ListWalker.first(e, { sameIndent: true })
          if (!n) {
            return false
          }
          if (n.getAttribute('listType') == e.getAttribute('listType')) {
            return true
          }
          return false
        }
      }
      function qO(t) {
        const e = Array.from(t.getSelectedBlocks())
        const n = e.findIndex((t) => !isListItemBlock(t))
        if (n != -1) {
          e.length = n
        }
        return e
      }
      class $O extends (null && Command) {
        constructor(t, e) {
          super(t)
          this.type = e
        }
        refresh() {
          this.value = this._getValue()
          this.isEnabled = this._checkEnabled()
        }
        execute(t = {}) {
          const e = this.editor.model
          const n = e.document
          const o = getSelectedBlockObject(e)
          const i = Array.from(n.selection.getSelectedBlocks()).filter((t) => e.schema.checkAttribute(t, 'listType'))
          const r = t.forceValue !== undefined ? !t.forceValue : this.value
          e.change((t) => {
            if (r) {
              const e = i[i.length - 1]
              const n = getListItemBlocks(e, { direction: 'forward' })
              const o = []
              if (n.length > 1) {
                o.push(...splitListItemBefore(n[1], t))
              }
              o.push(...removeListAttributes(i, t))
              o.push(...outdentFollowingItems(e, t))
              this._fireAfterExecute(o)
            } else if ((o || n.selection.isCollapsed) && isListItemBlock(i[0])) {
              const e = getListItems(o || i[0])
              for (const n of e) {
                t.setAttribute('listType', this.type, n)
              }
              this._fireAfterExecute(e)
            } else {
              const e = []
              for (const n of i) {
                if (!n.hasAttribute('listType')) {
                  t.setAttributes({ listIndent: 0, listItemId: ListItemUid.next(), listType: this.type }, n)
                  e.push(n)
                } else {
                  for (const o of expandListBlocksToCompleteItems(n, { withNested: false })) {
                    if (o.getAttribute('listType') != this.type) {
                      t.setAttribute('listType', this.type, o)
                      e.push(o)
                    }
                  }
                }
              }
              this._fireAfterExecute(e)
            }
          })
        }
        _fireAfterExecute(t) {
          this.fire('afterExecute', sortBlocks(new Set(t)))
        }
        _getValue() {
          const t = this.editor.model.document.selection
          const e = Array.from(t.getSelectedBlocks())
          if (!e.length) {
            return false
          }
          for (const t of e) {
            if (t.getAttribute('listType') != this.type) {
              return false
            }
          }
          return true
        }
        _checkEnabled() {
          const t = this.editor.model.document.selection
          const e = this.editor.model.schema
          const n = Array.from(t.getSelectedBlocks())
          if (!n.length) {
            return false
          }
          if (this.value) {
            return true
          }
          for (const t of n) {
            if (e.checkAttribute(t, 'listType')) {
              return true
            }
          }
          return false
        }
      }
      class KO extends (null && Command) {
        constructor(t, e) {
          super(t)
          this._direction = e
        }
        refresh() {
          this.isEnabled = this._checkEnabled()
        }
        execute({ shouldMergeOnBlocksContentLevel: t = false } = {}) {
          const e = this.editor.model
          const n = e.document.selection
          const o = []
          e.change((i) => {
            const { firstElement: r, lastElement: s } = this._getMergeSubjectElements(n, t)
            const a = r.getAttribute('listIndent') || 0
            const c = s.getAttribute('listIndent')
            const l = s.getAttribute('listItemId')
            if (a != c) {
              const t = getNestedListBlocks(s)
              o.push(...indentBlocks([s, ...t], i, { indentBy: a - c, expand: a < c }))
            }
            if (t) {
              let t = n
              if (n.isCollapsed) {
                t = i.createSelection(i.createRange(i.createPositionAt(r, 'end'), i.createPositionAt(s, 0)))
              }
              e.deleteContent(t, { doNotResetEntireContent: n.isCollapsed })
              const a = t.getLastPosition().parent
              const c = a.nextSibling
              o.push(a)
              if (c && c !== s && c.getAttribute('listItemId') == l) {
                o.push(...mergeListItemBefore(c, a, i))
              }
            } else {
              o.push(...mergeListItemBefore(s, r, i))
            }
            this._fireAfterExecute(o)
          })
        }
        _fireAfterExecute(t) {
          this.fire('afterExecute', sortBlocks(new Set(t)))
        }
        _checkEnabled() {
          const t = this.editor.model
          const e = t.document.selection
          const n = getSelectedBlockObject(t)
          if (e.isCollapsed || n) {
            const t = n || e.getFirstPosition().parent
            if (!isListItemBlock(t)) {
              return false
            }
            const o = this._direction == 'backward' ? t.previousSibling : t.nextSibling
            if (!o) {
              return false
            }
            if (isSingleListItem([t, o])) {
              return false
            }
          } else {
            const t = e.getLastPosition()
            const n = e.getFirstPosition()
            if (t.parent === n.parent) {
              return false
            }
            if (!isListItemBlock(t.parent)) {
              return false
            }
          }
          return true
        }
        _getMergeSubjectElements(t, e) {
          const n = this.editor.model
          const o = getSelectedBlockObject(n)
          let i, r
          if (t.isCollapsed || o) {
            const n = o || t.getFirstPosition().parent
            const s = isFirstBlockOfListItem(n)
            if (this._direction == 'backward') {
              r = n
              if (s && !e) {
                i = ListWalker.first(n, { sameIndent: true, lowerIndent: true })
              } else {
                i = n.previousSibling
              }
            } else {
              i = n
              r = n.nextSibling
            }
          } else {
            i = t.getFirstPosition().parent
            r = t.getLastPosition().parent
          }
          return { firstElement: i, lastElement: r }
        }
      }
      class YO extends (null && Command) {
        constructor(t, e) {
          super(t)
          this._direction = e
        }
        refresh() {
          this.isEnabled = this._checkEnabled()
        }
        execute() {
          const t = this.editor
          t.model.change((t) => {
            const e = splitListItemBefore(this._getStartBlock(), t)
            this._fireAfterExecute(e)
          })
        }
        _fireAfterExecute(t) {
          this.fire('afterExecute', sortBlocks(new Set(t)))
        }
        _checkEnabled() {
          const t = this.editor.model.document.selection
          const e = this._getStartBlock()
          return t.isCollapsed && isListItemBlock(e) && !isFirstBlockOfListItem(e)
        }
        _getStartBlock() {
          const t = this.editor.model.document
          const e = t.selection.getFirstPosition().parent
          return this._direction == 'before' ? e : e.nextSibling
        }
      }
      class ZO extends (null && Plugin) {
        static get pluginName() {
          return 'DocumentListUtils'
        }
        expandListBlocksToCompleteList(t) {
          return expandListBlocksToCompleteList(t)
        }
        isFirstBlockOfListItem(t) {
          return isFirstBlockOfListItem(t)
        }
        isListItemBlock(t) {
          return isListItemBlock(t)
        }
        expandListBlocksToCompleteItems(t, e = {}) {
          return expandListBlocksToCompleteItems(t, e)
        }
      }
      function QO(t, e) {
        const n = t.nodeBefore
        if (!isListItemBlock(n)) {
          const n = t.nodeAfter
          if (isListItemBlock(n)) {
            e.set(n, n)
          }
        } else {
          let t = n
          for (const { node: n } of iterateSiblingListBlocks(t, 'backward')) {
            t = n
            if (e.has(t)) {
              return
            }
          }
          e.set(n, t)
        }
      }
      function JO(t, e) {
        let n = 0
        let o = -1
        let i = null
        let r = false
        for (const { node: s } of t) {
          const t = s.getAttribute('listIndent')
          if (t > n) {
            let a
            if (i === null) {
              i = t - n
              a = n
            } else {
              if (i > t) {
                i = t
              }
              a = t - i
            }
            if (a > o + 1) {
              a = o + 1
            }
            e.setAttribute('listIndent', a, s)
            r = true
            o = a
          } else {
            i = null
            n = t + 1
            o = t
          }
        }
        return r
      }
      function XO(t, e, n) {
        const o = new Set()
        let i = false
        for (const { node: r } of t) {
          if (o.has(r)) {
            continue
          }
          let t = r.getAttribute('listType')
          let s = r.getAttribute('listItemId')
          if (e.has(s)) {
            s = ListItemUid.next()
          }
          e.add(s)
          for (const e of getListItemBlocks(r, { direction: 'forward' })) {
            o.add(e)
            if (e.getAttribute('listType') != t) {
              s = ListItemUid.next()
              t = e.getAttribute('listType')
            }
            if (e.getAttribute('listItemId') != s) {
              n.setAttribute('listItemId', s, e)
              i = true
            }
          }
        }
        return i
      }
      function tV() {
        return (t, e, n) => {
          const { writer: o, schema: i } = n
          if (!e.modelRange) {
            return
          }
          const r = Array.from(e.modelRange.getItems({ shallow: true })).filter((t) =>
            i.checkAttribute(t, 'listItemId'),
          )
          if (!r.length) {
            return
          }
          const s = {
            listItemId: ListItemUid.next(),
            listIndent: getIndent(e.viewItem),
            listType: e.viewItem.parent && e.viewItem.parent.is('element', 'ol') ? 'numbered' : 'bulleted',
          }
          for (const t of r) {
            if (!isListItemBlock(t)) {
              o.setAttributes(s, t)
            }
          }
          if (r.length > 1) {
            if (r[1].getAttribute('listItemId') != s.listItemId) {
              n.keepEmptyElement(r[0])
            }
          }
        }
      }
      function eV() {
        return (t, e, n) => {
          if (!n.consumable.test(e.viewItem, { name: true })) {
            return
          }
          const o = new UpcastWriter(e.viewItem.document)
          for (const t of Array.from(e.viewItem.getChildren())) {
            if (!isListItemView(t) && !isListView(t)) {
              o.remove(t)
            }
          }
        }
      }
      function nV(t, e, n, o) {
        return () => {
          const o = t.document.differ.getChanges()
          const s = []
          const a = new Map()
          const c = new Set()
          for (const t of o) {
            if (t.type == 'insert' && t.name != '$text') {
              findAndAddListHeadToMap(t.position, a)
              if (!t.attributes.has('listItemId')) {
                findAndAddListHeadToMap(t.position.getShiftedBy(t.length), a)
              } else {
                c.add(t.position.nodeAfter)
              }
            } else if (t.type == 'remove' && t.attributes.has('listItemId')) {
              findAndAddListHeadToMap(t.position, a)
            } else if (t.type == 'attribute') {
              const e = t.range.start.nodeAfter
              if (n.includes(t.attributeKey)) {
                findAndAddListHeadToMap(t.range.start, a)
                if (t.attributeNewValue === null) {
                  findAndAddListHeadToMap(t.range.start.getShiftedBy(1), a)
                  if (r(e)) {
                    s.push(e)
                  }
                } else {
                  c.add(e)
                }
              } else if (isListItemBlock(e)) {
                if (r(e)) {
                  s.push(e)
                }
              }
            }
          }
          for (const t of a.values()) {
            s.push(...i(t, c))
          }
          for (const t of new Set(s)) {
            e.reconvertItem(t)
          }
        }
        function i(t, e) {
          const o = []
          const i = new Set()
          const a = []
          for (const { node: c, previous: l } of iterateSiblingListBlocks(t, 'forward')) {
            if (i.has(c)) {
              continue
            }
            const t = c.getAttribute('listIndent')
            if (l && t < l.getAttribute('listIndent')) {
              a.length = t + 1
            }
            a[t] = Object.fromEntries(Array.from(c.getAttributes()).filter(([t]) => n.includes(t)))
            const d = getListItemBlocks(c, { direction: 'forward' })
            for (const t of d) {
              i.add(t)
              if (r(t, d)) {
                o.push(t)
              } else if (s(t, a, e)) {
                o.push(t)
              }
            }
          }
          return o
        }
        function r(t, o) {
          if (!t.is('element', 'paragraph')) {
            return false
          }
          const i = e.mapper.toViewElement(t)
          if (!i) {
            return false
          }
          const r = lV(t, n, o)
          if (r && i.is('element', 'p')) {
            return true
          } else if (!r && i.is('element', 'span')) {
            return true
          }
          return false
        }
        function s(t, n, i) {
          if (i.has(t)) {
            return false
          }
          const r = e.mapper.toViewElement(t)
          let s = n.length - 1
          for (let t = r.parent; !t.is('editableElement'); t = t.parent) {
            const e = isListItemView(t)
            const i = isListView(t)
            if (!i && !e) {
              continue
            }
            const r = `checkAttributes:${e ? 'item' : 'list'}`
            const a = o.fire(r, { viewElement: t, modelAttributes: n[s] })
            if (a) {
              break
            }
            if (i) {
              s--
              if (s < 0) {
                return false
              }
            }
          }
          return true
        }
      }
      function oV(t, e, n) {
        const o = cV(t)
        return (i, r, s) => {
          const { writer: a, mapper: c, consumable: l } = s
          const d = r.item
          if (!t.includes(r.attributeKey)) {
            return
          }
          if (!o(d, l)) {
            return
          }
          const u = rV(d, c, n)
          sV(u, a)
          aV(d, a.createRangeOn(u), e, a)
        }
      }
      function iV(t, { dataPipeline: e } = {}) {
        return (n, { writer: o }) => {
          if (!lV(n, t)) {
            return null
          }
          if (!e) {
            return o.createContainerElement('span', { class: 'ck-list-bogus-paragraph' })
          }
          const i = o.createContainerElement('p')
          o.setCustomProperty('dataPipeline:transparentRendering', true, i)
          return i
        }
      }
      function rV(t, e, n) {
        const o = n.createRangeOn(t)
        const i = e.toViewRange(o).getTrimmed()
        return i.getContainedElement()
      }
      function sV(t, e) {
        let n = t.parent
        while (n.is('attributeElement') && ['ul', 'ol', 'li'].includes(n.name)) {
          const o = n.parent
          e.unwrap(e.createRangeOn(t), n)
          n = o
        }
      }
      function aV(t, e, n, o) {
        if (!t.hasAttribute('listIndent')) {
          return
        }
        const i = t.getAttribute('listIndent')
        let r = t
        for (let t = i; t >= 0; t--) {
          const i = createListItemElement(o, t, r.getAttribute('listItemId'))
          const s = createListElement(o, t, r.getAttribute('listType'))
          for (const t of n) {
            if (r.hasAttribute(t.attributeName)) {
              t.setAttributeOnDowncast(o, r.getAttribute(t.attributeName), t.scope == 'list' ? s : i)
            }
          }
          e = o.wrap(e, i)
          e = o.wrap(e, s)
          if (t == 0) {
            break
          }
          r = ListWalker.first(r, { lowerIndent: true })
          if (!r) {
            break
          }
        }
      }
      function cV(t) {
        return (e, n) => {
          const o = []
          for (const n of t) {
            if (e.hasAttribute(n)) {
              o.push(`attribute:${n}`)
            }
          }
          if (!o.every((t) => n.test(e, t) !== false)) {
            return false
          }
          o.forEach((t) => n.consume(e, t))
          return true
        }
      }
      function lV(t, e, n = getAllListItemBlocks(t)) {
        if (!isListItemBlock(t)) {
          return false
        }
        for (const n of t.getAttributeKeys()) {
          if (n.startsWith('selection:')) {
            continue
          }
          if (!e.includes(n)) {
            return false
          }
        }
        return n.length < 2
      }
      var dV = n(3190)
      var uV = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      uV.insert = 'head'
      uV.singleton = true
      var hV = Rl()(dV.Z, uV)
      const gV = dV.Z.locals || {}
      var fV = n(4784)
      var mV = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      mV.insert = 'head'
      mV.singleton = true
      var pV = Rl()(fV.Z, mV)
      const bV = fV.Z.locals || {}
      const kV = null && ['listType', 'listIndent', 'listItemId']
      class wV extends (null && Plugin) {
        constructor() {
          super(...arguments)
          this._downcastStrategies = []
        }
        static get pluginName() {
          return 'DocumentListEditing'
        }
        static get requires() {
          return [Enter, Delete, DocumentListUtils]
        }
        init() {
          const t = this.editor
          const e = t.model
          if (t.plugins.has('ListEditing')) {
            throw new CKEditorError('document-list-feature-conflict', this, { conflictPlugin: 'ListEditing' })
          }
          e.schema.extend('$container', { allowAttributes: kV })
          e.schema.extend('$block', { allowAttributes: kV })
          e.schema.extend('$blockObject', { allowAttributes: kV })
          for (const t of kV) {
            e.schema.setAttributeProperties(t, { copyOnReplace: true })
          }
          t.commands.add('numberedList', new DocumentListCommand(t, 'numbered'))
          t.commands.add('bulletedList', new DocumentListCommand(t, 'bulleted'))
          t.commands.add('indentList', new DocumentListIndentCommand(t, 'forward'))
          t.commands.add('outdentList', new DocumentListIndentCommand(t, 'backward'))
          t.commands.add('mergeListItemBackward', new DocumentListMergeCommand(t, 'backward'))
          t.commands.add('mergeListItemForward', new DocumentListMergeCommand(t, 'forward'))
          t.commands.add('splitListItemBefore', new DocumentListSplitCommand(t, 'before'))
          t.commands.add('splitListItemAfter', new DocumentListSplitCommand(t, 'after'))
          this._setupDeleteIntegration()
          this._setupEnterIntegration()
          this._setupTabIntegration()
          this._setupClipboardIntegration()
        }
        afterInit() {
          const t = this.editor
          const e = t.commands
          const n = e.get('indent')
          const o = e.get('outdent')
          if (n) {
            n.registerChildCommand(e.get('indentList'), { priority: 'high' })
          }
          if (o) {
            o.registerChildCommand(e.get('outdentList'), { priority: 'lowest' })
          }
          this._setupModelPostFixing()
          this._setupConversion()
        }
        registerDowncastStrategy(t) {
          this._downcastStrategies.push(t)
        }
        _getListAttributeNames() {
          return [...kV, ...this._downcastStrategies.map((t) => t.attributeName)]
        }
        _setupDeleteIntegration() {
          const t = this.editor
          const e = t.commands.get('mergeListItemBackward')
          const n = t.commands.get('mergeListItemForward')
          this.listenTo(
            t.editing.view.document,
            'delete',
            (o, i) => {
              const r = t.model.document.selection
              if (getSelectedBlockObject(t.model)) {
                return
              }
              t.model.change(() => {
                const s = r.getFirstPosition()
                if (r.isCollapsed && i.direction == 'backward') {
                  if (!s.isAtStart) {
                    return
                  }
                  const n = s.parent
                  if (!isListItemBlock(n)) {
                    return
                  }
                  const r = ListWalker.first(n, { sameAttributes: 'listType', sameIndent: true })
                  if (!r && n.getAttribute('listIndent') === 0) {
                    if (!isLastBlockOfListItem(n)) {
                      t.execute('splitListItemAfter')
                    }
                    t.execute('outdentList')
                  } else {
                    if (!e.isEnabled) {
                      return
                    }
                    e.execute({ shouldMergeOnBlocksContentLevel: CV(t.model, 'backward') })
                  }
                  i.preventDefault()
                  o.stop()
                } else {
                  if (r.isCollapsed && !r.getLastPosition().isAtEnd) {
                    return
                  }
                  if (!n.isEnabled) {
                    return
                  }
                  n.execute({ shouldMergeOnBlocksContentLevel: CV(t.model, 'forward') })
                  i.preventDefault()
                  o.stop()
                }
              })
            },
            { context: 'li' },
          )
        }
        _setupEnterIntegration() {
          const t = this.editor
          const e = t.model
          const n = t.commands
          const o = n.get('enter')
          this.listenTo(
            t.editing.view.document,
            'enter',
            (n, o) => {
              const i = e.document
              const r = i.selection.getFirstPosition().parent
              if (i.selection.isCollapsed && isListItemBlock(r) && r.isEmpty && !o.isSoft) {
                const e = isFirstBlockOfListItem(r)
                const i = isLastBlockOfListItem(r)
                if (e && i) {
                  t.execute('outdentList')
                  o.preventDefault()
                  n.stop()
                } else if (e && !i) {
                  t.execute('splitListItemAfter')
                  o.preventDefault()
                  n.stop()
                } else if (i) {
                  t.execute('splitListItemBefore')
                  o.preventDefault()
                  n.stop()
                }
              }
            },
            { context: 'li' },
          )
          this.listenTo(o, 'afterExecute', () => {
            const e = n.get('splitListItemBefore')
            e.refresh()
            if (!e.isEnabled) {
              return
            }
            const o = t.model.document
            const i = o.selection.getLastPosition().parent
            const r = getAllListItemBlocks(i)
            if (r.length === 2) {
              e.execute()
            }
          })
        }
        _setupTabIntegration() {
          const t = this.editor
          this.listenTo(
            t.editing.view.document,
            'tab',
            (e, n) => {
              const o = n.shiftKey ? 'outdentList' : 'indentList'
              const i = this.editor.commands.get(o)
              if (i.isEnabled) {
                t.execute(o)
                n.stopPropagation()
                n.preventDefault()
                e.stop()
              }
            },
            { context: 'li' },
          )
        }
        _setupConversion() {
          const t = this.editor
          const e = t.model
          const n = this._getListAttributeNames()
          t.conversion
            .for('upcast')
            .elementToElement({ view: 'li', model: 'paragraph' })
            .add((t) => {
              t.on('element:li', listItemUpcastConverter())
              t.on('element:ul', listUpcastCleanList(), { priority: 'high' })
              t.on('element:ol', listUpcastCleanList(), { priority: 'high' })
            })
          t.conversion
            .for('editingDowncast')
            .elementToElement({ model: 'paragraph', view: bogusParagraphCreator(n), converterPriority: 'high' })
          t.conversion
            .for('dataDowncast')
            .elementToElement({
              model: 'paragraph',
              view: bogusParagraphCreator(n, { dataPipeline: true }),
              converterPriority: 'high',
            })
          t.conversion.for('downcast').add((t) => {
            t.on('attribute', listItemDowncastConverter(n, this._downcastStrategies, e))
          })
          this.listenTo(e.document, 'change:data', reconvertItemsOnDataChange(e, t.editing, n, this), {
            priority: 'high',
          })
          this.on('checkAttributes:item', (t, { viewElement: e, modelAttributes: n }) => {
            if (e.id != n.listItemId) {
              t.return = true
              t.stop()
            }
          })
          this.on('checkAttributes:list', (t, { viewElement: e, modelAttributes: n }) => {
            if (
              e.name != getViewElementNameForListType(n.listType) ||
              e.id != getViewElementIdForListType(n.listType, n.listIndent)
            ) {
              t.return = true
              t.stop()
            }
          })
        }
        _setupModelPostFixing() {
          const t = this.editor.model
          const e = this._getListAttributeNames()
          t.document.registerPostFixer((n) => AV(t, n, e, this))
          this.on(
            'postFixer',
            (t, { listNodes: e, writer: n }) => {
              t.return = fixListIndents(e, n) || t.return
            },
            { priority: 'high' },
          )
          this.on(
            'postFixer',
            (t, { listNodes: e, writer: n, seenIds: o }) => {
              t.return = fixListItemIds(e, o, n) || t.return
            },
            { priority: 'high' },
          )
        }
        _setupClipboardIntegration() {
          const t = this.editor.model
          this.listenTo(t, 'insertContent', _V(t), { priority: 'high' })
          this.listenTo(t, 'getSelectedContent', (e, [n]) => {
            const o = isSingleListItem(Array.from(n.getSelectedBlocks()))
            if (o) {
              t.change((t) => removeListAttributes(Array.from(e.return.getChildren()), t))
            }
          })
        }
      }
      function AV(t, e, n, o) {
        const i = t.document.differ.getChanges()
        const r = new Map()
        let s = false
        for (const o of i) {
          if (o.type == 'insert' && o.name != '$text') {
            const i = o.position.nodeAfter
            if (!t.schema.checkAttribute(i, 'listItemId')) {
              for (const t of Array.from(i.getAttributeKeys())) {
                if (n.includes(t)) {
                  e.removeAttribute(t, i)
                  s = true
                }
              }
            }
            findAndAddListHeadToMap(o.position, r)
            if (!o.attributes.has('listItemId')) {
              findAndAddListHeadToMap(o.position.getShiftedBy(o.length), r)
            }
            for (const { item: e, previousPosition: n } of t.createRangeIn(i)) {
              if (isListItemBlock(e)) {
                findAndAddListHeadToMap(n, r)
              }
            }
          } else if (o.type == 'remove') {
            findAndAddListHeadToMap(o.position, r)
          } else if (o.type == 'attribute' && n.includes(o.attributeKey)) {
            findAndAddListHeadToMap(o.range.start, r)
            if (o.attributeNewValue === null) {
              findAndAddListHeadToMap(o.range.start.getShiftedBy(1), r)
            }
          }
        }
        const a = new Set()
        for (const t of r.values()) {
          s = o.fire('postFixer', { listNodes: new ListBlocksIterable(t), listHead: t, writer: e, seenIds: a }) || s
        }
        return s
      }
      function _V(t) {
        return (e, [n, o]) => {
          const i = n.is('documentFragment') ? n.getChild(0) : n
          if (!isListItemBlock(i)) {
            return
          }
          let r
          if (!o) {
            r = t.document.selection
          } else {
            r = t.createSelection(o)
          }
          const s = r.getFirstPosition()
          let a = null
          if (isListItemBlock(s.parent)) {
            a = s.parent
          } else if (isListItemBlock(s.nodeBefore)) {
            a = s.nodeBefore
          }
          if (!a) {
            return
          }
          const c = a.getAttribute('listIndent') - i.getAttribute('listIndent')
          if (c <= 0) {
            return
          }
          t.change((t) => {
            for (const { node: e } of iterateSiblingListBlocks(i, 'forward')) {
              t.setAttribute('listIndent', e.getAttribute('listIndent') + c, e)
            }
          })
        }
      }
      function CV(t, e) {
        const n = t.document.selection
        if (!n.isCollapsed) {
          return !getSelectedBlockObject(t)
        }
        if (e === 'forward') {
          return true
        }
        const o = n.getFirstPosition()
        const i = o.parent
        const r = i.previousSibling
        if (t.schema.isObject(r)) {
          return false
        }
        if (r.isEmpty) {
          return true
        }
        return isSingleListItem([i, r])
      }
      function vV(t) {
        const e = t.createContainerElement('li')
        e.getFillerOffset = zV
        return e
      }
      function yV(t, e) {
        const n = e.mapper
        const o = e.writer
        const i = t.getAttribute('listType') == 'numbered' ? 'ol' : 'ul'
        const r = vV(o)
        const s = o.createContainerElement(i, null)
        o.insert(o.createPositionAt(s, 0), r)
        n.bindElements(t, r)
        return r
      }
      function xV(t, e, n, o) {
        const i = e.parent
        const r = n.mapper
        const s = n.writer
        let a = r.toViewPosition(o.createPositionBefore(t))
        const c = TV(t.previousSibling, {
          sameIndent: true,
          smallerIndent: true,
          listIndent: t.getAttribute('listIndent'),
        })
        const l = t.previousSibling
        if (c && c.getAttribute('listIndent') == t.getAttribute('listIndent')) {
          const t = r.toViewElement(c)
          a = s.breakContainer(s.createPositionAfter(t))
        } else {
          if (l && l.name == 'listItem') {
            a = r.toViewPosition(o.createPositionAt(l, 'end'))
            const t = r.findMappedViewAncestor(a)
            const e = SV(t)
            if (e) {
              a = s.createPositionBefore(e)
            } else {
              a = s.createPositionAt(t, 'end')
            }
          } else {
            a = r.toViewPosition(o.createPositionBefore(t))
          }
        }
        a = DV(a)
        s.insert(a, i)
        if (l && l.name == 'listItem') {
          const t = r.toViewElement(l)
          const n = s.createRange(s.createPositionAt(t, 0), a)
          const o = n.getWalker({ ignoreElementEnd: true })
          for (const t of o) {
            if (t.item.is('element', 'li')) {
              const n = s.breakContainer(s.createPositionBefore(t.item))
              const i = t.item.parent
              const r = s.createPositionAt(e, 'end')
              EV(s, r.nodeBefore, r.nodeAfter)
              s.move(s.createRangeOn(i), r)
              o._position = n
            }
          }
        } else {
          const n = i.nextSibling
          if (n && (n.is('element', 'ul') || n.is('element', 'ol'))) {
            let o = null
            for (const e of n.getChildren()) {
              const n = r.toModelElement(e)
              if (n && n.getAttribute('listIndent') > t.getAttribute('listIndent')) {
                o = e
              } else {
                break
              }
            }
            if (o) {
              s.breakContainer(s.createPositionAfter(o))
              s.move(s.createRangeOn(o.parent), s.createPositionAt(e, 'end'))
            }
          }
        }
        EV(s, i, i.nextSibling)
        EV(s, i.previousSibling, i)
      }
      function EV(t, e, n) {
        if (!e || !n || (e.name != 'ul' && e.name != 'ol')) {
          return null
        }
        if (e.name != n.name || e.getAttribute('class') !== n.getAttribute('class')) {
          return null
        }
        return t.mergeContainers(t.createPositionAfter(e))
      }
      function DV(t) {
        return t.getLastMatchingPosition((t) => t.item.is('uiElement'))
      }
      function TV(t, e) {
        const n = !!e.sameIndent
        const o = !!e.smallerIndent
        const i = e.listIndent
        let r = t
        while (r && r.name == 'listItem') {
          const t = r.getAttribute('listIndent')
          if ((n && i == t) || (o && i > t)) {
            return r
          }
          if (e.direction === 'forward') {
            r = r.nextSibling
          } else {
            r = r.previousSibling
          }
        }
        return null
      }
      function IV(t, e, n, o) {
        t.ui.componentFactory.add(e, (i) => {
          const r = t.commands.get(e)
          const s = new Dd(i)
          s.set({ label: n, icon: o, tooltip: true, isToggleable: true })
          s.bind('isOn', 'isEnabled').to(r, 'value', 'isEnabled')
          s.on('execute', () => {
            t.execute(e)
            t.editing.view.focus()
          })
          return s
        })
      }
      function SV(t) {
        for (const e of t.getChildren()) {
          if (e.name == 'ul' || e.name == 'ol') {
            return e
          }
        }
        return null
      }
      function MV(t, e) {
        const n = []
        const o = t.parent
        const i = { ignoreElementEnd: false, startPosition: t, shallow: true, direction: e }
        const r = o.getAttribute('listIndent')
        const s = [...new xb(i)].filter((t) => t.item.is('element')).map((t) => t.item)
        for (const t of s) {
          if (!t.is('element', 'listItem')) {
            break
          }
          if (t.getAttribute('listIndent') < r) {
            break
          }
          if (t.getAttribute('listIndent') > r) {
            continue
          }
          if (t.getAttribute('listType') !== o.getAttribute('listType')) {
            break
          }
          if (t.getAttribute('listStyle') !== o.getAttribute('listStyle')) {
            break
          }
          if (t.getAttribute('listReversed') !== o.getAttribute('listReversed')) {
            break
          }
          if (t.getAttribute('listStart') !== o.getAttribute('listStart')) {
            break
          }
          if (e === 'backward') {
            n.unshift(t)
          } else {
            n.push(t)
          }
        }
        return n
      }
      function BV(t) {
        const e = t.document
        let n = [...e.selection.getSelectedBlocks()]
          .filter((t) => t.is('element', 'listItem'))
          .map((e) => {
            const n = t.change((t) => t.createPositionAt(e, 0))
            return [...MV(n, 'backward'), ...MV(n, 'forward')]
          })
          .flat()
        n = [...new Set(n)]
        return n
      }
      const NV = ['disc', 'circle', 'square']
      const PV = ['decimal', 'decimal-leading-zero', 'lower-roman', 'upper-roman', 'lower-latin', 'upper-latin']
      function LV(t) {
        if (NV.includes(t)) {
          return 'bulleted'
        }
        if (PV.includes(t)) {
          return 'numbered'
        }
        return null
      }
      function zV() {
        const t = !this.isEmpty && (this.getChild(0).name == 'ul' || this.getChild(0).name == 'ol')
        if (this.isEmpty || t) {
          return 0
        }
        return rf.call(this)
      }
      const RV =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM3.5 3v5H2V3.7H1v-1h2.5V3zM.343 17.857l2.59-3.257H2.92a.6.6 0 1 0-1.04 0H.302a2 2 0 1 1 3.995 0h-.001c-.048.405-.16.734-.333.988-.175.254-.59.692-1.244 1.312H4.3v1h-4l.043-.043zM7 14.75a.75.75 0 0 1 .75-.75h9.5a.75.75 0 1 1 0 1.5h-9.5a.75.75 0 0 1-.75-.75z"/></svg>'
      const OV =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0C1 4.784 1.777 4 2.75 4c.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75C1.784 7.5 1 6.723 1 5.75zm6 9c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0c0-.966.777-1.75 1.75-1.75.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75-.966 0-1.75-.777-1.75-1.75z"/></svg>'
      class VV extends Du {
        static get pluginName() {
          return 'ListUI'
        }
        init() {
          const t = this.editor.t
          IV(this.editor, 'numberedList', t('Numbered List'), RV)
          IV(this.editor, 'bulletedList', t('Bulleted List'), OV)
        }
      }
      class FV extends (null && Plugin) {
        static get requires() {
          return [DocumentListEditing, ListUI]
        }
        static get pluginName() {
          return 'DocumentList'
        }
      }
      class jV extends (null && Plugin) {
        static get pluginName() {
          return 'AdjacentListsSupport'
        }
        init() {
          const t = this.editor
          const e = t.model
          e.schema.register('listSeparator', { allowWhere: '$block', isBlock: true })
          t.conversion
            .for('upcast')
            .add((t) => {
              t.on('element:ol', HV())
              t.on('element:ul', HV())
            })
            .elementToElement({ model: 'listSeparator', view: 'ck-list-separator' })
          t.conversion
            .for('editingDowncast')
            .elementToElement({
              model: 'listSeparator',
              view: { name: 'div', classes: ['ck-list-separator', 'ck-hidden'] },
            })
          t.conversion.for('dataDowncast').elementToElement({
            model: 'listSeparator',
            view: (t, e) => {
              const n = e.writer.createContainerElement('ck-list-separator')
              e.writer.setCustomProperty('dataPipeline:transparentRendering', true, n)
              n.getFillerOffset = () => null
              return n
            },
          })
        }
      }
      function HV() {
        return (t, e, n) => {
          const o = e.viewItem
          const i = o.nextSibling
          if (!i) {
            return
          }
          if (o.name !== i.name) {
            return
          }
          if (!e.modelRange) {
            Object.assign(e, n.convertChildren(e.viewItem, e.modelCursor))
          }
          const r = n.writer
          const s = r.createElement('listSeparator')
          if (!n.safeInsert(s, e.modelCursor)) {
            return
          }
          const a = n.getSplitParts(s)
          e.modelRange = r.createRange(e.modelRange.start, r.createPositionAfter(a[a.length - 1]))
          n.updateConversionResult(s, e)
        }
      }
      class UV extends (null && Command) {
        refresh() {
          const t = this._getValue()
          this.value = t
          this.isEnabled = t != null
        }
        execute({ startIndex: t = 1 } = {}) {
          const e = this.editor.model
          const n = e.document
          let o = Array.from(n.selection.getSelectedBlocks()).filter(
            (t) => isListItemBlock(t) && t.getAttribute('listType') == 'numbered',
          )
          o = expandListBlocksToCompleteList(o)
          e.change((e) => {
            for (const n of o) {
              e.setAttribute('listStart', t >= 0 ? t : 1, n)
            }
          })
        }
        _getValue() {
          const t = this.editor.model
          const e = t.document
          const n = first(e.selection.getSelectedBlocks())
          if (n && isListItemBlock(n) && n.getAttribute('listType') == 'numbered') {
            return n.getAttribute('listStart')
          }
          return null
        }
      }
      const WV = {}
      const GV = {}
      const qV = {}
      const $V = [
        { listStyle: 'disc', typeAttribute: 'disc', listType: 'bulleted' },
        { listStyle: 'circle', typeAttribute: 'circle', listType: 'bulleted' },
        { listStyle: 'square', typeAttribute: 'square', listType: 'bulleted' },
        { listStyle: 'decimal', typeAttribute: '1', listType: 'numbered' },
        { listStyle: 'decimal-leading-zero', typeAttribute: null, listType: 'numbered' },
        { listStyle: 'lower-roman', typeAttribute: 'i', listType: 'numbered' },
        { listStyle: 'upper-roman', typeAttribute: 'I', listType: 'numbered' },
        { listStyle: 'lower-alpha', typeAttribute: 'a', listType: 'numbered' },
        { listStyle: 'upper-alpha', typeAttribute: 'A', listType: 'numbered' },
        { listStyle: 'lower-latin', typeAttribute: 'a', listType: 'numbered' },
        { listStyle: 'upper-latin', typeAttribute: 'A', listType: 'numbered' },
      ]
      for (const { listStyle: t, typeAttribute: e, listType: n } of $V) {
        WV[t] = n
        GV[t] = e
        if (e) {
          qV[e] = t
        }
      }
      function KV() {
        return $V.map((t) => t.listStyle)
      }
      function YV(t) {
        return WV[t] || null
      }
      function ZV(t) {
        return qV[t] || null
      }
      function QV(t) {
        return GV[t] || null
      }
      class JV extends (null && Command) {
        constructor(t, e, n) {
          super(t)
          this.defaultType = e
          this._supportedTypes = n
        }
        refresh() {
          this.value = this._getValue()
          this.isEnabled = this._checkEnabled()
        }
        execute(t = {}) {
          const e = this.editor.model
          const n = e.document
          e.change((e) => {
            this._tryToConvertItemsToList(t)
            let o = Array.from(n.selection.getSelectedBlocks()).filter((t) => t.hasAttribute('listType'))
            if (!o.length) {
              return
            }
            o = expandListBlocksToCompleteList(o)
            for (const n of o) {
              e.setAttribute('listStyle', t.type || this.defaultType, n)
            }
          })
        }
        isStyleTypeSupported(t) {
          if (!this._supportedTypes) {
            return true
          }
          return this._supportedTypes.includes(t)
        }
        _getValue() {
          const t = first(this.editor.model.document.selection.getSelectedBlocks())
          if (isListItemBlock(t)) {
            return t.getAttribute('listStyle')
          }
          return null
        }
        _checkEnabled() {
          const t = this.editor
          const e = t.commands.get('numberedList')
          const n = t.commands.get('bulletedList')
          return e.isEnabled || n.isEnabled
        }
        _tryToConvertItemsToList(t) {
          if (!t.type) {
            return
          }
          const e = getListTypeFromListStyleType(t.type)
          if (!e) {
            return
          }
          const n = this.editor
          const o = `${e}List`
          const i = n.commands.get(o)
          if (!i.value) {
            n.execute(o)
          }
        }
      }
      class XV extends (null && Command) {
        refresh() {
          const t = this._getValue()
          this.value = t
          this.isEnabled = t != null
        }
        execute(t = {}) {
          const e = this.editor.model
          const n = e.document
          let o = Array.from(n.selection.getSelectedBlocks()).filter(
            (t) => isListItemBlock(t) && t.getAttribute('listType') == 'numbered',
          )
          o = expandListBlocksToCompleteList(o)
          e.change((e) => {
            for (const n of o) {
              e.setAttribute('listReversed', !!t.reversed, n)
            }
          })
        }
        _getValue() {
          const t = this.editor.model
          const e = t.document
          const n = first(e.selection.getSelectedBlocks())
          if (isListItemBlock(n) && n.getAttribute('listType') == 'numbered') {
            return n.getAttribute('listReversed')
          }
          return null
        }
      }
      class tF extends (null && Plugin) {
        static get pluginName() {
          return 'DocumentListPropertiesUtils'
        }
        getAllSupportedStyleTypes() {
          return getAllSupportedStyleTypes()
        }
        getListTypeFromListStyleType(t) {
          return getListTypeFromListStyleType(t)
        }
        getListStyleTypeFromTypeAttribute(t) {
          return getListStyleTypeFromTypeAttribute(t)
        }
        getTypeAttributeFromListStyleType(t) {
          return getTypeAttributeFromListStyleType(t)
        }
      }
      const eF = 'default'
      class nF extends (null && Plugin) {
        static get requires() {
          return [DocumentListEditing, DocumentListPropertiesUtils]
        }
        static get pluginName() {
          return 'DocumentListPropertiesEditing'
        }
        constructor(t) {
          super(t)
          t.config.define('list', { properties: { styles: true, startIndex: false, reversed: false } })
        }
        init() {
          const t = this.editor
          const e = t.model
          const n = t.plugins.get(DocumentListEditing)
          const o = t.config.get('list.properties')
          const i = oF(o)
          for (const o of i) {
            o.addCommand(t)
            e.schema.extend('$container', { allowAttributes: o.attributeName })
            e.schema.extend('$block', { allowAttributes: o.attributeName })
            e.schema.extend('$blockObject', { allowAttributes: o.attributeName })
            n.registerDowncastStrategy({
              scope: 'list',
              attributeName: o.attributeName,
              setAttributeOnDowncast(t, e, n) {
                o.setAttributeOnDowncast(t, e, n)
              },
            })
          }
          t.conversion.for('upcast').add((t) => {
            for (const e of i) {
              t.on('element:ol', listPropertiesUpcastConverter(e))
              t.on('element:ul', listPropertiesUpcastConverter(e))
            }
          })
          n.on('checkAttributes:list', (t, { viewElement: e, modelAttributes: n }) => {
            for (const o of i) {
              if (o.getAttributeOnUpcast(e) != n[o.attributeName]) {
                t.return = true
                t.stop()
              }
            }
          })
          this.listenTo(t.commands.get('indentList'), 'afterExecute', (t, n) => {
            e.change((t) => {
              for (const e of n) {
                for (const n of i) {
                  if (n.appliesToListItem(e)) {
                    t.setAttribute(n.attributeName, n.defaultValue, e)
                  }
                }
              }
            })
          })
          n.on('postFixer', (t, { listNodes: e, writer: n }) => {
            for (const { node: o } of e) {
              for (const e of i) {
                if (e.hasValidAttribute(o)) {
                  continue
                }
                if (e.appliesToListItem(o)) {
                  n.setAttribute(e.attributeName, e.defaultValue, o)
                } else {
                  n.removeAttribute(e.attributeName, o)
                }
                t.return = true
              }
            }
          })
          n.on('postFixer', (t, { listNodes: e, writer: n }) => {
            const o = []
            for (const { node: r, previous: s } of e) {
              if (!s) {
                continue
              }
              const e = r.getAttribute('listIndent')
              const a = s.getAttribute('listIndent')
              let c = null
              if (e > a) {
                o[a] = s
              } else if (e < a) {
                c = o[e]
                o.length = e
              } else {
                c = s
              }
              if (!c) {
                continue
              }
              if (c.getAttribute('listType') != r.getAttribute('listType')) {
                continue
              }
              for (const e of i) {
                const { attributeName: o } = e
                if (!e.appliesToListItem(r)) {
                  continue
                }
                const i = c.getAttribute(o)
                if (r.getAttribute(o) != i) {
                  n.setAttribute(o, i, r)
                  t.return = true
                }
              }
            }
          })
        }
      }
      function oF(t) {
        const e = []
        if (t.styles) {
          const n = typeof t.styles == 'object' && t.styles.useAttribute
          e.push({
            attributeName: 'listStyle',
            defaultValue: eF,
            viewConsumables: { styles: 'list-style-type' },
            addCommand(t) {
              let e = getAllSupportedStyleTypes()
              if (n) {
                e = e.filter((t) => !!getTypeAttributeFromListStyleType(t))
              }
              t.commands.add('listStyle', new DocumentListStyleCommand(t, eF, e))
            },
            appliesToListItem() {
              return true
            },
            hasValidAttribute(t) {
              if (!t.hasAttribute('listStyle')) {
                return false
              }
              const e = t.getAttribute('listStyle')
              if (e == eF) {
                return true
              }
              return getListTypeFromListStyleType(e) == t.getAttribute('listType')
            },
            setAttributeOnDowncast(t, e, o) {
              if (e && e !== eF) {
                if (n) {
                  const n = getTypeAttributeFromListStyleType(e)
                  if (n) {
                    t.setAttribute('type', n, o)
                    return
                  }
                } else {
                  t.setStyle('list-style-type', e, o)
                  return
                }
              }
              t.removeStyle('list-style-type', o)
              t.removeAttribute('type', o)
            },
            getAttributeOnUpcast(t) {
              const e = t.getStyle('list-style-type')
              if (e) {
                return e
              }
              const n = t.getAttribute('type')
              if (n) {
                return getListStyleTypeFromTypeAttribute(n)
              }
              return eF
            },
          })
        }
        if (t.reversed) {
          e.push({
            attributeName: 'listReversed',
            defaultValue: false,
            viewConsumables: { attributes: 'reversed' },
            addCommand(t) {
              t.commands.add('listReversed', new DocumentListReversedCommand(t))
            },
            appliesToListItem(t) {
              return t.getAttribute('listType') == 'numbered'
            },
            hasValidAttribute(t) {
              return this.appliesToListItem(t) == t.hasAttribute('listReversed')
            },
            setAttributeOnDowncast(t, e, n) {
              if (e) {
                t.setAttribute('reversed', 'reversed', n)
              } else {
                t.removeAttribute('reversed', n)
              }
            },
            getAttributeOnUpcast(t) {
              return t.hasAttribute('reversed')
            },
          })
        }
        if (t.startIndex) {
          e.push({
            attributeName: 'listStart',
            defaultValue: 1,
            viewConsumables: { attributes: 'start' },
            addCommand(t) {
              t.commands.add('listStart', new DocumentListStartCommand(t))
            },
            appliesToListItem(t) {
              return t.getAttribute('listType') == 'numbered'
            },
            hasValidAttribute(t) {
              return this.appliesToListItem(t) == t.hasAttribute('listStart')
            },
            setAttributeOnDowncast(t, e, n) {
              if (e == 0 || e > 1) {
                t.setAttribute('start', e, n)
              } else {
                t.removeAttribute('start', n)
              }
            },
            getAttributeOnUpcast(t) {
              const e = t.getAttribute('start')
              return e >= 0 ? e : 1
            },
          })
        }
        return e
      }
      var iF = n(5782)
      var rF = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      rF.insert = 'head'
      rF.singleton = true
      var sF = Rl()(iF.Z, rF)
      const aF = iF.Z.locals || {}
      class cF extends (null && View) {
        constructor(t, e) {
          super(t)
          const n = this.bindTemplate
          this.set('isCollapsed', false)
          this.set('label', '')
          this.buttonView = this._createButtonView()
          this.children = this.createCollection()
          this.set('_collapsibleAriaLabelUid', undefined)
          if (e) {
            this.children.addMany(e)
          }
          this.setTemplate({
            tag: 'div',
            attributes: { class: ['ck', 'ck-collapsible', n.if('isCollapsed', 'ck-collapsible_collapsed')] },
            children: [
              this.buttonView,
              {
                tag: 'div',
                attributes: {
                  class: ['ck', 'ck-collapsible__children'],
                  role: 'region',
                  hidden: n.if('isCollapsed', 'hidden'),
                  'aria-labelledby': n.to('_collapsibleAriaLabelUid'),
                },
                children: this.children,
              },
            ],
          })
        }
        render() {
          super.render()
          this._collapsibleAriaLabelUid = this.buttonView.labelView.element.id
        }
        _createButtonView() {
          const t = new ButtonView(this.locale)
          const e = t.bindTemplate
          t.set({ withText: true, icon: dropdownArrowIcon })
          t.extendTemplate({ attributes: { 'aria-expanded': e.to('isOn', (t) => String(t)) } })
          t.bind('label').to(this)
          t.bind('isOn').to(this, 'isCollapsed', (t) => !t)
          t.on('execute', () => {
            this.isCollapsed = !this.isCollapsed
          })
          return t
        }
      }
      var lF = n(9938)
      var dF = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      dF.insert = 'head'
      dF.singleton = true
      var uF = Rl()(lF.Z, dF)
      const hF = lF.Z.locals || {}
      class gF extends (null && View) {
        constructor(t, { enabledProperties: e, styleButtonViews: n, styleGridAriaLabel: o }) {
          super(t)
          this.stylesView = null
          this.additionalPropertiesCollapsibleView = null
          this.startIndexFieldView = null
          this.reversedSwitchButtonView = null
          this.focusTracker = new FocusTracker()
          this.keystrokes = new KeystrokeHandler()
          this.focusables = new ViewCollection()
          const i = ['ck', 'ck-list-properties']
          this.children = this.createCollection()
          this.focusCycler = new FocusCycler({
            focusables: this.focusables,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: { focusPrevious: 'shift + tab', focusNext: 'tab' },
          })
          if (e.styles) {
            this.stylesView = this._createStylesView(n, o)
            this.children.add(this.stylesView)
          } else {
            i.push('ck-list-properties_without-styles')
          }
          if (e.startIndex || e.reversed) {
            this._addNumberedListPropertyViews(e)
            i.push('ck-list-properties_with-numbered-properties')
          }
          this.setTemplate({ tag: 'div', attributes: { class: i }, children: this.children })
        }
        render() {
          super.render()
          if (this.stylesView) {
            this.focusables.add(this.stylesView)
            this.focusTracker.add(this.stylesView.element)
            if (this.startIndexFieldView || this.reversedSwitchButtonView) {
              this.focusables.add(this.children.last.buttonView)
              this.focusTracker.add(this.children.last.buttonView.element)
            }
            for (const t of this.stylesView.children) {
              this.stylesView.focusTracker.add(t.element)
            }
            addKeyboardHandlingForGrid({
              keystrokeHandler: this.stylesView.keystrokes,
              focusTracker: this.stylesView.focusTracker,
              gridItems: this.stylesView.children,
              numberOfColumns: () =>
                global.window
                  .getComputedStyle(this.stylesView.element)
                  .getPropertyValue('grid-template-columns')
                  .split(' ').length,
              uiLanguageDirection: this.locale && this.locale.uiLanguageDirection,
            })
          }
          if (this.startIndexFieldView) {
            this.focusables.add(this.startIndexFieldView)
            this.focusTracker.add(this.startIndexFieldView.element)
            const t = (t) => t.stopPropagation()
            this.keystrokes.set('arrowright', t)
            this.keystrokes.set('arrowleft', t)
            this.keystrokes.set('arrowup', t)
            this.keystrokes.set('arrowdown', t)
          }
          if (this.reversedSwitchButtonView) {
            this.focusables.add(this.reversedSwitchButtonView)
            this.focusTracker.add(this.reversedSwitchButtonView.element)
          }
          this.keystrokes.listenTo(this.element)
        }
        focus() {
          this.focusCycler.focusFirst()
        }
        focusLast() {
          this.focusCycler.focusLast()
        }
        destroy() {
          super.destroy()
          this.focusTracker.destroy()
          this.keystrokes.destroy()
        }
        _createStylesView(t, e) {
          const n = new View(this.locale)
          n.children = n.createCollection()
          n.children.addMany(t)
          n.setTemplate({
            tag: 'div',
            attributes: { 'aria-label': e, class: ['ck', 'ck-list-styles-list'] },
            children: n.children,
          })
          n.children.delegate('execute').to(this)
          n.focus = function () {
            this.children.first.focus()
          }
          n.focusTracker = new FocusTracker()
          n.keystrokes = new KeystrokeHandler()
          n.render()
          n.keystrokes.listenTo(n.element)
          return n
        }
        _addNumberedListPropertyViews(t) {
          const e = this.locale.t
          const n = []
          if (t.startIndex) {
            this.startIndexFieldView = this._createStartIndexField()
            n.push(this.startIndexFieldView)
          }
          if (t.reversed) {
            this.reversedSwitchButtonView = this._createReversedSwitchButton()
            n.push(this.reversedSwitchButtonView)
          }
          if (t.styles) {
            this.additionalPropertiesCollapsibleView = new CollapsibleView(this.locale, n)
            this.additionalPropertiesCollapsibleView.set({ label: e('List properties'), isCollapsed: true })
            this.additionalPropertiesCollapsibleView.buttonView
              .bind('isEnabled')
              .toMany(n, 'isEnabled', (...t) => t.some((t) => t))
            this.additionalPropertiesCollapsibleView.buttonView.on('change:isEnabled', (t, e, n) => {
              if (!n) {
                this.additionalPropertiesCollapsibleView.isCollapsed = true
              }
            })
            this.children.add(this.additionalPropertiesCollapsibleView)
          } else {
            this.children.addMany(n)
          }
        }
        _createStartIndexField() {
          const t = this.locale.t
          const e = new LabeledFieldView(this.locale, createLabeledInputNumber)
          e.set({ label: t('Start at'), class: 'ck-numbered-list-properties__start-index' })
          e.fieldView.set({ min: 0, step: 1, value: 1, inputMode: 'numeric' })
          e.fieldView.on('input', () => {
            const n = e.fieldView.element
            const o = n.valueAsNumber
            if (Number.isNaN(o)) {
              return
            }
            if (!n.checkValidity()) {
              e.errorText = t('Start index must be greater than 0.')
            } else {
              this.fire('listStart', { startIndex: o })
            }
          })
          return e
        }
        _createReversedSwitchButton() {
          const t = this.locale.t
          const e = new SwitchButtonView(this.locale)
          e.set({ withText: true, label: t('Reversed order'), class: 'ck-numbered-list-properties__reversed-order' })
          e.delegate('execute').to(this, 'listReversed')
          return e
        }
      }
      var fF = n(2591)
      var mF = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      mF.insert = 'head'
      mF.singleton = true
      var pF = Rl()(fF.Z, mF)
      const bF = fF.Z.locals || {}
      class kF extends (null && Plugin) {
        static get pluginName() {
          return 'ListPropertiesUI'
        }
        init() {
          const t = this.editor
          const e = t.locale.t
          const n = t.config.get('list.properties')
          if (n.styles) {
            t.ui.componentFactory.add(
              'bulletedList',
              wF({
                editor: t,
                parentCommandName: 'bulletedList',
                buttonLabel: e('Bulleted List'),
                buttonIcon: bulletedListIcon,
                styleGridAriaLabel: e('Bulleted list styles toolbar'),
                styleDefinitions: [
                  { label: e('Toggle the disc list style'), tooltip: e('Disc'), type: 'disc', icon: listStyleDiscIcon },
                  {
                    label: e('Toggle the circle list style'),
                    tooltip: e('Circle'),
                    type: 'circle',
                    icon: listStyleCircleIcon,
                  },
                  {
                    label: e('Toggle the square list style'),
                    tooltip: e('Square'),
                    type: 'square',
                    icon: listStyleSquareIcon,
                  },
                ],
              }),
            )
          }
          if (n.styles || n.startIndex || n.reversed) {
            t.ui.componentFactory.add(
              'numberedList',
              wF({
                editor: t,
                parentCommandName: 'numberedList',
                buttonLabel: e('Numbered List'),
                buttonIcon: numberedListIcon,
                styleGridAriaLabel: e('Numbered list styles toolbar'),
                styleDefinitions: [
                  {
                    label: e('Toggle the decimal list style'),
                    tooltip: e('Decimal'),
                    type: 'decimal',
                    icon: listStyleDecimalIcon,
                  },
                  {
                    label: e('Toggle the decimal with leading zero list style'),
                    tooltip: e('Decimal with leading zero'),
                    type: 'decimal-leading-zero',
                    icon: listStyleDecimalWithLeadingZeroIcon,
                  },
                  {
                    label: e('Toggle the lower–roman list style'),
                    tooltip: e('Lower–roman'),
                    type: 'lower-roman',
                    icon: listStyleLowerRomanIcon,
                  },
                  {
                    label: e('Toggle the upper–roman list style'),
                    tooltip: e('Upper-roman'),
                    type: 'upper-roman',
                    icon: listStyleUpperRomanIcon,
                  },
                  {
                    label: e('Toggle the lower–latin list style'),
                    tooltip: e('Lower-latin'),
                    type: 'lower-latin',
                    icon: listStyleLowerLatinIcon,
                  },
                  {
                    label: e('Toggle the upper–latin list style'),
                    tooltip: e('Upper-latin'),
                    type: 'upper-latin',
                    icon: listStyleUpperLatinIcon,
                  },
                ],
              }),
            )
          }
        }
      }
      function wF({
        editor: t,
        parentCommandName: e,
        buttonLabel: n,
        buttonIcon: o,
        styleGridAriaLabel: i,
        styleDefinitions: r,
      }) {
        const s = t.commands.get(e)
        return (a) => {
          const c = createDropdown(a, SplitButtonView)
          const l = c.buttonView
          c.bind('isEnabled').to(s)
          c.class = 'ck-list-styles-dropdown'
          l.on('execute', () => {
            t.execute(e)
            t.editing.view.focus()
          })
          l.set({ label: n, icon: o, tooltip: true, isToggleable: true })
          l.bind('isOn').to(s, 'value', (t) => !!t)
          c.once('change:isOpen', () => {
            const n = _F({
              editor: t,
              dropdownView: c,
              parentCommandName: e,
              styleGridAriaLabel: i,
              styleDefinitions: r,
            })
            c.panelView.children.add(n)
          })
          c.on('execute', () => {
            t.editing.view.focus()
          })
          return c
        }
      }
      function AF({ editor: t, listStyleCommand: e, parentCommandName: n }) {
        const o = t.locale
        const i = t.commands.get(n)
        return ({ label: n, type: r, icon: s, tooltip: a }) => {
          const c = new ButtonView(o)
          c.set({ label: n, icon: s, tooltip: a })
          e.on('change:value', () => {
            c.isOn = e.value === r
          })
          c.on('execute', () => {
            if (i.value) {
              if (e.value !== r) {
                t.execute('listStyle', { type: r })
              } else {
                t.execute('listStyle', { type: e.defaultType })
              }
            } else {
              t.model.change(() => {
                t.execute('listStyle', { type: r })
              })
            }
          })
          return c
        }
      }
      function _F({ editor: t, dropdownView: e, parentCommandName: n, styleDefinitions: o, styleGridAriaLabel: i }) {
        const r = t.locale
        const s = t.config.get('list.properties')
        let a = null
        if (n != 'numberedList') {
          s.startIndex = false
          s.reversed = false
        }
        if (s.styles) {
          const e = t.commands.get('listStyle')
          const i = AF({ editor: t, parentCommandName: n, listStyleCommand: e })
          const r = typeof e.isStyleTypeSupported == 'function' ? (t) => e.isStyleTypeSupported(t.type) : () => true
          a = o.filter(r).map(i)
        }
        const c = new ListPropertiesView(r, { styleGridAriaLabel: i, enabledProperties: s, styleButtonViews: a })
        if (s.styles) {
          focusChildOnDropdownOpen(e, () => c.stylesView.children.find((t) => t.isOn))
        }
        if (s.startIndex) {
          const e = t.commands.get('listStart')
          c.startIndexFieldView.bind('isEnabled').to(e)
          c.startIndexFieldView.fieldView.bind('value').to(e)
          c.on('listStart', (e, n) => t.execute('listStart', n))
        }
        if (s.reversed) {
          const e = t.commands.get('listReversed')
          c.reversedSwitchButtonView.bind('isEnabled').to(e)
          c.reversedSwitchButtonView.bind('isOn').to(e, 'value', (t) => !!t)
          c.on('listReversed', () => {
            const n = e.value
            t.execute('listReversed', { reversed: !n })
          })
        }
        c.delegate('execute').to(e)
        return c
      }
      class CF extends (null && Plugin) {
        static get requires() {
          return [DocumentListPropertiesEditing, ListPropertiesUI]
        }
        static get pluginName() {
          return 'DocumentListProperties'
        }
      }
      class vF extends Iu {
        constructor(t, e) {
          super(t)
          this._indentBy = e == 'forward' ? 1 : -1
        }
        refresh() {
          this.isEnabled = this._checkEnabled()
        }
        execute() {
          const t = this.editor.model
          const e = t.document
          let n = Array.from(e.selection.getSelectedBlocks())
          t.change((t) => {
            const e = n[n.length - 1]
            let o = e.nextSibling
            while (o && o.name == 'listItem' && o.getAttribute('listIndent') > e.getAttribute('listIndent')) {
              n.push(o)
              o = o.nextSibling
            }
            if (this._indentBy < 0) {
              n = n.reverse()
            }
            for (const e of n) {
              const n = e.getAttribute('listIndent') + this._indentBy
              if (n < 0) {
                t.rename(e, 'paragraph')
              } else {
                t.setAttribute('listIndent', n, e)
              }
            }
            this.fire('_executeCleanup', n)
          })
        }
        _checkEnabled() {
          const t = bl(this.editor.model.document.selection.getSelectedBlocks())
          if (!t || !t.is('element', 'listItem')) {
            return false
          }
          if (this._indentBy > 0) {
            const e = t.getAttribute('listIndent')
            const n = t.getAttribute('listType')
            let o = t.previousSibling
            while (o && o.is('element', 'listItem') && o.getAttribute('listIndent') >= e) {
              if (o.getAttribute('listIndent') == e) {
                return o.getAttribute('listType') == n
              }
              o = o.previousSibling
            }
            return false
          }
          return true
        }
      }
      class yF extends Iu {
        constructor(t, e) {
          super(t)
          this.type = e
        }
        refresh() {
          this.value = this._getValue()
          this.isEnabled = this._checkEnabled()
        }
        execute(t = {}) {
          const e = this.editor.model
          const n = e.document
          const o = Array.from(n.selection.getSelectedBlocks()).filter((t) => EF(t, e.schema))
          const i = t.forceValue !== undefined ? !t.forceValue : this.value
          e.change((t) => {
            if (i) {
              let e = o[o.length - 1].nextSibling
              let n = Number.POSITIVE_INFINITY
              let i = []
              while (e && e.name == 'listItem' && e.getAttribute('listIndent') !== 0) {
                const t = e.getAttribute('listIndent')
                if (t < n) {
                  n = t
                }
                const o = t - n
                i.push({ element: e, listIndent: o })
                e = e.nextSibling
              }
              i = i.reverse()
              for (const e of i) {
                t.setAttribute('listIndent', e.listIndent, e.element)
              }
            }
            if (!i) {
              let t = Number.POSITIVE_INFINITY
              for (const e of o) {
                if (e.is('element', 'listItem') && e.getAttribute('listIndent') < t) {
                  t = e.getAttribute('listIndent')
                }
              }
              t = t === 0 ? 1 : t
              xF(o, true, t)
              xF(o, false, t)
            }
            for (const e of o.reverse()) {
              if (i && e.name == 'listItem') {
                t.rename(e, 'paragraph')
              } else if (!i && e.name != 'listItem') {
                t.setAttributes({ listType: this.type, listIndent: 0 }, e)
                t.rename(e, 'listItem')
              } else if (!i && e.name == 'listItem' && e.getAttribute('listType') != this.type) {
                t.setAttribute('listType', this.type, e)
              }
            }
            this.fire('_executeCleanup', o)
          })
        }
        _getValue() {
          const t = bl(this.editor.model.document.selection.getSelectedBlocks())
          return !!t && t.is('element', 'listItem') && t.getAttribute('listType') == this.type
        }
        _checkEnabled() {
          if (this.value) {
            return true
          }
          const t = this.editor.model.document.selection
          const e = this.editor.model.schema
          const n = bl(t.getSelectedBlocks())
          if (!n) {
            return false
          }
          return EF(n, e)
        }
      }
      function xF(t, e, n) {
        const o = e ? t[0] : t[t.length - 1]
        if (o.is('element', 'listItem')) {
          let i = o[e ? 'previousSibling' : 'nextSibling']
          let r = o.getAttribute('listIndent')
          while (i && i.is('element', 'listItem') && i.getAttribute('listIndent') >= n) {
            if (r > i.getAttribute('listIndent')) {
              r = i.getAttribute('listIndent')
            }
            if (i.getAttribute('listIndent') == r) {
              t[e ? 'unshift' : 'push'](i)
            }
            i = i[e ? 'previousSibling' : 'nextSibling']
          }
        }
      }
      function EF(t, e) {
        return e.checkChild(t.parent, 'listItem') && !e.isObject(t)
      }
      class DF extends Du {
        static get pluginName() {
          return 'ListUtils'
        }
        getListTypeFromListStyleType(t) {
          return LV(t)
        }
        getSelectedListItems(t) {
          return BV(t)
        }
        getSiblingNodes(t, e) {
          return MV(t, e)
        }
      }
      function TF(t) {
        return (e, n, o) => {
          const i = o.consumable
          if (
            !i.test(n.item, 'insert') ||
            !i.test(n.item, 'attribute:listType') ||
            !i.test(n.item, 'attribute:listIndent')
          ) {
            return
          }
          i.consume(n.item, 'insert')
          i.consume(n.item, 'attribute:listType')
          i.consume(n.item, 'attribute:listIndent')
          const r = n.item
          const s = yV(r, o)
          xV(r, s, o, t)
        }
      }
      function IF(t) {
        return (e, n, o) => {
          const i = o.mapper.toViewPosition(n.position)
          const r = i.getLastMatchingPosition((t) => !t.item.is('element', 'li'))
          const s = r.nodeAfter
          const a = o.writer
          a.breakContainer(a.createPositionBefore(s))
          a.breakContainer(a.createPositionAfter(s))
          const c = s.parent
          const l = c.previousSibling
          const d = a.createRangeOn(c)
          const u = a.remove(d)
          if (l && l.nextSibling) {
            EV(a, l, l.nextSibling)
          }
          const h = o.mapper.toModelElement(s)
          WF(h.getAttribute('listIndent') + 1, n.position, d.start, s, o, t)
          for (const t of a.createRangeIn(u).getItems()) {
            o.mapper.unbindViewElement(t)
          }
          e.stop()
        }
      }
      const SF = (t, e, n) => {
        if (!n.consumable.test(e.item, t.name)) {
          return
        }
        const o = n.mapper.toViewElement(e.item)
        const i = n.writer
        i.breakContainer(i.createPositionBefore(o))
        i.breakContainer(i.createPositionAfter(o))
        const r = o.parent
        const s = e.attributeNewValue == 'numbered' ? 'ol' : 'ul'
        i.rename(s, r)
      }
      const MF = (t, e, n) => {
        n.consumable.consume(e.item, t.name)
        const o = n.mapper.toViewElement(e.item)
        const i = o.parent
        const r = n.writer
        EV(r, i, i.nextSibling)
        EV(r, i.previousSibling, i)
      }
      function BF(t) {
        return (e, n, o) => {
          if (!o.consumable.consume(n.item, 'attribute:listIndent')) {
            return
          }
          const i = o.mapper.toViewElement(n.item)
          const r = o.writer
          r.breakContainer(r.createPositionBefore(i))
          r.breakContainer(r.createPositionAfter(i))
          const s = i.parent
          const a = s.previousSibling
          const c = r.createRangeOn(s)
          r.remove(c)
          if (a && a.nextSibling) {
            EV(r, a, a.nextSibling)
          }
          WF(n.attributeOldValue + 1, n.range.start, c.start, i, o, t)
          xV(n.item, i, o, t)
          for (const t of n.item.getChildren()) {
            o.consumable.consume(t, 'insert')
          }
        }
      }
      const NF = (t, e, n) => {
        if (!n.consumable.test(e.item, t.name)) {
          return
        }
        if (e.item.name != 'listItem') {
          let t = n.mapper.toViewPosition(e.range.start)
          const o = n.writer
          const i = []
          while (t.parent.name == 'ul' || t.parent.name == 'ol') {
            t = o.breakContainer(t)
            if (t.parent.name != 'li') {
              break
            }
            const e = t
            const n = o.createPositionAt(t.parent, 'end')
            if (!e.isEqual(n)) {
              const t = o.remove(o.createRange(e, n))
              i.push(t)
            }
            t = o.createPositionAfter(t.parent)
          }
          if (i.length > 0) {
            for (let e = 0; e < i.length; e++) {
              const n = t.nodeBefore
              const r = o.insert(t, i[e])
              t = r.end
              if (e > 0) {
                const e = EV(o, n, n.nextSibling)
                if (e && e.parent == n) {
                  t.offset--
                }
              }
            }
            EV(o, t.nodeBefore, t.nodeAfter)
          }
        }
      }
      const PF = (t, e, n) => {
        const o = n.mapper.toViewPosition(e.position)
        const i = o.nodeBefore
        const r = o.nodeAfter
        EV(n.writer, i, r)
      }
      const LF = (t, e, n) => {
        if (n.consumable.consume(e.viewItem, { name: true })) {
          const t = n.writer
          const o = t.createElement('listItem')
          const i = qF(e.viewItem)
          t.setAttribute('listIndent', i, o)
          const r = e.viewItem.parent && e.viewItem.parent.name == 'ol' ? 'numbered' : 'bulleted'
          t.setAttribute('listType', r, o)
          if (!n.safeInsert(o, e.modelCursor)) {
            return
          }
          const s = HF(o, e.viewItem.getChildren(), n)
          e.modelRange = t.createRange(e.modelCursor, s)
          n.updateConversionResult(o, e)
        }
      }
      const zF = (t, e, n) => {
        if (n.consumable.test(e.viewItem, { name: true })) {
          const t = Array.from(e.viewItem.getChildren())
          for (const e of t) {
            const t = !(e.is('element', 'li') || GF(e))
            if (t) {
              e._remove()
            }
          }
        }
      }
      const RF = (t, e, n) => {
        if (n.consumable.test(e.viewItem, { name: true })) {
          if (e.viewItem.childCount === 0) {
            return
          }
          const t = [...e.viewItem.getChildren()]
          let n = false
          for (const e of t) {
            if (n && !GF(e)) {
              e._remove()
            }
            if (GF(e)) {
              n = true
            }
          }
        }
      }
      function OF(t) {
        return (e, n) => {
          if (n.isPhantom) {
            return
          }
          const o = n.modelPosition.nodeBefore
          if (o && o.is('element', 'listItem')) {
            const e = n.mapper.toViewElement(o)
            const i = e.getAncestors().find(GF)
            const r = t.createPositionAt(e, 0).getWalker()
            for (const t of r) {
              if (t.type == 'elementStart' && t.item.is('element', 'li')) {
                n.viewPosition = t.previousPosition
                break
              } else if (t.type == 'elementEnd' && t.item == i) {
                n.viewPosition = t.nextPosition
                break
              }
            }
          }
        }
      }
      function VF(t) {
        return (e, n) => {
          const o = n.viewPosition
          const i = o.parent
          const r = n.mapper
          if (i.name == 'ul' || i.name == 'ol') {
            if (!o.isAtEnd) {
              const e = r.toModelElement(o.nodeAfter)
              n.modelPosition = t.createPositionBefore(e)
            } else {
              const e = r.toModelElement(o.nodeBefore)
              const i = r.getModelLength(o.nodeBefore)
              n.modelPosition = t.createPositionBefore(e).getShiftedBy(i)
            }
            e.stop()
          } else if (i.name == 'li' && o.nodeBefore && (o.nodeBefore.name == 'ul' || o.nodeBefore.name == 'ol')) {
            const s = r.toModelElement(i)
            let a = 1
            let c = o.nodeBefore
            while (c && GF(c)) {
              a += r.getModelLength(c)
              c = c.previousSibling
            }
            n.modelPosition = t.createPositionBefore(s).getShiftedBy(a)
            e.stop()
          }
        }
      }
      function FF(t, e) {
        const n = t.document.differ.getChanges()
        const o = new Map()
        let i = false
        for (const o of n) {
          if (o.type == 'insert' && o.name == 'listItem') {
            r(o.position)
          } else if (o.type == 'insert' && o.name != 'listItem') {
            if (o.name != '$text') {
              const n = o.position.nodeAfter
              if (n.hasAttribute('listIndent')) {
                e.removeAttribute('listIndent', n)
                i = true
              }
              if (n.hasAttribute('listType')) {
                e.removeAttribute('listType', n)
                i = true
              }
              if (n.hasAttribute('listStyle')) {
                e.removeAttribute('listStyle', n)
                i = true
              }
              if (n.hasAttribute('listReversed')) {
                e.removeAttribute('listReversed', n)
                i = true
              }
              if (n.hasAttribute('listStart')) {
                e.removeAttribute('listStart', n)
                i = true
              }
              for (const e of Array.from(t.createRangeIn(n)).filter((t) => t.item.is('element', 'listItem'))) {
                r(e.previousPosition)
              }
            }
            const n = o.position.getShiftedBy(o.length)
            r(n)
          } else if (o.type == 'remove' && o.name == 'listItem') {
            r(o.position)
          } else if (o.type == 'attribute' && o.attributeKey == 'listIndent') {
            r(o.range.start)
          } else if (o.type == 'attribute' && o.attributeKey == 'listType') {
            r(o.range.start)
          }
        }
        for (const t of o.values()) {
          s(t)
          a(t)
        }
        return i
        function r(t) {
          const e = t.nodeBefore
          if (!e || !e.is('element', 'listItem')) {
            const e = t.nodeAfter
            if (e && e.is('element', 'listItem')) {
              o.set(e, e)
            }
          } else {
            let t = e
            if (o.has(t)) {
              return
            }
            for (let e = t.previousSibling; e && e.is('element', 'listItem'); e = t.previousSibling) {
              t = e
              if (o.has(t)) {
                return
              }
            }
            o.set(e, t)
          }
        }
        function s(t) {
          let n = 0
          let o = null
          while (t && t.is('element', 'listItem')) {
            const r = t.getAttribute('listIndent')
            if (r > n) {
              let s
              if (o === null) {
                o = r - n
                s = n
              } else {
                if (o > r) {
                  o = r
                }
                s = r - o
              }
              e.setAttribute('listIndent', s, t)
              i = true
            } else {
              o = null
              n = t.getAttribute('listIndent') + 1
            }
            t = t.nextSibling
          }
        }
        function a(t) {
          let n = []
          let o = null
          while (t && t.is('element', 'listItem')) {
            const r = t.getAttribute('listIndent')
            if (o && o.getAttribute('listIndent') > r) {
              n = n.slice(0, r + 1)
            }
            if (r != 0) {
              if (n[r]) {
                const o = n[r]
                if (t.getAttribute('listType') != o) {
                  e.setAttribute('listType', o, t)
                  i = true
                }
              } else {
                n[r] = t.getAttribute('listType')
              }
            }
            o = t
            t = t.nextSibling
          }
        }
      }
      const jF = function (t, [e, n]) {
        const o = this
        let i = e.is('documentFragment') ? e.getChild(0) : e
        let r
        if (!n) {
          r = o.document.selection
        } else {
          r = o.createSelection(n)
        }
        if (i && i.is('element', 'listItem')) {
          const t = r.getFirstPosition()
          let e = null
          if (t.parent.is('element', 'listItem')) {
            e = t.parent
          } else if (t.nodeBefore && t.nodeBefore.is('element', 'listItem')) {
            e = t.nodeBefore
          }
          if (e) {
            const t = e.getAttribute('listIndent')
            if (t > 0) {
              while (i && i.is('element', 'listItem')) {
                i._setAttribute('listIndent', i.getAttribute('listIndent') + t)
                i = i.nextSibling
              }
            }
          }
        }
      }
      function HF(t, e, n) {
        const { writer: o, schema: i } = n
        let r = o.createPositionAfter(t)
        for (const s of e) {
          if (s.name == 'ul' || s.name == 'ol') {
            r = n.convertItem(s, r).modelCursor
          } else {
            const e = n.convertItem(s, o.createPositionAt(t, 'end'))
            const a = e.modelRange.start.nodeAfter
            const c = a && a.is('element') && !i.checkChild(t, a.name)
            if (c) {
              if (e.modelCursor.parent.is('element', 'listItem')) {
                t = e.modelCursor.parent
              } else {
                t = UF(e.modelCursor)
              }
              r = o.createPositionAfter(t)
            }
          }
        }
        return r
      }
      function UF(t) {
        const e = new xb({ startPosition: t })
        let n
        do {
          n = e.next()
        } while (!n.value.item.is('element', 'listItem'))
        return n.value.item
      }
      function WF(t, e, n, o, i, r) {
        const s = TV(e.nodeBefore, { sameIndent: true, smallerIndent: true, listIndent: t })
        const a = i.mapper
        const c = i.writer
        const l = s ? s.getAttribute('listIndent') : null
        let d
        if (!s) {
          d = n
        } else if (l == t) {
          const t = a.toViewElement(s).parent
          d = c.createPositionAfter(t)
        } else {
          const t = r.createPositionAt(s, 'end')
          d = a.toViewPosition(t)
        }
        d = DV(d)
        for (const t of [...o.getChildren()]) {
          if (GF(t)) {
            d = c.move(c.createRangeOn(t), d).end
            EV(c, t, t.nextSibling)
            EV(c, t.previousSibling, t)
          }
        }
      }
      function GF(t) {
        return t.is('element', 'ol') || t.is('element', 'ul')
      }
      function qF(t) {
        let e = 0
        let n = t.parent
        while (n) {
          if (n.is('element', 'li')) {
            e++
          } else {
            const t = n.previousSibling
            if (t && t.is('element', 'li')) {
              e++
            }
          }
          n = n.parent
        }
        return e
      }
      class $F extends Du {
        static get pluginName() {
          return 'ListEditing'
        }
        static get requires() {
          return [zI, cT, DF]
        }
        init() {
          const t = this.editor
          t.model.schema.register('listItem', { inheritAllFrom: '$block', allowAttributes: ['listType', 'listIndent'] })
          const e = t.data
          const n = t.editing
          t.model.document.registerPostFixer((e) => FF(t.model, e))
          n.mapper.registerViewToModelLength('li', KF)
          e.mapper.registerViewToModelLength('li', KF)
          n.mapper.on('modelToViewPosition', OF(n.view))
          n.mapper.on('viewToModelPosition', VF(t.model))
          e.mapper.on('modelToViewPosition', OF(n.view))
          t.conversion.for('editingDowncast').add((e) => {
            e.on('insert', NF, { priority: 'high' })
            e.on('insert:listItem', TF(t.model))
            e.on('attribute:listType:listItem', SF, { priority: 'high' })
            e.on('attribute:listType:listItem', MF, { priority: 'low' })
            e.on('attribute:listIndent:listItem', BF(t.model))
            e.on('remove:listItem', IF(t.model))
            e.on('remove', PF, { priority: 'low' })
          })
          t.conversion.for('dataDowncast').add((e) => {
            e.on('insert', NF, { priority: 'high' })
            e.on('insert:listItem', TF(t.model))
          })
          t.conversion.for('upcast').add((t) => {
            t.on('element:ul', zF, { priority: 'high' })
            t.on('element:ol', zF, { priority: 'high' })
            t.on('element:li', RF, { priority: 'high' })
            t.on('element:li', LF)
          })
          t.model.on('insertContent', jF, { priority: 'high' })
          t.commands.add('numberedList', new yF(t, 'numbered'))
          t.commands.add('bulletedList', new yF(t, 'bulleted'))
          t.commands.add('indentList', new vF(t, 'forward'))
          t.commands.add('outdentList', new vF(t, 'backward'))
          const o = n.view.document
          this.listenTo(
            o,
            'enter',
            (t, e) => {
              const n = this.editor.model.document
              const o = n.selection.getLastPosition().parent
              if (n.selection.isCollapsed && o.name == 'listItem' && o.isEmpty) {
                this.editor.execute('outdentList')
                e.preventDefault()
                t.stop()
              }
            },
            { context: 'li' },
          )
          this.listenTo(
            o,
            'delete',
            (t, e) => {
              if (e.direction !== 'backward') {
                return
              }
              const n = this.editor.model.document.selection
              if (!n.isCollapsed) {
                return
              }
              const o = n.getFirstPosition()
              if (!o.isAtStart) {
                return
              }
              const i = o.parent
              if (i.name !== 'listItem') {
                return
              }
              const r = i.previousSibling && i.previousSibling.name === 'listItem'
              if (r) {
                return
              }
              this.editor.execute('outdentList')
              e.preventDefault()
              t.stop()
            },
            { context: 'li' },
          )
          this.listenTo(
            t.editing.view.document,
            'tab',
            (e, n) => {
              const o = n.shiftKey ? 'outdentList' : 'indentList'
              const i = this.editor.commands.get(o)
              if (i.isEnabled) {
                t.execute(o)
                n.stopPropagation()
                n.preventDefault()
                e.stop()
              }
            },
            { context: 'li' },
          )
        }
        afterInit() {
          const t = this.editor.commands
          const e = t.get('indent')
          const n = t.get('outdent')
          if (e) {
            e.registerChildCommand(t.get('indentList'))
          }
          if (n) {
            n.registerChildCommand(t.get('outdentList'))
          }
        }
      }
      function KF(t) {
        let e = 1
        for (const n of t.getChildren()) {
          if (n.name == 'ul' || n.name == 'ol') {
            for (const t of n.getChildren()) {
              e += KF(t)
            }
          }
        }
        return e
      }
      class YF extends Du {
        static get requires() {
          return [$F, VV]
        }
        static get pluginName() {
          return 'List'
        }
      }
      class ZF extends (null && Command) {
        constructor(t, e) {
          super(t)
          this.defaultType = e
        }
        refresh() {
          this.value = this._getValue()
          this.isEnabled = this._checkEnabled()
        }
        execute(t = {}) {
          this._tryToConvertItemsToList(t)
          const e = this.editor.model
          const n = getSelectedListItems(e)
          if (!n.length) {
            return
          }
          e.change((e) => {
            for (const o of n) {
              e.setAttribute('listStyle', t.type || this.defaultType, o)
            }
          })
        }
        _getValue() {
          const t = this.editor.model.document.selection.getFirstPosition().parent
          if (t && t.is('element', 'listItem')) {
            return t.getAttribute('listStyle')
          }
          return null
        }
        _checkEnabled() {
          const t = this.editor
          const e = t.commands.get('numberedList')
          const n = t.commands.get('bulletedList')
          return e.isEnabled || n.isEnabled
        }
        _tryToConvertItemsToList(t) {
          if (!t.type) {
            return
          }
          const e = getListTypeFromListStyleType(t.type)
          if (!e) {
            return
          }
          const n = this.editor
          const o = `${e}List`
          const i = n.commands.get(o)
          if (!i.value) {
            n.execute(o)
          }
        }
      }
      class QF extends (null && Command) {
        refresh() {
          const t = this._getValue()
          this.value = t
          this.isEnabled = t != null
        }
        execute(t = {}) {
          const e = this.editor.model
          const n = getSelectedListItems(e).filter((t) => t.getAttribute('listType') == 'numbered')
          e.change((e) => {
            for (const o of n) {
              e.setAttribute('listReversed', !!t.reversed, o)
            }
          })
        }
        _getValue() {
          const t = this.editor.model.document.selection.getFirstPosition().parent
          if (t && t.is('element', 'listItem') && t.getAttribute('listType') == 'numbered') {
            return t.getAttribute('listReversed')
          }
          return null
        }
      }
      class JF extends (null && Command) {
        refresh() {
          const t = this._getValue()
          this.value = t
          this.isEnabled = t != null
        }
        execute({ startIndex: t = 1 } = {}) {
          const e = this.editor.model
          const n = getSelectedListItems(e).filter((t) => t.getAttribute('listType') == 'numbered')
          e.change((e) => {
            for (const o of n) {
              e.setAttribute('listStart', t >= 0 ? t : 1, o)
            }
          })
        }
        _getValue() {
          const t = this.editor.model.document.selection.getFirstPosition().parent
          if (t && t.is('element', 'listItem') && t.getAttribute('listType') == 'numbered') {
            return t.getAttribute('listStart')
          }
          return null
        }
      }
      const XF = 'default'
      class tj extends (null && Plugin) {
        static get requires() {
          return [ListEditing]
        }
        static get pluginName() {
          return 'ListPropertiesEditing'
        }
        constructor(t) {
          super(t)
          t.config.define('list', { properties: { styles: true, startIndex: false, reversed: false } })
        }
        init() {
          const t = this.editor
          const e = t.model
          const n = t.config.get('list.properties')
          const o = ej(n)
          e.schema.extend('listItem', { allowAttributes: o.map((t) => t.attributeName) })
          for (const e of o) {
            e.addCommand(t)
          }
          this.listenTo(t.commands.get('indentList'), '_executeCleanup', ij(t, o))
          this.listenTo(t.commands.get('outdentList'), '_executeCleanup', rj(t, o))
          this.listenTo(t.commands.get('bulletedList'), '_executeCleanup', dj(t))
          this.listenTo(t.commands.get('numberedList'), '_executeCleanup', dj(t))
          e.document.registerPostFixer(sj(t, o))
          t.conversion.for('upcast').add(nj(o))
          t.conversion.for('downcast').add(oj(o))
          this._mergeListAttributesWhileMergingLists(o)
        }
        afterInit() {
          const t = this.editor
          if (t.commands.get('todoList')) {
            t.model.document.registerPostFixer(lj(t))
          }
        }
        _mergeListAttributesWhileMergingLists(t) {
          const e = this.editor
          const n = e.model
          let o
          this.listenTo(
            n,
            'deleteContent',
            (t, [e]) => {
              const n = e.getFirstPosition()
              const i = e.getLastPosition()
              if (n.parent === i.parent) {
                return
              }
              if (!n.parent.is('element', 'listItem')) {
                return
              }
              const r = i.parent.nextSibling
              if (!r || !r.is('element', 'listItem')) {
                return
              }
              const s = getSiblingListItem(n.parent, { sameIndent: true, listIndent: r.getAttribute('listIndent') })
              if (!s) {
                return
              }
              if (s.getAttribute('listType') === r.getAttribute('listType')) {
                o = s
              }
            },
            { priority: 'high' },
          )
          this.listenTo(
            n,
            'deleteContent',
            () => {
              if (!o) {
                return
              }
              n.change((e) => {
                const n = getSiblingListItem(o.nextSibling, {
                  sameIndent: true,
                  listIndent: o.getAttribute('listIndent'),
                  direction: 'forward',
                })
                if (!n) {
                  o = null
                  return
                }
                const i = [n, ...getSiblingNodes(e.createPositionAt(n, 0), 'forward')]
                for (const n of i) {
                  for (const i of t) {
                    if (i.appliesToListItem(n)) {
                      const t = i.attributeName
                      const r = o.getAttribute(t)
                      e.setAttribute(t, r, n)
                    }
                  }
                }
              })
              o = null
            },
            { priority: 'low' },
          )
        }
      }
      function ej(t) {
        const e = []
        if (t.styles) {
          e.push({
            attributeName: 'listStyle',
            defaultValue: XF,
            addCommand(t) {
              t.commands.add('listStyle', new ListStyleCommand(t, XF))
            },
            appliesToListItem() {
              return true
            },
            setAttributeOnDowncast(t, e, n) {
              if (e && e !== XF) {
                t.setStyle('list-style-type', e, n)
              } else {
                t.removeStyle('list-style-type', n)
              }
            },
            getAttributeOnUpcast(t) {
              return t.getStyle('list-style-type') || XF
            },
          })
        }
        if (t.reversed) {
          e.push({
            attributeName: 'listReversed',
            defaultValue: false,
            addCommand(t) {
              t.commands.add('listReversed', new ListReversedCommand(t))
            },
            appliesToListItem(t) {
              return t.getAttribute('listType') == 'numbered'
            },
            setAttributeOnDowncast(t, e, n) {
              if (e) {
                t.setAttribute('reversed', 'reversed', n)
              } else {
                t.removeAttribute('reversed', n)
              }
            },
            getAttributeOnUpcast(t) {
              return t.hasAttribute('reversed')
            },
          })
        }
        if (t.startIndex) {
          e.push({
            attributeName: 'listStart',
            defaultValue: 1,
            addCommand(t) {
              t.commands.add('listStart', new ListStartCommand(t))
            },
            appliesToListItem(t) {
              return t.getAttribute('listType') == 'numbered'
            },
            setAttributeOnDowncast(t, e, n) {
              if (e == 0 || e > 1) {
                t.setAttribute('start', e, n)
              } else {
                t.removeAttribute('start', n)
              }
            },
            getAttributeOnUpcast(t) {
              const e = t.getAttribute('start')
              return e >= 0 ? e : 1
            },
          })
        }
        return e
      }
      function nj(t) {
        return (e) => {
          e.on(
            'element:li',
            (e, n, o) => {
              if (!n.modelRange) {
                return
              }
              const i = n.viewItem.parent
              const r = n.modelRange.start.nodeAfter || n.modelRange.end.nodeBefore
              for (const e of t) {
                if (e.appliesToListItem(r)) {
                  const t = e.getAttributeOnUpcast(i)
                  o.writer.setAttribute(e.attributeName, t, r)
                }
              }
            },
            { priority: 'low' },
          )
        }
      }
      function oj(t) {
        return (n) => {
          for (const o of t) {
            n.on(
              `attribute:${o.attributeName}:listItem`,
              (t, n, i) => {
                const r = i.writer
                const s = n.item
                const a = getSiblingListItem(s.previousSibling, {
                  sameIndent: true,
                  listIndent: s.getAttribute('listIndent'),
                  direction: 'backward',
                })
                const c = i.mapper.toViewElement(s)
                if (!e(s, a)) {
                  r.breakContainer(r.createPositionBefore(c))
                }
                o.setAttributeOnDowncast(r, n.attributeNewValue, c.parent)
              },
              { priority: 'low' },
            )
          }
        }
        function e(t, e) {
          return (
            e &&
            t.getAttribute('listType') === e.getAttribute('listType') &&
            t.getAttribute('listIndent') === e.getAttribute('listIndent') &&
            t.getAttribute('listStyle') === e.getAttribute('listStyle') &&
            t.getAttribute('listReversed') === e.getAttribute('listReversed') &&
            t.getAttribute('listStart') === e.getAttribute('listStart')
          )
        }
      }
      function ij(t, e) {
        return (n, o) => {
          const i = o[0]
          const r = i.getAttribute('listIndent')
          const s = o.filter((t) => t.getAttribute('listIndent') === r)
          let a = null
          if (i.previousSibling.getAttribute('listIndent') + 1 !== r) {
            a = getSiblingListItem(i.previousSibling, { sameIndent: true, direction: 'backward', listIndent: r })
          }
          t.model.change((t) => {
            for (const n of s) {
              for (const o of e) {
                if (o.appliesToListItem(n)) {
                  const e = a == null ? o.defaultValue : a.getAttribute(o.attributeName)
                  t.setAttribute(o.attributeName, e, n)
                }
              }
            }
          })
        }
      }
      function rj(t, e) {
        return (n, o) => {
          o = o.reverse().filter((t) => t.is('element', 'listItem'))
          if (!o.length) {
            return
          }
          const i = o[0].getAttribute('listIndent')
          const r = o[0].getAttribute('listType')
          let s = o[0].previousSibling
          if (s.is('element', 'listItem')) {
            while (s.getAttribute('listIndent') !== i) {
              s = s.previousSibling
            }
          } else {
            s = null
          }
          if (!s) {
            s = o[o.length - 1].nextSibling
          }
          if (!s || !s.is('element', 'listItem')) {
            return
          }
          if (s.getAttribute('listType') !== r) {
            return
          }
          t.model.change((t) => {
            const n = o.filter((t) => t.getAttribute('listIndent') === i)
            for (const o of n) {
              for (const n of e) {
                if (n.appliesToListItem(o)) {
                  const e = n.attributeName
                  const i = s.getAttribute(e)
                  t.setAttribute(e, i, o)
                }
              }
            }
          })
        }
      }
      function sj(t, e) {
        return (n) => {
          let o = false
          const i = uj(t.model.document.differ.getChanges()).filter((t) => t.getAttribute('listType') !== 'todo')
          if (!i.length) {
            return o
          }
          let r = i[i.length - 1].nextSibling
          if (!r || !r.is('element', 'listItem')) {
            r = i[0].previousSibling
            if (r) {
              const t = i[0].getAttribute('listIndent')
              while (r.is('element', 'listItem') && r.getAttribute('listIndent') !== t) {
                r = r.previousSibling
                if (!r) {
                  break
                }
              }
            }
          }
          for (const t of e) {
            const e = t.attributeName
            for (const s of i) {
              if (!t.appliesToListItem(s)) {
                n.removeAttribute(e, s)
                continue
              }
              if (!s.hasAttribute(e)) {
                if (aj(r, s, t)) {
                  n.setAttribute(e, r.getAttribute(e), s)
                } else {
                  n.setAttribute(e, t.defaultValue, s)
                }
                o = true
              } else {
                const i = s.previousSibling
                if (cj(i, s, t.attributeName)) {
                  n.setAttribute(e, i.getAttribute(e), s)
                  o = true
                }
              }
            }
          }
          return o
        }
      }
      function aj(t, e, n) {
        if (!t) {
          return false
        }
        const o = t.getAttribute(n.attributeName)
        if (!o) {
          return false
        }
        if (o == n.defaultValue) {
          return false
        }
        if (t.getAttribute('listType') !== e.getAttribute('listType')) {
          return false
        }
        return true
      }
      function cj(t, e, n) {
        if (!t || !t.is('element', 'listItem')) {
          return false
        }
        if (e.getAttribute('listType') !== t.getAttribute('listType')) {
          return false
        }
        const o = t.getAttribute('listIndent')
        if (o < 1 || o !== e.getAttribute('listIndent')) {
          return false
        }
        const i = t.getAttribute(n)
        if (!i || i === e.getAttribute(n)) {
          return false
        }
        return true
      }
      function lj(t) {
        return (e) => {
          const n = uj(t.model.document.differ.getChanges()).filter(
            (t) =>
              t.getAttribute('listType') === 'todo' &&
              (t.hasAttribute('listStyle') || t.hasAttribute('listReversed') || t.hasAttribute('listStart')),
          )
          if (!n.length) {
            return false
          }
          for (const t of n) {
            e.removeAttribute('listStyle', t)
            e.removeAttribute('listReversed', t)
            e.removeAttribute('listStart', t)
          }
          return true
        }
      }
      function dj(t) {
        return (e, n) => {
          n = n.filter((t) => t.is('element', 'listItem'))
          t.model.change((t) => {
            for (const e of n) {
              t.removeAttribute('listStyle', e)
            }
          })
        }
      }
      function uj(t) {
        const e = []
        for (const n of t) {
          const t = hj(n)
          if (t && t.is('element', 'listItem')) {
            e.push(t)
          }
        }
        return e
      }
      function hj(t) {
        if (t.type === 'attribute') {
          return t.range.start.nodeAfter
        }
        if (t.type === 'insert') {
          return t.position.nodeAfter
        }
        return null
      }
      class gj extends (null && Plugin) {
        static get requires() {
          return [ListPropertiesEditing, ListPropertiesUI]
        }
        static get pluginName() {
          return 'ListProperties'
        }
      }
      const fj = 'todoListChecked'
      class mj extends (null && Command) {
        constructor(t) {
          super(t)
          this._selectedElements = []
          this.on(
            'execute',
            () => {
              this.refresh()
            },
            { priority: 'highest' },
          )
        }
        refresh() {
          this._selectedElements = this._getSelectedItems()
          this.value = this._selectedElements.every((t) => !!t.getAttribute(fj))
          this.isEnabled = !!this._selectedElements.length
        }
        _getSelectedItems() {
          const t = this.editor.model
          const e = t.schema
          const n = t.document.selection.getFirstRange()
          const o = n.start.parent
          const i = []
          if (e.checkAttribute(o, fj)) {
            i.push(o)
          }
          for (const t of n.getItems()) {
            if (e.checkAttribute(t, fj) && !i.includes(t)) {
              i.push(t)
            }
          }
          return i
        }
        execute(t = {}) {
          this.editor.model.change((e) => {
            for (const n of this._selectedElements) {
              const o = t.forceValue === undefined ? !this.value : t.forceValue
              if (o) {
                e.setAttribute(fj, true, n)
              } else {
                e.removeAttribute(fj, n)
              }
            }
          })
        }
      }
      function pj(t, e) {
        return (n, o, i) => {
          const r = i.consumable
          if (
            !r.test(o.item, 'insert') ||
            !r.test(o.item, 'attribute:listType') ||
            !r.test(o.item, 'attribute:listIndent')
          ) {
            return
          }
          if (o.item.getAttribute('listType') != 'todo') {
            return
          }
          const s = o.item
          r.consume(s, 'insert')
          r.consume(s, 'attribute:listType')
          r.consume(s, 'attribute:listIndent')
          r.consume(s, 'attribute:todoListChecked')
          const a = i.writer
          const c = generateLiInUl(s, i)
          const l = !!s.getAttribute('todoListChecked')
          const d = Cj(s, a, l, e)
          const u = a.createContainerElement('span', { class: 'todo-list__label__description' })
          a.addClass('todo-list', c.parent)
          a.insert(a.createPositionAt(c, 0), d)
          a.insert(a.createPositionAfter(d), u)
          injectViewList(s, c, i, t)
        }
      }
      function bj(t) {
        return (e, n, o) => {
          const i = o.consumable
          if (
            !i.test(n.item, 'insert') ||
            !i.test(n.item, 'attribute:listType') ||
            !i.test(n.item, 'attribute:listIndent')
          ) {
            return
          }
          if (n.item.getAttribute('listType') != 'todo') {
            return
          }
          const r = n.item
          i.consume(r, 'insert')
          i.consume(r, 'attribute:listType')
          i.consume(r, 'attribute:listIndent')
          i.consume(r, 'attribute:todoListChecked')
          const s = o.writer
          const a = generateLiInUl(r, o)
          s.addClass('todo-list', a.parent)
          const c = s.createContainerElement('label', { class: 'todo-list__label' })
          const l = s.createEmptyElement('input', { type: 'checkbox', disabled: 'disabled' })
          const d = s.createContainerElement('span', { class: 'todo-list__label__description' })
          if (r.getAttribute('todoListChecked')) {
            s.setAttribute('checked', 'checked', l)
          }
          s.insert(s.createPositionAt(a, 0), c)
          s.insert(s.createPositionAt(c, 0), l)
          s.insert(s.createPositionAfter(l), d)
          injectViewList(r, a, o, t)
        }
      }
      const kj = (t, e, n) => {
        const o = e.modelCursor
        const i = o.parent
        const r = e.viewItem
        if (r.getAttribute('type') != 'checkbox' || i.name != 'listItem' || !o.isAtStart) {
          return
        }
        if (!n.consumable.consume(r, { name: true })) {
          return
        }
        const s = n.writer
        s.setAttribute('listType', 'todo', i)
        if (e.viewItem.hasAttribute('checked')) {
          s.setAttribute('todoListChecked', true, i)
        }
        e.modelRange = s.createRange(o)
      }
      function wj(t, e) {
        return (n, o, i) => {
          if (!i.consumable.consume(o.item, n.name)) {
            return
          }
          const r = i.mapper.toViewElement(o.item)
          const s = i.writer
          const a = vj(r, e)
          if (o.attributeNewValue == 'todo') {
            const e = !!o.item.getAttribute('todoListChecked')
            const n = Cj(o.item, s, e, t)
            const i = s.createContainerElement('span', { class: 'todo-list__label__description' })
            const a = s.createRangeIn(r)
            const c = findNestedList(r)
            const l = positionAfterUiElements(a.start)
            const d = c ? s.createPositionBefore(c) : a.end
            const u = s.createRange(l, d)
            s.addClass('todo-list', r.parent)
            s.move(u, s.createPositionAt(i, 0))
            s.insert(s.createPositionAt(r, 0), n)
            s.insert(s.createPositionAfter(n), i)
          } else if (o.attributeOldValue == 'todo') {
            const t = yj(r, e)
            s.removeClass('todo-list', r.parent)
            s.remove(a)
            s.move(s.createRangeIn(t), s.createPositionBefore(t))
            s.remove(t)
          }
        }
      }
      function Aj(t) {
        return (e, n, o) => {
          if (n.item.getAttribute('listType') != 'todo') {
            return
          }
          if (!o.consumable.consume(n.item, 'attribute:todoListChecked')) {
            return
          }
          const { mapper: i, writer: r } = o
          const s = !!n.item.getAttribute('todoListChecked')
          const a = i.toViewElement(n.item)
          const c = a.getChild(0)
          const l = Cj(n.item, r, s, t)
          r.insert(r.createPositionAfter(c), l)
          r.remove(c)
        }
      }
      function _j(t) {
        return (e, n) => {
          const o = n.modelPosition
          const i = o.parent
          if (!i.is('element', 'listItem') || i.getAttribute('listType') != 'todo') {
            return
          }
          const r = n.mapper.toViewElement(i)
          const s = yj(r, t)
          if (s) {
            n.viewPosition = n.mapper.findPositionIn(s, o.offset)
          }
        }
      }
      function Cj(t, e, n, o) {
        const i = e.createUIElement('label', { class: 'todo-list__label', contenteditable: false }, function (e) {
          const i = createElement(document, 'input', { type: 'checkbox', tabindex: '-1' })
          if (n) {
            i.setAttribute('checked', 'checked')
          }
          i.addEventListener('change', () => o(t))
          const r = this.toDomElement(e)
          r.appendChild(i)
          return r
        })
        return i
      }
      function vj(t, e) {
        const n = e.createRangeIn(t)
        for (const t of n) {
          if (t.item.is('uiElement', 'label')) {
            return t.item
          }
        }
      }
      function yj(t, e) {
        const n = e.createRangeIn(t)
        for (const t of n) {
          if (t.item.is('containerElement', 'span') && t.item.hasClass('todo-list__label__description')) {
            return t.item
          }
        }
      }
      const xj = Jc('Ctrl+Enter')
      class Ej extends (null && Plugin) {
        static get pluginName() {
          return 'TodoListEditing'
        }
        static get requires() {
          return [ListEditing]
        }
        init() {
          const t = this.editor
          const { editing: e, data: n, model: o } = t
          o.schema.extend('listItem', { allowAttributes: ['todoListChecked'] })
          o.schema.addAttributeCheck((t, e) => {
            const n = t.last
            if (e == 'todoListChecked' && n.name == 'listItem' && n.getAttribute('listType') != 'todo') {
              return false
            }
          })
          t.commands.add('todoList', new ListCommand(t, 'todo'))
          const i = new CheckTodoListCommand(t)
          t.commands.add('checkTodoList', i)
          t.commands.add('todoListCheck', i)
          n.downcastDispatcher.on('insert:listItem', dataModelViewInsertion(o), { priority: 'high' })
          n.upcastDispatcher.on('element:input', dataViewModelCheckmarkInsertion, { priority: 'high' })
          e.downcastDispatcher.on(
            'insert:listItem',
            modelViewInsertion(o, (t) => this._handleCheckmarkChange(t)),
            { priority: 'high' },
          )
          e.downcastDispatcher.on(
            'attribute:listType:listItem',
            modelViewChangeType((t) => this._handleCheckmarkChange(t), e.view),
          )
          e.downcastDispatcher.on(
            'attribute:todoListChecked:listItem',
            modelViewChangeChecked((t) => this._handleCheckmarkChange(t)),
          )
          e.mapper.on('modelToViewPosition', mapModelToViewPosition(e.view))
          n.mapper.on('modelToViewPosition', mapModelToViewPosition(e.view))
          this.listenTo(e.view.document, 'arrowKey', Dj(o, t.locale), { context: 'li' })
          this.listenTo(
            e.view.document,
            'keydown',
            (e, n) => {
              if (getCode(n) === xj) {
                t.execute('checkTodoList')
                e.stop()
              }
            },
            { priority: 'high' },
          )
          const r = new Set()
          this.listenTo(o, 'applyOperation', (t, e) => {
            const n = e[0]
            if (n.type == 'rename' && n.oldName == 'listItem') {
              const t = n.position.nodeAfter
              if (t.hasAttribute('todoListChecked')) {
                r.add(t)
              }
            } else if (n.type == 'changeAttribute' && n.key == 'listType' && n.oldValue === 'todo') {
              for (const t of n.range.getItems()) {
                if (t.hasAttribute('todoListChecked') && t.getAttribute('listType') !== 'todo') {
                  r.add(t)
                }
              }
            }
          })
          o.document.registerPostFixer((t) => {
            let e = false
            for (const n of r) {
              t.removeAttribute('todoListChecked', n)
              e = true
            }
            r.clear()
            return e
          })
        }
        _handleCheckmarkChange(t) {
          const e = this.editor
          const n = e.model
          const o = Array.from(n.document.selection.getRanges())
          n.change((n) => {
            n.setSelection(t, 'end')
            e.execute('checkTodoList')
            n.setSelection(o)
          })
        }
      }
      function Dj(t, e) {
        return (n, o) => {
          const i = getLocalizedArrowKeyCodeDirection(o.keyCode, e.contentLanguageDirection)
          if (i != 'left') {
            return
          }
          const r = t.schema
          const s = t.document.selection
          if (!s.isCollapsed) {
            return
          }
          const a = s.getFirstPosition()
          const c = a.parent
          if (c.name === 'listItem' && c.getAttribute('listType') == 'todo' && a.isAtStart) {
            const e = r.getNearestSelectionRange(t.createPositionBefore(c), 'backward')
            if (e) {
              t.change((t) => t.setSelection(e))
            }
            o.preventDefault()
            o.stopPropagation()
            n.stop()
          }
        }
      }
      class Tj extends (null && Plugin) {
        static get pluginName() {
          return 'TodoListUI'
        }
        init() {
          const t = this.editor.t
          createUIComponent(this.editor, 'todoList', t('To-do List'), todoListIcon)
        }
      }
      var Ij = n(9292)
      var Sj = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      Sj.insert = 'head'
      Sj.singleton = true
      var Mj = Rl()(Ij.Z, Sj)
      const Bj = Ij.Z.locals || {}
      class Nj extends (null && Plugin) {
        static get requires() {
          return [TodoListEditing, TodoListUI]
        }
        static get pluginName() {
          return 'TodoList'
        }
      }
      function Pj(t, e) {
        const n = (n, o, i) => {
          if (!i.consumable.consume(o.item, n.name)) {
            return
          }
          const r = o.attributeNewValue
          const s = i.writer
          const a = i.mapper.toViewElement(o.item)
          const c = [...a.getChildren()].find((t) => t.getCustomProperty('media-content'))
          s.remove(c)
          const l = t.getMediaViewElement(s, r, e)
          s.insert(s.createPositionAt(a, 0), l)
        }
        return (t) => {
          t.on('attribute:url:media', n)
        }
      }
      function Lj(t, e, n) {
        e.setCustomProperty('media', true, t)
        return ES(t, e, { label: n })
      }
      function zj(t) {
        const e = t.getSelectedElement()
        if (e && Rj(e)) {
          return e
        }
        return null
      }
      function Rj(t) {
        return !!t.getCustomProperty('media') && isWidget(t)
      }
      function Oj(t, e, n, o) {
        return t.createContainerElement('figure', { class: 'media' }, [e.getMediaViewElement(t, n, o), t.createSlot()])
      }
      function Vj(t) {
        const e = t.getSelectedElement()
        if (e && e.is('element', 'media')) {
          return e
        }
        return null
      }
      function Fj(t, e, n, o) {
        t.change((i) => {
          const r = i.createElement('media', { url: e })
          t.insertObject(r, n, null, { setSelection: 'on', findOptimalPosition: o ? 'auto' : undefined })
        })
      }
      class jj extends Iu {
        refresh() {
          const t = this.editor.model
          const e = t.document.selection
          const n = Vj(e)
          this.value = n ? n.getAttribute('url') : undefined
          this.isEnabled = Uj(e) || Hj(e, t)
        }
        execute(t) {
          const e = this.editor.model
          const n = e.document.selection
          const o = Vj(n)
          if (o) {
            e.change((e) => {
              e.setAttribute('url', t, o)
            })
          } else {
            Fj(e, t, n, true)
          }
        }
      }
      function Hj(t, e) {
        const n = NS(t, e)
        let o = n.start.parent
        if (o.isEmpty && !e.schema.isLimit(o)) {
          o = o.parent
        }
        return e.schema.checkChild(o, 'media')
      }
      function Uj(t) {
        const e = t.getSelectedElement()
        return !!e && e.name === 'media'
      }
      const Wj =
        '<svg viewBox="0 0 64 42" xmlns="http://www.w3.org/2000/svg"><path d="M47.426 17V3.713L63.102 0v19.389h-.001l.001.272c0 1.595-2.032 3.43-4.538 4.098-2.506.668-4.538-.083-4.538-1.678 0-1.594 2.032-3.43 4.538-4.098.914-.244 2.032-.565 2.888-.603V4.516L49.076 7.447v9.556A1.014 1.014 0 0 0 49 17h-1.574zM29.5 17h-8.343a7.073 7.073 0 1 0-4.657 4.06v3.781H3.3a2.803 2.803 0 0 1-2.8-2.804V8.63a2.803 2.803 0 0 1 2.8-2.805h4.082L8.58 2.768A1.994 1.994 0 0 1 10.435 1.5h8.985c.773 0 1.477.448 1.805 1.149l1.488 3.177H26.7c1.546 0 2.8 1.256 2.8 2.805V17zm-11.637 0H17.5a1 1 0 0 0-1 1v.05A4.244 4.244 0 1 1 17.863 17zm29.684 2c.97 0 .953-.048.953.889v20.743c0 .953.016.905-.953.905H19.453c-.97 0-.953.048-.953-.905V19.89c0-.937-.016-.889.97-.889h28.077zm-4.701 19.338V22.183H24.154v16.155h18.692zM20.6 21.375v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616V37.53H20.6zm24.233-16.155v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615V37.53h-1.615zM29.485 25.283a.4.4 0 0 1 .593-.35l9.05 4.977a.4.4 0 0 1 0 .701l-9.05 4.978a.4.4 0 0 1-.593-.35v-9.956z"/></svg>'
      const Gj = '0 0 64 42'
      class qj {
        constructor(t, e) {
          const n = e.providers
          const o = e.extraProviders || []
          const i = new Set(e.removeProviders)
          const r = n.concat(o).filter((t) => {
            const e = t.name
            if (!e) {
              L('media-embed-no-provider-name', { provider: t })
              return false
            }
            return !i.has(e)
          })
          this.locale = t
          this.providerDefinitions = r
        }
        hasMedia(t) {
          return !!this._getMedia(t)
        }
        getMediaViewElement(t, e, n) {
          return this._getMedia(e).getViewElement(t, n)
        }
        _getMedia(t) {
          if (!t) {
            return new $j(this.locale)
          }
          t = t.trim()
          for (const e of this.providerDefinitions) {
            const n = e.html
            const o = sl(e.url)
            for (const e of o) {
              const o = this._getUrlMatches(t, e)
              if (o) {
                return new $j(this.locale, t, o, n)
              }
            }
          }
          return null
        }
        _getUrlMatches(t, e) {
          let n = t.match(e)
          if (n) {
            return n
          }
          let o = t.replace(/^https?:\/\//, '')
          n = o.match(e)
          if (n) {
            return n
          }
          o = o.replace(/^www\./, '')
          n = o.match(e)
          if (n) {
            return n
          }
          return null
        }
      }
      class $j {
        constructor(t, e, n, o) {
          this.url = this._getValidUrl(e)
          this._locale = t
          this._match = n
          this._previewRenderer = o
        }
        getViewElement(t, e) {
          const n = {}
          let o
          if (e.renderForEditingView || (e.renderMediaPreview && this.url && this._previewRenderer)) {
            if (this.url) {
              n['data-oembed-url'] = this.url
            }
            if (e.renderForEditingView) {
              n.class = 'ck-media__wrapper'
            }
            const i = this._getPreviewHtml(e)
            o = t.createRawElement('div', n, (t, e) => {
              e.setContentOf(t, i)
            })
          } else {
            if (this.url) {
              n.url = this.url
            }
            o = t.createEmptyElement(e.elementName, n)
          }
          t.setCustomProperty('media-content', true, o)
          return o
        }
        _getPreviewHtml(t) {
          if (this._previewRenderer) {
            return this._previewRenderer(this._match)
          } else {
            if (this.url && t.renderForEditingView) {
              return this._getPlaceholderHtml()
            }
            return ''
          }
        }
        _getPlaceholderHtml() {
          const t = new Cd()
          const e = this._locale.t
          t.content = Wj
          t.viewBox = Gj
          const n = new Wl({
            tag: 'div',
            attributes: { class: 'ck ck-reset_all ck-media__placeholder' },
            children: [
              { tag: 'div', attributes: { class: 'ck-media__placeholder__icon' }, children: [t] },
              {
                tag: 'a',
                attributes: {
                  class: 'ck-media__placeholder__url',
                  target: '_blank',
                  rel: 'noopener noreferrer',
                  href: this.url,
                  'data-cke-tooltip-text': e('Open media in new tab'),
                },
                children: [
                  { tag: 'span', attributes: { class: 'ck-media__placeholder__url__text' }, children: [this.url] },
                ],
              },
            ],
          }).render()
          return n.outerHTML
        }
        _getValidUrl(t) {
          if (!t) {
            return null
          }
          if (t.match(/^https?/)) {
            return t
          }
          return 'https://' + t
        }
      }
      var Kj = n(1922)
      var Yj = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      Yj.insert = 'head'
      Yj.singleton = true
      var Zj = Rl()(Kj.Z, Yj)
      const Qj = Kj.Z.locals || {}
      class Jj extends Du {
        static get pluginName() {
          return 'MediaEmbedEditing'
        }
        constructor(t) {
          super(t)
          t.config.define('mediaEmbed', {
            elementName: 'oembed',
            providers: [
              {
                name: 'dailymotion',
                url: /^dailymotion\.com\/video\/(\w+)/,
                html: (t) => {
                  const e = t[1]
                  return (
                    '<div style="position: relative; padding-bottom: 100%; height: 0; ">' +
                    `<iframe src="https://www.dailymotion.com/embed/video/${e}" ` +
                    'style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" ' +
                    'frameborder="0" width="480" height="270" allowfullscreen allow="autoplay">' +
                    '</iframe>' +
                    '</div>'
                  )
                },
              },
              {
                name: 'spotify',
                url: [
                  /^open\.spotify\.com\/(artist\/\w+)/,
                  /^open\.spotify\.com\/(album\/\w+)/,
                  /^open\.spotify\.com\/(track\/\w+)/,
                ],
                html: (t) => {
                  const e = t[1]
                  return (
                    '<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 126%;">' +
                    `<iframe src="https://open.spotify.com/embed/${e}" ` +
                    'style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" ' +
                    'frameborder="0" allowtransparency="true" allow="encrypted-media">' +
                    '</iframe>' +
                    '</div>'
                  )
                },
              },
              {
                name: 'youtube',
                url: [
                  /^(?:m\.)?youtube\.com\/watch\?v=([\w-]+)(?:&t=(\d+))?/,
                  /^(?:m\.)?youtube\.com\/v\/([\w-]+)(?:\?t=(\d+))?/,
                  /^youtube\.com\/embed\/([\w-]+)(?:\?start=(\d+))?/,
                  /^youtu\.be\/([\w-]+)(?:\?t=(\d+))?/,
                ],
                html: (t) => {
                  const e = t[1]
                  const n = t[2]
                  return (
                    '<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 56.2493%;">' +
                    `<iframe src="https://www.youtube.com/embed/${e}${n ? `?start=${n}` : ''}" ` +
                    'style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" ' +
                    'frameborder="0" allow="autoplay; encrypted-media" allowfullscreen>' +
                    '</iframe>' +
                    '</div>'
                  )
                },
              },
              {
                name: 'vimeo',
                url: [
                  /^vimeo\.com\/(\d+)/,
                  /^vimeo\.com\/[^/]+\/[^/]+\/video\/(\d+)/,
                  /^vimeo\.com\/album\/[^/]+\/video\/(\d+)/,
                  /^vimeo\.com\/channels\/[^/]+\/(\d+)/,
                  /^vimeo\.com\/groups\/[^/]+\/videos\/(\d+)/,
                  /^vimeo\.com\/ondemand\/[^/]+\/(\d+)/,
                  /^player\.vimeo\.com\/video\/(\d+)/,
                ],
                html: (t) => {
                  const e = t[1]
                  return (
                    '<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 56.2493%;">' +
                    `<iframe src="https://player.vimeo.com/video/${e}" ` +
                    'style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" ' +
                    'frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen>' +
                    '</iframe>' +
                    '</div>'
                  )
                },
              },
              { name: 'instagram', url: /^instagram\.com\/p\/(\w+)/ },
              { name: 'twitter', url: /^twitter\.com/ },
              {
                name: 'googleMaps',
                url: [/^google\.com\/maps/, /^goo\.gl\/maps/, /^maps\.google\.com/, /^maps\.app\.goo\.gl/],
              },
              { name: 'flickr', url: /^flickr\.com/ },
              { name: 'facebook', url: /^facebook\.com/ },
            ],
          })
          this.registry = new qj(t.locale, t.config.get('mediaEmbed'))
        }
        init() {
          const t = this.editor
          const e = t.model.schema
          const n = t.t
          const o = t.conversion
          const i = t.config.get('mediaEmbed.previewsInData')
          const r = t.config.get('mediaEmbed.elementName')
          const s = this.registry
          t.commands.add('mediaEmbed', new jj(t))
          e.register('media', { inheritAllFrom: '$blockObject', allowAttributes: ['url'] })
          o.for('dataDowncast').elementToStructure({
            model: 'media',
            view: (t, { writer: e }) => {
              const n = t.getAttribute('url')
              return Oj(e, s, n, { elementName: r, renderMediaPreview: !!n && i })
            },
          })
          o.for('dataDowncast').add(Pj(s, { elementName: r, renderMediaPreview: i }))
          o.for('editingDowncast').elementToStructure({
            model: 'media',
            view: (t, { writer: e }) => {
              const o = t.getAttribute('url')
              const i = Oj(e, s, o, { elementName: r, renderForEditingView: true })
              return Lj(i, e, n('media widget'))
            },
          })
          o.for('editingDowncast').add(Pj(s, { elementName: r, renderForEditingView: true }))
          o.for('upcast')
            .elementToElement({
              view: (t) => (['oembed', r].includes(t.name) && t.getAttribute('url') ? { name: true } : null),
              model: (t, { writer: e }) => {
                const n = t.getAttribute('url')
                if (s.hasMedia(n)) {
                  return e.createElement('media', { url: n })
                }
                return null
              },
            })
            .elementToElement({
              view: { name: 'div', attributes: { 'data-oembed-url': true } },
              model: (t, { writer: e }) => {
                const n = t.getAttribute('data-oembed-url')
                if (s.hasMedia(n)) {
                  return e.createElement('media', { url: n })
                }
                return null
              },
            })
            .add((t) => {
              const e = (t, e, n) => {
                if (!n.consumable.consume(e.viewItem, { name: true, classes: 'media' })) {
                  return
                }
                const { modelRange: o, modelCursor: i } = n.convertChildren(e.viewItem, e.modelCursor)
                e.modelRange = o
                e.modelCursor = i
                const r = bl(o.getItems())
                if (!r) {
                  n.consumable.revert(e.viewItem, { name: true, classes: 'media' })
                }
              }
              t.on('element:figure', e)
            })
        }
      }
      const Xj = /^(?:http(s)?:\/\/)?[\w-]+\.[\w-.~:/?#[\]@!$&'()*+,;=%]+$/
      class tH extends Du {
        static get requires() {
          return [ZM, cT, EB]
        }
        static get pluginName() {
          return 'AutoMediaEmbed'
        }
        constructor(t) {
          super(t)
          this._timeoutId = null
          this._positionToInsert = null
        }
        init() {
          const t = this.editor
          const e = t.model.document
          const n = t.plugins.get('ClipboardPipeline')
          this.listenTo(n, 'inputTransformation', () => {
            const t = e.selection.getFirstRange()
            const n = GA.fromPosition(t.start)
            n.stickiness = 'toPrevious'
            const o = GA.fromPosition(t.end)
            o.stickiness = 'toNext'
            e.once(
              'change:data',
              () => {
                this._embedMediaBetweenPositions(n, o)
                n.detach()
                o.detach()
              },
              { priority: 'high' },
            )
          })
          const o = t.commands.get('undo')
          o.on(
            'execute',
            () => {
              if (this._timeoutId) {
                oc.window.clearTimeout(this._timeoutId)
                this._positionToInsert.detach()
                this._timeoutId = null
                this._positionToInsert = null
              }
            },
            { priority: 'high' },
          )
        }
        _embedMediaBetweenPositions(t, e) {
          const n = this.editor
          const o = n.plugins.get(Jj).registry
          const i = new Zb(t, e)
          const r = i.getWalker({ ignoreElementEnd: true })
          let s = ''
          for (const t of r) {
            if (t.item.is('$textProxy')) {
              s += t.item.data
            }
          }
          s = s.trim()
          if (!s.match(Xj)) {
            i.detach()
            return
          }
          if (!o.hasMedia(s)) {
            i.detach()
            return
          }
          const a = n.commands.get('mediaEmbed')
          if (!a.isEnabled) {
            i.detach()
            return
          }
          this._positionToInsert = GA.fromPosition(t)
          this._timeoutId = oc.window.setTimeout(() => {
            n.model.change((t) => {
              this._timeoutId = null
              t.remove(i)
              i.detach()
              let e = null
              if (this._positionToInsert.root.rootName !== '$graveyard') {
                e = this._positionToInsert
              }
              Fj(n.model, s, e, false)
              this._positionToInsert.detach()
              this._positionToInsert = null
            })
            n.plugins.get(cT).requestUndoOnBackspace()
          }, 100)
        }
      }
      var eH = n(7138)
      var nH = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      nH.insert = 'head'
      nH.singleton = true
      var oH = Rl()(eH.Z, nH)
      const iH = eH.Z.locals || {}
      class rH extends Hl {
        constructor(t, e) {
          super(e)
          const n = e.t
          this.focusTracker = new kl()
          this.keystrokes = new wl()
          this.set('mediaURLInputValue', '')
          this.urlInputView = this._createUrlInput()
          this.saveButtonView = this._createButton(n('Save'), Sv.check, 'ck-button-save')
          this.saveButtonView.type = 'submit'
          this.saveButtonView.bind('isEnabled').to(this, 'mediaURLInputValue', (t) => !!t)
          this.cancelButtonView = this._createButton(n('Cancel'), Sv.cancel, 'ck-button-cancel', 'cancel')
          this._focusables = new Pl()
          this._focusCycler = new _u({
            focusables: this._focusables,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: { focusPrevious: 'shift + tab', focusNext: 'tab' },
          })
          this._validators = t
          this.setTemplate({
            tag: 'form',
            attributes: { class: ['ck', 'ck-media-form', 'ck-responsive-form'], tabindex: '-1' },
            children: [this.urlInputView, this.saveButtonView, this.cancelButtonView],
          })
        }
        render() {
          super.render()
          i({ view: this })
          const t = [this.urlInputView, this.saveButtonView, this.cancelButtonView]
          t.forEach((t) => {
            this._focusables.add(t)
            this.focusTracker.add(t.element)
          })
          this.keystrokes.listenTo(this.element)
          const e = (t) => t.stopPropagation()
          this.keystrokes.set('arrowright', e)
          this.keystrokes.set('arrowleft', e)
          this.keystrokes.set('arrowup', e)
          this.keystrokes.set('arrowdown', e)
        }
        destroy() {
          super.destroy()
          this.focusTracker.destroy()
          this.keystrokes.destroy()
        }
        focus() {
          this._focusCycler.focusFirst()
        }
        get url() {
          return this.urlInputView.fieldView.element.value.trim()
        }
        set url(t) {
          this.urlInputView.fieldView.element.value = t.trim()
        }
        isValid() {
          this.resetFormStatus()
          for (const t of this._validators) {
            const e = t(this)
            if (e) {
              this.urlInputView.errorText = e
              return false
            }
          }
          return true
        }
        resetFormStatus() {
          this.urlInputView.errorText = null
          this.urlInputView.infoText = this._urlInputViewInfoDefault
        }
        _createUrlInput() {
          const t = this.locale.t
          const e = new iu(this.locale, Ay)
          const n = e.fieldView
          this._urlInputViewInfoDefault = t('Paste the media URL in the input.')
          this._urlInputViewInfoTip = t('Tip: Paste the URL into the content to embed faster.')
          e.label = t('Media URL')
          e.infoText = this._urlInputViewInfoDefault
          n.on('input', () => {
            e.infoText = n.element.value ? this._urlInputViewInfoTip : this._urlInputViewInfoDefault
            this.mediaURLInputValue = n.element.value.trim()
          })
          return e
        }
        _createButton(t, e, n, o) {
          const i = new Dd(this.locale)
          i.set({ label: t, icon: e, tooltip: true })
          i.extendTemplate({ attributes: { class: n } })
          if (o) {
            i.delegate('execute').to(this, o)
          }
          return i
        }
      }
      const sH =
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M18.68 3.03c.6 0 .59-.03.59.55v12.84c0 .59.01.56-.59.56H1.29c-.6 0-.59.03-.59-.56V3.58c0-.58-.01-.55.6-.55h17.38zM15.77 15V5H4.2v10h11.57zM2 4v1h1V4H2zm0 2v1h1V6H2zm0 2v1h1V8H2zm0 2v1h1v-1H2zm0 2v1h1v-1H2zm0 2v1h1v-1H2zM17 4v1h1V4h-1zm0 2v1h1V6h-1zm0 2v1h1V8h-1zm0 2v1h1v-1h-1zm0 2v1h1v-1h-1zm0 2v1h1v-1h-1zM7.5 7.177a.4.4 0 0 1 .593-.351l5.133 2.824a.4.4 0 0 1 0 .7l-5.133 2.824a.4.4 0 0 1-.593-.35V7.176v.001z"/></svg>'
      class aH extends Du {
        static get requires() {
          return [Jj]
        }
        static get pluginName() {
          return 'MediaEmbedUI'
        }
        init() {
          const t = this.editor
          const e = t.commands.get('mediaEmbed')
          t.ui.componentFactory.add('mediaEmbed', (t) => {
            const n = ay(t)
            this._setUpDropdown(n, e)
            return n
          })
        }
        _setUpDropdown(t, n) {
          const o = this.editor
          const i = o.t
          const r = t.buttonView
          const s = o.plugins.get(Jj).registry
          t.once('change:isOpen', () => {
            const i = new (e(rH))(cH(o.t, s), o.locale)
            t.panelView.children.add(i)
            r.on(
              'open',
              () => {
                i.disableCssTransitions()
                i.url = n.value || ''
                i.urlInputView.fieldView.select()
                i.enableCssTransitions()
              },
              { priority: 'low' },
            )
            t.on('submit', () => {
              if (i.isValid()) {
                o.execute('mediaEmbed', i.url)
                o.editing.view.focus()
              }
            })
            t.on('change:isOpen', () => i.resetFormStatus())
            t.on('cancel', () => {
              o.editing.view.focus()
            })
            i.delegate('submit', 'cancel').to(t)
            i.urlInputView.fieldView.bind('value').to(n, 'value')
            i.urlInputView.bind('isEnabled').to(n, 'isEnabled')
          })
          t.bind('isEnabled').to(n)
          r.set({ label: i('Insert media'), icon: sH, tooltip: true })
        }
      }
      function cH(t, e) {
        return [
          (e) => {
            if (!e.url.length) {
              return t('The URL must not be empty.')
            }
          },
          (n) => {
            if (!e.hasMedia(n.url)) {
              return t('This media URL is not supported.')
            }
          },
        ]
      }
      var lH = n(8705)
      var dH = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      dH.insert = 'head'
      dH.singleton = true
      var uH = Rl()(lH.Z, dH)
      const hH = lH.Z.locals || {}
      class gH extends Du {
        static get requires() {
          return [Jj, aH, tH, hM]
        }
        static get pluginName() {
          return 'MediaEmbed'
        }
      }
      class fH extends (null && Plugin) {
        static get requires() {
          return [WidgetToolbarRepository]
        }
        static get pluginName() {
          return 'MediaEmbedToolbar'
        }
        afterInit() {
          const t = this.editor
          const e = t.t
          const n = t.plugins.get(WidgetToolbarRepository)
          n.register('mediaEmbed', {
            ariaLabel: e('Media toolbar'),
            items: t.config.get('mediaEmbed.toolbar') || [],
            getRelatedElement: getSelectedMediaViewWidget,
          })
        }
      }
      function mH(t, e) {
        if (!t.childCount) {
          return
        }
        const n = new Y_(t.document)
        const o = bH(t, n)
        if (!o.length) {
          return
        }
        let i = null
        let r = 1
        o.forEach((t, s) => {
          const a = EH(o[s - 1], t)
          const c = a ? null : o[s - 1]
          const l = TH(c, t)
          if (a) {
            i = null
            r = 1
          }
          if (!i || l !== 0) {
            const o = kH(t, e)
            if (!i) {
              i = CH(o, t.element, n)
            } else if (t.indent > r) {
              const t = i.getChild(i.childCount - 1)
              const e = t.getChild(t.childCount - 1)
              i = CH(o, e, n)
              r += 1
            } else if (t.indent < r) {
              const e = r - t.indent
              i = IH(i, e)
              r = t.indent
            }
            if (t.indent <= r) {
              if (!i.is('element', o.type)) {
                i = n.rename(o.type, i)
              }
            }
          }
          const d = vH(t.element, n)
          n.appendChild(d, i)
        })
      }
      function pH(t, e) {
        for (const n of e.createRangeIn(t)) {
          const t = n.item
          if (t.is('element', 'li')) {
            const n = t.getChild(0)
            if (n && n.is('element', 'p')) {
              e.unwrapElement(n)
            }
          }
        }
      }
      function bH(t, e) {
        const n = e.createRangeIn(t)
        const o = new eh({ name: /^p|h\d+$/, styles: { 'mso-list': /.*/ } })
        const i = []
        for (const t of n) {
          if (t.type === 'elementStart' && o.match(t.item)) {
            const e = yH(t.item)
            i.push({ element: t.item, id: e.id, order: e.order, indent: e.indent })
          }
        }
        return i
      }
      function kH(t, e) {
        const n = new RegExp(`@list l${t.id}:level${t.indent}\\s*({[^}]*)`, 'gi')
        const o = /mso-level-number-format:([^;]{0,100});/gi
        const i = /mso-level-start-at:\s{0,100}([0-9]{0,10})\s{0,100};/gi
        const r = n.exec(e)
        let s = 'decimal'
        let a = 'ol'
        let c = null
        if (r && r[1]) {
          const e = o.exec(r[1])
          if (e && e[1]) {
            s = e[1].trim()
            a = s !== 'bullet' && s !== 'image' ? 'ol' : 'ul'
          }
          if (s === 'bullet') {
            const e = wH(t.element)
            if (e) {
              s = e
            }
          } else {
            const t = i.exec(r[1])
            if (t && t[1]) {
              c = parseInt(t[1])
            }
          }
        }
        return { type: a, startIndex: c, style: _H(s) }
      }
      function wH(t) {
        const e = AH(t)
        if (!e) {
          return null
        }
        const n = e._data
        if (n === 'o') {
          return 'circle'
        } else if (n === '·') {
          return 'disc'
        } else if (n === '§') {
          return 'square'
        }
        return null
      }
      function AH(t) {
        if (t.getChild(0).is('$text')) {
          return null
        }
        for (const e of t.getChildren()) {
          if (!e.is('element', 'span')) {
            continue
          }
          const t = e.getChild(0)
          if (!t) {
            continue
          }
          if (t.is('$text')) {
            return t
          }
          return t.getChild(0)
        }
        return null
      }
      function _H(t) {
        if (t.startsWith('arabic-leading-zero')) {
          return 'decimal-leading-zero'
        }
        switch (t) {
          case 'alpha-upper':
            return 'upper-alpha'
          case 'alpha-lower':
            return 'lower-alpha'
          case 'roman-upper':
            return 'upper-roman'
          case 'roman-lower':
            return 'lower-roman'
          case 'circle':
          case 'disc':
          case 'square':
            return t
          default:
            return null
        }
      }
      function CH(t, e, n) {
        const o = e.parent
        const i = n.createElement(t.type)
        const r = o.getChildIndex(e) + 1
        n.insertChild(r, i, o)
        if (t.style) {
          n.setStyle('list-style-type', t.style, i)
        }
        if (t.startIndex && t.startIndex > 1) {
          n.setAttribute('start', t.startIndex, i)
        }
        return i
      }
      function vH(t, e) {
        xH(t, e)
        e.removeStyle('text-indent', t)
        return e.rename('li', t)
      }
      function yH(t) {
        const e = {}
        const n = t.getStyle('mso-list')
        if (n) {
          const t = n.match(/(^|\s{1,100})l(\d+)/i)
          const o = n.match(/\s{0,100}lfo(\d+)/i)
          const i = n.match(/\s{0,100}level(\d+)/i)
          if (t && o && i) {
            e.id = t[2]
            e.order = o[1]
            e.indent = parseInt(i[1])
          }
        }
        return e
      }
      function xH(t, e) {
        const n = new eh({ name: 'span', styles: { 'mso-list': 'Ignore' } })
        const o = e.createRangeIn(t)
        for (const t of o) {
          if (t.type === 'elementStart' && n.match(t.item)) {
            e.remove(t.item)
          }
        }
      }
      function EH(t, e) {
        if (!t) {
          return true
        }
        if (t.id !== e.id) {
          if (e.indent - t.indent === 1) {
            return false
          }
          return true
        }
        const n = e.element.previousSibling
        if (!n) {
          return true
        }
        return !DH(n)
      }
      function DH(t) {
        return t.is('element', 'ol') || t.is('element', 'ul')
      }
      function TH(t, e) {
        return t ? e.indent - t.indent : e.indent - 1
      }
      function IH(t, e) {
        const n = t.getAncestors({ parentFirst: true })
        let o = null
        let i = 0
        for (const t of n) {
          if (t.is('element', 'ul') || t.is('element', 'ol')) {
            i++
          }
          if (i === e) {
            o = t
            break
          }
        }
        return o
      }
      function SH(t, e) {
        if (!t.childCount) {
          return
        }
        const n = new Y_(t.document)
        const o = BH(t, n)
        NH(o, t, n)
        LH(o, t, n)
        PH(t, n)
        const i = zH(t, n)
        if (i.length) {
          OH(i, RH(e), n)
        }
      }
      function MH(t) {
        return btoa(
          t
            .match(/\w{2}/g)
            .map((t) => String.fromCharCode(parseInt(t, 16)))
            .join(''),
        )
      }
      function BH(t, e) {
        const n = e.createRangeIn(t)
        const o = new eh({ name: /v:(.+)/ })
        const i = []
        for (const t of n) {
          if (t.type != 'elementStart') {
            continue
          }
          const e = t.item
          const n = e.previousSibling
          const r = n && n.is('element') ? n.name : null
          if (o.match(e) && e.getAttribute('o:gfxdata') && r !== 'v:shapetype') {
            i.push(t.item.getAttribute('id'))
          }
        }
        return i
      }
      function NH(t, e, n) {
        const o = n.createRangeIn(e)
        const i = new eh({ name: 'img' })
        const r = []
        for (const e of o) {
          if (e.item.is('element') && i.match(e.item)) {
            const n = e.item
            const o = n.getAttribute('v:shapes') ? n.getAttribute('v:shapes').split(' ') : []
            if (o.length && o.every((e) => t.indexOf(e) > -1)) {
              r.push(n)
            } else if (!n.getAttribute('src')) {
              r.push(n)
            }
          }
        }
        for (const t of r) {
          n.remove(t)
        }
      }
      function PH(t, e) {
        const n = e.createRangeIn(t)
        const o = new eh({ name: /v:(.+)/ })
        const i = []
        for (const t of n) {
          if (t.type == 'elementStart' && o.match(t.item)) {
            i.push(t.item)
          }
        }
        for (const t of i) {
          e.remove(t)
        }
      }
      function LH(t, e, n) {
        const o = n.createRangeIn(e)
        const i = []
        for (const e of o) {
          if (e.type == 'elementStart' && e.item.is('element', 'v:shape')) {
            const n = e.item.getAttribute('id')
            if (t.includes(n)) {
              continue
            }
            if (!r(e.item.parent.getChildren(), n)) {
              i.push(e.item)
            }
          }
        }
        for (const t of i) {
          const e = { src: s(t) }
          if (t.hasAttribute('alt')) {
            e.alt = t.getAttribute('alt')
          }
          const o = n.createElement('img', e)
          n.insertChild(t.index + 1, o, t.parent)
        }
        function r(t, e) {
          for (const n of t) {
            if (n.is('element')) {
              if (n.name == 'img' && n.getAttribute('v:shapes') == e) {
                return true
              }
              if (r(n.getChildren(), e)) {
                return true
              }
            }
          }
          return false
        }
        function s(t) {
          for (const e of t.getChildren()) {
            if (e.is('element') && e.getAttribute('src')) {
              return e.getAttribute('src')
            }
          }
        }
      }
      function zH(t, e) {
        const n = e.createRangeIn(t)
        const o = new eh({ name: 'img' })
        const i = []
        for (const t of n) {
          if (t.item.is('element') && o.match(t.item)) {
            if (t.item.getAttribute('src').startsWith('file://')) {
              i.push(t.item)
            }
          }
        }
        return i
      }
      function RH(t) {
        if (!t) {
          return []
        }
        const e = /{\\pict[\s\S]+?\\bliptag-?\d+(\\blipupi-?\d+)?({\\\*\\blipuid\s?[\da-fA-F]+)?[\s}]*?/
        const n = new RegExp('(?:(' + e.source + '))([\\da-fA-F\\s]+)\\}', 'g')
        const o = t.match(n)
        const i = []
        if (o) {
          for (const t of o) {
            let n = false
            if (t.includes('\\pngblip')) {
              n = 'image/png'
            } else if (t.includes('\\jpegblip')) {
              n = 'image/jpeg'
            }
            if (n) {
              i.push({ hex: t.replace(e, '').replace(/[^\da-fA-F]/g, ''), type: n })
            }
          }
        }
        return i
      }
      function OH(t, e, n) {
        if (t.length === e.length) {
          for (let o = 0; o < t.length; o++) {
            const i = `data:${e[o].type};base64,${MH(e[o].hex)}`
            n.setAttribute('src', i, t[o])
          }
        }
      }
      function VH(t) {
        const e = new Y_(t.document)
        for (const n of t.getChildren()) {
          if (!n.is('element')) {
            continue
          }
          if (n.is('element', 'table')) {
            e.setAttribute('align', 'left', n)
            continue
          }
          const t = n.getAttribute('align')
          const o = n.getChild(0)
          if (n.name !== 'div' || !t || !o) {
            continue
          }
          if (o.is('element', 'table')) {
            e.setAttribute('align', t === 'center' ? 'none' : t, o)
          }
        }
      }
      const FH = /<meta\s*name="?generator"?\s*content="?microsoft\s*word\s*\d+"?\/?>/i
      const jH = /xmlns:o="urn:schemas-microsoft-com/i
      class HH {
        constructor(t) {
          this.document = t
        }
        isActive(t) {
          return FH.test(t) || jH.test(t)
        }
        execute(t) {
          const { body: e, stylesString: n } = t._parsedData
          mH(e, n)
          SH(e, t.dataTransfer.getData('text/rtf'))
          VH(e)
          t.content = e
        }
      }
      function UH(t, e) {
        for (const n of t.getChildren()) {
          if (n.is('element', 'b') && n.getStyle('font-weight') === 'normal') {
            const o = t.getChildIndex(n)
            e.remove(n)
            e.insertChild(o, n.getChildren(), t)
          }
        }
      }
      function WH(t, e) {
        const n = new vf(e.document.stylesProcessor)
        const o = new xm(n, { renderingMode: 'data' })
        const i = o.blockElements
        const r = o.inlineObjectElements
        const s = []
        for (const n of e.createRangeIn(t)) {
          const t = n.item
          if (t.is('element', 'br')) {
            const n = GH(t, 'forward', e, { blockElements: i, inlineObjectElements: r })
            const o = GH(t, 'backward', e, { blockElements: i, inlineObjectElements: r })
            const a = qH(n, i)
            const c = qH(o, i)
            if (c || a) {
              s.push(t)
            }
          }
        }
        for (const t of s) {
          if (t.hasClass('Apple-interchange-newline')) {
            e.remove(t)
          } else {
            e.replace(t, e.createElement('p'))
          }
        }
      }
      function GH(t, e, n, { blockElements: o, inlineObjectElements: i }) {
        let r = n.createPositionAt(t, e == 'forward' ? 'after' : 'before')
        r = r.getLastMatchingPosition(({ item: t }) => t.is('element') && !o.includes(t.name) && !i.includes(t.name), {
          direction: e,
        })
        return e == 'forward' ? r.nodeAfter : r.nodeBefore
      }
      function qH(t, e) {
        return !!t && t.is('element') && e.includes(t.name)
      }
      const $H = /id=("|')docs-internal-guid-[-0-9a-f]+("|')/i
      class KH {
        constructor(t) {
          this.document = t
        }
        isActive(t) {
          return $H.test(t)
        }
        execute(t) {
          const e = new Y_(this.document)
          const { body: n } = t._parsedData
          UH(n, e)
          pH(n, e)
          WH(n, e)
          t.content = n
        }
      }
      function YH(t, e) {
        for (const n of t.getChildren()) {
          if (n.is('element', 'table') && n.hasAttribute('xmlns')) {
            e.removeAttribute('xmlns', n)
          }
        }
      }
      function ZH(t, e) {
        for (const n of t.getChildren()) {
          if (n.is('element', 'google-sheets-html-origin')) {
            const o = t.getChildIndex(n)
            e.remove(n)
            e.insertChild(o, n.getChildren(), t)
          }
        }
      }
      function QH(t, e) {
        for (const n of t.getChildren()) {
          if (n.is('element', 'table') && n.getStyle('width') === '0px') {
            e.removeStyle('width', n)
          }
        }
      }
      function JH(t, e) {
        for (const n of Array.from(t.getChildren())) {
          if (n.is('element', 'style')) {
            e.remove(n)
          }
        }
      }
      const XH = /<google-sheets-html-origin/i
      class tU {
        constructor(t) {
          this.document = t
        }
        isActive(t) {
          return XH.test(t)
        }
        execute(t) {
          const e = new Y_(this.document)
          const { body: n } = t._parsedData
          ZH(n, e)
          YH(n, e)
          QH(n, e)
          JH(n, e)
          t.content = n
        }
      }
      function eU(t) {
        return oU(oU(t))
          .replace(/(<span\s+style=['"]mso-spacerun:yes['"]>[^\S\r\n]*?)[\r\n]+([^\S\r\n]*<\/span>)/g, '$1$2')
          .replace(/<span\s+style=['"]mso-spacerun:yes['"]><\/span>/g, '')
          .replace(/(<span\s+style=['"]letter-spacing:[^'"]+?['"]>)[\r\n]+(<\/span>)/g, '$1 $2')
          .replace(/ <\//g, ' </')
          .replace(/ <o:p><\/o:p>/g, ' <o:p></o:p>')
          .replace(/<o:p>(&nbsp;|\u00A0)<\/o:p>/g, '')
          .replace(/>([^\S\r\n]*[\r\n]\s*)</g, '><')
      }
      function nU(t) {
        t.querySelectorAll('span[style*=spacerun]').forEach((t) => {
          const e = t
          const n = e.innerText.length || 0
          e.innerText = Array(n + 1)
            .join('  ')
            .substr(0, n)
        })
      }
      function oU(t) {
        return t.replace(/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g, (t, e) =>
          e.length === 1
            ? ' '
            : Array(e.length + 1)
                .join('  ')
                .substr(0, e.length),
        )
      }
      function iU(t, e) {
        const n = new DOMParser()
        t = t.replace(/<!--\[if gte vml 1]>/g, '')
        const o = eU(aU(t))
        const i = n.parseFromString(o, 'text/html')
        nU(i)
        const r = i.body.innerHTML
        const s = rU(i, e)
        const a = sU(i)
        return { body: s, bodyString: r, styles: a.styles, stylesString: a.stylesString }
      }
      function rU(t, e) {
        const n = new vf(e)
        const o = new xm(n, { renderingMode: 'data' })
        const i = t.createDocumentFragment()
        const r = t.body.childNodes
        while (r.length > 0) {
          i.appendChild(r[0])
        }
        return o.domToView(i, { skipComments: true })
      }
      function sU(t) {
        const e = []
        const n = []
        const o = Array.from(t.getElementsByTagName('style'))
        for (const t of o) {
          if (t.sheet && t.sheet.cssRules && t.sheet.cssRules.length) {
            e.push(t.sheet)
            n.push(t.innerHTML)
          }
        }
        return { styles: e, stylesString: n.join(' ') }
      }
      function aU(t) {
        const e = '</body>'
        const n = '</html>'
        const o = t.indexOf(e)
        if (o < 0) {
          return t
        }
        const i = t.indexOf(n, o + e.length)
        return t.substring(0, o + e.length) + (i >= 0 ? t.substring(i) : '')
      }
      class cU extends Du {
        static get pluginName() {
          return 'PasteFromOffice'
        }
        static get requires() {
          return [bS]
        }
        init() {
          const t = this.editor
          const e = t.plugins.get('ClipboardPipeline')
          const n = t.editing.view.document
          const o = []
          o.push(new HH(n))
          o.push(new KH(n))
          o.push(new tU(n))
          e.on(
            'inputTransformation',
            (e, i) => {
              if (i._isTransformedWithPasteFromOffice) {
                return
              }
              const r = t.model.document.selection.getFirstPosition().parent
              if (r.is('element', 'codeBlock')) {
                return
              }
              const s = i.dataTransfer.getData('text/html')
              const a = o.find((t) => t.isActive(s))
              if (a) {
                if (!i._parsedData) {
                  i._parsedData = iU(s, n.stylesProcessor)
                }
                a.execute(i)
                i._isTransformedWithPasteFromOffice = true
              }
            },
            { priority: 'high' },
          )
        }
      }
      const lU =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8.69 14.915c.053.052.173.083.36.093a.366.366 0 0 1 .345.485l-.003.01a.738.738 0 0 1-.697.497h-2.67a.374.374 0 0 1-.353-.496l.013-.038a.681.681 0 0 1 .644-.458c.197-.012.325-.043.386-.093a.28.28 0 0 0 .072-.11L9.592 4.5H6.269c-.359-.017-.609.013-.75.09-.142.078-.289.265-.442.563-.192.29-.516.464-.864.464H4.17a.43.43 0 0 1-.407-.569L4.46 3h13.08l-.62 2.043a.81.81 0 0 1-.775.574h-.114a.486.486 0 0 1-.486-.486c.001-.284-.054-.464-.167-.54-.112-.076-.367-.106-.766-.091h-3.28l-2.68 10.257c-.006.074.007.127.038.158zM3 17h8a.5.5 0 1 1 0 1H3a.5.5 0 1 1 0-1zm11.299 1.17a.75.75 0 1 1-1.06-1.06l1.414-1.415-1.415-1.414a.75.75 0 0 1 1.06-1.06l1.415 1.414 1.414-1.415a.75.75 0 1 1 1.06 1.06l-1.413 1.415 1.414 1.415a.75.75 0 0 1-1.06 1.06l-1.415-1.414-1.414 1.414z"/></svg>'
      const dU = 'removeFormat'
      class uU extends Du {
        static get pluginName() {
          return 'RemoveFormatUI'
        }
        init() {
          const t = this.editor
          const e = t.t
          t.ui.componentFactory.add(dU, (n) => {
            const o = t.commands.get(dU)
            const i = new Dd(n)
            i.set({ label: e('Remove Format'), icon: lU, tooltip: true })
            i.bind('isOn', 'isEnabled').to(o, 'value', 'isEnabled')
            this.listenTo(i, 'execute', () => {
              t.execute(dU)
              t.editing.view.focus()
            })
            return i
          })
        }
      }
      class hU extends Iu {
        refresh() {
          const t = this.editor.model
          this.isEnabled = !!bl(this._getFormattingItems(t.document.selection, t.schema))
        }
        execute() {
          const t = this.editor.model
          const e = t.schema
          t.change((n) => {
            for (const o of this._getFormattingItems(t.document.selection, e)) {
              if (o.is('selection')) {
                for (const t of this._getFormattingAttributes(o, e)) {
                  n.removeSelectionAttribute(t)
                }
              } else {
                const t = n.createRangeOn(o)
                for (const i of this._getFormattingAttributes(o, e)) {
                  n.removeAttribute(i, t)
                }
              }
            }
          })
        }
        *_getFormattingItems(t, e) {
          const n = (t) => !!bl(this._getFormattingAttributes(t, e))
          for (const o of t.getRanges()) {
            for (const t of o.getItems()) {
              if (!e.isBlock(t) && n(t)) {
                yield t
              }
            }
          }
          for (const e of t.getSelectedBlocks()) {
            if (n(e)) {
              yield e
            }
          }
          if (n(t)) {
            yield t
          }
        }
        *_getFormattingAttributes(t, e) {
          for (const [n] of t.getAttributes()) {
            const t = e.getAttributeProperties(n)
            if (t && t.isFormatting) {
              yield n
            }
          }
        }
      }
      class gU extends Du {
        static get pluginName() {
          return 'RemoveFormatEditing'
        }
        init() {
          const t = this.editor
          t.commands.add('removeFormat', new hU(t))
        }
      }
      class fU extends Du {
        static get requires() {
          return [gU, uU]
        }
        static get pluginName() {
          return 'RemoveFormat'
        }
      }
      function mU(t, e, n, o, i = 1) {
        if (e !== undefined && e !== null && i !== undefined && i !== null && e > i) {
          o.setAttribute(t, e, n)
        } else {
          o.removeAttribute(t, n)
        }
      }
      function pU(t, e, n = {}) {
        const o = t.createElement('tableCell', n)
        t.insertElement('paragraph', o)
        t.insert(o, e)
        return o
      }
      function bU(t, e) {
        const n = e.parent.parent
        const o = parseInt(n.getAttribute('headingColumns') || '0')
        const { column: i } = t.getCellLocation(e)
        return !!o && i < o
      }
      function kU(t, e, n) {
        const { modelAttribute: o } = n
        t.extend('tableCell', { allowAttributes: [o] })
        upcastStyleToAttribute(e, { viewElement: /^(td|th)$/, ...n })
        downcastAttributeToStyle(e, { modelElement: 'tableCell', ...n })
      }
      function wU() {
        return (t) => {
          t.on('element:figure', (t, e, n) => {
            if (!n.consumable.test(e.viewItem, { name: true, classes: 'table' })) {
              return
            }
            const o = vU(e.viewItem)
            if (!o || !n.consumable.test(o, { name: true })) {
              return
            }
            n.consumable.consume(e.viewItem, { name: true, classes: 'table' })
            const i = n.convertItem(o, e.modelCursor)
            const r = bl(i.modelRange.getItems())
            if (!r) {
              n.consumable.revert(e.viewItem, { name: true, classes: 'table' })
              return
            }
            n.convertChildren(e.viewItem, n.writer.createPositionAt(r, 'end'))
            n.updateConversionResult(r, e)
          })
        }
      }
      function AU() {
        return (t) => {
          t.on('element:table', (t, e, n) => {
            const o = e.viewItem
            if (!n.consumable.test(o, { name: true })) {
              return
            }
            const { rows: i, headingRows: r, headingColumns: s } = yU(o)
            const a = {}
            if (s) {
              a.headingColumns = s
            }
            if (r) {
              a.headingRows = r
            }
            const c = n.writer.createElement('table', a)
            if (!n.safeInsert(c, e.modelCursor)) {
              return
            }
            n.consumable.consume(o, { name: true })
            i.forEach((t) => n.convertItem(t, n.writer.createPositionAt(c, 'end')))
            n.convertChildren(o, n.writer.createPositionAt(c, 'end'))
            if (c.isEmpty) {
              const t = n.writer.createElement('tableRow')
              n.writer.insert(t, n.writer.createPositionAt(c, 'end'))
              pU(n.writer, n.writer.createPositionAt(t, 'end'))
            }
            n.updateConversionResult(c, e)
          })
        }
      }
      function _U() {
        return (t) => {
          t.on(
            'element:tr',
            (t, e) => {
              if (e.viewItem.isEmpty && e.modelCursor.index == 0) {
                t.stop()
              }
            },
            { priority: 'high' },
          )
        }
      }
      function CU(t) {
        return (e) => {
          e.on(
            `element:${t}`,
            (t, e, { writer: n }) => {
              if (!e.modelRange) {
                return
              }
              const o = e.modelRange.start.nodeAfter
              const i = n.createPositionAt(o, 0)
              if (e.viewItem.isEmpty) {
                n.insertElement('paragraph', i)
                return
              }
              const r = Array.from(o.getChildren())
              if (r.every((t) => t.is('element', '$marker'))) {
                const t = n.createElement('paragraph')
                n.insert(t, n.createPositionAt(o, 0))
                for (const e of r) {
                  n.move(n.createRangeOn(e), n.createPositionAt(t, 'end'))
                }
              }
            },
            { priority: 'low' },
          )
        }
      }
      function vU(t) {
        for (const e of t.getChildren()) {
          if (e.is('element', 'table')) {
            return e
          }
        }
      }
      function yU(t) {
        let e = 0
        let n = undefined
        const o = []
        const i = []
        let r
        for (const s of Array.from(t.getChildren())) {
          if (s.name !== 'tbody' && s.name !== 'thead' && s.name !== 'tfoot') {
            continue
          }
          if (s.name === 'thead' && !r) {
            r = s
          }
          const t = Array.from(s.getChildren()).filter((t) => t.is('element', 'tr'))
          for (const a of t) {
            if (
              (r && s === r) ||
              (s.name === 'tbody' &&
                Array.from(a.getChildren()).length &&
                Array.from(a.getChildren()).every((t) => t.is('element', 'th')))
            ) {
              e++
              o.push(a)
            } else {
              i.push(a)
              const t = xU(a)
              if (!n || t < n) {
                n = t
              }
            }
          }
        }
        return { headingRows: e, headingColumns: n || 0, rows: [...o, ...i] }
      }
      function xU(t) {
        let e = 0
        let n = 0
        const o = Array.from(t.getChildren()).filter((t) => t.name === 'th' || t.name === 'td')
        while (n < o.length && o[n].name === 'th') {
          const t = o[n]
          const i = parseInt(t.getAttribute('colspan') || '1')
          e = e + i
          n++
        }
        return e
      }
      class EU {
        constructor(t, e = {}) {
          this._table = t
          this._startRow = e.row !== undefined ? e.row : e.startRow || 0
          this._endRow = e.row !== undefined ? e.row : e.endRow
          this._startColumn = e.column !== undefined ? e.column : e.startColumn || 0
          this._endColumn = e.column !== undefined ? e.column : e.endColumn
          this._includeAllSlots = !!e.includeAllSlots
          this._skipRows = new Set()
          this._row = 0
          this._rowIndex = 0
          this._column = 0
          this._cellIndex = 0
          this._spannedCells = new Map()
          this._nextCellAtColumn = -1
        }
        [Symbol.iterator]() {
          return this
        }
        next() {
          const t = this._table.getChild(this._rowIndex)
          if (!t || this._isOverEndRow()) {
            return { done: true, value: undefined }
          }
          if (!t.is('element', 'tableRow')) {
            this._rowIndex++
            return this.next()
          }
          if (this._isOverEndColumn()) {
            return this._advanceToNextRow()
          }
          let e = null
          const n = this._getSpanned()
          if (n) {
            if (this._includeAllSlots && !this._shouldSkipSlot()) {
              e = this._formatOutValue(n.cell, n.row, n.column)
            }
          } else {
            const n = t.getChild(this._cellIndex)
            if (!n) {
              return this._advanceToNextRow()
            }
            const o = parseInt(n.getAttribute('colspan') || '1')
            const i = parseInt(n.getAttribute('rowspan') || '1')
            if (o > 1 || i > 1) {
              this._recordSpans(n, i, o)
            }
            if (!this._shouldSkipSlot()) {
              e = this._formatOutValue(n)
            }
            this._nextCellAtColumn = this._column + o
          }
          this._column++
          if (this._column == this._nextCellAtColumn) {
            this._cellIndex++
          }
          return e || this.next()
        }
        skipRow(t) {
          this._skipRows.add(t)
        }
        _advanceToNextRow() {
          this._row++
          this._rowIndex++
          this._column = 0
          this._cellIndex = 0
          this._nextCellAtColumn = -1
          return this.next()
        }
        _isOverEndRow() {
          return this._endRow !== undefined && this._row > this._endRow
        }
        _isOverEndColumn() {
          return this._endColumn !== undefined && this._column > this._endColumn
        }
        _formatOutValue(t, e = this._row, n = this._column) {
          return { done: false, value: new DU(this, t, e, n) }
        }
        _shouldSkipSlot() {
          const t = this._skipRows.has(this._row)
          const e = this._row < this._startRow
          const n = this._column < this._startColumn
          const o = this._endColumn !== undefined && this._column > this._endColumn
          return t || e || n || o
        }
        _getSpanned() {
          const t = this._spannedCells.get(this._row)
          if (!t) {
            return null
          }
          return t.get(this._column) || null
        }
        _recordSpans(t, e, n) {
          const o = { cell: t, row: this._row, column: this._column }
          for (let t = this._row; t < this._row + e; t++) {
            for (let e = this._column; e < this._column + n; e++) {
              if (t != this._row || e != this._column) {
                this._markSpannedCell(t, e, o)
              }
            }
          }
        }
        _markSpannedCell(t, e, n) {
          if (!this._spannedCells.has(t)) {
            this._spannedCells.set(t, new Map())
          }
          const o = this._spannedCells.get(t)
          o.set(e, n)
        }
      }
      class DU {
        constructor(t, e, n, o) {
          this.cell = e
          this.row = t._row
          this.column = t._column
          this.cellAnchorRow = n
          this.cellAnchorColumn = o
          this._cellIndex = t._cellIndex
          this._rowIndex = t._rowIndex
          this._table = t._table
        }
        get isAnchor() {
          return this.row === this.cellAnchorRow && this.column === this.cellAnchorColumn
        }
        get cellWidth() {
          return parseInt(this.cell.getAttribute('colspan') || '1')
        }
        get cellHeight() {
          return parseInt(this.cell.getAttribute('rowspan') || '1')
        }
        get rowIndex() {
          return this._rowIndex
        }
        getPositionBefore() {
          const t = this._table.root.document.model
          return t.createPositionAt(this._table.getChild(this.row), this._cellIndex)
        }
      }
      function TU(t, e) {
        return (n, { writer: o }) => {
          const i = n.getAttribute('headingRows') || 0
          const r = o.createContainerElement('table', null, [])
          const s = o.createContainerElement('figure', { class: 'table' }, r)
          if (i > 0) {
            o.insert(
              o.createPositionAt(r, 'end'),
              o.createContainerElement(
                'thead',
                null,
                o.createSlot((t) => t.is('element', 'tableRow') && t.index < i),
              ),
            )
          }
          if (i < t.getRows(n)) {
            o.insert(
              o.createPositionAt(r, 'end'),
              o.createContainerElement(
                'tbody',
                null,
                o.createSlot((t) => t.is('element', 'tableRow') && t.index >= i),
              ),
            )
          }
          for (const { positionOffset: t, filter: n } of e.additionalSlots) {
            o.insert(o.createPositionAt(r, t), o.createSlot(n))
          }
          o.insert(
            o.createPositionAt(r, 'after'),
            o.createSlot((t) => {
              if (t.is('element', 'tableRow')) {
                return false
              }
              return !e.additionalSlots.some(({ filter: e }) => e(t))
            }),
          )
          return e.asWidget ? NU(s, o) : s
        }
      }
      function IU() {
        return (t, { writer: e }) => (t.isEmpty ? e.createEmptyElement('tr') : e.createContainerElement('tr'))
      }
      function SU(t = {}) {
        return (e, { writer: n }) => {
          const o = e.parent
          const i = o.parent
          const r = i.getChildIndex(o)
          const s = new EU(i, { row: r })
          const a = i.getAttribute('headingRows') || 0
          const c = i.getAttribute('headingColumns') || 0
          let l = null
          for (const o of s) {
            if (o.cell == e) {
              const e = o.row < a || o.column < c
              const i = e ? 'th' : 'td'
              l = t.asWidget ? BS(n.createEditableElement(i), n) : n.createContainerElement(i)
              break
            }
          }
          return l
        }
      }
      function MU(t = {}) {
        return (e, { writer: n }) => {
          if (!e.parent.is('element', 'tableCell')) {
            return null
          }
          if (!BU(e)) {
            return null
          }
          if (t.asWidget) {
            return n.createContainerElement('span', { class: 'ck-table-bogus-paragraph' })
          } else {
            const t = n.createContainerElement('p')
            n.setCustomProperty('dataPipeline:transparentRendering', true, t)
            return t
          }
        }
      }
      function BU(t) {
        const e = t.parent
        const n = e.childCount == 1
        return n && !PU(t)
      }
      function NU(t, e) {
        e.setCustomProperty('table', true, t)
        return ES(t, e, { hasSelectionHandle: true })
      }
      function PU(t) {
        const e = t.getAttributeKeys().next()
        return !e.done
      }
      class LU extends Iu {
        refresh() {
          const t = this.editor.model
          const e = t.document.selection
          const n = t.schema
          this.isEnabled = zU(e, n)
        }
        execute(t = {}) {
          const e = this.editor
          const n = e.model
          const o = e.plugins.get('TableUtils')
          const i = e.config.get('table.defaultHeadings.rows')
          const r = e.config.get('table.defaultHeadings.columns')
          if (t.headingRows === undefined && i) {
            t.headingRows = i
          }
          if (t.headingColumns === undefined && r) {
            t.headingColumns = r
          }
          n.change((e) => {
            const i = o.createTable(e, t)
            n.insertObject(i, null, null, { findOptimalPosition: 'auto' })
            e.setSelection(e.createPositionAt(i.getNodeByPath([0, 0, 0]), 0))
          })
        }
      }
      function zU(t, e) {
        const n = t.getFirstPosition().parent
        const o = n === n.root ? n : n.parent
        return e.checkChild(o, 'table')
      }
      class RU extends Iu {
        constructor(t, e = {}) {
          super(t)
          this.order = e.order || 'below'
        }
        refresh() {
          const t = this.editor.model.document.selection
          const e = this.editor.plugins.get('TableUtils')
          const n = !!e.getSelectionAffectedTableCells(t).length
          this.isEnabled = n
        }
        execute() {
          const t = this.editor
          const e = t.model.document.selection
          const n = t.plugins.get('TableUtils')
          const o = this.order === 'above'
          const i = n.getSelectionAffectedTableCells(e)
          const r = n.getRowIndexes(i)
          const s = o ? r.first : r.last
          const a = i[0].findAncestor('table')
          n.insertRows(a, { at: o ? s : s + 1, copyStructureFromAbove: !o })
        }
      }
      class OU extends Iu {
        constructor(t, e = {}) {
          super(t)
          this.order = e.order || 'right'
        }
        refresh() {
          const t = this.editor.model.document.selection
          const e = this.editor.plugins.get('TableUtils')
          const n = !!e.getSelectionAffectedTableCells(t).length
          this.isEnabled = n
        }
        execute() {
          const t = this.editor
          const e = t.model.document.selection
          const n = t.plugins.get('TableUtils')
          const o = this.order === 'left'
          const i = n.getSelectionAffectedTableCells(e)
          const r = n.getColumnIndexes(i)
          const s = o ? r.first : r.last
          const a = i[0].findAncestor('table')
          n.insertColumns(a, { columns: 1, at: o ? s : s + 1 })
        }
      }
      class VU extends Iu {
        constructor(t, e = {}) {
          super(t)
          this.direction = e.direction || 'horizontally'
        }
        refresh() {
          const t = this.editor.plugins.get('TableUtils')
          const e = t.getSelectionAffectedTableCells(this.editor.model.document.selection)
          this.isEnabled = e.length === 1
        }
        execute() {
          const t = this.editor.plugins.get('TableUtils')
          const e = t.getSelectionAffectedTableCells(this.editor.model.document.selection)[0]
          const n = this.direction === 'horizontally'
          if (n) {
            t.splitCellHorizontally(e, 2)
          } else {
            t.splitCellVertically(e, 2)
          }
        }
      }
      function FU(t, e, n) {
        const { startRow: o, startColumn: i, endRow: r, endColumn: s } = e
        const a = n.createElement('table')
        const c = r - o + 1
        for (let t = 0; t < c; t++) {
          n.insertElement('tableRow', a, 'end')
        }
        const l = [...new EU(t, { startRow: o, endRow: r, startColumn: i, endColumn: s, includeAllSlots: true })]
        for (const { row: t, column: e, cell: c, isAnchor: d, cellAnchorRow: u, cellAnchorColumn: h } of l) {
          const l = t - o
          const g = a.getChild(l)
          if (!d) {
            if (u < o || h < i) {
              pU(n, n.createPositionAt(g, 'end'))
            }
          } else {
            const o = n.cloneElement(c)
            n.append(o, g)
            GU(o, t, e, r, s, n)
          }
        }
        qU(a, t, o, i, n)
        return a
      }
      function jU(t, e, n = 0) {
        const o = []
        const i = new EU(t, { startRow: n, endRow: e - 1 })
        for (const t of i) {
          const { row: n, cellHeight: i } = t
          const r = n + i - 1
          if (n < e && e <= r) {
            o.push(t)
          }
        }
        return o
      }
      function HU(t, e, n) {
        const o = t.parent
        const i = o.parent
        const r = o.index
        const s = parseInt(t.getAttribute('rowspan'))
        const a = e - r
        const c = {}
        const l = s - a
        if (l > 1) {
          c.rowspan = l
        }
        const d = parseInt(t.getAttribute('colspan') || '1')
        if (d > 1) {
          c.colspan = d
        }
        const u = r
        const h = u + a
        const g = [...new EU(i, { startRow: u, endRow: h, includeAllSlots: true })]
        let f = null
        let m
        for (const e of g) {
          const { row: o, column: i, cell: r } = e
          if (r === t && m === undefined) {
            m = i
          }
          if (m !== undefined && m === i && o === h) {
            f = pU(n, e.getPositionBefore(), c)
          }
        }
        mU('rowspan', a, t, n)
        return f
      }
      function UU(t, e) {
        const n = []
        const o = new EU(t)
        for (const t of o) {
          const { column: o, cellWidth: i } = t
          const r = o + i - 1
          if (o < e && e <= r) {
            n.push(t)
          }
        }
        return n
      }
      function WU(t, e, n, o) {
        const i = parseInt(t.getAttribute('colspan'))
        const r = n - e
        const s = {}
        const a = i - r
        if (a > 1) {
          s.colspan = a
        }
        const c = parseInt(t.getAttribute('rowspan') || '1')
        if (c > 1) {
          s.rowspan = c
        }
        const l = pU(o, o.createPositionAfter(t), s)
        mU('colspan', r, t, o)
        return l
      }
      function GU(t, e, n, o, i, r) {
        const s = parseInt(t.getAttribute('colspan') || '1')
        const a = parseInt(t.getAttribute('rowspan') || '1')
        const c = n + s - 1
        if (c > i) {
          const e = i - n + 1
          mU('colspan', e, t, r, 1)
        }
        const l = e + a - 1
        if (l > o) {
          const n = o - e + 1
          mU('rowspan', n, t, r, 1)
        }
      }
      function qU(t, e, n, o, i) {
        const r = parseInt(e.getAttribute('headingRows') || '0')
        if (r > 0) {
          const e = r - n
          mU('headingRows', e, t, i, 0)
        }
        const s = parseInt(e.getAttribute('headingColumns') || '0')
        if (s > 0) {
          const e = s - o
          mU('headingColumns', e, t, i, 0)
        }
      }
      function $U(t, e) {
        const n = e.getColumns(t)
        const o = new Array(n).fill(0)
        for (const { column: e } of new EU(t)) {
          o[e]++
        }
        const i = o.reduce((t, e, n) => (e ? t : [...t, n]), [])
        if (i.length > 0) {
          const n = i[i.length - 1]
          e.removeColumns(t, { at: n })
          return true
        }
        return false
      }
      function KU(t, e) {
        const n = []
        const o = e.getRows(t)
        for (let e = 0; e < o; e++) {
          const o = t.getChild(e)
          if (o.isEmpty) {
            n.push(e)
          }
        }
        if (n.length > 0) {
          const o = n[n.length - 1]
          e.removeRows(t, { at: o })
          return true
        }
        return false
      }
      function YU(t, e) {
        const n = $U(t, e)
        if (!n) {
          KU(t, e)
        }
      }
      function ZU(t, e) {
        const n = Array.from(new EU(t, { startColumn: e.firstColumn, endColumn: e.lastColumn, row: e.lastRow }))
        const o = n.every(({ cellHeight: t }) => t === 1)
        if (o) {
          return e.lastRow
        }
        const i = n[0].cellHeight - 1
        return e.lastRow + i
      }
      function QU(t, e) {
        const n = Array.from(new EU(t, { startRow: e.firstRow, endRow: e.lastRow, column: e.lastColumn }))
        const o = n.every(({ cellWidth: t }) => t === 1)
        if (o) {
          return e.lastColumn
        }
        const i = n[0].cellWidth - 1
        return e.lastColumn + i
      }
      class JU extends Iu {
        constructor(t, e) {
          super(t)
          this.direction = e.direction
          this.isHorizontal = this.direction == 'right' || this.direction == 'left'
        }
        refresh() {
          const t = this._getMergeableCell()
          this.value = t
          this.isEnabled = !!t
        }
        execute() {
          const t = this.editor.model
          const e = t.document
          const n = this.editor.plugins.get('TableUtils')
          const o = n.getTableCellsContainingSelection(e.selection)[0]
          const i = this.value
          const r = this.direction
          t.change((t) => {
            const e = r == 'right' || r == 'down'
            const n = e ? o : i
            const s = e ? i : o
            const a = s.parent
            eW(s, n, t)
            const c = this.isHorizontal ? 'colspan' : 'rowspan'
            const l = parseInt(o.getAttribute(c) || '1')
            const d = parseInt(i.getAttribute(c) || '1')
            t.setAttribute(c, l + d, n)
            t.setSelection(t.createRangeIn(n))
            const u = this.editor.plugins.get('TableUtils')
            const h = a.findAncestor('table')
            YU(h, u)
          })
        }
        _getMergeableCell() {
          const t = this.editor.model
          const e = t.document
          const n = this.editor.plugins.get('TableUtils')
          const o = n.getTableCellsContainingSelection(e.selection)[0]
          if (!o) {
            return
          }
          const i = this.isHorizontal ? XU(o, this.direction, n) : tW(o, this.direction, n)
          if (!i) {
            return
          }
          const r = this.isHorizontal ? 'rowspan' : 'colspan'
          const s = parseInt(o.getAttribute(r) || '1')
          const a = parseInt(i.getAttribute(r) || '1')
          if (a === s) {
            return i
          }
        }
      }
      function XU(t, e, n) {
        const o = t.parent
        const i = o.parent
        const r = e == 'right' ? t.nextSibling : t.previousSibling
        const s = (i.getAttribute('headingColumns') || 0) > 0
        if (!r) {
          return
        }
        const a = e == 'right' ? t : r
        const c = e == 'right' ? r : t
        const { column: l } = n.getCellLocation(a)
        const { column: d } = n.getCellLocation(c)
        const u = parseInt(a.getAttribute('colspan') || '1')
        const h = bU(n, a)
        const g = bU(n, c)
        if (s && h != g) {
          return
        }
        const f = l + u === d
        return f ? r : undefined
      }
      function tW(t, e, n) {
        const o = t.parent
        const i = o.parent
        const r = i.getChildIndex(o)
        if ((e == 'down' && r === n.getRows(i) - 1) || (e == 'up' && r === 0)) {
          return null
        }
        const s = parseInt(t.getAttribute('rowspan') || '1')
        const a = i.getAttribute('headingRows') || 0
        const c = e == 'down' && r + s === a
        const l = e == 'up' && r === a
        if (a && (c || l)) {
          return null
        }
        const d = parseInt(t.getAttribute('rowspan') || '1')
        const u = e == 'down' ? r + d : r
        const h = [...new EU(i, { endRow: u })]
        const g = h.find((e) => e.cell === t)
        const f = g.column
        const m = h.find(({ row: t, cellHeight: n, column: o }) => {
          if (o !== f) {
            return false
          }
          if (e == 'down') {
            return t === u
          } else {
            return u === t + n
          }
        })
        return m && m.cell ? m.cell : null
      }
      function eW(t, e, n) {
        if (!nW(t)) {
          if (nW(e)) {
            n.remove(n.createRangeIn(e))
          }
          n.move(n.createRangeIn(t), n.createPositionAt(e, 'end'))
        }
        n.remove(t)
      }
      function nW(t) {
        const e = t.getChild(0)
        return t.childCount == 1 && e.is('element', 'paragraph') && e.isEmpty
      }
      class oW extends Iu {
        refresh() {
          const t = this.editor.plugins.get('TableUtils')
          const e = t.getSelectionAffectedTableCells(this.editor.model.document.selection)
          const n = e[0]
          if (n) {
            const o = n.findAncestor('table')
            const i = t.getRows(o)
            const r = i - 1
            const s = t.getRowIndexes(e)
            const a = s.first === 0 && s.last === r
            this.isEnabled = !a
          } else {
            this.isEnabled = false
          }
        }
        execute() {
          const t = this.editor.model
          const e = this.editor.plugins.get('TableUtils')
          const n = e.getSelectionAffectedTableCells(t.document.selection)
          const o = e.getRowIndexes(n)
          const i = n[0]
          const r = i.findAncestor('table')
          const s = e.getCellLocation(i).column
          t.change((t) => {
            const n = o.last - o.first + 1
            e.removeRows(r, { at: o.first, rows: n })
            const i = iW(r, o.first, s, e.getRows(r))
            t.setSelection(t.createPositionAt(i, 0))
          })
        }
      }
      function iW(t, e, n, o) {
        const i = t.getChild(Math.min(e, o - 1))
        let r = i.getChild(0)
        let s = 0
        for (const t of i.getChildren()) {
          if (s > n) {
            return r
          }
          r = t
          s += parseInt(t.getAttribute('colspan') || '1')
        }
        return r
      }
      class rW extends Iu {
        refresh() {
          const t = this.editor.plugins.get('TableUtils')
          const e = t.getSelectionAffectedTableCells(this.editor.model.document.selection)
          const n = e[0]
          if (n) {
            const o = n.findAncestor('table')
            const i = t.getColumns(o)
            const { first: r, last: s } = t.getColumnIndexes(e)
            this.isEnabled = s - r < i - 1
          } else {
            this.isEnabled = false
          }
        }
        execute() {
          const t = this.editor.plugins.get('TableUtils')
          const [e, n] = aW(this.editor.model.document.selection, t)
          const o = e.parent.parent
          const i = [...new EU(o)]
          const r = { first: i.find((t) => t.cell === e).column, last: i.find((t) => t.cell === n).column }
          const s = sW(i, e, n, r)
          this.editor.model.change((e) => {
            const n = r.last - r.first + 1
            t.removeColumns(o, { at: r.first, columns: n })
            e.setSelection(e.createPositionAt(s, 0))
          })
        }
      }
      function sW(t, e, n, o) {
        const i = parseInt(n.getAttribute('colspan') || '1')
        if (i > 1) {
          return n
        } else if (e.previousSibling || n.nextSibling) {
          return n.nextSibling || e.previousSibling
        } else {
          if (o.first) {
            return t.reverse().find(({ column: t }) => t < o.first).cell
          } else {
            return t.reverse().find(({ column: t }) => t > o.last).cell
          }
        }
      }
      function aW(t, e) {
        const n = e.getSelectionAffectedTableCells(t)
        const o = n[0]
        const i = n.pop()
        const r = [o, i]
        return o.isBefore(i) ? r : r.reverse()
      }
      class cW extends Iu {
        refresh() {
          const t = this.editor.plugins.get('TableUtils')
          const e = this.editor.model
          const n = t.getSelectionAffectedTableCells(e.document.selection)
          const o = n.length > 0
          this.isEnabled = o
          this.value = o && n.every((t) => this._isInHeading(t, t.parent.parent))
        }
        execute(t = {}) {
          if (t.forceValue === this.value) {
            return
          }
          const e = this.editor.plugins.get('TableUtils')
          const n = this.editor.model
          const o = e.getSelectionAffectedTableCells(n.document.selection)
          const i = o[0].findAncestor('table')
          const { first: r, last: s } = e.getRowIndexes(o)
          const a = this.value ? r : s + 1
          const c = i.getAttribute('headingRows') || 0
          n.change((t) => {
            if (a) {
              const e = a > c ? c : 0
              const n = jU(i, a, e)
              for (const { cell: e } of n) {
                HU(e, a, t)
              }
            }
            mU('headingRows', a, i, t, 0)
          })
        }
        _isInHeading(t, e) {
          const n = parseInt(e.getAttribute('headingRows') || '0')
          return !!n && t.parent.index < n
        }
      }
      class lW extends Iu {
        refresh() {
          const t = this.editor.model
          const e = this.editor.plugins.get('TableUtils')
          const n = e.getSelectionAffectedTableCells(t.document.selection)
          const o = n.length > 0
          this.isEnabled = o
          this.value = o && n.every((t) => bU(e, t))
        }
        execute(t = {}) {
          if (t.forceValue === this.value) {
            return
          }
          const e = this.editor.plugins.get('TableUtils')
          const n = this.editor.model
          const o = e.getSelectionAffectedTableCells(n.document.selection)
          const i = o[0].findAncestor('table')
          const { first: r, last: s } = e.getColumnIndexes(o)
          const a = this.value ? r : s + 1
          n.change((t) => {
            if (a) {
              const e = UU(i, a)
              for (const { cell: n, column: o } of e) {
                WU(n, o, a, t)
              }
            }
            mU('headingColumns', a, i, t, 0)
          })
        }
      }
      class dW extends Du {
        static get pluginName() {
          return 'TableUtils'
        }
        init() {
          this.decorate('insertColumns')
          this.decorate('insertRows')
        }
        getCellLocation(t) {
          const e = t.parent
          const n = e.parent
          const o = n.getChildIndex(e)
          const i = new EU(n, { row: o })
          for (const { cell: e, row: n, column: o } of i) {
            if (e === t) {
              return { row: n, column: o }
            }
          }
          return undefined
        }
        createTable(t, e) {
          const n = t.createElement('table')
          const o = e.rows || 2
          const i = e.columns || 2
          uW(t, n, 0, o, i)
          if (e.headingRows) {
            mU('headingRows', Math.min(e.headingRows, o), n, t, 0)
          }
          if (e.headingColumns) {
            mU('headingColumns', Math.min(e.headingColumns, i), n, t, 0)
          }
          return n
        }
        insertRows(t, e = {}) {
          const n = this.editor.model
          const o = e.at || 0
          const i = e.rows || 1
          const r = e.copyStructureFromAbove !== undefined
          const s = e.copyStructureFromAbove ? o - 1 : o
          const a = this.getRows(t)
          const c = this.getColumns(t)
          if (o > a) {
            throw new P('tableutils-insertrows-insert-out-of-range', this, { options: e })
          }
          n.change((e) => {
            const n = t.getAttribute('headingRows') || 0
            if (n > o) {
              mU('headingRows', n + i, t, e, 0)
            }
            if (!r && (o === 0 || o === a)) {
              uW(e, t, o, i, c)
              return
            }
            const l = r ? Math.max(o, s) : o
            const d = new EU(t, { endRow: l })
            const u = new Array(c).fill(1)
            for (const { row: t, column: n, cellHeight: a, cellWidth: c, cell: l } of d) {
              const d = t + a - 1
              const h = t < o && o <= d
              const g = t <= s && s <= d
              if (h) {
                e.setAttribute('rowspan', a + i, l)
                u[n] = -c
              } else if (r && g) {
                u[n] = c
              }
            }
            for (let n = 0; n < i; n++) {
              const n = e.createElement('tableRow')
              e.insert(n, t, o)
              for (let t = 0; t < u.length; t++) {
                const o = u[t]
                const i = e.createPositionAt(n, 'end')
                if (o > 0) {
                  pU(e, i, o > 1 ? { colspan: o } : undefined)
                }
                t += Math.abs(o) - 1
              }
            }
          })
        }
        insertColumns(t, e = {}) {
          const n = this.editor.model
          const o = e.at || 0
          const i = e.columns || 1
          n.change((e) => {
            const n = t.getAttribute('headingColumns')
            if (o < n) {
              e.setAttribute('headingColumns', n + i, t)
            }
            const r = this.getColumns(t)
            if (o === 0 || r === o) {
              for (const n of t.getChildren()) {
                if (!n.is('element', 'tableRow')) {
                  continue
                }
                hW(i, e, e.createPositionAt(n, o ? 'end' : 0))
              }
              return
            }
            const s = new EU(t, { column: o, includeAllSlots: true })
            for (const t of s) {
              const { row: n, cell: r, cellAnchorColumn: a, cellAnchorRow: c, cellWidth: l, cellHeight: d } = t
              if (a < o) {
                e.setAttribute('colspan', l + i, r)
                const t = c + d - 1
                for (let e = n; e <= t; e++) {
                  s.skipRow(e)
                }
              } else {
                hW(i, e, t.getPositionBefore())
              }
            }
          })
        }
        removeRows(t, e) {
          const n = this.editor.model
          const o = e.rows || 1
          const i = this.getRows(t)
          const r = e.at
          const s = r + o - 1
          if (s > i - 1) {
            throw new P('tableutils-removerows-row-index-out-of-range', this, { table: t, options: e })
          }
          n.change((e) => {
            const n = { first: r, last: s }
            const { cellsToMove: o, cellsToTrim: i } = pW(t, n)
            if (o.size) {
              const n = s + 1
              bW(t, n, o, e)
            }
            for (let n = s; n >= r; n--) {
              e.remove(t.getChild(n))
            }
            for (const { rowspan: t, cell: n } of i) {
              mU('rowspan', t, n, e)
            }
            mW(t, n, e)
            if (!$U(t, this)) {
              KU(t, this)
            }
          })
        }
        removeColumns(t, e) {
          const n = this.editor.model
          const o = e.at
          const i = e.columns || 1
          const r = e.at + i - 1
          n.change((e) => {
            fW(t, { first: o, last: r }, e)
            for (let n = r; n >= o; n--) {
              for (const { cell: o, column: i, cellWidth: r } of [...new EU(t)]) {
                if (i <= n && r > 1 && i + r > n) {
                  mU('colspan', r - 1, o, e)
                } else if (i === n) {
                  e.remove(o)
                }
              }
            }
            if (!KU(t, this)) {
              $U(t, this)
            }
          })
        }
        splitCellVertically(t, e = 2) {
          const n = this.editor.model
          const o = t.parent
          const i = o.parent
          const r = parseInt(t.getAttribute('rowspan') || '1')
          const s = parseInt(t.getAttribute('colspan') || '1')
          n.change((n) => {
            if (s > 1) {
              const { newCellsSpan: o, updatedSpan: i } = gW(s, e)
              mU('colspan', i, t, n)
              const a = {}
              if (o > 1) {
                a.colspan = o
              }
              if (r > 1) {
                a.rowspan = r
              }
              const c = s > e ? e - 1 : s - 1
              hW(c, n, n.createPositionAfter(t), a)
            }
            if (s < e) {
              const o = e - s
              const a = [...new EU(i)]
              const { column: c } = a.find(({ cell: e }) => e === t)
              const l = a.filter(({ cell: e, cellWidth: n, column: o }) => {
                const i = e !== t && o === c
                const r = o < c && o + n > c
                return i || r
              })
              for (const { cell: t, cellWidth: e } of l) {
                n.setAttribute('colspan', e + o, t)
              }
              const d = {}
              if (r > 1) {
                d.rowspan = r
              }
              hW(o, n, n.createPositionAfter(t), d)
              const u = i.getAttribute('headingColumns') || 0
              if (u > c) {
                mU('headingColumns', u + o, i, n)
              }
            }
          })
        }
        splitCellHorizontally(t, e = 2) {
          const n = this.editor.model
          const o = t.parent
          const i = o.parent
          const r = i.getChildIndex(o)
          const s = parseInt(t.getAttribute('rowspan') || '1')
          const a = parseInt(t.getAttribute('colspan') || '1')
          n.change((n) => {
            if (s > 1) {
              const o = [...new EU(i, { startRow: r, endRow: r + s - 1, includeAllSlots: true })]
              const { newCellsSpan: c, updatedSpan: l } = gW(s, e)
              mU('rowspan', l, t, n)
              const { column: d } = o.find(({ cell: e }) => e === t)
              const u = {}
              if (c > 1) {
                u.rowspan = c
              }
              if (a > 1) {
                u.colspan = a
              }
              for (const t of o) {
                const { column: e, row: o } = t
                const i = o >= r + l
                const s = e === d
                const a = (o + r + l) % c === 0
                if (i && s && a) {
                  hW(1, n, t.getPositionBefore(), u)
                }
              }
            }
            if (s < e) {
              const o = e - s
              const c = [...new EU(i, { startRow: 0, endRow: r })]
              for (const { cell: e, cellHeight: i, row: s } of c) {
                if (e !== t && s + i > r) {
                  const t = i + o
                  n.setAttribute('rowspan', t, e)
                }
              }
              const l = {}
              if (a > 1) {
                l.colspan = a
              }
              uW(n, i, r + 1, o, 1, l)
              const d = i.getAttribute('headingRows') || 0
              if (d > r) {
                mU('headingRows', d + o, i, n)
              }
            }
          })
        }
        getColumns(t) {
          const e = t.getChild(0)
          return [...e.getChildren()].reduce((t, e) => {
            const n = parseInt(e.getAttribute('colspan') || '1')
            return t + n
          }, 0)
        }
        getRows(t) {
          return Array.from(t.getChildren()).reduce((t, e) => (e.is('element', 'tableRow') ? t + 1 : t), 0)
        }
        createTableWalker(t, e = {}) {
          return new EU(t, e)
        }
        getSelectedTableCells(t) {
          const e = []
          for (const n of this.sortRanges(t.getRanges())) {
            const t = n.getContainedElement()
            if (t && t.is('element', 'tableCell')) {
              e.push(t)
            }
          }
          return e
        }
        getTableCellsContainingSelection(t) {
          const e = []
          for (const n of t.getRanges()) {
            const t = n.start.findAncestor('tableCell')
            if (t) {
              e.push(t)
            }
          }
          return e
        }
        getSelectionAffectedTableCells(t) {
          const e = this.getSelectedTableCells(t)
          if (e.length) {
            return e
          }
          return this.getTableCellsContainingSelection(t)
        }
        getRowIndexes(t) {
          const e = t.map((t) => t.parent.index)
          return this._getFirstLastIndexesObject(e)
        }
        getColumnIndexes(t) {
          const e = t[0].findAncestor('table')
          const n = [...new EU(e)]
          const o = n.filter((e) => t.includes(e.cell)).map((t) => t.column)
          return this._getFirstLastIndexesObject(o)
        }
        isSelectionRectangular(t) {
          if (t.length < 2 || !this._areCellInTheSameTableSection(t)) {
            return false
          }
          const e = new Set()
          const n = new Set()
          let o = 0
          for (const i of t) {
            const { row: t, column: r } = this.getCellLocation(i)
            const s = parseInt(i.getAttribute('rowspan')) || 1
            const a = parseInt(i.getAttribute('colspan')) || 1
            e.add(t)
            n.add(r)
            if (s > 1) {
              e.add(t + s - 1)
            }
            if (a > 1) {
              n.add(r + a - 1)
            }
            o += s * a
          }
          const i = wW(e, n)
          return i == o
        }
        sortRanges(t) {
          return Array.from(t).sort(kW)
        }
        _getFirstLastIndexesObject(t) {
          const e = t.sort((t, e) => t - e)
          const n = e[0]
          const o = e[e.length - 1]
          return { first: n, last: o }
        }
        _areCellInTheSameTableSection(t) {
          const e = t[0].findAncestor('table')
          const n = this.getRowIndexes(t)
          const o = parseInt(e.getAttribute('headingRows')) || 0
          if (!this._areIndexesInSameSection(n, o)) {
            return false
          }
          const i = this.getColumnIndexes(t)
          const r = parseInt(e.getAttribute('headingColumns')) || 0
          return this._areIndexesInSameSection(i, r)
        }
        _areIndexesInSameSection({ first: t, last: e }, n) {
          const o = t < n
          const i = e < n
          return o === i
        }
      }
      function uW(t, e, n, o, i, r = {}) {
        for (let s = 0; s < o; s++) {
          const o = t.createElement('tableRow')
          t.insert(o, e, n)
          hW(i, t, t.createPositionAt(o, 'end'), r)
        }
      }
      function hW(t, e, n, o = {}) {
        for (let i = 0; i < t; i++) {
          pU(e, n, o)
        }
      }
      function gW(t, e) {
        if (t < e) {
          return { newCellsSpan: 1, updatedSpan: 1 }
        }
        const n = Math.floor(t / e)
        const o = t - n * e + n
        return { newCellsSpan: n, updatedSpan: o }
      }
      function fW(t, e, n) {
        const o = t.getAttribute('headingColumns') || 0
        if (o && e.first < o) {
          const i = Math.min(o - 1, e.last) - e.first + 1
          n.setAttribute('headingColumns', o - i, t)
        }
      }
      function mW(t, { first: e, last: n }, o) {
        const i = t.getAttribute('headingRows') || 0
        if (e < i) {
          const r = n < i ? i - (n - e + 1) : e
          mU('headingRows', r, t, o, 0)
        }
      }
      function pW(t, { first: e, last: n }) {
        const o = new Map()
        const i = []
        for (const { row: r, column: s, cellHeight: a, cell: c } of new EU(t, { endRow: n })) {
          const t = r + a - 1
          const l = r >= e && r <= n && t > n
          if (l) {
            const t = n - r + 1
            const e = a - t
            o.set(s, { cell: c, rowspan: e })
          }
          const d = r < e && t >= e
          if (d) {
            let o
            if (t >= n) {
              o = n - e + 1
            } else {
              o = t - e + 1
            }
            i.push({ cell: c, rowspan: a - o })
          }
        }
        return { cellsToMove: o, cellsToTrim: i }
      }
      function bW(t, e, n, o) {
        const i = new EU(t, { includeAllSlots: true, row: e })
        const r = [...i]
        const s = t.getChild(e)
        let a
        for (const { column: t, cell: e, isAnchor: i } of r) {
          if (n.has(t)) {
            const { cell: e, rowspan: i } = n.get(t)
            const r = a ? o.createPositionAfter(a) : o.createPositionAt(s, 0)
            o.move(o.createRangeOn(e), r)
            mU('rowspan', i, e, o)
            a = e
          } else if (i) {
            a = e
          }
        }
      }
      function kW(t, e) {
        const n = t.start
        const o = e.start
        return n.isBefore(o) ? -1 : 1
      }
      function wW(t, e) {
        const n = Array.from(t.values())
        const o = Array.from(e.values())
        const i = Math.max(...n)
        const r = Math.min(...n)
        const s = Math.max(...o)
        const a = Math.min(...o)
        return (i - r + 1) * (s - a + 1)
      }
      class AW extends Iu {
        refresh() {
          const t = this.editor.plugins.get(dW)
          const e = t.getSelectedTableCells(this.editor.model.document.selection)
          this.isEnabled = t.isSelectionRectangular(e)
        }
        execute() {
          const t = this.editor.model
          const e = this.editor.plugins.get(dW)
          t.change((n) => {
            const o = e.getSelectedTableCells(t.document.selection)
            const i = o.shift()
            const { mergeWidth: r, mergeHeight: s } = vW(i, o, e)
            mU('colspan', r, i, n)
            mU('rowspan', s, i, n)
            for (const t of o) {
              _W(t, i, n)
            }
            const a = i.findAncestor('table')
            YU(a, e)
            n.setSelection(i, 'in')
          })
        }
      }
      function _W(t, e, n) {
        if (!CW(t)) {
          if (CW(e)) {
            n.remove(n.createRangeIn(e))
          }
          n.move(n.createRangeIn(t), n.createPositionAt(e, 'end'))
        }
        n.remove(t)
      }
      function CW(t) {
        const e = t.getChild(0)
        return t.childCount == 1 && e.is('element', 'paragraph') && e.isEmpty
      }
      function vW(t, e, n) {
        let o = 0
        let i = 0
        for (const t of e) {
          const { row: e, column: r } = n.getCellLocation(t)
          o = yW(t, r, o, 'colspan')
          i = yW(t, e, i, 'rowspan')
        }
        const { row: r, column: s } = n.getCellLocation(t)
        const a = o - s
        const c = i - r
        return { mergeWidth: a, mergeHeight: c }
      }
      function yW(t, e, n, o) {
        const i = parseInt(t.getAttribute(o) || '1')
        return Math.max(n, e + i)
      }
      class xW extends Iu {
        constructor(t) {
          super(t)
          this.affectsData = false
        }
        refresh() {
          const t = this.editor.plugins.get('TableUtils')
          const e = t.getSelectionAffectedTableCells(this.editor.model.document.selection)
          this.isEnabled = e.length > 0
        }
        execute() {
          const t = this.editor.model
          const e = this.editor.plugins.get('TableUtils')
          const n = e.getSelectionAffectedTableCells(t.document.selection)
          const o = e.getRowIndexes(n)
          const i = n[0].findAncestor('table')
          const r = []
          for (let e = o.first; e <= o.last; e++) {
            for (const n of i.getChild(e).getChildren()) {
              r.push(t.createRangeOn(n))
            }
          }
          t.change((t) => {
            t.setSelection(r)
          })
        }
      }
      class EW extends Iu {
        constructor(t) {
          super(t)
          this.affectsData = false
        }
        refresh() {
          const t = this.editor.plugins.get('TableUtils')
          const e = t.getSelectionAffectedTableCells(this.editor.model.document.selection)
          this.isEnabled = e.length > 0
        }
        execute() {
          const t = this.editor.plugins.get('TableUtils')
          const e = this.editor.model
          const n = t.getSelectionAffectedTableCells(e.document.selection)
          const o = n[0]
          const i = n.pop()
          const r = o.findAncestor('table')
          const s = t.getCellLocation(o)
          const a = t.getCellLocation(i)
          const c = Math.min(s.column, a.column)
          const l = Math.max(s.column, a.column)
          const d = []
          for (const t of new EU(r, { startColumn: c, endColumn: l })) {
            d.push(e.createRangeOn(t.cell))
          }
          e.change((t) => {
            t.setSelection(d)
          })
        }
      }
      function DW(t) {
        t.document.registerPostFixer((e) => TW(e, t))
      }
      function TW(t, e) {
        const n = e.document.differ.getChanges()
        let o = false
        const i = new Set()
        for (const e of n) {
          let n = null
          if (e.type == 'insert' && e.name == 'table') {
            n = e.position.nodeAfter
          }
          if ((e.type == 'insert' || e.type == 'remove') && (e.name == 'tableRow' || e.name == 'tableCell')) {
            n = e.position.findAncestor('table')
          }
          if (NW(e)) {
            n = e.range.start.findAncestor('table')
          }
          if (n && !i.has(n)) {
            o = IW(n, t) || o
            o = SW(n, t) || o
            i.add(n)
          }
        }
        return o
      }
      function IW(t, e) {
        let n = false
        const o = MW(t)
        if (o.length) {
          n = true
          for (const t of o) {
            mU('rowspan', t.rowspan, t.cell, e, 1)
          }
        }
        return n
      }
      function SW(t, e) {
        let n = false
        const o = BW(t)
        const i = []
        for (const [e, n] of o.entries()) {
          if (!n && t.getChild(e).is('element', 'tableRow')) {
            i.push(e)
          }
        }
        if (i.length) {
          n = true
          for (const n of i.reverse()) {
            e.remove(t.getChild(n))
            o.splice(n, 1)
          }
        }
        const r = o.filter((e, n) => t.getChild(n).is('element', 'tableRow'))
        const s = r[0]
        const a = r.every((t) => t === s)
        if (!a) {
          const o = r.reduce((t, e) => (e > t ? e : t), 0)
          for (const [i, s] of r.entries()) {
            const r = o - s
            if (r) {
              for (let n = 0; n < r; n++) {
                pU(e, e.createPositionAt(t.getChild(i), 'end'))
              }
              n = true
            }
          }
        }
        return n
      }
      function MW(t) {
        const e = parseInt(t.getAttribute('headingRows') || '0')
        const n = Array.from(t.getChildren()).reduce((t, e) => (e.is('element', 'tableRow') ? t + 1 : t), 0)
        const o = []
        for (const { row: i, cell: r, cellHeight: s } of new EU(t)) {
          if (s < 2) {
            continue
          }
          const t = i < e
          const a = t ? e : n
          if (i + s > a) {
            const t = a - i
            o.push({ cell: r, rowspan: t })
          }
        }
        return o
      }
      function BW(t) {
        const e = new Array(t.childCount).fill(0)
        for (const { rowIndex: n } of new EU(t, { includeAllSlots: true })) {
          e[n]++
        }
        return e
      }
      function NW(t) {
        if (t.type !== 'attribute') {
          return false
        }
        const e = t.attributeKey
        return e === 'headingRows' || e === 'colspan' || e === 'rowspan'
      }
      function PW(t) {
        t.document.registerPostFixer((e) => LW(e, t))
      }
      function LW(t, e) {
        const n = e.document.differ.getChanges()
        let o = false
        for (const e of n) {
          if (e.type == 'insert' && e.name == 'table') {
            o = zW(e.position.nodeAfter, t) || o
          }
          if (e.type == 'insert' && e.name == 'tableRow') {
            o = RW(e.position.nodeAfter, t) || o
          }
          if (e.type == 'insert' && e.name == 'tableCell') {
            o = OW(e.position.nodeAfter, t) || o
          }
          if ((e.type == 'remove' || e.type == 'insert') && VW(e)) {
            o = OW(e.position.parent, t) || o
          }
        }
        return o
      }
      function zW(t, e) {
        let n = false
        for (const o of t.getChildren()) {
          if (o.is('element', 'tableRow')) {
            n = RW(o, e) || n
          }
        }
        return n
      }
      function RW(t, e) {
        let n = false
        for (const o of t.getChildren()) {
          n = OW(o, e) || n
        }
        return n
      }
      function OW(t, e) {
        if (t.childCount == 0) {
          e.insertElement('paragraph', t)
          return true
        }
        const n = Array.from(t.getChildren()).filter((t) => t.is('$text'))
        for (const t of n) {
          e.wrap(e.createRangeOn(t), 'paragraph')
        }
        return !!n.length
      }
      function VW(t) {
        if (!t.position.parent.is('element', 'tableCell')) {
          return false
        }
        return (t.type == 'insert' && t.name == '$text') || t.type == 'remove'
      }
      function FW(t, e) {
        const n = t.document.differ
        for (const t of n.getChanges()) {
          let n
          let o = false
          if (t.type == 'attribute') {
            const e = t.range.start.nodeAfter
            if (!e || !e.is('element', 'table')) {
              continue
            }
            if (t.attributeKey != 'headingRows' && t.attributeKey != 'headingColumns') {
              continue
            }
            n = e
            o = t.attributeKey == 'headingRows'
          } else if (t.name == 'tableRow' || t.name == 'tableCell') {
            n = t.position.findAncestor('table')
            o = t.name == 'tableRow'
          }
          if (!n) {
            continue
          }
          const i = n.getAttribute('headingRows') || 0
          const r = n.getAttribute('headingColumns') || 0
          const s = new EU(n)
          for (const t of s) {
            const n = t.row < i || t.column < r
            const s = n ? 'th' : 'td'
            const a = e.mapper.toViewElement(t.cell)
            if (a && a.is('element') && a.name != s) {
              e.reconvertItem(o ? t.cell.parent : t.cell)
            }
          }
        }
      }
      function jW(t, e) {
        const n = t.document.differ
        const o = new Set()
        for (const t of n.getChanges()) {
          const e = t.type == 'attribute' ? t.range.start.parent : t.position.parent
          if (e.is('element', 'tableCell')) {
            o.add(e)
          }
        }
        for (const t of o.values()) {
          const n = Array.from(t.getChildren()).filter((t) => HW(t, e.mapper))
          for (const t of n) {
            e.reconvertItem(t)
          }
        }
      }
      function HW(t, e) {
        if (!t.is('element', 'paragraph')) {
          return false
        }
        const n = e.toViewElement(t)
        if (!n) {
          return false
        }
        return BU(t) !== n.is('element', 'span')
      }
      var UW = n(8361)
      var WW = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      WW.insert = 'head'
      WW.singleton = true
      var GW = Rl()(UW.Z, WW)
      const qW = UW.Z.locals || {}
      class $W extends Du {
        static get pluginName() {
          return 'TableEditing'
        }
        static get requires() {
          return [dW]
        }
        constructor(t) {
          super(t)
          this._additionalSlots = []
        }
        init() {
          const t = this.editor
          const e = t.model
          const n = e.schema
          const o = t.conversion
          const i = t.plugins.get(dW)
          n.register('table', { inheritAllFrom: '$blockObject', allowAttributes: ['headingRows', 'headingColumns'] })
          n.register('tableRow', { allowIn: 'table', isLimit: true })
          n.register('tableCell', {
            allowContentOf: '$container',
            allowIn: 'tableRow',
            allowAttributes: ['colspan', 'rowspan'],
            isLimit: true,
            isSelectable: true,
          })
          o.for('upcast').add(wU())
          o.for('upcast').add(AU())
          o.for('editingDowncast').elementToStructure({
            model: { name: 'table', attributes: ['headingRows'] },
            view: TU(i, { asWidget: true, additionalSlots: this._additionalSlots }),
          })
          o.for('dataDowncast').elementToStructure({
            model: { name: 'table', attributes: ['headingRows'] },
            view: TU(i, { additionalSlots: this._additionalSlots }),
          })
          o.for('upcast').elementToElement({ model: 'tableRow', view: 'tr' })
          o.for('upcast').add(_U())
          o.for('downcast').elementToElement({ model: 'tableRow', view: IU() })
          o.for('upcast').elementToElement({ model: 'tableCell', view: 'td' })
          o.for('upcast').elementToElement({ model: 'tableCell', view: 'th' })
          o.for('upcast').add(CU('td'))
          o.for('upcast').add(CU('th'))
          o.for('editingDowncast').elementToElement({ model: 'tableCell', view: SU({ asWidget: true }) })
          o.for('dataDowncast').elementToElement({ model: 'tableCell', view: SU() })
          o.for('editingDowncast').elementToElement({
            model: 'paragraph',
            view: MU({ asWidget: true }),
            converterPriority: 'high',
          })
          o.for('dataDowncast').elementToElement({ model: 'paragraph', view: MU(), converterPriority: 'high' })
          o.for('downcast').attributeToAttribute({ model: 'colspan', view: 'colspan' })
          o.for('upcast').attributeToAttribute({ model: { key: 'colspan', value: KW('colspan') }, view: 'colspan' })
          o.for('downcast').attributeToAttribute({ model: 'rowspan', view: 'rowspan' })
          o.for('upcast').attributeToAttribute({ model: { key: 'rowspan', value: KW('rowspan') }, view: 'rowspan' })
          t.config.define('table.defaultHeadings.rows', 0)
          t.config.define('table.defaultHeadings.columns', 0)
          t.commands.add('insertTable', new LU(t))
          t.commands.add('insertTableRowAbove', new RU(t, { order: 'above' }))
          t.commands.add('insertTableRowBelow', new RU(t, { order: 'below' }))
          t.commands.add('insertTableColumnLeft', new OU(t, { order: 'left' }))
          t.commands.add('insertTableColumnRight', new OU(t, { order: 'right' }))
          t.commands.add('removeTableRow', new oW(t))
          t.commands.add('removeTableColumn', new rW(t))
          t.commands.add('splitTableCellVertically', new VU(t, { direction: 'vertically' }))
          t.commands.add('splitTableCellHorizontally', new VU(t, { direction: 'horizontally' }))
          t.commands.add('mergeTableCells', new AW(t))
          t.commands.add('mergeTableCellRight', new JU(t, { direction: 'right' }))
          t.commands.add('mergeTableCellLeft', new JU(t, { direction: 'left' }))
          t.commands.add('mergeTableCellDown', new JU(t, { direction: 'down' }))
          t.commands.add('mergeTableCellUp', new JU(t, { direction: 'up' }))
          t.commands.add('setTableColumnHeader', new lW(t))
          t.commands.add('setTableRowHeader', new cW(t))
          t.commands.add('selectTableRow', new xW(t))
          t.commands.add('selectTableColumn', new EW(t))
          DW(e)
          PW(e)
          this.listenTo(e.document, 'change:data', () => {
            FW(e, t.editing)
            jW(e, t.editing)
          })
        }
        registerAdditionalSlot(t) {
          this._additionalSlots.push(t)
        }
      }
      function KW(t) {
        return (e) => {
          const n = parseInt(e.getAttribute(t))
          if (Number.isNaN(n) || n <= 0) {
            return null
          }
          return n
        }
      }
      var YW = n(468)
      var ZW = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      ZW.insert = 'head'
      ZW.singleton = true
      var QW = Rl()(YW.Z, ZW)
      const JW = YW.Z.locals || {}
      class XW extends Hl {
        constructor(t) {
          super(t)
          const e = this.bindTemplate
          this.items = this._createGridCollection()
          this.keystrokes = new wl()
          this.focusTracker = new kl()
          this.set('rows', 0)
          this.set('columns', 0)
          this.bind('label').to(this, 'columns', this, 'rows', (t, e) => `${e} × ${t}`)
          this.setTemplate({
            tag: 'div',
            attributes: { class: ['ck'] },
            children: [
              {
                tag: 'div',
                attributes: { class: ['ck-insert-table-dropdown__grid'] },
                on: { 'mouseover@.ck-insert-table-dropdown-grid-box': e.to('boxover') },
                children: this.items,
              },
              {
                tag: 'div',
                attributes: { class: ['ck', 'ck-insert-table-dropdown__label'], 'aria-hidden': true },
                children: [{ text: e.to('label') }],
              },
            ],
            on: {
              mousedown: e.to((t) => {
                t.preventDefault()
              }),
              click: e.to(() => {
                this.fire('execute')
              }),
            },
          })
          this.on('boxover', (t, e) => {
            const { row: n, column: o } = e.target.dataset
            this.items.get((parseInt(n, 10) - 1) * 10 + (parseInt(o, 10) - 1)).focus()
          })
          this.focusTracker.on('change:focusedElement', (t, e, n) => {
            if (!n) {
              return
            }
            const { row: o, column: i } = n.dataset
            this.set({ rows: parseInt(o), columns: parseInt(i) })
          })
          this.on('change:columns', () => this._highlightGridBoxes())
          this.on('change:rows', () => this._highlightGridBoxes())
        }
        render() {
          super.render()
          r({
            keystrokeHandler: this.keystrokes,
            focusTracker: this.focusTracker,
            gridItems: this.items,
            numberOfColumns: 10,
            uiLanguageDirection: this.locale && this.locale.uiLanguageDirection,
          })
          for (const t of this.items) {
            this.focusTracker.add(t.element)
          }
          this.keystrokes.listenTo(this.element)
        }
        focus() {
          this.items.get(0).focus()
        }
        focusLast() {
          this.items.get(0).focus()
        }
        _highlightGridBoxes() {
          const t = this.rows
          const e = this.columns
          this.items.map((n, o) => {
            const i = Math.floor(o / 10)
            const r = o % 10
            const s = i < t && r < e
            n.set('isOn', s)
          })
        }
        _createGridButton(t, e, n, o) {
          const i = new Dd(t)
          i.set({ label: o, class: 'ck-insert-table-dropdown-grid-box' })
          i.extendTemplate({ attributes: { 'data-row': e, 'data-column': n } })
          return i
        }
        _createGridCollection() {
          const t = []
          for (let e = 0; e < 100; e++) {
            const n = Math.floor(e / 10)
            const o = e % 10
            const i = `${n + 1} × ${o + 1}`
            t.push(this._createGridButton(this.locale, n + 1, o + 1, i))
          }
          return this.createCollection(t)
        }
      }
      const tG =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 6v3h4V6H3zm0 4v3h4v-3H3zm0 4v3h4v-3H3zm5 3h4v-3H8v3zm5 0h4v-3h-4v3zm4-4v-3h-4v3h4zm0-4V6h-4v3h4zm1.5 8a1.5 1.5 0 0 1-1.5 1.5H3A1.5 1.5 0 0 1 1.5 17V4c.222-.863 1.068-1.5 2-1.5h13c.932 0 1.778.637 2 1.5v13zM12 13v-3H8v3h4zm0-4V6H8v3h4z"/></svg>'
      const eG =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M18 7v1H2V7h16zm0 5v1H2v-1h16z" opacity=".6"/><path d="M14 1v18a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V1a1 1 0 0 1 1-1h6a1 1 0 0 1 1 1zm-2 1H8v4h4V2zm0 6H8v4h4V8zm0 6H8v4h4v-4z"/></svg>'
      const nG =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M7 2h1v16H7V2zm5 0h1v16h-1V2z" opacity=".6"/><path d="M1 6h18a1 1 0 0 1 1 1v6a1 1 0 0 1-1 1H1a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1zm1 2v4h4V8H2zm6 0v4h4V8H8zm6 0v4h4V8h-4z"/></svg>'
      const oG =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M7 2h1v16H7V2zm5 0h1v7h-1V2zm6 5v1H2V7h16zM8 12v1H2v-1h6z" opacity=".6"/><path d="M7 7h12a1 1 0 0 1 1 1v11a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V8a1 1 0 0 1 1-1zm1 2v9h10V9H8z"/></svg>'
      class iG extends Du {
        static get pluginName() {
          return 'TableUI'
        }
        init() {
          const t = this.editor
          const e = this.editor.t
          const n = t.locale.contentLanguageDirection
          const o = n === 'ltr'
          t.ui.componentFactory.add('insertTable', (n) => {
            const o = t.commands.get('insertTable')
            const i = ay(n)
            i.bind('isEnabled').to(o)
            i.buttonView.set({ icon: tG, label: e('Insert table'), tooltip: true })
            let r
            i.on('change:isOpen', () => {
              if (r) {
                return
              }
              r = new XW(n)
              i.panelView.children.add(r)
              r.delegate('execute').to(i)
              i.on('execute', () => {
                t.execute('insertTable', { rows: r.rows, columns: r.columns })
                t.editing.view.focus()
              })
            })
            return i
          })
          t.ui.componentFactory.add('tableColumn', (t) => {
            const n = [
              {
                type: 'switchbutton',
                model: { commandName: 'setTableColumnHeader', label: e('Header column'), bindIsOn: true },
              },
              { type: 'separator' },
              {
                type: 'button',
                model: {
                  commandName: o ? 'insertTableColumnLeft' : 'insertTableColumnRight',
                  label: e('Insert column left'),
                },
              },
              {
                type: 'button',
                model: {
                  commandName: o ? 'insertTableColumnRight' : 'insertTableColumnLeft',
                  label: e('Insert column right'),
                },
              },
              { type: 'button', model: { commandName: 'removeTableColumn', label: e('Delete column') } },
              { type: 'button', model: { commandName: 'selectTableColumn', label: e('Select column') } },
            ]
            return this._prepareDropdown(e('Column'), eG, n, t)
          })
          t.ui.componentFactory.add('tableRow', (t) => {
            const n = [
              {
                type: 'switchbutton',
                model: { commandName: 'setTableRowHeader', label: e('Header row'), bindIsOn: true },
              },
              { type: 'separator' },
              { type: 'button', model: { commandName: 'insertTableRowAbove', label: e('Insert row above') } },
              { type: 'button', model: { commandName: 'insertTableRowBelow', label: e('Insert row below') } },
              { type: 'button', model: { commandName: 'removeTableRow', label: e('Delete row') } },
              { type: 'button', model: { commandName: 'selectTableRow', label: e('Select row') } },
            ]
            return this._prepareDropdown(e('Row'), nG, n, t)
          })
          t.ui.componentFactory.add('mergeTableCells', (t) => {
            const n = [
              { type: 'button', model: { commandName: 'mergeTableCellUp', label: e('Merge cell up') } },
              {
                type: 'button',
                model: { commandName: o ? 'mergeTableCellRight' : 'mergeTableCellLeft', label: e('Merge cell right') },
              },
              { type: 'button', model: { commandName: 'mergeTableCellDown', label: e('Merge cell down') } },
              {
                type: 'button',
                model: { commandName: o ? 'mergeTableCellLeft' : 'mergeTableCellRight', label: e('Merge cell left') },
              },
              { type: 'separator' },
              { type: 'button', model: { commandName: 'splitTableCellVertically', label: e('Split cell vertically') } },
              {
                type: 'button',
                model: { commandName: 'splitTableCellHorizontally', label: e('Split cell horizontally') },
              },
            ]
            return this._prepareMergeSplitButtonDropdown(e('Merge cells'), oG, n, t)
          })
        }
        _prepareDropdown(t, e, n, o) {
          const i = this.editor
          const r = ay(o)
          const s = this._fillDropdownWithListOptions(r, n)
          r.buttonView.set({ label: t, icon: e, tooltip: true })
          r.bind('isEnabled').toMany(s, 'isEnabled', (...t) => t.some((t) => t))
          this.listenTo(r, 'execute', (t) => {
            i.execute(t.source.commandName)
            if (!(t.source instanceof Bd)) {
              i.editing.view.focus()
            }
          })
          return r
        }
        _prepareMergeSplitButtonDropdown(t, e, n, o) {
          const i = this.editor
          const r = ay(o, Jv)
          const s = 'mergeTableCells'
          const a = i.commands.get(s)
          const c = this._fillDropdownWithListOptions(r, n)
          r.buttonView.set({ label: t, icon: e, tooltip: true, isEnabled: true })
          r.bind('isEnabled').toMany([a, ...c], 'isEnabled', (...t) => t.some((t) => t))
          this.listenTo(r.buttonView, 'execute', () => {
            i.execute(s)
            i.editing.view.focus()
          })
          this.listenTo(r, 'execute', (t) => {
            i.execute(t.source.commandName)
            i.editing.view.focus()
          })
          return r
        }
        _fillDropdownWithListOptions(t, e) {
          const n = this.editor
          const o = []
          const i = new pl()
          for (const t of e) {
            rG(t, n, o, i)
          }
          dy(t, i)
          return o
        }
      }
      function rG(t, e, n, o) {
        if (t.type === 'button' || t.type === 'switchbutton') {
          const o = (t.model = new UE(t.model))
          const { commandName: i, bindIsOn: r } = t.model
          const s = e.commands.get(i)
          n.push(s)
          o.set({ commandName: i })
          o.bind('isEnabled').to(s)
          if (r) {
            o.bind('isOn').to(s, 'value')
          }
          o.set({ withText: true })
        }
        o.add(t)
      }
      var sG = n(1546)
      var aG = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      aG.insert = 'head'
      aG.singleton = true
      var cG = Rl()(sG.Z, aG)
      const lG = sG.Z.locals || {}
      class dG extends Du {
        static get pluginName() {
          return 'TableSelection'
        }
        static get requires() {
          return [dW, dW]
        }
        init() {
          const t = this.editor
          const e = t.model
          const n = t.editing.view
          this.listenTo(e, 'deleteContent', (t, e) => this._handleDeleteContent(t, e), { priority: 'high' })
          this.listenTo(n.document, 'insertText', (t, e) => this._handleInsertTextEvent(t, e), { priority: 'high' })
          this._defineSelectionConverter()
          this._enablePluginDisabling()
        }
        getSelectedTableCells() {
          const t = this.editor.plugins.get(dW)
          const e = this.editor.model.document.selection
          const n = t.getSelectedTableCells(e)
          if (n.length == 0) {
            return null
          }
          return n
        }
        getSelectionAsFragment() {
          const t = this.editor.plugins.get(dW)
          const e = this.getSelectedTableCells()
          if (!e) {
            return null
          }
          return this.editor.model.change((n) => {
            const o = n.createDocumentFragment()
            const { first: i, last: r } = t.getColumnIndexes(e)
            const { first: s, last: a } = t.getRowIndexes(e)
            const c = e[0].findAncestor('table')
            let l = a
            let d = r
            if (t.isSelectionRectangular(e)) {
              const t = { firstColumn: i, lastColumn: r, firstRow: s, lastRow: a }
              l = ZU(c, t)
              d = QU(c, t)
            }
            const u = { startRow: s, startColumn: i, endRow: l, endColumn: d }
            const h = FU(c, u, n)
            n.insert(h, o, 0)
            return o
          })
        }
        setCellSelection(t, e) {
          const n = this._getCellsToSelect(t, e)
          this.editor.model.change((t) => {
            t.setSelection(
              n.cells.map((e) => t.createRangeOn(e)),
              { backward: n.backward },
            )
          })
        }
        getFocusCell() {
          const t = this.editor.model.document.selection
          const e = [...t.getRanges()].pop()
          const n = e.getContainedElement()
          if (n && n.is('element', 'tableCell')) {
            return n
          }
          return null
        }
        getAnchorCell() {
          const t = this.editor.model.document.selection
          const e = bl(t.getRanges())
          const n = e.getContainedElement()
          if (n && n.is('element', 'tableCell')) {
            return n
          }
          return null
        }
        _defineSelectionConverter() {
          const t = this.editor
          const e = new Set()
          t.conversion.for('editingDowncast').add((t) =>
            t.on(
              'selection',
              (t, o, i) => {
                const r = i.writer
                n(r)
                const s = this.getSelectedTableCells()
                if (!s) {
                  return
                }
                for (const t of s) {
                  const n = i.mapper.toViewElement(t)
                  r.addClass('ck-editor__editable_selected', n)
                  e.add(n)
                }
                const a = i.mapper.toViewElement(s[s.length - 1])
                r.setSelection(a, 0)
              },
              { priority: 'lowest' },
            ),
          )
          function n(t) {
            for (const n of e) {
              t.removeClass('ck-editor__editable_selected', n)
            }
            e.clear()
          }
        }
        _enablePluginDisabling() {
          const t = this.editor
          this.on('change:isEnabled', () => {
            if (!this.isEnabled) {
              const e = this.getSelectedTableCells()
              if (!e) {
                return
              }
              t.model.change((n) => {
                const o = n.createPositionAt(e[0], 0)
                const i = t.model.schema.getNearestSelectionRange(o)
                n.setSelection(i)
              })
            }
          })
        }
        _handleDeleteContent(t, e) {
          const n = this.editor.plugins.get(dW)
          const o = e[0]
          const i = e[1]
          const r = this.editor.model
          const s = !i || i.direction == 'backward'
          const a = n.getSelectedTableCells(o)
          if (!a.length) {
            return
          }
          t.stop()
          r.change((t) => {
            const e = a[s ? a.length - 1 : 0]
            r.change((t) => {
              for (const e of a) {
                r.deleteContent(t.createSelection(e, 'in'))
              }
            })
            const n = r.schema.getNearestSelectionRange(t.createPositionAt(e, 0))
            if (o.is('documentSelection')) {
              t.setSelection(n)
            } else {
              o.setTo(n)
            }
          })
        }
        _handleInsertTextEvent(t, e) {
          const n = this.editor
          const o = this.getSelectedTableCells()
          if (!o) {
            return
          }
          const i = n.editing.view
          const r = n.editing.mapper
          const s = o.map((t) => i.createRangeOn(r.toViewElement(t)))
          e.selection = i.createSelection(s)
        }
        _getCellsToSelect(t, e) {
          const n = this.editor.plugins.get('TableUtils')
          const o = n.getCellLocation(t)
          const i = n.getCellLocation(e)
          const r = Math.min(o.row, i.row)
          const s = Math.max(o.row, i.row)
          const a = Math.min(o.column, i.column)
          const c = Math.max(o.column, i.column)
          const l = new Array(s - r + 1).fill(null).map(() => [])
          const d = { startRow: r, endRow: s, startColumn: a, endColumn: c }
          for (const { row: e, cell: n } of new EU(t.findAncestor('table'), d)) {
            l[e - r].push(n)
          }
          const u = i.row < o.row
          const h = i.column < o.column
          if (u) {
            l.reverse()
          }
          if (h) {
            l.forEach((t) => t.reverse())
          }
          return { cells: l.flat(), backward: u || h }
        }
      }
      class uG extends Du {
        static get pluginName() {
          return 'TableClipboard'
        }
        static get requires() {
          return [dG, dW]
        }
        init() {
          const t = this.editor
          const e = t.editing.view.document
          this.listenTo(e, 'copy', (t, e) => this._onCopyCut(t, e))
          this.listenTo(e, 'cut', (t, e) => this._onCopyCut(t, e))
          this.listenTo(t.model, 'insertContent', (t, [e, n]) => this._onInsertContent(t, e, n), { priority: 'high' })
          this.decorate('_replaceTableSlotCell')
        }
        _onCopyCut(t, e) {
          const n = this.editor.plugins.get(dG)
          if (!n.getSelectedTableCells()) {
            return
          }
          if (t.name == 'cut' && !this.editor.model.canEditAt(this.editor.model.document.selection)) {
            return
          }
          e.preventDefault()
          t.stop()
          const o = this.editor.data
          const i = this.editor.editing.view.document
          const r = o.toView(n.getSelectionAsFragment())
          i.fire('clipboardOutput', { dataTransfer: e.dataTransfer, content: r, method: t.name })
        }
        _onInsertContent(t, e, n) {
          if (n && !n.is('documentSelection')) {
            return
          }
          const o = this.editor.model
          const i = this.editor.plugins.get(dW)
          let r = this.getTableIfOnlyTableInContent(e, o)
          if (!r) {
            return
          }
          const s = i.getSelectionAffectedTableCells(o.document.selection)
          if (!s.length) {
            YU(r, i)
            return
          }
          t.stop()
          o.change((t) => {
            const e = { width: i.getColumns(r), height: i.getRows(r) }
            const n = hG(s, e, t, i)
            const o = n.lastRow - n.firstRow + 1
            const a = n.lastColumn - n.firstColumn + 1
            const c = {
              startRow: 0,
              startColumn: 0,
              endRow: Math.min(o, e.height) - 1,
              endColumn: Math.min(a, e.width) - 1,
            }
            r = FU(r, c, t)
            const l = s[0].findAncestor('table')
            const d = this._replaceSelectedCellsWithPasted(r, e, l, n, t)
            if (this.editor.plugins.get('TableSelection').isEnabled) {
              const e = i.sortRanges(d.map((e) => t.createRangeOn(e)))
              t.setSelection(e)
            } else {
              t.setSelection(d[0], 0)
            }
          })
        }
        _replaceSelectedCellsWithPasted(t, e, n, o, i) {
          const { width: r, height: s } = e
          const a = fG(t, r, s)
          const c = [
            ...new EU(n, {
              startRow: o.firstRow,
              endRow: o.lastRow,
              startColumn: o.firstColumn,
              endColumn: o.lastColumn,
              includeAllSlots: true,
            }),
          ]
          const l = []
          let d
          for (const t of c) {
            const { row: e, column: n } = t
            if (n === o.firstColumn) {
              d = t.getPositionBefore()
            }
            const c = e - o.firstRow
            const u = n - o.firstColumn
            const h = a[c % s][u % r]
            const g = h ? i.cloneElement(h) : null
            const f = this._replaceTableSlotCell(t, g, d, i)
            if (!f) {
              continue
            }
            GU(f, e, n, o.lastRow, o.lastColumn, i)
            l.push(f)
            d = i.createPositionAfter(f)
          }
          const u = parseInt(n.getAttribute('headingRows') || '0')
          const h = parseInt(n.getAttribute('headingColumns') || '0')
          const g = o.firstRow < u && u <= o.lastRow
          const f = o.firstColumn < h && h <= o.lastColumn
          if (g) {
            const t = { first: o.firstColumn, last: o.lastColumn }
            const e = pG(n, u, t, i, o.firstRow)
            l.push(...e)
          }
          if (f) {
            const t = { first: o.firstRow, last: o.lastRow }
            const e = bG(n, h, t, i)
            l.push(...e)
          }
          return l
        }
        _replaceTableSlotCell(t, e, n, o) {
          const { cell: i, isAnchor: r } = t
          if (r) {
            o.remove(i)
          }
          if (!e) {
            return null
          }
          o.insert(e, n)
          return e
        }
        getTableIfOnlyTableInContent(t, e) {
          if (!t.is('documentFragment') && !t.is('element')) {
            return null
          }
          if (t.is('element', 'table')) {
            return t
          }
          if (t.childCount == 1 && t.getChild(0).is('element', 'table')) {
            return t.getChild(0)
          }
          const n = e.createRangeIn(t)
          for (const t of n.getItems()) {
            if (t.is('element', 'table')) {
              const o = e.createRange(n.start, e.createPositionBefore(t))
              if (e.hasContent(o, { ignoreWhitespaces: true })) {
                return null
              }
              const i = e.createRange(e.createPositionAfter(t), n.end)
              if (e.hasContent(i, { ignoreWhitespaces: true })) {
                return null
              }
              return t
            }
          }
          return null
        }
      }
      function hG(t, e, n, o) {
        const i = t[0].findAncestor('table')
        const r = o.getColumnIndexes(t)
        const s = o.getRowIndexes(t)
        const a = { firstColumn: r.first, lastColumn: r.last, firstRow: s.first, lastRow: s.last }
        const c = t.length === 1
        if (c) {
          a.lastRow += e.height - 1
          a.lastColumn += e.width - 1
          gG(i, a.lastRow + 1, a.lastColumn + 1, o)
        }
        if (c || !o.isSelectionRectangular(t)) {
          mG(i, a, n)
        } else {
          a.lastRow = ZU(i, a)
          a.lastColumn = QU(i, a)
        }
        return a
      }
      function gG(t, e, n, o) {
        const i = o.getColumns(t)
        const r = o.getRows(t)
        if (n > i) {
          o.insertColumns(t, { at: i, columns: n - i })
        }
        if (e > r) {
          o.insertRows(t, { at: r, rows: e - r })
        }
      }
      function fG(t, e, n) {
        const o = new Array(n).fill(null).map(() => new Array(e).fill(null))
        for (const { column: e, row: n, cell: i } of new EU(t)) {
          o[n][e] = i
        }
        return o
      }
      function mG(t, e, n) {
        const { firstRow: o, lastRow: i, firstColumn: r, lastColumn: s } = e
        const a = { first: o, last: i }
        const c = { first: r, last: s }
        bG(t, r, a, n)
        bG(t, s + 1, a, n)
        pG(t, o, c, n)
        pG(t, i + 1, c, n, o)
      }
      function pG(t, e, n, o, i = 0) {
        if (e < 1) {
          return
        }
        const r = jU(t, e, i)
        const s = r.filter(({ column: t, cellWidth: e }) => kG(t, e, n))
        return s.map(({ cell: t }) => HU(t, e, o))
      }
      function bG(t, e, n, o) {
        if (e < 1) {
          return
        }
        const i = UU(t, e)
        const r = i.filter(({ row: t, cellHeight: e }) => kG(t, e, n))
        return r.map(({ cell: t, column: n }) => WU(t, n, e, o))
      }
      function kG(t, e, n) {
        const o = t + e - 1
        const { first: i, last: r } = n
        const s = t >= i && t <= r
        const a = t < i && o >= i
        return s || a
      }
      class wG extends Du {
        static get pluginName() {
          return 'TableKeyboard'
        }
        static get requires() {
          return [dG, dW]
        }
        init() {
          const t = this.editor.editing.view
          const e = t.document
          this.listenTo(e, 'arrowKey', (...t) => this._onArrowKey(...t), { context: 'table' })
          this.listenTo(e, 'tab', (...t) => this._handleTabOnSelectedTable(...t), { context: 'figure' })
          this.listenTo(e, 'tab', (...t) => this._handleTab(...t), { context: ['th', 'td'] })
        }
        _handleTabOnSelectedTable(t, e) {
          const n = this.editor
          const o = n.model.document.selection
          const i = o.getSelectedElement()
          if (!i || !i.is('element', 'table')) {
            return
          }
          e.preventDefault()
          e.stopPropagation()
          t.stop()
          n.model.change((t) => {
            t.setSelection(t.createRangeIn(i.getChild(0).getChild(0)))
          })
        }
        _handleTab(t, e) {
          const n = this.editor
          const o = this.editor.plugins.get(dW)
          const i = this.editor.plugins.get('TableSelection')
          const r = n.model.document.selection
          const s = !e.shiftKey
          let a = o.getTableCellsContainingSelection(r)[0]
          if (!a) {
            a = i.getFocusCell()
          }
          if (!a) {
            return
          }
          e.preventDefault()
          e.stopPropagation()
          t.stop()
          const c = a.parent
          const l = c.parent
          const d = l.getChildIndex(c)
          const u = c.getChildIndex(a)
          const h = u === 0
          if (!s && h && d === 0) {
            n.model.change((t) => {
              t.setSelection(t.createRangeOn(l))
            })
            return
          }
          const g = u === c.childCount - 1
          const f = d === o.getRows(l) - 1
          if (s && f && g) {
            n.execute('insertTableRowBelow')
            if (d === o.getRows(l) - 1) {
              n.model.change((t) => {
                t.setSelection(t.createRangeOn(l))
              })
              return
            }
          }
          let m
          if (s && g) {
            const t = l.getChild(d + 1)
            m = t.getChild(0)
          } else if (!s && h) {
            const t = l.getChild(d - 1)
            m = t.getChild(t.childCount - 1)
          } else {
            m = c.getChild(u + (s ? 1 : -1))
          }
          n.model.change((t) => {
            t.setSelection(t.createRangeIn(m))
          })
        }
        _onArrowKey(t, e) {
          const n = this.editor
          const o = e.keyCode
          const i = el(o, n.locale.contentLanguageDirection)
          const r = this._handleArrowKeys(i, e.shiftKey)
          if (r) {
            e.preventDefault()
            e.stopPropagation()
            t.stop()
          }
        }
        _handleArrowKeys(t, e) {
          const n = this.editor.plugins.get(dW)
          const o = this.editor.plugins.get('TableSelection')
          const i = this.editor.model
          const r = i.document.selection
          const s = ['right', 'down'].includes(t)
          const a = n.getSelectedTableCells(r)
          if (a.length) {
            let n
            if (e) {
              n = o.getFocusCell()
            } else {
              n = s ? a[a.length - 1] : a[0]
            }
            this._navigateFromCellInDirection(n, t, e)
            return true
          }
          const c = r.focus.findAncestor('tableCell')
          if (!c) {
            return false
          }
          if (!r.isCollapsed) {
            if (e) {
              if (r.isBackward == s && !r.containsEntireContent(c)) {
                return false
              }
            } else {
              const t = r.getSelectedElement()
              if (!t || !i.schema.isObject(t)) {
                return false
              }
            }
          }
          if (this._isSelectionAtCellEdge(r, c, s)) {
            this._navigateFromCellInDirection(c, t, e)
            return true
          }
          return false
        }
        _isSelectionAtCellEdge(t, e, n) {
          const o = this.editor.model
          const i = this.editor.model.schema
          const r = n ? t.getLastPosition() : t.getFirstPosition()
          if (!i.getLimitElement(r).is('element', 'tableCell')) {
            const t = o.createPositionAt(e, n ? 'end' : 0)
            return t.isTouching(r)
          }
          const s = o.createSelection(r)
          o.modifySelection(s, { direction: n ? 'forward' : 'backward' })
          return r.isEqual(s.focus)
        }
        _navigateFromCellInDirection(t, e, n = false) {
          const o = this.editor.model
          const i = t.findAncestor('table')
          const r = [...new EU(i, { includeAllSlots: true })]
          const { row: s, column: a } = r[r.length - 1]
          const c = r.find(({ cell: e }) => e == t)
          let { row: l, column: d } = c
          switch (e) {
            case 'left':
              d--
              break
            case 'up':
              l--
              break
            case 'right':
              d += c.cellWidth
              break
            case 'down':
              l += c.cellHeight
              break
          }
          const u = l < 0 || l > s
          const h = d < 0 && l <= 0
          const g = d > a && l >= s
          if (u || h || g) {
            o.change((t) => {
              t.setSelection(t.createRangeOn(i))
            })
            return
          }
          if (d < 0) {
            d = n ? 0 : a
            l--
          } else if (d > a) {
            d = n ? a : 0
            l++
          }
          const f = r.find((t) => t.row == l && t.column == d).cell
          const m = ['right', 'down'].includes(e)
          const p = this.editor.plugins.get('TableSelection')
          if (n && p.isEnabled) {
            const e = p.getAnchorCell() || t
            p.setCellSelection(e, f)
          } else {
            const t = o.createPositionAt(f, m ? 0 : 'end')
            o.change((e) => {
              e.setSelection(t)
            })
          }
        }
      }
      class AG extends Lm {
        constructor() {
          super(...arguments)
          this.domEventType = ['mousemove', 'mouseleave']
        }
        onDomEvent(t) {
          this.fire(t.type, t)
        }
      }
      class _G extends Du {
        static get pluginName() {
          return 'TableMouse'
        }
        static get requires() {
          return [dG, dW]
        }
        init() {
          const t = this.editor
          t.editing.view.addObserver(AG)
          this._enableShiftClickSelection()
          this._enableMouseDragSelection()
        }
        _enableShiftClickSelection() {
          const t = this.editor
          const e = t.plugins.get(dW)
          let n = false
          const o = t.plugins.get(dG)
          this.listenTo(t.editing.view.document, 'mousedown', (i, r) => {
            const s = t.model.document.selection
            if (!this.isEnabled || !o.isEnabled) {
              return
            }
            if (!r.domEvent.shiftKey) {
              return
            }
            const a = o.getAnchorCell() || e.getTableCellsContainingSelection(s)[0]
            if (!a) {
              return
            }
            const c = this._getModelTableCellFromDomEvent(r)
            if (c && CG(a, c)) {
              n = true
              o.setCellSelection(a, c)
              r.preventDefault()
            }
          })
          this.listenTo(t.editing.view.document, 'mouseup', () => {
            n = false
          })
          this.listenTo(
            t.editing.view.document,
            'selectionChange',
            (t) => {
              if (n) {
                t.stop()
              }
            },
            { priority: 'highest' },
          )
        }
        _enableMouseDragSelection() {
          const t = this.editor
          let e, n
          let o = false
          let i = false
          const r = t.plugins.get(dG)
          this.listenTo(t.editing.view.document, 'mousedown', (t, n) => {
            if (!this.isEnabled || !r.isEnabled) {
              return
            }
            if (n.domEvent.shiftKey || n.domEvent.ctrlKey || n.domEvent.altKey) {
              return
            }
            e = this._getModelTableCellFromDomEvent(n)
          })
          this.listenTo(t.editing.view.document, 'mousemove', (t, s) => {
            if (!s.domEvent.buttons) {
              return
            }
            if (!e) {
              return
            }
            const a = this._getModelTableCellFromDomEvent(s)
            if (a && CG(e, a)) {
              n = a
              if (!o && n != e) {
                o = true
              }
            }
            if (!o) {
              return
            }
            i = true
            r.setCellSelection(e, n)
            s.preventDefault()
          })
          this.listenTo(t.editing.view.document, 'mouseup', () => {
            o = false
            i = false
            e = null
            n = null
          })
          this.listenTo(
            t.editing.view.document,
            'selectionChange',
            (t) => {
              if (i) {
                t.stop()
              }
            },
            { priority: 'highest' },
          )
        }
        _getModelTableCellFromDomEvent(t) {
          const e = t.target
          const n = this.editor.editing.view.createPositionAt(e, 0)
          const o = this.editor.editing.mapper.toModelPosition(n)
          const i = o.parent
          return i.findAncestor('tableCell', { includeSelf: true })
        }
      }
      function CG(t, e) {
        return t.parent.parent == e.parent.parent
      }
      var vG = n(2510)
      var yG = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      yG.insert = 'head'
      yG.singleton = true
      var xG = Rl()(vG.Z, yG)
      const EG = vG.Z.locals || {}
      class DG extends Du {
        static get requires() {
          return [$W, iG, dG, _G, wG, uG, hM]
        }
        static get pluginName() {
          return 'Table'
        }
      }
      class TG extends (null && Plugin) {
        static get pluginName() {
          return 'PlainTableOutput'
        }
        static get requires() {
          return [Table]
        }
        init() {
          const t = this.editor
          t.conversion.for('dataDowncast').elementToStructure({ model: 'table', view: IG, converterPriority: 'high' })
          if (t.plugins.has('TableCaption')) {
            t.conversion.for('dataDowncast').elementToElement({
              model: 'caption',
              view: (t, { writer: e }) => {
                if (t.parent.name === 'table') {
                  return e.createContainerElement('caption')
                }
              },
              converterPriority: 'high',
            })
          }
          if (t.plugins.has('TableProperties')) {
            SG(t)
          }
        }
      }
      function IG(t, { writer: e }) {
        const n = t.getAttribute('headingRows') || 0
        const o = e.createSlot((t) => t.is('element', 'tableRow') && t.index < n)
        const i = e.createSlot((t) => t.is('element', 'tableRow') && t.index >= n)
        const r = e.createSlot((t) => !t.is('element', 'tableRow'))
        const s = e.createContainerElement('thead', null, o)
        const a = e.createContainerElement('tbody', null, i)
        const c = []
        if (n) {
          c.push(s)
        }
        if (n < t.childCount) {
          c.push(a)
        }
        return e.createContainerElement('table', null, [r, ...c])
      }
      function SG(t) {
        const e = {
          'border-width': 'tableBorderWidth',
          'border-color': 'tableBorderColor',
          'border-style': 'tableBorderStyle',
          'background-color': 'tableBackgroundColor',
        }
        for (const [n, o] of Object.entries(e)) {
          t.conversion.for('dataDowncast').add((t) =>
            t.on(
              `attribute:${o}:table`,
              (t, e, o) => {
                const { item: i, attributeNewValue: r } = e
                const { mapper: s, writer: a } = o
                if (!o.consumable.consume(i, t.name)) {
                  return
                }
                const c = s.toViewElement(i)
                if (r) {
                  a.setStyle(n, r, c)
                } else {
                  a.removeStyle(n, c)
                }
              },
              { priority: 'high' },
            ),
          )
        }
      }
      function MG(t) {
        const e = t.getSelectedElement()
        if (e && NG(e)) {
          return e
        }
        return null
      }
      function BG(t) {
        const e = t.getFirstPosition()
        if (!e) {
          return null
        }
        let n = e.parent
        while (n) {
          if (n.is('element') && NG(n)) {
            return n
          }
          n = n.parent
        }
        return null
      }
      function NG(t) {
        return !!t.getCustomProperty('table') && xS(t)
      }
      class PG extends Du {
        static get requires() {
          return [mM]
        }
        static get pluginName() {
          return 'TableToolbar'
        }
        afterInit() {
          const t = this.editor
          const e = t.t
          const n = t.plugins.get(mM)
          const o = t.config.get('table.contentToolbar')
          const i = t.config.get('table.tableToolbar')
          if (o) {
            n.register('tableContent', { ariaLabel: e('Table toolbar'), items: o, getRelatedElement: BG })
          }
          if (i) {
            n.register('table', { ariaLabel: e('Table toolbar'), items: i, getRelatedElement: MG })
          }
        }
      }
      var LG = n(9953)
      var zG = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      zG.insert = 'head'
      zG.singleton = true
      var RG = Rl()(LG.Z, zG)
      const OG = LG.Z.locals || {}
      class VG extends (null && View) {
        constructor(t, e) {
          super(t)
          this.set('value', '')
          this.set('isReadOnly', false)
          this.set('isFocused', false)
          this.set('isEmpty', true)
          this.options = e
          this.focusTracker = new FocusTracker()
          this._focusables = new ViewCollection()
          this.dropdownView = this._createDropdownView()
          this.inputView = this._createInputTextView()
          this.keystrokes = new KeystrokeHandler()
          this._stillTyping = false
          this._focusCycler = new FocusCycler({
            focusables: this._focusables,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: { focusPrevious: 'shift + tab', focusNext: 'tab' },
          })
          this.setTemplate({
            tag: 'div',
            attributes: { class: ['ck', 'ck-input-color'] },
            children: [this.dropdownView, this.inputView],
          })
          this.on('change:value', (t, e, n) => this._setInputValue(n))
        }
        render() {
          super.render()
          this.keystrokes.listenTo(this.dropdownView.panelView.element)
        }
        focus() {
          this.inputView.focus()
        }
        destroy() {
          super.destroy()
          this.focusTracker.destroy()
          this.keystrokes.destroy()
        }
        _createDropdownView() {
          const t = this.locale
          const e = t.t
          const n = this.bindTemplate
          const o = this._createColorSelector(t)
          const i = createDropdown(t)
          const r = new View()
          r.setTemplate({
            tag: 'span',
            attributes: { class: ['ck', 'ck-input-color__button__preview'], style: { backgroundColor: n.to('value') } },
            children: [
              {
                tag: 'span',
                attributes: {
                  class: [
                    'ck',
                    'ck-input-color__button__preview__no-color-indicator',
                    n.if('value', 'ck-hidden', (t) => t != ''),
                  ],
                },
              },
            ],
          })
          i.buttonView.extendTemplate({ attributes: { class: 'ck-input-color__button' } })
          i.buttonView.children.add(r)
          i.buttonView.label = e('Color picker')
          i.buttonView.tooltip = true
          i.panelPosition = t.uiLanguageDirection === 'rtl' ? 'se' : 'sw'
          i.panelView.children.add(o)
          i.bind('isEnabled').to(this, 'isReadOnly', (t) => !t)
          this._focusables.add(o)
          this.focusTracker.add(o.element)
          i.on('change:isOpen', (t, e, n) => {
            if (n) {
              o.updateSelectedColors()
              o.showColorGridsFragment()
            }
          })
          return i
        }
        _createInputTextView() {
          const t = this.locale
          const e = new InputTextView(t)
          e.extendTemplate({ on: { blur: e.bindTemplate.to('blur') } })
          e.value = this.value
          e.bind('isReadOnly', 'hasError').to(this)
          this.bind('isFocused', 'isEmpty').to(e)
          e.on('input', () => {
            const t = e.element.value
            const n = this.options.colorDefinitions.find((e) => t === e.label)
            this._stillTyping = true
            this.value = (n && n.color) || t
          })
          e.on('blur', () => {
            this._stillTyping = false
            this._setInputValue(e.element.value)
          })
          e.delegate('input').to(this)
          return e
        }
        _createColorSelector(t) {
          const e = t.t
          const n = this.options.defaultColorValue || ''
          const o = n ? e('Restore default') : e('Remove color')
          const i = new ColorSelectorView(t, {
            colors: this.options.colorDefinitions,
            columns: this.options.columns,
            removeButtonLabel: o,
            colorPickerLabel: e('Color picker'),
            colorPickerViewConfig:
              this.options.colorPickerConfig === false ? false : { ...this.options.colorPickerConfig, hideInput: true },
          })
          i.appendUI()
          i.on('execute', (t, e) => {
            if (e.source === 'colorPickerSaveButton') {
              this.dropdownView.isOpen = false
              return
            }
            this.value = e.value || n
            this.fire('input')
            if (e.source !== 'colorPicker') {
              this.dropdownView.isOpen = false
            }
          })
          let r = this.value
          i.on('colorPicker:cancel', () => {
            this.value = r
            this.fire('input')
            this.dropdownView.isOpen = false
          })
          i.colorGridsFragmentView.colorPickerButtonView.on('execute', () => {
            r = this.value
          })
          i.bind('selectedColor').to(this, 'value')
          return i
        }
        _setInputValue(t) {
          if (!this._stillTyping) {
            const e = FG(t)
            const n = this.options.colorDefinitions.find((t) => e === FG(t.color))
            if (n) {
              this.inputView.value = n.label
            } else {
              this.inputView.value = t || ''
            }
          }
        }
      }
      function FG(t) {
        return t
          .replace(/([(,])\s+/g, '$1')
          .replace(/^\s+|\s+(?=[),\s]|$)/g, '')
          .replace(/,|\s/g, ' ')
      }
      const jG = (t) => t === ''
      function HG(t) {
        return {
          none: t('None'),
          solid: t('Solid'),
          dotted: t('Dotted'),
          dashed: t('Dashed'),
          double: t('Double'),
          groove: t('Groove'),
          ridge: t('Ridge'),
          inset: t('Inset'),
          outset: t('Outset'),
        }
      }
      function UG(t) {
        return t('The color is invalid. Try "#FF0000" or "rgb(255,0,0)" or "red".')
      }
      function WG(t) {
        return t('The value is invalid. Try "10px" or "2em" or simply "2".')
      }
      function GG(t) {
        t = t.trim()
        return jG(t) || isColor(t)
      }
      function qG(t) {
        t = t.trim()
        return jG(t) || JG(t) || isLength(t) || isPercentage(t)
      }
      function $G(t) {
        t = t.trim()
        return jG(t) || JG(t) || isLength(t)
      }
      function KG(t, e) {
        const n = new Collection()
        const o = HG(t.t)
        for (const i in o) {
          const r = {
            type: 'button',
            model: new Model({ _borderStyleValue: i, label: o[i], role: 'menuitemradio', withText: true }),
          }
          if (i === 'none') {
            r.model.bind('isOn').to(t, 'borderStyle', (t) => {
              if (e === 'none') {
                return !t
              }
              return t === i
            })
          } else {
            r.model.bind('isOn').to(t, 'borderStyle', (t) => t === i)
          }
          n.add(r)
        }
        return n
      }
      function YG(t) {
        const { view: e, icons: n, toolbar: o, labels: i, propertyName: r, nameToValue: s, defaultValue: a } = t
        for (const t in i) {
          const c = new ButtonView(e.locale)
          c.set({ label: i[t], icon: n[t], tooltip: i[t] })
          const l = s ? s(t) : t
          c.bind('isOn').to(e, r, (t) => {
            let e = t
            if (t === '' && a) {
              e = a
            }
            return l === e
          })
          c.on('execute', () => {
            e[r] = l
          })
          o.items.add(c)
        }
      }
      const ZG = [
        { color: 'hsl(0, 0%, 0%)', label: 'Black' },
        { color: 'hsl(0, 0%, 30%)', label: 'Dim grey' },
        { color: 'hsl(0, 0%, 60%)', label: 'Grey' },
        { color: 'hsl(0, 0%, 90%)', label: 'Light grey' },
        { color: 'hsl(0, 0%, 100%)', label: 'White', hasBorder: true },
        { color: 'hsl(0, 75%, 60%)', label: 'Red' },
        { color: 'hsl(30, 75%, 60%)', label: 'Orange' },
        { color: 'hsl(60, 75%, 60%)', label: 'Yellow' },
        { color: 'hsl(90, 75%, 60%)', label: 'Light green' },
        { color: 'hsl(120, 75%, 60%)', label: 'Green' },
        { color: 'hsl(150, 75%, 60%)', label: 'Aquamarine' },
        { color: 'hsl(180, 75%, 60%)', label: 'Turquoise' },
        { color: 'hsl(210, 75%, 60%)', label: 'Light blue' },
        { color: 'hsl(240, 75%, 60%)', label: 'Blue' },
        { color: 'hsl(270, 75%, 60%)', label: 'Purple' },
      ]
      function QG(t) {
        return (e, n, o) => {
          const i = new ColorInputView(e.locale, {
            colorDefinitions: XG(t.colorConfig),
            columns: t.columns,
            defaultColorValue: t.defaultColorValue,
            colorPickerConfig: t.colorPickerConfig,
          })
          i.inputView.set({ id: n, ariaDescribedById: o })
          i.bind('isReadOnly').to(e, 'isEnabled', (t) => !t)
          i.bind('hasError').to(e, 'errorText', (t) => !!t)
          i.on('input', () => {
            e.errorText = null
          })
          e.bind('isEmpty', 'isFocused').to(i)
          return i
        }
      }
      function JG(t) {
        const e = parseFloat(t)
        return !Number.isNaN(e) && t === String(e)
      }
      function XG(t) {
        return t.map((t) => ({ color: t.model, label: t.label, options: { hasBorder: t.hasBorder } }))
      }
      var tq = n(6908)
      var eq = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      eq.insert = 'head'
      eq.singleton = true
      var nq = Rl()(tq.Z, eq)
      const oq = tq.Z.locals || {}
      class iq extends (null && View) {
        constructor(t, e = {}) {
          super(t)
          const n = this.bindTemplate
          this.set('class', e.class || null)
          this.children = this.createCollection()
          if (e.children) {
            e.children.forEach((t) => this.children.add(t))
          }
          this.set('_role', null)
          this.set('_ariaLabelledBy', null)
          if (e.labelView) {
            this.set({ _role: 'group', _ariaLabelledBy: e.labelView.id })
          }
          this.setTemplate({
            tag: 'div',
            attributes: {
              class: ['ck', 'ck-form__row', n.to('class')],
              role: n.to('_role'),
              'aria-labelledby': n.to('_ariaLabelledBy'),
            },
            children: this.children,
          })
        }
      }
      var rq = n(7502)
      var sq = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      sq.insert = 'head'
      sq.singleton = true
      var aq = Rl()(rq.Z, sq)
      const cq = rq.Z.locals || {}
      var lq = n(9429)
      var dq = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      dq.insert = 'head'
      dq.singleton = true
      var uq = Rl()(lq.Z, dq)
      const hq = lq.Z.locals || {}
      var gq = n(3964)
      var fq = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      fq.insert = 'head'
      fq.singleton = true
      var mq = Rl()(gq.Z, fq)
      const pq = gq.Z.locals || {}
      const bq = {
        left: Sv.alignLeft,
        center: Sv.alignCenter,
        right: Sv.alignRight,
        justify: Sv.alignJustify,
        top: Sv.alignTop,
        middle: Sv.alignMiddle,
        bottom: Sv.alignBottom,
      }
      class kq extends (null && View) {
        constructor(t, e) {
          super(t)
          this.set({
            borderStyle: '',
            borderWidth: '',
            borderColor: '',
            padding: '',
            backgroundColor: '',
            width: '',
            height: '',
            horizontalAlignment: '',
            verticalAlignment: '',
          })
          this.options = e
          const {
            borderStyleDropdown: n,
            borderWidthInput: o,
            borderColorInput: i,
            borderRowLabel: r,
          } = this._createBorderFields()
          const { backgroundRowLabel: s, backgroundInput: a } = this._createBackgroundFields()
          const { widthInput: c, operatorLabel: l, heightInput: d, dimensionsLabel: u } = this._createDimensionFields()
          const {
            horizontalAlignmentToolbar: h,
            verticalAlignmentToolbar: g,
            alignmentLabel: f,
          } = this._createAlignmentFields()
          this.focusTracker = new FocusTracker()
          this.keystrokes = new KeystrokeHandler()
          this.children = this.createCollection()
          this.borderStyleDropdown = n
          this.borderWidthInput = o
          this.borderColorInput = i
          this.backgroundInput = a
          this.paddingInput = this._createPaddingField()
          this.widthInput = c
          this.heightInput = d
          this.horizontalAlignmentToolbar = h
          this.verticalAlignmentToolbar = g
          const { saveButtonView: m, cancelButtonView: p } = this._createActionButtons()
          this.saveButtonView = m
          this.cancelButtonView = p
          this._focusables = new ViewCollection()
          this._focusCycler = new FocusCycler({
            focusables: this._focusables,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: { focusPrevious: 'shift + tab', focusNext: 'tab' },
          })
          this.children.add(new FormHeaderView(t, { label: this.t('Cell properties') }))
          this.children.add(
            new FormRowView(t, { labelView: r, children: [r, n, i, o], class: 'ck-table-form__border-row' }),
          )
          this.children.add(
            new FormRowView(t, { labelView: s, children: [s, a], class: 'ck-table-form__background-row' }),
          )
          this.children.add(
            new FormRowView(t, {
              children: [
                new FormRowView(t, { labelView: u, children: [u, c, l, d], class: 'ck-table-form__dimensions-row' }),
                new FormRowView(t, {
                  children: [this.paddingInput],
                  class: 'ck-table-cell-properties-form__padding-row',
                }),
              ],
            }),
          )
          this.children.add(
            new FormRowView(t, {
              labelView: f,
              children: [f, h, g],
              class: 'ck-table-cell-properties-form__alignment-row',
            }),
          )
          this.children.add(
            new FormRowView(t, {
              children: [this.saveButtonView, this.cancelButtonView],
              class: 'ck-table-form__action-row',
            }),
          )
          this.setTemplate({
            tag: 'form',
            attributes: { class: ['ck', 'ck-form', 'ck-table-form', 'ck-table-cell-properties-form'], tabindex: '-1' },
            children: this.children,
          })
        }
        render() {
          super.render()
          submitHandler({ view: this })
          ;[
            this.borderStyleDropdown,
            this.borderColorInput,
            this.borderColorInput.fieldView.dropdownView.buttonView,
            this.borderWidthInput,
            this.backgroundInput,
            this.backgroundInput.fieldView.dropdownView.buttonView,
            this.widthInput,
            this.heightInput,
            this.paddingInput,
            this.horizontalAlignmentToolbar,
            this.verticalAlignmentToolbar,
            this.saveButtonView,
            this.cancelButtonView,
          ].forEach((t) => {
            this._focusables.add(t)
            this.focusTracker.add(t.element)
          })
          this.keystrokes.listenTo(this.element)
        }
        destroy() {
          super.destroy()
          this.focusTracker.destroy()
          this.keystrokes.destroy()
        }
        focus() {
          this._focusCycler.focusFirst()
        }
        _createBorderFields() {
          const t = this.options.defaultTableCellProperties
          const e = { style: t.borderStyle, width: t.borderWidth, color: t.borderColor }
          const n = getLabeledColorInputCreator({
            colorConfig: this.options.borderColors,
            columns: 5,
            defaultColorValue: e.color,
            colorPickerConfig: this.options.colorPickerConfig,
          })
          const o = this.locale
          const i = this.t
          const r = i('Style')
          const s = new LabelView(o)
          s.text = i('Border')
          const a = getBorderStyleLabels(i)
          const c = new LabeledFieldView(o, createLabeledDropdown)
          c.set({ label: r, class: 'ck-table-form__border-style' })
          c.fieldView.buttonView.set({
            ariaLabel: r,
            ariaLabelledBy: undefined,
            isOn: false,
            withText: true,
            tooltip: r,
          })
          c.fieldView.buttonView.bind('label').to(this, 'borderStyle', (t) => a[t ? t : 'none'])
          c.fieldView.on('execute', (t) => {
            this.borderStyle = t.source._borderStyleValue
          })
          c.bind('isEmpty').to(this, 'borderStyle', (t) => !t)
          addListToDropdown(c.fieldView, getBorderStyleDefinitions(this, e.style), { role: 'menu', ariaLabel: r })
          const l = new LabeledFieldView(o, createLabeledInputText)
          l.set({ label: i('Width'), class: 'ck-table-form__border-width' })
          l.fieldView.bind('value').to(this, 'borderWidth')
          l.bind('isEnabled').to(this, 'borderStyle', wq)
          l.fieldView.on('input', () => {
            this.borderWidth = l.fieldView.element.value
          })
          const d = new LabeledFieldView(o, n)
          d.set({ label: i('Color'), class: 'ck-table-form__border-color' })
          d.fieldView.bind('value').to(this, 'borderColor')
          d.bind('isEnabled').to(this, 'borderStyle', wq)
          d.fieldView.on('input', () => {
            this.borderColor = d.fieldView.value
          })
          this.on('change:borderStyle', (t, n, o, i) => {
            if (!wq(o)) {
              this.borderColor = ''
              this.borderWidth = ''
            }
            if (!wq(i)) {
              this.borderColor = e.color
              this.borderWidth = e.width
            }
          })
          return { borderRowLabel: s, borderStyleDropdown: c, borderColorInput: d, borderWidthInput: l }
        }
        _createBackgroundFields() {
          const t = this.locale
          const e = this.t
          const n = new LabelView(t)
          n.text = e('Background')
          const o = getLabeledColorInputCreator({
            colorConfig: this.options.backgroundColors,
            columns: 5,
            defaultColorValue: this.options.defaultTableCellProperties.backgroundColor,
            colorPickerConfig: this.options.colorPickerConfig,
          })
          const i = new LabeledFieldView(t, o)
          i.set({ label: e('Color'), class: 'ck-table-cell-properties-form__background' })
          i.fieldView.bind('value').to(this, 'backgroundColor')
          i.fieldView.on('input', () => {
            this.backgroundColor = i.fieldView.value
          })
          return { backgroundRowLabel: n, backgroundInput: i }
        }
        _createDimensionFields() {
          const t = this.locale
          const e = this.t
          const n = new LabelView(t)
          n.text = e('Dimensions')
          const o = new LabeledFieldView(t, createLabeledInputText)
          o.set({ label: e('Width'), class: 'ck-table-form__dimensions-row__width' })
          o.fieldView.bind('value').to(this, 'width')
          o.fieldView.on('input', () => {
            this.width = o.fieldView.element.value
          })
          const i = new View(t)
          i.setTemplate({
            tag: 'span',
            attributes: { class: ['ck-table-form__dimension-operator'] },
            children: [{ text: '×' }],
          })
          const r = new LabeledFieldView(t, createLabeledInputText)
          r.set({ label: e('Height'), class: 'ck-table-form__dimensions-row__height' })
          r.fieldView.bind('value').to(this, 'height')
          r.fieldView.on('input', () => {
            this.height = r.fieldView.element.value
          })
          return { dimensionsLabel: n, widthInput: o, operatorLabel: i, heightInput: r }
        }
        _createPaddingField() {
          const t = this.locale
          const e = this.t
          const n = new LabeledFieldView(t, createLabeledInputText)
          n.set({ label: e('Padding'), class: 'ck-table-cell-properties-form__padding' })
          n.fieldView.bind('value').to(this, 'padding')
          n.fieldView.on('input', () => {
            this.padding = n.fieldView.element.value
          })
          return n
        }
        _createAlignmentFields() {
          const t = this.locale
          const e = this.t
          const n = new LabelView(t)
          n.text = e('Table cell text alignment')
          const o = new ToolbarView(t)
          const i = t.contentLanguageDirection === 'rtl'
          o.set({ isCompact: true, ariaLabel: e('Horizontal text alignment toolbar') })
          fillToolbar({
            view: this,
            icons: bq,
            toolbar: o,
            labels: this._horizontalAlignmentLabels,
            propertyName: 'horizontalAlignment',
            nameToValue: (t) => {
              if (i) {
                if (t === 'left') {
                  return 'right'
                } else if (t === 'right') {
                  return 'left'
                }
              }
              return t
            },
            defaultValue: this.options.defaultTableCellProperties.horizontalAlignment,
          })
          const r = new ToolbarView(t)
          r.set({ isCompact: true, ariaLabel: e('Vertical text alignment toolbar') })
          fillToolbar({
            view: this,
            icons: bq,
            toolbar: r,
            labels: this._verticalAlignmentLabels,
            propertyName: 'verticalAlignment',
            defaultValue: this.options.defaultTableCellProperties.verticalAlignment,
          })
          return { horizontalAlignmentToolbar: o, verticalAlignmentToolbar: r, alignmentLabel: n }
        }
        _createActionButtons() {
          const t = this.locale
          const e = this.t
          const n = new ButtonView(t)
          const o = new ButtonView(t)
          const i = [this.borderWidthInput, this.borderColorInput, this.backgroundInput, this.paddingInput]
          n.set({ label: e('Save'), icon: icons.check, class: 'ck-button-save', type: 'submit', withText: true })
          n.bind('isEnabled').toMany(i, 'errorText', (...t) => t.every((t) => !t))
          o.set({ label: e('Cancel'), icon: icons.cancel, class: 'ck-button-cancel', withText: true })
          o.delegate('execute').to(this, 'cancel')
          return { saveButtonView: n, cancelButtonView: o }
        }
        get _horizontalAlignmentLabels() {
          const t = this.locale
          const e = this.t
          const n = e('Align cell text to the left')
          const o = e('Align cell text to the center')
          const i = e('Align cell text to the right')
          const r = e('Justify cell text')
          if (t.uiLanguageDirection === 'rtl') {
            return { right: i, center: o, left: n, justify: r }
          } else {
            return { left: n, center: o, right: i, justify: r }
          }
        }
        get _verticalAlignmentLabels() {
          const t = this.t
          return {
            top: t('Align cell text to the top'),
            middle: t('Align cell text to the middle'),
            bottom: t('Align cell text to the bottom'),
          }
        }
      }
      function wq(t) {
        return t !== 'none'
      }
      const Aq = Jx.defaultPositions
      const _q = [
        Aq.northArrowSouth,
        Aq.northArrowSouthWest,
        Aq.northArrowSouthEast,
        Aq.southArrowNorth,
        Aq.southArrowNorthWest,
        Aq.southArrowNorthEast,
        Aq.viewportStickyNorth,
      ]
      function Cq(t, e) {
        const n = t.plugins.get('ContextualBalloon')
        if (getTableWidgetAncestor(t.editing.view.document.selection)) {
          let o
          if (e === 'cell') {
            o = yq(t)
          } else {
            o = vq(t)
          }
          n.updatePosition(o)
        }
      }
      function vq(t) {
        const e = t.model.document.selection.getFirstPosition()
        const n = e.findAncestor('table')
        const o = t.editing.mapper.toViewElement(n)
        return { target: t.editing.view.domConverter.mapViewToDom(o), positions: _q }
      }
      function yq(t) {
        const e = t.editing.mapper
        const n = t.editing.view.domConverter
        const o = t.model.document.selection
        if (o.rangeCount > 1) {
          return { target: () => Eq(o.getRanges(), t), positions: _q }
        }
        const i = xq(o.getFirstPosition())
        const r = e.toViewElement(i)
        return { target: n.mapViewToDom(r), positions: _q }
      }
      function xq(t) {
        const e = t.nodeAfter && t.nodeAfter.is('element', 'tableCell')
        return e ? t.nodeAfter : t.findAncestor('tableCell')
      }
      function Eq(t, e) {
        const n = e.editing.mapper
        const o = e.editing.view.domConverter
        const i = Array.from(t).map((t) => {
          const e = xq(t.start)
          const i = n.toViewElement(e)
          return new Rect(o.mapViewToDom(i))
        })
        return Rect.getBoundingRect(i)
      }
      const Dq = 500
      const Tq = {
        borderStyle: 'tableCellBorderStyle',
        borderColor: 'tableCellBorderColor',
        borderWidth: 'tableCellBorderWidth',
        height: 'tableCellHeight',
        width: 'tableCellWidth',
        padding: 'tableCellPadding',
        backgroundColor: 'tableCellBackgroundColor',
        horizontalAlignment: 'tableCellHorizontalAlignment',
        verticalAlignment: 'tableCellVerticalAlignment',
      }
      class Iq extends (null && Plugin) {
        static get requires() {
          return [ContextualBalloon]
        }
        static get pluginName() {
          return 'TableCellPropertiesUI'
        }
        constructor(t) {
          super(t)
          t.config.define('table.tableCellProperties', { borderColors: defaultColors, backgroundColors: defaultColors })
        }
        init() {
          const t = this.editor
          const e = t.t
          this._defaultTableCellProperties = getNormalizedDefaultProperties(
            t.config.get('table.tableCellProperties.defaultProperties'),
            {
              includeVerticalAlignmentProperty: true,
              includeHorizontalAlignmentProperty: true,
              includePaddingProperty: true,
              isRightToLeftContent: t.locale.contentLanguageDirection === 'rtl',
            },
          )
          this._balloon = t.plugins.get(ContextualBalloon)
          this.view = null
          this._isReady = false
          t.ui.componentFactory.add('tableCellProperties', (n) => {
            const o = new ButtonView(n)
            o.set({ label: e('Cell properties'), icon: tableCellProperties, tooltip: true })
            this.listenTo(o, 'execute', () => this._showView())
            const i = Object.values(Tq).map((e) => t.commands.get(e))
            o.bind('isEnabled').toMany(i, 'isEnabled', (...t) => t.some((t) => t))
            return o
          })
        }
        destroy() {
          super.destroy()
          if (this.view) {
            this.view.destroy()
          }
        }
        _createPropertiesView() {
          const t = this.editor
          const e = t.config.get('table.tableCellProperties')
          const n = normalizeColorOptions(e.borderColors)
          const o = getLocalizedColorOptions(t.locale, n)
          const i = normalizeColorOptions(e.backgroundColors)
          const r = getLocalizedColorOptions(t.locale, i)
          const s = e.colorPicker !== false
          const a = new TableCellPropertiesView(t.locale, {
            borderColors: o,
            backgroundColors: r,
            defaultTableCellProperties: this._defaultTableCellProperties,
            colorPickerConfig: s ? e.colorPicker || {} : false,
          })
          const c = t.t
          a.render()
          this.listenTo(a, 'submit', () => {
            this._hideView()
          })
          this.listenTo(a, 'cancel', () => {
            if (this._undoStepBatch.operations.length) {
              t.execute('undo', this._undoStepBatch)
            }
            this._hideView()
          })
          a.keystrokes.set('Esc', (t, e) => {
            this._hideView()
            e()
          })
          clickOutsideHandler({
            emitter: a,
            activator: () => this._isViewInBalloon,
            contextElements: [this._balloon.view.element],
            callback: () => this._hideView(),
          })
          const l = getLocalizedColorErrorText(c)
          const d = getLocalizedLengthErrorText(c)
          a.on('change:borderStyle', this._getPropertyChangeCallback('tableCellBorderStyle'))
          a.on(
            'change:borderColor',
            this._getValidatedPropertyChangeCallback({
              viewField: a.borderColorInput,
              commandName: 'tableCellBorderColor',
              errorText: l,
              validator: colorFieldValidator,
            }),
          )
          a.on(
            'change:borderWidth',
            this._getValidatedPropertyChangeCallback({
              viewField: a.borderWidthInput,
              commandName: 'tableCellBorderWidth',
              errorText: d,
              validator: lineWidthFieldValidator,
            }),
          )
          a.on(
            'change:padding',
            this._getValidatedPropertyChangeCallback({
              viewField: a.paddingInput,
              commandName: 'tableCellPadding',
              errorText: d,
              validator: lengthFieldValidator,
            }),
          )
          a.on(
            'change:width',
            this._getValidatedPropertyChangeCallback({
              viewField: a.widthInput,
              commandName: 'tableCellWidth',
              errorText: d,
              validator: lengthFieldValidator,
            }),
          )
          a.on(
            'change:height',
            this._getValidatedPropertyChangeCallback({
              viewField: a.heightInput,
              commandName: 'tableCellHeight',
              errorText: d,
              validator: lengthFieldValidator,
            }),
          )
          a.on(
            'change:backgroundColor',
            this._getValidatedPropertyChangeCallback({
              viewField: a.backgroundInput,
              commandName: 'tableCellBackgroundColor',
              errorText: l,
              validator: colorFieldValidator,
            }),
          )
          a.on('change:horizontalAlignment', this._getPropertyChangeCallback('tableCellHorizontalAlignment'))
          a.on('change:verticalAlignment', this._getPropertyChangeCallback('tableCellVerticalAlignment'))
          return a
        }
        _fillViewFormFromCommandValues() {
          const t = this.editor.commands
          const e = t.get('tableCellBorderStyle')
          Object.entries(Tq)
            .map(([e, n]) => {
              const o = this._defaultTableCellProperties[e] || ''
              return [e, t.get(n).value || o]
            })
            .forEach(([t, n]) => {
              if ((t === 'borderColor' || t === 'borderWidth') && e.value === 'none') {
                return
              }
              this.view.set(t, n)
            })
          this._isReady = true
        }
        _showView() {
          const t = this.editor
          if (!this.view) {
            this.view = this._createPropertiesView()
          }
          this.listenTo(t.ui, 'update', () => {
            this._updateView()
          })
          this._fillViewFormFromCommandValues()
          this._balloon.add({ view: this.view, position: getBalloonCellPositionData(t) })
          this._undoStepBatch = t.model.createBatch()
          this.view.focus()
        }
        _hideView() {
          const t = this.editor
          this.stopListening(t.ui, 'update')
          this._isReady = false
          this.view.saveButtonView.focus()
          this._balloon.remove(this.view)
          this.editor.editing.view.focus()
        }
        _updateView() {
          const t = this.editor
          const e = t.editing.view.document
          if (!getTableWidgetAncestor(e.selection)) {
            this._hideView()
          } else if (this._isViewVisible) {
            repositionContextualBalloon(t, 'cell')
          }
        }
        get _isViewVisible() {
          return !!this.view && this._balloon.visibleView === this.view
        }
        get _isViewInBalloon() {
          return !!this.view && this._balloon.hasView(this.view)
        }
        _getPropertyChangeCallback(t) {
          return (e, n, o) => {
            if (!this._isReady) {
              return
            }
            this.editor.execute(t, { value: o, batch: this._undoStepBatch })
          }
        }
        _getValidatedPropertyChangeCallback(t) {
          const { commandName: e, viewField: n, validator: o, errorText: i } = t
          const r = debounce(() => {
            n.errorText = i
          }, Dq)
          return (t, i, s) => {
            r.cancel()
            if (!this._isReady) {
              return
            }
            if (o(s)) {
              this.editor.execute(e, { value: s, batch: this._undoStepBatch })
              n.errorText = null
            } else {
              r()
            }
          }
        }
      }
      class Sq extends (null && Command) {
        constructor(t, e, n) {
          super(t)
          this.attributeName = e
          this._defaultValue = n
        }
        refresh() {
          const t = this.editor
          const e = this.editor.plugins.get('TableUtils')
          const n = e.getSelectionAffectedTableCells(t.model.document.selection)
          this.isEnabled = !!n.length
          this.value = this._getSingleValue(n)
        }
        execute(t = {}) {
          const { value: e, batch: n } = t
          const o = this.editor.model
          const i = this.editor.plugins.get('TableUtils')
          const r = i.getSelectionAffectedTableCells(o.document.selection)
          const s = this._getValueToSet(e)
          o.enqueueChange(n, (t) => {
            if (s) {
              r.forEach((e) => t.setAttribute(this.attributeName, s, e))
            } else {
              r.forEach((e) => t.removeAttribute(this.attributeName, e))
            }
          })
        }
        _getAttribute(t) {
          if (!t) {
            return
          }
          const e = t.getAttribute(this.attributeName)
          if (e === this._defaultValue) {
            return
          }
          return e
        }
        _getValueToSet(t) {
          if (t === this._defaultValue) {
            return
          }
          return t
        }
        _getSingleValue(t) {
          const e = this._getAttribute(t[0])
          const n = t.every((t) => this._getAttribute(t) === e)
          return n ? e : undefined
        }
      }
      class Mq extends (null && TableCellPropertyCommand) {
        constructor(t, e) {
          super(t, 'tableCellWidth', e)
        }
        _getValueToSet(t) {
          t = addDefaultUnitToNumericValue(t, 'px')
          if (t === this._defaultValue) {
            return
          }
          return t
        }
      }
      class Bq extends (null && Plugin) {
        static get pluginName() {
          return 'TableCellWidthEditing'
        }
        static get requires() {
          return [TableEditing]
        }
        init() {
          const t = this.editor
          const e = getNormalizedDefaultProperties(t.config.get('table.tableCellProperties.defaultProperties'))
          enableProperty(t.model.schema, t.conversion, {
            modelAttribute: 'tableCellWidth',
            styleName: 'width',
            defaultValue: e.width,
          })
          t.commands.add('tableCellWidth', new TableCellWidthCommand(t, e.width))
        }
      }
      class Nq extends (null && TableCellPropertyCommand) {
        constructor(t, e) {
          super(t, 'tableCellPadding', e)
        }
        _getAttribute(t) {
          if (!t) {
            return
          }
          const e = getSingleValue(t.getAttribute(this.attributeName))
          if (e === this._defaultValue) {
            return
          }
          return e
        }
        _getValueToSet(t) {
          const e = addDefaultUnitToNumericValue(t, 'px')
          if (e === this._defaultValue) {
            return
          }
          return e
        }
      }
      class Pq extends (null && TableCellPropertyCommand) {
        constructor(t, e) {
          super(t, 'tableCellHeight', e)
        }
        _getValueToSet(t) {
          const e = addDefaultUnitToNumericValue(t, 'px')
          if (e === this._defaultValue) {
            return
          }
          return e
        }
      }
      class Lq extends (null && TableCellPropertyCommand) {
        constructor(t, e) {
          super(t, 'tableCellBackgroundColor', e)
        }
      }
      class zq extends (null && TableCellPropertyCommand) {
        constructor(t, e) {
          super(t, 'tableCellVerticalAlignment', e)
        }
      }
      class Rq extends (null && TableCellPropertyCommand) {
        constructor(t, e) {
          super(t, 'tableCellHorizontalAlignment', e)
        }
      }
      class Oq extends (null && TableCellPropertyCommand) {
        constructor(t, e) {
          super(t, 'tableCellBorderStyle', e)
        }
        _getAttribute(t) {
          if (!t) {
            return
          }
          const e = getSingleValue(t.getAttribute(this.attributeName))
          if (e === this._defaultValue) {
            return
          }
          return e
        }
      }
      class Vq extends (null && TableCellPropertyCommand) {
        constructor(t, e) {
          super(t, 'tableCellBorderColor', e)
        }
        _getAttribute(t) {
          if (!t) {
            return
          }
          const e = getSingleValue(t.getAttribute(this.attributeName))
          if (e === this._defaultValue) {
            return
          }
          return e
        }
      }
      class Fq extends (null && TableCellPropertyCommand) {
        constructor(t, e) {
          super(t, 'tableCellBorderWidth', e)
        }
        _getAttribute(t) {
          if (!t) {
            return
          }
          const e = getSingleValue(t.getAttribute(this.attributeName))
          if (e === this._defaultValue) {
            return
          }
          return e
        }
        _getValueToSet(t) {
          const e = addDefaultUnitToNumericValue(t, 'px')
          if (e === this._defaultValue) {
            return
          }
          return e
        }
      }
      const jq = /^(top|middle|bottom)$/
      const Hq = /^(left|center|right|justify)$/
      class Uq extends (null && Plugin) {
        static get pluginName() {
          return 'TableCellPropertiesEditing'
        }
        static get requires() {
          return [TableEditing, TableCellWidthEditing]
        }
        init() {
          const t = this.editor
          const e = t.model.schema
          const n = t.conversion
          t.config.define('table.tableCellProperties.defaultProperties', {})
          const o = getNormalizedDefaultProperties(t.config.get('table.tableCellProperties.defaultProperties'), {
            includeVerticalAlignmentProperty: true,
            includeHorizontalAlignmentProperty: true,
            includePaddingProperty: true,
            isRightToLeftContent: t.locale.contentLanguageDirection === 'rtl',
          })
          t.data.addStyleProcessorRules(addBorderRules)
          Wq(e, n, { color: o.borderColor, style: o.borderStyle, width: o.borderWidth })
          t.commands.add('tableCellBorderStyle', new TableCellBorderStyleCommand(t, o.borderStyle))
          t.commands.add('tableCellBorderColor', new TableCellBorderColorCommand(t, o.borderColor))
          t.commands.add('tableCellBorderWidth', new TableCellBorderWidthCommand(t, o.borderWidth))
          enableProperty(e, n, { modelAttribute: 'tableCellHeight', styleName: 'height', defaultValue: o.height })
          t.commands.add('tableCellHeight', new TableCellHeightCommand(t, o.height))
          t.data.addStyleProcessorRules(addPaddingRules)
          enableProperty(e, n, {
            modelAttribute: 'tableCellPadding',
            styleName: 'padding',
            reduceBoxSides: true,
            defaultValue: o.padding,
          })
          t.commands.add('tableCellPadding', new TableCellPaddingCommand(t, o.padding))
          t.data.addStyleProcessorRules(addBackgroundRules)
          enableProperty(e, n, {
            modelAttribute: 'tableCellBackgroundColor',
            styleName: 'background-color',
            defaultValue: o.backgroundColor,
          })
          t.commands.add('tableCellBackgroundColor', new TableCellBackgroundColorCommand(t, o.backgroundColor))
          Gq(e, n, o.horizontalAlignment)
          t.commands.add(
            'tableCellHorizontalAlignment',
            new TableCellHorizontalAlignmentCommand(t, o.horizontalAlignment),
          )
          qq(e, n, o.verticalAlignment)
          t.commands.add('tableCellVerticalAlignment', new TableCellVerticalAlignmentCommand(t, o.verticalAlignment))
        }
      }
      function Wq(t, e, n) {
        const o = { width: 'tableCellBorderWidth', color: 'tableCellBorderColor', style: 'tableCellBorderStyle' }
        t.extend('tableCell', { allowAttributes: Object.values(o) })
        upcastBorderStyles(e, 'td', o, n)
        upcastBorderStyles(e, 'th', o, n)
        downcastAttributeToStyle(e, { modelElement: 'tableCell', modelAttribute: o.style, styleName: 'border-style' })
        downcastAttributeToStyle(e, { modelElement: 'tableCell', modelAttribute: o.color, styleName: 'border-color' })
        downcastAttributeToStyle(e, { modelElement: 'tableCell', modelAttribute: o.width, styleName: 'border-width' })
      }
      function Gq(t, e, n) {
        t.extend('tableCell', { allowAttributes: ['tableCellHorizontalAlignment'] })
        e.for('downcast').attributeToAttribute({
          model: { name: 'tableCell', key: 'tableCellHorizontalAlignment' },
          view: (t) => ({ key: 'style', value: { 'text-align': t } }),
        })
        e.for('upcast')
          .attributeToAttribute({
            view: { name: /^(td|th)$/, styles: { 'text-align': Hq } },
            model: {
              key: 'tableCellHorizontalAlignment',
              value: (t) => {
                const e = t.getStyle('text-align')
                return e === n ? null : e
              },
            },
          })
          .attributeToAttribute({
            view: { name: /^(td|th)$/, attributes: { align: Hq } },
            model: {
              key: 'tableCellHorizontalAlignment',
              value: (t) => {
                const e = t.getAttribute('align')
                return e === n ? null : e
              },
            },
          })
      }
      function qq(t, e, n) {
        t.extend('tableCell', { allowAttributes: ['tableCellVerticalAlignment'] })
        e.for('downcast').attributeToAttribute({
          model: { name: 'tableCell', key: 'tableCellVerticalAlignment' },
          view: (t) => ({ key: 'style', value: { 'vertical-align': t } }),
        })
        e.for('upcast')
          .attributeToAttribute({
            view: { name: /^(td|th)$/, styles: { 'vertical-align': jq } },
            model: {
              key: 'tableCellVerticalAlignment',
              value: (t) => {
                const e = t.getStyle('vertical-align')
                return e === n ? null : e
              },
            },
          })
          .attributeToAttribute({
            view: { name: /^(td|th)$/, attributes: { valign: jq } },
            model: {
              key: 'tableCellVerticalAlignment',
              value: (t) => {
                const e = t.getAttribute('valign')
                return e === n ? null : e
              },
            },
          })
      }
      class $q extends (null && Plugin) {
        static get pluginName() {
          return 'TableCellProperties'
        }
        static get requires() {
          return [TableCellPropertiesEditing, TableCellPropertiesUI]
        }
      }
      class Kq extends (null && Command) {
        constructor(t, e, n) {
          super(t)
          this.attributeName = e
          this._defaultValue = n
        }
        refresh() {
          const t = this.editor
          const e = t.model.document.selection
          const n = e.getFirstPosition().findAncestor('table')
          this.isEnabled = !!n
          this.value = this._getValue(n)
        }
        execute(t = {}) {
          const e = this.editor.model
          const n = e.document.selection
          const { value: o, batch: i } = t
          const r = n.getFirstPosition().findAncestor('table')
          const s = this._getValueToSet(o)
          e.enqueueChange(i, (t) => {
            if (s) {
              t.setAttribute(this.attributeName, s, r)
            } else {
              t.removeAttribute(this.attributeName, r)
            }
          })
        }
        _getValue(t) {
          if (!t) {
            return
          }
          const e = t.getAttribute(this.attributeName)
          if (e === this._defaultValue) {
            return
          }
          return e
        }
        _getValueToSet(t) {
          if (t === this._defaultValue) {
            return
          }
          return t
        }
      }
      class Yq extends (null && TablePropertyCommand) {
        constructor(t, e) {
          super(t, 'tableBackgroundColor', e)
        }
      }
      class Zq extends (null && TablePropertyCommand) {
        constructor(t, e) {
          super(t, 'tableBorderColor', e)
        }
        _getValue(t) {
          if (!t) {
            return
          }
          const e = getSingleValue(t.getAttribute(this.attributeName))
          if (e === this._defaultValue) {
            return
          }
          return e
        }
      }
      class Qq extends (null && TablePropertyCommand) {
        constructor(t, e) {
          super(t, 'tableBorderStyle', e)
        }
        _getValue(t) {
          if (!t) {
            return
          }
          const e = getSingleValue(t.getAttribute(this.attributeName))
          if (e === this._defaultValue) {
            return
          }
          return e
        }
      }
      class Jq extends (null && TablePropertyCommand) {
        constructor(t, e) {
          super(t, 'tableBorderWidth', e)
        }
        _getValue(t) {
          if (!t) {
            return
          }
          const e = getSingleValue(t.getAttribute(this.attributeName))
          if (e === this._defaultValue) {
            return
          }
          return e
        }
        _getValueToSet(t) {
          const e = addDefaultUnitToNumericValue(t, 'px')
          if (e === this._defaultValue) {
            return
          }
          return e
        }
      }
      class Xq extends (null && TablePropertyCommand) {
        constructor(t, e) {
          super(t, 'tableWidth', e)
        }
        _getValueToSet(t) {
          t = addDefaultUnitToNumericValue(t, 'px')
          if (t === this._defaultValue) {
            return
          }
          return t
        }
      }
      class t$ extends (null && TablePropertyCommand) {
        constructor(t, e) {
          super(t, 'tableHeight', e)
        }
        _getValueToSet(t) {
          t = addDefaultUnitToNumericValue(t, 'px')
          if (t === this._defaultValue) {
            return
          }
          return t
        }
      }
      class e$ extends (null && TablePropertyCommand) {
        constructor(t, e) {
          super(t, 'tableAlignment', e)
        }
      }
      const n$ = /^(left|center|right)$/
      const o$ = /^(left|none|right)$/
      class i$ extends (null && Plugin) {
        static get pluginName() {
          return 'TablePropertiesEditing'
        }
        static get requires() {
          return [TableEditing]
        }
        init() {
          const t = this.editor
          const e = t.model.schema
          const n = t.conversion
          t.config.define('table.tableProperties.defaultProperties', {})
          const o = getNormalizedDefaultProperties(t.config.get('table.tableProperties.defaultProperties'), {
            includeAlignmentProperty: true,
          })
          t.data.addStyleProcessorRules(addBorderRules)
          r$(e, n, { color: o.borderColor, style: o.borderStyle, width: o.borderWidth })
          t.commands.add('tableBorderColor', new TableBorderColorCommand(t, o.borderColor))
          t.commands.add('tableBorderStyle', new TableBorderStyleCommand(t, o.borderStyle))
          t.commands.add('tableBorderWidth', new TableBorderWidthCommand(t, o.borderWidth))
          s$(e, n, o.alignment)
          t.commands.add('tableAlignment', new TableAlignmentCommand(t, o.alignment))
          c$(e, n, { modelAttribute: 'tableWidth', styleName: 'width', defaultValue: o.width })
          t.commands.add('tableWidth', new TableWidthCommand(t, o.width))
          c$(e, n, { modelAttribute: 'tableHeight', styleName: 'height', defaultValue: o.height })
          t.commands.add('tableHeight', new TableHeightCommand(t, o.height))
          t.data.addStyleProcessorRules(addBackgroundRules)
          a$(e, n, {
            modelAttribute: 'tableBackgroundColor',
            styleName: 'background-color',
            defaultValue: o.backgroundColor,
          })
          t.commands.add('tableBackgroundColor', new TableBackgroundColorCommand(t, o.backgroundColor))
        }
      }
      function r$(t, e, n) {
        const o = { width: 'tableBorderWidth', color: 'tableBorderColor', style: 'tableBorderStyle' }
        t.extend('table', { allowAttributes: Object.values(o) })
        upcastBorderStyles(e, 'table', o, n)
        downcastTableAttribute(e, { modelAttribute: o.color, styleName: 'border-color' })
        downcastTableAttribute(e, { modelAttribute: o.style, styleName: 'border-style' })
        downcastTableAttribute(e, { modelAttribute: o.width, styleName: 'border-width' })
      }
      function s$(t, e, n) {
        t.extend('table', { allowAttributes: ['tableAlignment'] })
        e.for('downcast').attributeToAttribute({
          model: { name: 'table', key: 'tableAlignment' },
          view: (t) => ({ key: 'style', value: { float: t === 'center' ? 'none' : t } }),
          converterPriority: 'high',
        })
        e.for('upcast')
          .attributeToAttribute({
            view: { name: /^(table|figure)$/, styles: { float: o$ } },
            model: {
              key: 'tableAlignment',
              value: (t) => {
                let e = t.getStyle('float')
                if (e === 'none') {
                  e = 'center'
                }
                return e === n ? null : e
              },
            },
          })
          .attributeToAttribute({
            view: { attributes: { align: n$ } },
            model: {
              name: 'table',
              key: 'tableAlignment',
              value: (t) => {
                const e = t.getAttribute('align')
                return e === n ? null : e
              },
            },
          })
      }
      function a$(t, e, n) {
        const { modelAttribute: o } = n
        t.extend('table', { allowAttributes: [o] })
        upcastStyleToAttribute(e, { viewElement: 'table', ...n })
        downcastTableAttribute(e, n)
      }
      function c$(t, e, n) {
        const { modelAttribute: o } = n
        t.extend('table', { allowAttributes: [o] })
        upcastStyleToAttribute(e, {
          viewElement: /^(table|figure)$/,
          shouldUpcast: (t) => !(t.name == 'table' && t.parent.name == 'figure'),
          ...n,
        })
        downcastAttributeToStyle(e, { modelElement: 'table', ...n })
      }
      var l$ = n(6596)
      var d$ = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      d$.insert = 'head'
      d$.singleton = true
      var u$ = Rl()(l$.Z, d$)
      const h$ = l$.Z.locals || {}
      const g$ = { left: Sv.objectLeft, center: Sv.objectCenter, right: Sv.objectRight }
      class f$ extends (null && View) {
        constructor(t, e) {
          super(t)
          this.set({
            borderStyle: '',
            borderWidth: '',
            borderColor: '',
            backgroundColor: '',
            width: '',
            height: '',
            alignment: '',
          })
          this.options = e
          const {
            borderStyleDropdown: n,
            borderWidthInput: o,
            borderColorInput: i,
            borderRowLabel: r,
          } = this._createBorderFields()
          const { backgroundRowLabel: s, backgroundInput: a } = this._createBackgroundFields()
          const { widthInput: c, operatorLabel: l, heightInput: d, dimensionsLabel: u } = this._createDimensionFields()
          const { alignmentToolbar: h, alignmentLabel: g } = this._createAlignmentFields()
          this.focusTracker = new FocusTracker()
          this.keystrokes = new KeystrokeHandler()
          this.children = this.createCollection()
          this.borderStyleDropdown = n
          this.borderWidthInput = o
          this.borderColorInput = i
          this.backgroundInput = a
          this.widthInput = c
          this.heightInput = d
          this.alignmentToolbar = h
          const { saveButtonView: f, cancelButtonView: m } = this._createActionButtons()
          this.saveButtonView = f
          this.cancelButtonView = m
          this._focusables = new ViewCollection()
          this._focusCycler = new FocusCycler({
            focusables: this._focusables,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: { focusPrevious: 'shift + tab', focusNext: 'tab' },
          })
          this.children.add(new FormHeaderView(t, { label: this.t('Table properties') }))
          this.children.add(
            new FormRowView(t, { labelView: r, children: [r, n, i, o], class: 'ck-table-form__border-row' }),
          )
          this.children.add(
            new FormRowView(t, { labelView: s, children: [s, a], class: 'ck-table-form__background-row' }),
          )
          this.children.add(
            new FormRowView(t, {
              children: [
                new FormRowView(t, { labelView: u, children: [u, c, l, d], class: 'ck-table-form__dimensions-row' }),
                new FormRowView(t, {
                  labelView: g,
                  children: [g, h],
                  class: 'ck-table-properties-form__alignment-row',
                }),
              ],
            }),
          )
          this.children.add(
            new FormRowView(t, {
              children: [this.saveButtonView, this.cancelButtonView],
              class: 'ck-table-form__action-row',
            }),
          )
          this.setTemplate({
            tag: 'form',
            attributes: { class: ['ck', 'ck-form', 'ck-table-form', 'ck-table-properties-form'], tabindex: '-1' },
            children: this.children,
          })
        }
        render() {
          super.render()
          submitHandler({ view: this })
          ;[
            this.borderStyleDropdown,
            this.borderColorInput,
            this.borderColorInput.fieldView.dropdownView.buttonView,
            this.borderWidthInput,
            this.backgroundInput,
            this.backgroundInput.fieldView.dropdownView.buttonView,
            this.widthInput,
            this.heightInput,
            this.alignmentToolbar,
            this.saveButtonView,
            this.cancelButtonView,
          ].forEach((t) => {
            this._focusables.add(t)
            this.focusTracker.add(t.element)
          })
          this.keystrokes.listenTo(this.element)
        }
        destroy() {
          super.destroy()
          this.focusTracker.destroy()
          this.keystrokes.destroy()
        }
        focus() {
          this._focusCycler.focusFirst()
        }
        _createBorderFields() {
          const t = this.options.defaultTableProperties
          const e = { style: t.borderStyle, width: t.borderWidth, color: t.borderColor }
          const n = getLabeledColorInputCreator({
            colorConfig: this.options.borderColors,
            columns: 5,
            defaultColorValue: e.color,
            colorPickerConfig: this.options.colorPickerConfig,
          })
          const o = this.locale
          const i = this.t
          const r = i('Style')
          const s = new LabelView(o)
          s.text = i('Border')
          const a = getBorderStyleLabels(i)
          const c = new LabeledFieldView(o, createLabeledDropdown)
          c.set({ label: r, class: 'ck-table-form__border-style' })
          c.fieldView.buttonView.set({
            ariaLabel: r,
            ariaLabelledBy: undefined,
            isOn: false,
            withText: true,
            tooltip: r,
          })
          c.fieldView.buttonView.bind('label').to(this, 'borderStyle', (t) => a[t ? t : 'none'])
          c.fieldView.on('execute', (t) => {
            this.borderStyle = t.source._borderStyleValue
          })
          c.bind('isEmpty').to(this, 'borderStyle', (t) => !t)
          addListToDropdown(c.fieldView, getBorderStyleDefinitions(this, e.style), { role: 'menu', ariaLabel: r })
          const l = new LabeledFieldView(o, createLabeledInputText)
          l.set({ label: i('Width'), class: 'ck-table-form__border-width' })
          l.fieldView.bind('value').to(this, 'borderWidth')
          l.bind('isEnabled').to(this, 'borderStyle', m$)
          l.fieldView.on('input', () => {
            this.borderWidth = l.fieldView.element.value
          })
          const d = new LabeledFieldView(o, n)
          d.set({ label: i('Color'), class: 'ck-table-form__border-color' })
          d.fieldView.bind('value').to(this, 'borderColor')
          d.bind('isEnabled').to(this, 'borderStyle', m$)
          d.fieldView.on('input', () => {
            this.borderColor = d.fieldView.value
          })
          this.on('change:borderStyle', (t, n, o, i) => {
            if (!m$(o)) {
              this.borderColor = ''
              this.borderWidth = ''
            }
            if (!m$(i)) {
              this.borderColor = e.color
              this.borderWidth = e.width
            }
          })
          return { borderRowLabel: s, borderStyleDropdown: c, borderColorInput: d, borderWidthInput: l }
        }
        _createBackgroundFields() {
          const t = this.locale
          const e = this.t
          const n = new LabelView(t)
          n.text = e('Background')
          const o = getLabeledColorInputCreator({
            colorConfig: this.options.backgroundColors,
            columns: 5,
            defaultColorValue: this.options.defaultTableProperties.backgroundColor,
            colorPickerConfig: this.options.colorPickerConfig,
          })
          const i = new LabeledFieldView(t, o)
          i.set({ label: e('Color'), class: 'ck-table-properties-form__background' })
          i.fieldView.bind('value').to(this, 'backgroundColor')
          i.fieldView.on('input', () => {
            this.backgroundColor = i.fieldView.value
          })
          return { backgroundRowLabel: n, backgroundInput: i }
        }
        _createDimensionFields() {
          const t = this.locale
          const e = this.t
          const n = new LabelView(t)
          n.text = e('Dimensions')
          const o = new LabeledFieldView(t, createLabeledInputText)
          o.set({ label: e('Width'), class: 'ck-table-form__dimensions-row__width' })
          o.fieldView.bind('value').to(this, 'width')
          o.fieldView.on('input', () => {
            this.width = o.fieldView.element.value
          })
          const i = new View(t)
          i.setTemplate({
            tag: 'span',
            attributes: { class: ['ck-table-form__dimension-operator'] },
            children: [{ text: '×' }],
          })
          const r = new LabeledFieldView(t, createLabeledInputText)
          r.set({ label: e('Height'), class: 'ck-table-form__dimensions-row__height' })
          r.fieldView.bind('value').to(this, 'height')
          r.fieldView.on('input', () => {
            this.height = r.fieldView.element.value
          })
          return { dimensionsLabel: n, widthInput: o, operatorLabel: i, heightInput: r }
        }
        _createAlignmentFields() {
          const t = this.locale
          const e = this.t
          const n = new LabelView(t)
          n.text = e('Alignment')
          const o = new ToolbarView(t)
          o.set({ isCompact: true, ariaLabel: e('Table alignment toolbar') })
          fillToolbar({
            view: this,
            icons: g$,
            toolbar: o,
            labels: this._alignmentLabels,
            propertyName: 'alignment',
            defaultValue: this.options.defaultTableProperties.alignment,
          })
          return { alignmentLabel: n, alignmentToolbar: o }
        }
        _createActionButtons() {
          const t = this.locale
          const e = this.t
          const n = new ButtonView(t)
          const o = new ButtonView(t)
          const i = [
            this.borderWidthInput,
            this.borderColorInput,
            this.backgroundInput,
            this.widthInput,
            this.heightInput,
          ]
          n.set({ label: e('Save'), icon: icons.check, class: 'ck-button-save', type: 'submit', withText: true })
          n.bind('isEnabled').toMany(i, 'errorText', (...t) => t.every((t) => !t))
          o.set({ label: e('Cancel'), icon: icons.cancel, class: 'ck-button-cancel', withText: true })
          o.delegate('execute').to(this, 'cancel')
          return { saveButtonView: n, cancelButtonView: o }
        }
        get _alignmentLabels() {
          const t = this.locale
          const e = this.t
          const n = e('Align table to the left')
          const o = e('Center table')
          const i = e('Align table to the right')
          if (t.uiLanguageDirection === 'rtl') {
            return { right: i, center: o, left: n }
          } else {
            return { left: n, center: o, right: i }
          }
        }
      }
      function m$(t) {
        return t !== 'none'
      }
      const p$ = 500
      const b$ = {
        borderStyle: 'tableBorderStyle',
        borderColor: 'tableBorderColor',
        borderWidth: 'tableBorderWidth',
        backgroundColor: 'tableBackgroundColor',
        width: 'tableWidth',
        height: 'tableHeight',
        alignment: 'tableAlignment',
      }
      class k$ extends (null && Plugin) {
        static get requires() {
          return [ContextualBalloon]
        }
        static get pluginName() {
          return 'TablePropertiesUI'
        }
        constructor(t) {
          super(t)
          this.view = null
          t.config.define('table.tableProperties', { borderColors: defaultColors, backgroundColors: defaultColors })
        }
        init() {
          const t = this.editor
          const e = t.t
          this._defaultTableProperties = getNormalizedDefaultProperties(
            t.config.get('table.tableProperties.defaultProperties'),
            { includeAlignmentProperty: true },
          )
          this._balloon = t.plugins.get(ContextualBalloon)
          t.ui.componentFactory.add('tableProperties', (n) => {
            const o = new ButtonView(n)
            o.set({ label: e('Table properties'), icon: tableProperties, tooltip: true })
            this.listenTo(o, 'execute', () => this._showView())
            const i = Object.values(b$).map((e) => t.commands.get(e))
            o.bind('isEnabled').toMany(i, 'isEnabled', (...t) => t.some((t) => t))
            return o
          })
        }
        destroy() {
          super.destroy()
          if (this.view) {
            this.view.destroy()
          }
        }
        _createPropertiesView() {
          const t = this.editor
          const e = t.config.get('table.tableProperties')
          const n = normalizeColorOptions(e.borderColors)
          const o = getLocalizedColorOptions(t.locale, n)
          const i = normalizeColorOptions(e.backgroundColors)
          const r = getLocalizedColorOptions(t.locale, i)
          const s = e.colorPicker !== false
          const a = new TablePropertiesView(t.locale, {
            borderColors: o,
            backgroundColors: r,
            defaultTableProperties: this._defaultTableProperties,
            colorPickerConfig: s ? e.colorPicker || {} : false,
          })
          const c = t.t
          a.render()
          this.listenTo(a, 'submit', () => {
            this._hideView()
          })
          this.listenTo(a, 'cancel', () => {
            if (this._undoStepBatch.operations.length) {
              t.execute('undo', this._undoStepBatch)
            }
            this._hideView()
          })
          a.keystrokes.set('Esc', (t, e) => {
            this._hideView()
            e()
          })
          clickOutsideHandler({
            emitter: a,
            activator: () => this._isViewInBalloon,
            contextElements: [this._balloon.view.element],
            callback: () => this._hideView(),
          })
          const l = getLocalizedColorErrorText(c)
          const d = getLocalizedLengthErrorText(c)
          a.on('change:borderStyle', this._getPropertyChangeCallback('tableBorderStyle'))
          a.on(
            'change:borderColor',
            this._getValidatedPropertyChangeCallback({
              viewField: a.borderColorInput,
              commandName: 'tableBorderColor',
              errorText: l,
              validator: colorFieldValidator,
            }),
          )
          a.on(
            'change:borderWidth',
            this._getValidatedPropertyChangeCallback({
              viewField: a.borderWidthInput,
              commandName: 'tableBorderWidth',
              errorText: d,
              validator: lineWidthFieldValidator,
            }),
          )
          a.on(
            'change:backgroundColor',
            this._getValidatedPropertyChangeCallback({
              viewField: a.backgroundInput,
              commandName: 'tableBackgroundColor',
              errorText: l,
              validator: colorFieldValidator,
            }),
          )
          a.on(
            'change:width',
            this._getValidatedPropertyChangeCallback({
              viewField: a.widthInput,
              commandName: 'tableWidth',
              errorText: d,
              validator: lengthFieldValidator,
            }),
          )
          a.on(
            'change:height',
            this._getValidatedPropertyChangeCallback({
              viewField: a.heightInput,
              commandName: 'tableHeight',
              errorText: d,
              validator: lengthFieldValidator,
            }),
          )
          a.on('change:alignment', this._getPropertyChangeCallback('tableAlignment'))
          return a
        }
        _fillViewFormFromCommandValues() {
          const t = this.editor.commands
          const e = t.get('tableBorderStyle')
          Object.entries(b$)
            .map(([e, n]) => {
              const o = e
              const i = this._defaultTableProperties[o] || ''
              return [o, t.get(n).value || i]
            })
            .forEach(([t, n]) => {
              if ((t === 'borderColor' || t === 'borderWidth') && e.value === 'none') {
                return
              }
              this.view.set(t, n)
            })
          this._isReady = true
        }
        _showView() {
          const t = this.editor
          if (!this.view) {
            this.view = this._createPropertiesView()
          }
          this.listenTo(t.ui, 'update', () => {
            this._updateView()
          })
          this._fillViewFormFromCommandValues()
          this._balloon.add({ view: this.view, position: getBalloonTablePositionData(t) })
          this._undoStepBatch = t.model.createBatch()
          this.view.focus()
        }
        _hideView() {
          const t = this.editor
          this.stopListening(t.ui, 'update')
          this._isReady = false
          this.view.saveButtonView.focus()
          this._balloon.remove(this.view)
          this.editor.editing.view.focus()
        }
        _updateView() {
          const t = this.editor
          const e = t.editing.view.document
          if (!getTableWidgetAncestor(e.selection)) {
            this._hideView()
          } else if (this._isViewVisible) {
            repositionContextualBalloon(t, 'table')
          }
        }
        get _isViewVisible() {
          return !!this.view && this._balloon.visibleView === this.view
        }
        get _isViewInBalloon() {
          return !!this.view && this._balloon.hasView(this.view)
        }
        _getPropertyChangeCallback(t) {
          return (e, n, o) => {
            if (!this._isReady) {
              return
            }
            this.editor.execute(t, { value: o, batch: this._undoStepBatch })
          }
        }
        _getValidatedPropertyChangeCallback(t) {
          const { commandName: e, viewField: n, validator: o, errorText: i } = t
          const r = debounce(() => {
            n.errorText = i
          }, p$)
          return (t, i, s) => {
            r.cancel()
            if (!this._isReady) {
              return
            }
            if (o(s)) {
              this.editor.execute(e, { value: s, batch: this._undoStepBatch })
              n.errorText = null
            } else {
              r()
            }
          }
        }
      }
      class w$ extends (null && Plugin) {
        static get pluginName() {
          return 'TableProperties'
        }
        static get requires() {
          return [TablePropertiesEditing, TablePropertiesUI]
        }
      }
      class A$ extends (null && Command) {
        refresh() {
          const t = this.editor
          const e = getSelectionAffectedTable(t.model.document.selection)
          this.isEnabled = !!e
          if (!this.isEnabled) {
            this.value = false
          } else {
            this.value = !!getCaptionFromTableModelElement(e)
          }
        }
        execute({ focusCaptionOnShow: t = false } = {}) {
          this.editor.model.change((e) => {
            if (this.value) {
              this._hideTableCaption(e)
            } else {
              this._showTableCaption(e, t)
            }
          })
        }
        _showTableCaption(t, e) {
          const n = this.editor.model
          const o = getSelectionAffectedTable(n.document.selection)
          const i = this.editor.plugins.get('TableCaptionEditing')
          const r = i._getSavedCaption(o)
          const s = r || t.createElement('caption')
          n.insertContent(s, o, 'end')
          if (e) {
            t.setSelection(s, 'in')
          }
        }
        _hideTableCaption(t) {
          const e = this.editor.model
          const n = getSelectionAffectedTable(e.document.selection)
          const o = this.editor.plugins.get('TableCaptionEditing')
          const i = getCaptionFromTableModelElement(n)
          o._saveCaption(n, i)
          e.deleteContent(t.createSelection(i, 'on'))
        }
      }
      class _$ extends (null && Plugin) {
        static get pluginName() {
          return 'TableCaptionEditing'
        }
        constructor(t) {
          super(t)
          this._savedCaptionsMap = new WeakMap()
        }
        init() {
          const t = this.editor
          const e = t.model.schema
          const n = t.editing.view
          const o = t.t
          if (!e.isRegistered('caption')) {
            e.register('caption', { allowIn: 'table', allowContentOf: '$block', isLimit: true })
          } else {
            e.extend('caption', { allowIn: 'table' })
          }
          t.commands.add('toggleTableCaption', new ToggleTableCaptionCommand(this.editor))
          t.conversion.for('upcast').elementToElement({ view: matchTableCaptionViewElement, model: 'caption' })
          t.conversion.for('dataDowncast').elementToElement({
            model: 'caption',
            view: (t, { writer: e }) => {
              if (!isTable(t.parent)) {
                return null
              }
              return e.createContainerElement('figcaption')
            },
          })
          t.conversion.for('editingDowncast').elementToElement({
            model: 'caption',
            view: (t, { writer: e }) => {
              if (!isTable(t.parent)) {
                return null
              }
              const i = e.createEditableElement('figcaption')
              e.setCustomProperty('tableCaption', true, i)
              i.placeholder = o('Enter table caption')
              enablePlaceholder({ view: n, element: i, keepOnFocus: true })
              return toWidgetEditable(i, e)
            },
          })
          injectTableCaptionPostFixer(t.model)
        }
        _getSavedCaption(t) {
          const e = this._savedCaptionsMap.get(t)
          return e ? Element.fromJSON(e) : null
        }
        _saveCaption(t, e) {
          this._savedCaptionsMap.set(t, e.toJSON())
        }
      }
      class C$ extends (null && Plugin) {
        static get pluginName() {
          return 'TableCaptionUI'
        }
        init() {
          const t = this.editor
          const e = t.editing.view
          const n = t.t
          t.ui.componentFactory.add('toggleTableCaption', (o) => {
            const i = t.commands.get('toggleTableCaption')
            const r = new ButtonView(o)
            r.set({ icon: icons.caption, tooltip: true, isToggleable: true })
            r.bind('isOn', 'isEnabled').to(i, 'value', 'isEnabled')
            r.bind('label').to(i, 'value', (t) => (t ? n('Toggle caption off') : n('Toggle caption on')))
            this.listenTo(r, 'execute', () => {
              t.execute('toggleTableCaption', { focusCaptionOnShow: true })
              if (i.value) {
                const n = getCaptionFromModelSelection(t.model.document.selection)
                const o = t.editing.mapper.toViewElement(n)
                if (!o) {
                  return
                }
                e.scrollToTheSelection()
                e.change((t) => {
                  t.addClass('table__caption_highlighted', o)
                })
              }
              t.editing.view.focus()
            })
            return r
          })
        }
      }
      var v$ = n(1111)
      var y$ = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      y$.insert = 'head'
      y$.singleton = true
      var x$ = Rl()(v$.Z, y$)
      const E$ = v$.Z.locals || {}
      class D$ extends (null && Plugin) {
        static get pluginName() {
          return 'TableCaption'
        }
        static get requires() {
          return [TableCaptionEditing, TableCaptionUI]
        }
      }
      function T$(t) {
        const e = new Set()
        for (const n of t.document.differ.getChanges()) {
          let o = null
          switch (n.type) {
            case 'insert':
              o = ['table', 'tableRow', 'tableCell'].includes(n.name) ? n.position : null
              break
            case 'remove':
              o = ['tableRow', 'tableCell'].includes(n.name) ? n.position : null
              break
            case 'attribute':
              if (n.range.start.nodeAfter) {
                o = ['table', 'tableRow', 'tableCell'].includes(n.range.start.nodeAfter.name) ? n.range.start : null
              }
              break
          }
          if (!o) {
            continue
          }
          const i = o.nodeAfter && o.nodeAfter.is('element', 'table') ? o.nodeAfter : o.findAncestor('table')
          for (const n of t.createRangeOn(i).getItems()) {
            if (!n.is('element', 'table')) {
              continue
            }
            if (!H$(n)) {
              continue
            }
            e.add(n)
          }
        }
        return e
      }
      function I$(t, e) {
        return (COLUMN_MIN_WIDTH_IN_PIXELS * 100) / S$(t, e)
      }
      function S$(t, e) {
        const n = M$(t, 'tbody', e) || M$(t, 'thead', e)
        const o = e.editing.view.domConverter.mapViewToDom(n)
        return B$(o)
      }
      function M$(t, e, n) {
        const o = n.editing.mapper.toViewElement(t)
        const i = [...o.getChildren()].find((t) => t.is('element', 'table'))
        return [...i.getChildren()].find((t) => t.is('element', e))
      }
      function B$(t) {
        const e = global.window.getComputedStyle(t)
        if (e.boxSizing === 'border-box') {
          return (
            parseFloat(e.width) -
            parseFloat(e.paddingLeft) -
            parseFloat(e.paddingRight) -
            parseFloat(e.borderLeftWidth) -
            parseFloat(e.borderRightWidth)
          )
        } else {
          return parseFloat(e.width)
        }
      }
      function N$(t, e) {
        const n = e.getCellLocation(t).column
        const o = t.getAttribute('colspan') || 1
        return { leftEdge: n, rightEdge: n + o - 1 }
      }
      function P$(t) {
        const e = Math.pow(10, COLUMN_WIDTH_PRECISION)
        const n = typeof t === 'number' ? t : parseFloat(t)
        return Math.round(n * e) / e
      }
      function L$(t, e, n) {
        if (t <= e) {
          return P$(e)
        }
        if (t >= n) {
          return P$(n)
        }
        return P$(t)
      }
      function z$(t, e) {
        return Array(t).fill(e)
      }
      function R$(t) {
        return t
          .map((t) => (typeof t === 'number' ? t : parseFloat(t)))
          .filter((t) => !Number.isNaN(t))
          .reduce((t, e) => t + e, 0)
      }
      function O$(t) {
        const e = t.map((t) => {
          if (t === 'auto') {
            return t
          }
          return parseFloat(t.replace('%', ''))
        })
        let n = V$(e)
        const o = R$(n)
        if (o !== 100) {
          n = n
            .map((t) => P$((t * 100) / o))
            .map((t, e, n) => {
              const o = e === n.length - 1
              if (!o) {
                return t
              }
              const i = R$(n)
              return P$(t + 100 - i)
            })
        }
        return n.map((t) => t + '%')
      }
      function V$(t) {
        const e = t.filter((t) => t === 'auto').length
        if (e === 0) {
          return t.map((t) => P$(t))
        }
        const n = R$(t)
        const o = Math.max((100 - n) / e, COLUMN_MIN_WIDTH_AS_PERCENTAGE)
        return t.map((t) => (t === 'auto' ? o : t)).map((t) => P$(t))
      }
      function F$(t) {
        const e = global.window.getComputedStyle(t)
        if (e.boxSizing === 'border-box') {
          return parseInt(e.width)
        } else {
          return (
            parseFloat(e.width) + parseFloat(e.paddingLeft) + parseFloat(e.paddingRight) + parseFloat(e.borderWidth)
          )
        }
      }
      function j$(t, e, n, o) {
        for (let i = 0; i < Math.max(n.length, t.length); i++) {
          const r = t[i]
          const s = n[i]
          if (!s) {
            o.remove(r)
          } else if (!r) {
            o.appendElement('tableColumn', { columnWidth: s }, e)
          } else {
            o.setAttribute('columnWidth', s, r)
          }
        }
      }
      function H$(t) {
        if (t.is('element', 'tableColumnGroup')) {
          return t
        }
        const e = t.getChildren()
        return Array.from(e).find((t) => t.is('element', 'tableColumnGroup'))
      }
      function U$(t) {
        return Array.from(H$(t).getChildren())
      }
      function W$(t) {
        return U$(t).map((t) => t.getAttribute('columnWidth'))
      }
      class G$ extends (null && Command) {
        refresh() {
          this.isEnabled = true
        }
        execute(t = {}) {
          const { model: e, plugins: n } = this.editor
          let { table: o = e.document.selection.getSelectedElement(), columnWidths: i, tableWidth: r } = t
          if (i) {
            i = Array.isArray(i) ? i : i.split(',')
          }
          e.change((t) => {
            if (r) {
              t.setAttribute('tableWidth', r, o)
            } else {
              t.removeAttribute('tableWidth', o)
            }
            const e = n.get('TableColumnResizeEditing').getColumnGroupElement(o)
            if (!i && !e) {
              return
            }
            if (!i) {
              return t.remove(e)
            }
            const s = normalizeColumnWidths(i)
            if (!e) {
              const e = t.createElement('tableColumnGroup')
              s.forEach((n) => t.appendElement('tableColumn', { columnWidth: n }, e))
              t.append(e, o)
            } else {
              Array.from(e.getChildren()).forEach((e, n) => t.setAttribute('columnWidth', s[n], e))
            }
          })
        }
      }
      function q$(t) {
        return (e) =>
          e.on(
            'element:colgroup',
            (e, n, o) => {
              const i = n.modelCursor.findAncestor('table')
              const r = getColumnGroupElement(i)
              if (!r) {
                return
              }
              const s = getTableColumnElements(r)
              let a = getTableColumnsWidths(r)
              const c = t.getColumns(i)
              a = Array.from({ length: c }, (t, e) => a[e] || 'auto')
              if (a.length != s.length || a.includes('auto')) {
                updateColumnElements(s, r, normalizeColumnWidths(a), o.writer)
              }
            },
            { priority: 'low' },
          )
      }
      function $$() {
        return (t) =>
          t.on(
            'insert:table',
            (t, e, n) => {
              const o = n.writer
              const i = e.item
              const r = n.mapper.toViewElement(i)
              const s = r.is('element', 'table') ? r : Array.from(r.getChildren()).find((t) => t.is('element', 'table'))
              const a = getColumnGroupElement(i)
              if (a) {
                o.addClass('ck-table-resized', s)
              } else {
                o.removeClass('ck-table-resized', s)
              }
            },
            { priority: 'low' },
          )
      }
      class K$ extends (null && Plugin) {
        static get requires() {
          return [TableEditing, TableUtils]
        }
        static get pluginName() {
          return 'TableColumnResizeEditing'
        }
        constructor(t) {
          super(t)
          this._isResizingActive = false
          this.set('_isResizingAllowed', true)
          this._resizingData = null
          this._domEmitter = new (DomEmitterMixin())()
          this._tableUtilsPlugin = t.plugins.get('TableUtils')
          this.on('change:_isResizingAllowed', (e, n, o) => {
            const i = o ? 'removeClass' : 'addClass'
            t.editing.view.change((e) => {
              for (const n of t.editing.view.document.roots) {
                e[i]('ck-column-resize_disabled', t.editing.view.document.getRoot(n.rootName))
              }
            })
          })
        }
        init() {
          this._extendSchema()
          this._registerPostFixer()
          this._registerConverters()
          this._registerResizingListeners()
          this._registerResizerInserter()
          const t = this.editor
          const e = t.plugins.get('TableColumnResize')
          const n = t.plugins.get('TableEditing')
          n.registerAdditionalSlot({ filter: (t) => t.is('element', 'tableColumnGroup'), positionOffset: 0 })
          const o = new TableWidthsCommand(t)
          t.commands.add('resizeTableWidth', o)
          t.commands.add('resizeColumnWidths', o)
          this.bind('_isResizingAllowed').to(t, 'isReadOnly', e, 'isEnabled', o, 'isEnabled', (t, e, n) => !t && e && n)
        }
        destroy() {
          this._domEmitter.stopListening()
          super.destroy()
        }
        getColumnGroupElement(t) {
          return getColumnGroupElement(t)
        }
        getTableColumnElements(t) {
          return getTableColumnElements(t)
        }
        getTableColumnsWidths(t) {
          return getTableColumnsWidths(t)
        }
        _extendSchema() {
          this.editor.model.schema.extend('table', { allowAttributes: ['tableWidth'] })
          this.editor.model.schema.register('tableColumnGroup', { allowIn: 'table', isLimit: true })
          this.editor.model.schema.register('tableColumn', {
            allowIn: 'tableColumnGroup',
            allowAttributes: ['columnWidth'],
            isLimit: true,
          })
        }
        _registerPostFixer() {
          const t = this.editor
          const e = t.model
          e.document.registerPostFixer((t) => {
            let o = false
            for (const i of getChangedResizedTables(e)) {
              const e = this.getColumnGroupElement(i)
              const r = this.getTableColumnElements(e)
              const s = this.getTableColumnsWidths(e)
              let a = normalizeColumnWidths(s)
              a = n(a, i, this)
              if (isEqual(s, a)) {
                continue
              }
              updateColumnElements(r, e, a, t)
              o = true
            }
            return o
          })
          function n(t, e, n) {
            const i = n._tableUtilsPlugin.getColumns(e)
            const r = i - t.length
            if (r === 0) {
              return t
            }
            const s = t.map((t) => Number(t.replace('%', '')))
            const a = o(n.editor.model.document.differ, e)
            for (const t of a) {
              const o = i - s.length
              if (o === 0) {
                continue
              }
              const r = o > 0
              const a = n._tableUtilsPlugin.getCellLocation(t).column
              if (r) {
                const t = getColumnMinWidthAsPercentage(e, n.editor)
                const i = createFilledArray(o, t)
                s.splice(a, 0, ...i)
              } else {
                const t = s.splice(a, Math.abs(o))
                s[a] += sumArray(t)
              }
            }
            return s.map((t) => t + '%')
          }
          function o(t, e) {
            const n = new Set()
            for (const o of t.getChanges()) {
              if (
                o.type == 'insert' &&
                o.position.nodeAfter &&
                o.position.nodeAfter.name == 'tableCell' &&
                o.position.nodeAfter.getAncestors().includes(e)
              ) {
                n.add(o.position.nodeAfter)
              } else if (o.type == 'remove') {
                const t = o.position.nodeBefore || o.position.nodeAfter
                if (t.name == 'tableCell' && t.getAncestors().includes(e)) {
                  n.add(t)
                }
              }
            }
            return n
          }
        }
        _registerConverters() {
          const t = this.editor
          const e = t.conversion
          e.for('upcast').attributeToAttribute({
            view: { name: 'figure', key: 'style', value: { width: /[\s\S]+/ } },
            model: { name: 'table', key: 'tableWidth', value: (t) => t.getStyle('width') },
          })
          e.for('downcast').attributeToAttribute({
            model: { name: 'table', key: 'tableWidth' },
            view: (t) => ({ name: 'figure', key: 'style', value: { width: t } }),
          })
          e.elementToElement({ model: 'tableColumnGroup', view: 'colgroup' })
          e.elementToElement({ model: 'tableColumn', view: 'col' })
          e.for('downcast').add(downcastTableResizedClass())
          e.for('upcast').add(upcastColgroupElement(this._tableUtilsPlugin))
          e.for('upcast').attributeToAttribute({
            view: { name: 'col', styles: { width: /.*/ } },
            model: {
              key: 'columnWidth',
              value: (t) => {
                const e = t.getStyle('width')
                if (!e || !e.endsWith('%')) {
                  return 'auto'
                }
                return e
              },
            },
          })
          e.for('downcast').attributeToAttribute({
            model: { name: 'tableColumn', key: 'columnWidth' },
            view: (t) => ({ key: 'style', value: { width: t } }),
          })
        }
        _registerResizingListeners() {
          const t = this.editor.editing.view
          t.addObserver(MouseEventsObserver)
          t.document.on('mousedown', this._onMouseDownHandler.bind(this), { priority: 'high' })
          this._domEmitter.listenTo(
            global.window.document,
            'mousemove',
            throttle(this._onMouseMoveHandler.bind(this), 50),
          )
          this._domEmitter.listenTo(global.window.document, 'mouseup', this._onMouseUpHandler.bind(this))
        }
        _onMouseDownHandler(t, e) {
          const n = e.target
          if (!n.hasClass('ck-table-column-resizer')) {
            return
          }
          if (!this._isResizingAllowed) {
            return
          }
          const o = this.editor
          const i = o.editing.mapper.toModelElement(n.findAncestor('figure'))
          if (!o.model.canEditAt(i)) {
            return
          }
          e.preventDefault()
          t.stop()
          const r = c(i, this._tableUtilsPlugin, o)
          const s = n.findAncestor('table')
          const a = o.editing.view
          if (!Array.from(s.getChildren()).find((t) => t.is('element', 'colgroup'))) {
            a.change((t) => {
              l(t, r, s)
            })
          }
          this._isResizingActive = true
          this._resizingData = this._getResizingData(e, r)
          a.change((t) => d(t, s, this._resizingData))
          function c(t, e, n) {
            const o = Array(e.getColumns(t))
            const i = new TableWalker(t)
            for (const t of i) {
              const e = n.editing.mapper.toViewElement(t.cell)
              const i = n.editing.view.domConverter.mapViewToDom(e)
              const r = getDomCellOuterWidth(i)
              if (!o[t.column] || r < o[t.column]) {
                o[t.column] = toPrecision(r)
              }
            }
            return o
          }
          function l(t, e, n) {
            const o = t.createContainerElement('colgroup')
            for (let n = 0; n < e.length; n++) {
              const i = t.createEmptyElement('col')
              const r = `${toPrecision((e[n] / sumArray(e)) * 100)}%`
              t.setStyle('width', r, i)
              t.insert(t.createPositionAt(o, 'end'), i)
            }
            t.insert(t.createPositionAt(n, 0), o)
          }
          function d(t, e, n) {
            const o = n.widths.viewFigureWidth / n.widths.viewFigureParentWidth
            t.addClass('ck-table-resized', e)
            t.addClass('ck-table-column-resizer__active', n.elements.viewResizer)
            t.setStyle('width', `${toPrecision(o * 100)}%`, e.findAncestor('figure'))
          }
        }
        _onMouseMoveHandler(t, e) {
          if (!this._isResizingActive) {
            return
          }
          if (!this._isResizingAllowed) {
            this._onMouseUpHandler()
            return
          }
          const {
            columnPosition: n,
            flags: { isRightEdge: o, isTableCentered: i, isLtrContent: r },
            elements: { viewFigure: s, viewLeftColumn: a, viewRightColumn: c },
            widths: { viewFigureParentWidth: l, tableWidth: d, leftColumnWidth: u, rightColumnWidth: h },
          } = this._resizingData
          const g = -u + COLUMN_MIN_WIDTH_IN_PIXELS
          const f = o ? l - d : h - COLUMN_MIN_WIDTH_IN_PIXELS
          const m = (r ? 1 : -1) * (o && i ? 2 : 1)
          const p = clamp((e.clientX - n) * m, Math.min(g, 0), Math.max(f, 0))
          if (p === 0) {
            return
          }
          this.editor.editing.view.change((t) => {
            const e = toPrecision(((u + p) * 100) / d)
            t.setStyle('width', `${e}%`, a)
            if (o) {
              const e = toPrecision(((d + p) * 100) / l)
              t.setStyle('width', `${e}%`, s)
            } else {
              const e = toPrecision(((h - p) * 100) / d)
              t.setStyle('width', `${e}%`, c)
            }
          })
        }
        _onMouseUpHandler() {
          if (!this._isResizingActive) {
            return
          }
          const { viewResizer: t, modelTable: e, viewFigure: n, viewColgroup: o } = this._resizingData.elements
          const i = this.editor
          const r = i.editing.view
          const s = this.getColumnGroupElement(e)
          const a = Array.from(o.getChildren()).filter((t) => t.is('view:element'))
          const c = s ? this.getTableColumnsWidths(s) : null
          const l = a.map((t) => t.getStyle('width'))
          const d = !isEqual(c, l)
          const u = e.getAttribute('tableWidth')
          const h = n.getStyle('width')
          const g = u !== h
          if (d || g) {
            if (this._isResizingAllowed) {
              i.execute('resizeTableWidth', { table: e, tableWidth: `${toPrecision(h)}%`, columnWidths: l })
            } else {
              r.change((t) => {
                if (c) {
                  for (const e of a) {
                    t.setStyle('width', c.shift(), e)
                  }
                } else {
                  t.remove(o)
                }
                if (g) {
                  if (u) {
                    t.setStyle('width', u, n)
                  } else {
                    t.removeStyle('width', n)
                  }
                }
                if (!c && !u) {
                  t.removeClass(
                    'ck-table-resized',
                    [...n.getChildren()].find((t) => t.name === 'table'),
                  )
                }
              })
            }
          }
          r.change((e) => {
            e.removeClass('ck-table-column-resizer__active', t)
          })
          this._isResizingActive = false
          this._resizingData = null
        }
        _getResizingData(t, e) {
          const n = this.editor
          const o = t.domEvent.clientX
          const i = t.target
          const r = i.findAncestor('td') || i.findAncestor('th')
          const s = n.editing.mapper.toModelElement(r)
          const a = s.findAncestor('table')
          const c = getColumnEdgesIndexes(s, this._tableUtilsPlugin).rightEdge
          const l = this._tableUtilsPlugin.getColumns(a) - 1
          const d = c === l
          const u = !a.hasAttribute('tableAlignment')
          const h = n.locale.contentLanguageDirection !== 'rtl'
          const g = r.findAncestor('table')
          const f = g.findAncestor('figure')
          const m = [...g.getChildren()].find((t) => t.is('element', 'colgroup'))
          const p = m.getChild(c)
          const b = d ? undefined : m.getChild(c + 1)
          const k = getElementWidthInPixels(n.editing.view.domConverter.mapViewToDom(f.parent))
          const w = getElementWidthInPixels(n.editing.view.domConverter.mapViewToDom(f))
          const A = getTableWidthInPixels(a, n)
          const _ = e[c]
          const C = d ? undefined : e[c + 1]
          return {
            columnPosition: o,
            flags: { isRightEdge: d, isTableCentered: u, isLtrContent: h },
            elements: {
              viewResizer: i,
              modelTable: a,
              viewFigure: f,
              viewColgroup: m,
              viewLeftColumn: p,
              viewRightColumn: b,
            },
            widths: {
              viewFigureParentWidth: k,
              viewFigureWidth: w,
              tableWidth: A,
              leftColumnWidth: _,
              rightColumnWidth: C,
            },
          }
        }
        _registerResizerInserter() {
          this.editor.conversion.for('editingDowncast').add((t) => {
            t.on(
              'insert:tableCell',
              (t, e, n) => {
                const o = e.item
                const i = n.mapper.toViewElement(o)
                const r = n.writer
                r.insert(r.createPositionAt(i, 'end'), r.createUIElement('div', { class: 'ck-table-column-resizer' }))
              },
              { priority: 'lowest' },
            )
          })
        }
      }
      var Y$ = n(7176)
      var Z$ = { injectType: 'singletonStyleTag', attributes: { 'data-cke': true } }
      Z$.insert = 'head'
      Z$.singleton = true
      var Q$ = Rl()(Y$.Z, Z$)
      const J$ = Y$.Z.locals || {}
      class X$ extends (null && Plugin) {
        static get requires() {
          return [TableColumnResizeEditing, TableCellWidthEditing]
        }
        static get pluginName() {
          return 'TableColumnResize'
        }
      }
      class tK extends HD {}
      tK.builtinPlugins = [
        VT,
        XI,
        qT,
        dS,
        DB,
        WB,
        JN,
        aP,
        sz,
        az,
        XP,
        fz,
        cI,
        dO,
        YF,
        gH,
        MB,
        cU,
        fU,
        fI,
        DG,
        PG,
        xT,
        SI,
      ]
      tK.defaultConfig = {
        toolbar: {
          items: [
            'heading',
            '|',
            'bold',
            'underline',
            'italic',
            'link',
            'bulletedList',
            'numberedList',
            '|',
            'outdent',
            'indent',
            '|',
            'imageUpload',
            'blockQuote',
            'insertTable',
            'mediaEmbed',
            'undo',
            'redo',
            'removeFormat',
            'strikethrough',
          ],
        },
        language: 'en',
        image: {
          toolbar: [
            'imageTextAlternative',
            'toggleImageCaption',
            'imageStyle:inline',
            'imageStyle:block',
            'imageStyle:side',
          ],
        },
        table: { contentToolbar: ['tableColumn', 'tableRow', 'mergeTableCells'] },
      }
      const eK = tK
    })()
    o = o['default']
    return o
  })(),
)
//# sourceMappingURL=ckeditor.js.map
